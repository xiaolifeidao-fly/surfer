"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cfcs";
exports.ids = ["vendor-chunks/@cfcs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@cfcs/core/dist/cfcs.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/@cfcs/core/dist/cfcs.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Computed: () => (/* binding */ Computed),\n/* harmony export */   ComputedObserver: () => (/* binding */ ComputedObserver),\n/* harmony export */   Observe: () => (/* binding */ Observe),\n/* harmony export */   Observer: () => (/* binding */ Observer),\n/* harmony export */   Reactive: () => (/* binding */ Reactive),\n/* harmony export */   ReactiveSubscribe: () => (/* binding */ ReactiveSubscribe),\n/* harmony export */   adaptReactive: () => (/* binding */ adaptReactive),\n/* harmony export */   camelize: () => (/* binding */ camelize),\n/* harmony export */   computed: () => (/* binding */ computed),\n/* harmony export */   defineObservers: () => (/* binding */ defineObservers),\n/* harmony export */   findTarget: () => (/* binding */ findTarget),\n/* harmony export */   getObserver: () => (/* binding */ getObserver),\n/* harmony export */   getObservers: () => (/* binding */ getObservers),\n/* harmony export */   injectReactiveSubscribe: () => (/* binding */ injectReactiveSubscribe),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isObserver: () => (/* binding */ isObserver),\n/* harmony export */   isReactive: () => (/* binding */ isReactive),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   partialReactive: () => (/* binding */ partialReactive),\n/* harmony export */   reactive: () => (/* binding */ reactive),\n/* harmony export */   setObserver: () => (/* binding */ setObserver),\n/* harmony export */   withClassMethods: () => (/* binding */ withClassMethods),\n/* harmony export */   withReactiveMethods: () => (/* binding */ withReactiveMethods)\n/* harmony export */ });\n/* harmony import */ var _egjs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/component */ \"(ssr)/./node_modules/@egjs/component/dist/component.esm.js\");\n/*\nCopyright (c) NAVER Crop.\nname: @cfcs/core\nlicense: MIT\nauthor: NAVER Crop.\nrepository: https://github.com/naver/cfcs\nversion: 0.0.26\n*/\n\n\n/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\n\n/**\n * @hidden\n */\nfunction keys(obj) {\n  return Object.keys(obj);\n}\n/**\n * @hidden\n */\n\nfunction camelize(str) {\n  return str.replace(/[\\s-_]([a-z])/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n}\n/**\n * @hidden\n */\n\nfunction isString(val) {\n  return typeof val === \"string\";\n}\n/**\n * @hidden\n */\n\nfunction isObject(val) {\n  return typeof val === \"object\";\n}\n/**\n * @hidden\n */\n\nfunction isFunction(val) {\n  return typeof val === \"function\";\n}\n\n/**\n * @hidden\n */\n\nfunction findTarget(target) {\n  var el;\n\n  if (!target) {\n    return null;\n  }\n\n  if (isString(target)) {\n    el = document.querySelector(target);\n  } else if (target instanceof Element) {\n    el = target;\n  } else if (\"value\" in target || \"current\" in target) {\n    el = target.value || target.current;\n  }\n\n  return el;\n}\n/**\n * @description Sets the name of the class method to be exposed to the outside.\n * @category DOM\n * @return Property Decorator\n * @example\n * ```ts\n * import { withClassMethods } from \"@cfcs/core\";\n *\n * class YourFrameworkComponent {\n *   @withClassMethod(METHOD_NAMES)\n *   inst = new YourComponent();\n * }\n * ```\n */\n\nfunction withClassMethods(methods) {\n  return function (prototype, memberName) {\n    methods.forEach(function (name) {\n      if (name in prototype) {\n        return;\n      }\n\n      prototype[name] = function () {\n        var _a;\n\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var result = (_a = this[memberName])[name].apply(_a, args); // fix `this` type to return your own `class` instance to the instance using the decorator.\n\n\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n\nvar OBSERVERS_PATH = \"__observers__\";\nvar COMPUTED_PATH = \"__computed__\";\nvar CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nvar CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction getDetectedStack() {\n  // Version issues do not occur when you access the native object in the global.\n  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};\n  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];\n  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\nfunction getCurrentDetected() {\n  var stack = getDetectedStack();\n  return stack[stack.length - 1];\n}\nfunction detectDependencies(host) {\n  var stack = getDetectedStack();\n  var observers = [];\n  var detected = {\n    host: host,\n    observers: observers,\n    push: function (observer) {\n      if (host !== observer && observers.indexOf(observer) === -1) {\n        observers.push(observer);\n      }\n    }\n  };\n  stack.push(detected);\n  return detected;\n}\nfunction endDetectDependencies() {\n  var stack = getDetectedStack();\n  return stack.pop();\n}\n\n/**\n * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @see observe\n */\n\nvar Observer =\n/*#__PURE__*/\nfunction () {\n  /**\n   *\n   */\n  function Observer(value) {\n    this._emitter = new _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this._current = value;\n  }\n\n  var __proto = Observer.prototype;\n  Object.defineProperty(__proto, \"current\", {\n    /**\n     * return the current value.\n     */\n    get: function () {\n      var currentDetected = getCurrentDetected();\n      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);\n      return this._current;\n    },\n    set: function (value) {\n      this._setCurrent(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * When the current value changes, the callback function is called.\n   */\n\n  __proto.subscribe = function (callback) {\n    this.current;\n\n    this._emitter.on(\"update\", callback);\n\n    return this;\n  };\n  /**\n   * Cancel the registered subscription through callback.\n   */\n\n\n  __proto.unsubscribe = function (callback) {\n    this._emitter.off(\"update\", callback);\n\n    return this;\n  };\n\n  __proto._setCurrent = function (value) {\n    var prevValue = this._current;\n    var isUpdate = value !== prevValue;\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value, prevValue);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  __proto.toString = function () {\n    return \"\".concat(this.current);\n  };\n  /**\n   * @hidden\n   */\n\n\n  __proto.valueOf = function () {\n    return this.current;\n  };\n\n  return Observer;\n}();\n\n/**\n * @category Reactive\n * @hidden\n */\n\nvar ComputedObserver =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ComputedObserver, _super);\n  /**\n   * @description Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */\n\n\n  function ComputedObserver(_computedCallback) {\n    var _this = _super.call(this) || this;\n\n    _this._computedCallback = _computedCallback;\n    _this._registered = [];\n\n    _this._onCheckUpdate = function () {\n      _this._setCurrent(_this.current);\n    };\n\n    _this._current = _this.current;\n    return _this;\n  }\n\n  var __proto = ComputedObserver.prototype;\n  Object.defineProperty(__proto, \"current\", {\n    get: function () {\n      var _this = this;\n\n      detectDependencies(this);\n\n      var value = this._computedCallback();\n\n      var results = endDetectDependencies();\n\n      this._registered.forEach(function (observer) {\n        observer.unsubscribe(_this._onCheckUpdate);\n      });\n\n      results.observers.forEach(function (observer) {\n        observer.subscribe(_this._onCheckUpdate);\n      });\n      this._registered = results.observers;\n      return value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ComputedObserver;\n}(Observer);\n\nfunction injectObserve(prototype, memberName, publicName) {\n  if (publicName === void 0) {\n    publicName = memberName;\n  }\n\n  var nextAttributes = {\n    configurable: true,\n    get: function () {\n      return getObserver(this, publicName).current;\n    },\n    set: function (value) {\n      getObserver(this, publicName, value).current = value;\n    }\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n\n  if (publicName !== memberName) {\n    Object.defineProperty(prototype, publicName, {\n      configurable: true,\n      get: function () {\n        return getObserver(this, publicName).current;\n      }\n    });\n  }\n}\n/**\n * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n* ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  // The public name and state name are the same.\n  @Observe value1 = 1;\n  // If you want to set public name and private properties separately\n  @Observe(\"value2\") _value2 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\ninterface C\n```\n */\n\n\nfunction Observe() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  if (args.length > 1) {\n    return injectObserve(args[0], args[1]);\n  }\n\n  return function (prototype, memberName) {\n    return injectObserve(prototype, memberName, args[0]);\n  };\n}\n/**\n * @hidden\n */\n\nfunction Reactive() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return Observe.apply(void 0, args);\n}\n\n/**\n * @hidden\n */\n\nfunction injectReactiveSubscribe(object) {\n  object[\"subscribe\"] = function (name, callback) {\n    this[name];\n    getObserver(this, name).subscribe(callback);\n  };\n\n  object[\"unsubscribe\"] = function (name, callback) {\n    var _this = this;\n\n    if (!name) {\n      keys(getObservers(this)).forEach(function (observerName) {\n        _this.unsubscribe(observerName);\n      });\n      return;\n    }\n\n    if (!(name in this)) {\n      return;\n    }\n\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\n/**\n * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.\n * @category Reactive-Decorator\n * @see Observe\n * @example\n * ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  @Observe value1 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\n\ninterface Component extends ReactiveSubscribe<{\n  value1: number;\n  value2: number;\n}> {}\n\nconst component = new Component();\n\n// 1\nconsole.log(component.value1);\n\ncomponent.subscribe(\"value1\", nextValue => {\n  // When the change event occurs => (2, 2)\n  console.log(nextValue, component.value2);\n});\n```\n */\n\nfunction ReactiveSubscribe(Constructor) {\n  var prototype = Constructor.prototype;\n  injectReactiveSubscribe(prototype);\n}\n\nfunction makeReactiveObject(setup, all) {\n  var result = isFunction(setup) ? setup() : setup;\n  var reactiveObject = {};\n  defineObservers(reactiveObject);\n  keys(result).forEach(function (name) {\n    var value = result[name];\n\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n    } else {\n      setObserver(reactiveObject, name, observe(value));\n    }\n\n    Observe(name)(reactiveObject, name);\n  });\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject;\n}\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Makes all values into reactive objects.\n * @example\n * ```ts\n * import { reactive } from \"@cfcs/core\";\n *\n * const obj = reactive({\n *  value1: 1,\n *  value2: 2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * obj.value1 = 2;\n * ```\n */\n\n\nfunction reactive(setup) {\n  return makeReactiveObject(setup);\n}\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Only the values to which observer is applied are objects to which reactive is applied.\n * @example\n * ```ts\n * import { partialReactive, observe } from \"@cfcs/core\";\n *\n * const value1 = observe(1);\n * const value2 = observe(2);\n * const obj = partialReactive({\n *  value1,\n *  value2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * value1.current = 2;\n * ```\n */\n\nfunction partialReactive(setup) {\n  return makeReactiveObject(setup);\n}\n/**\n * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @example\n * ```ts\n * import { observe } from \"@cfcs/core\";\n *\n * const ob1 = observe(1);\n *\n * ob1.subscribe(nextValue => {\n *   console.log(nextValue);\n * });\n *\n * ob1.current = 2;\n * ```\n */\n\nfunction observe(defaultValue) {\n  return new Observer(defaultValue);\n}\n/**\n * @hidden\n */\n\nfunction computed(computedCallback) {\n  return new ComputedObserver(computedCallback);\n}\n\n/**\n * @hidden\n */\n\nfunction withReactiveMethods(ref, methods) {\n  var obj = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(function (name) {\n    obj[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var current = ref.current || ref.value;\n      return current[name].apply(current, args);\n    };\n  });\n  return obj;\n}\n/**\n * @hidden\n */\n\nfunction defineObservers(instance) {\n  var observers = {};\n  Object.defineProperty(instance, OBSERVERS_PATH, {\n    get: function () {\n      return observers;\n    }\n  });\n  return observers;\n}\n/**\n * @hidden\n */\n\nfunction getObservers(instance, isComputed) {\n  var _a, _b;\n\n  if (!instance[OBSERVERS_PATH]) {\n    defineObservers(instance);\n  }\n\n  var observers = instance[OBSERVERS_PATH];\n\n  if (!isComputed) {\n    var computedList = (_b = (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b[COMPUTED_PATH];\n\n    if (computedList) {\n      computedList.forEach(function (name) {\n        if (!(name in observers) && name in instance) {\n          instance[name];\n        }\n      });\n    }\n  }\n\n  return observers;\n}\n/**\n * @hidden\n */\n\nfunction getObserver(instance, name, defaultValue) {\n  var observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n\n  return observers[name];\n}\n/**\n * @hidden\n */\n\nfunction setObserver(instance, name, observer) {\n  var observers = getObservers(instance);\n  observers[name] = observer;\n}\n/**\n * @description Whether that object is an observer instance\n * @category Reactive\n */\n\nfunction isObserver(val) {\n  return val && isObject(val) && \"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n/**\n * @description Whether the object is reactive\n * @category Reactive\n */\n\nfunction isReactive(val) {\n  return val && !isObserver(val) && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n\n/**\n * @category Reactive\n * @hidden\n */\n\nfunction adaptReactive(adapter, props) {\n  var objectAdapter = isFunction(adapter) ? {\n    setup: adapter\n  } : adapter;\n\n  function getProps() {\n    var _a, _b, _c, _d, _e;\n\n    return (_e = (_c = (_a = props === null || props === void 0 ? void 0 : props()) !== null && _a !== void 0 ? _a : (_b = objectAdapter.props) === null || _b === void 0 ? void 0 : _b.call(objectAdapter)) !== null && _c !== void 0 ? _c : (_d = objectAdapter.data) === null || _d === void 0 ? void 0 : _d.call(objectAdapter)) !== null && _e !== void 0 ? _e : {};\n  }\n\n  var eventEmitter = new _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n  var mountedHooks = [];\n  var initHooks = [];\n  var destroyHooks = [];\n  var onHooks = [];\n  var instanceRef = {\n    current: null\n  };\n  var offHooksList = [];\n  var initialState = null;\n  var eventNames = [];\n  var methodNames = [];\n\n  var onMounted = function (callback) {\n    mountedHooks.push(callback);\n  };\n\n  var onInit = function (callback) {\n    initHooks.push(callback);\n  };\n\n  var onDestroy = function (callback) {\n    destroyHooks.push(callback);\n  };\n\n  var on = function (callback) {\n    onHooks.push(callback);\n  };\n\n  var emit = function (eventName) {\n    var params = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      params[_i - 1] = arguments[_i];\n    }\n\n    eventEmitter.trigger.apply(eventEmitter, __spreadArray([eventName], params, false));\n  };\n\n  var setInitialState = function (state) {\n    initialState = state;\n  };\n\n  var setEvents = function (events) {\n    eventNames = events;\n  };\n\n  var setMethods = function (methods) {\n    methodNames = methods;\n  };\n\n  if (objectAdapter.setup) {\n    instanceRef.current = objectAdapter.setup({\n      getProps: getProps,\n      setInitialState: setInitialState,\n      setEvents: setEvents,\n      setMethods: setMethods,\n      onMounted: onMounted,\n      onDestroy: onDestroy,\n      onInit: onInit,\n      emit: emit,\n      on: on\n    }) || null;\n  }\n\n  if (objectAdapter.created) {\n    instanceRef.current = objectAdapter.created(getProps()) || null;\n  }\n\n  if (objectAdapter.events) {\n    setEvents(objectAdapter.events);\n  }\n\n  if (objectAdapter.state) {\n    setInitialState(objectAdapter.state);\n  }\n\n  if (objectAdapter.methods) {\n    setMethods(objectAdapter.methods);\n  }\n\n  if (objectAdapter.mounted) {\n    onMounted(objectAdapter.mounted);\n  }\n\n  if (objectAdapter.destroy) {\n    destroyHooks.push(objectAdapter.destroy);\n  }\n\n  if (objectAdapter.init) {\n    initHooks.push(objectAdapter.init);\n  }\n\n  if (objectAdapter.on) {\n    onHooks.push(function (instance, eventName, listener) {\n      var off = objectAdapter.on(instance, eventName, listener);\n      return function () {\n        var _a;\n\n        off && off();\n        (_a = objectAdapter.off) === null || _a === void 0 ? void 0 : _a.call(objectAdapter, instance, eventName, listener);\n      };\n    });\n  }\n\n  return {\n    events: function () {\n      return eventNames;\n    },\n    state: function () {\n      var inst = instanceRef.current;\n\n      if (initialState) {\n        return initialState;\n      }\n\n      if (inst) {\n        var observers_1 = getObservers(inst);\n        setInitialState(keys(observers_1).reduce(function (prev, cur) {\n          prev[cur] = observers_1[cur].current;\n          return prev;\n        }, {}));\n      }\n\n      return initialState || {};\n    },\n    instance: function () {\n      return instanceRef.current;\n    },\n    mounted: function () {\n      var props = getProps();\n      mountedHooks.forEach(function (hook) {\n        instanceRef.current = hook(props, instanceRef.current) || instanceRef.current;\n      });\n    },\n    init: function () {\n      // on events\n      var instance = instanceRef.current;\n      var props = getProps();\n      offHooksList = eventNames.map(function (eventName) {\n        var listener = function () {\n          var _a;\n\n          var params = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i] = arguments[_i];\n          }\n\n          (_a = eventEmitter).trigger.apply(_a, __spreadArray([eventName], params, false));\n        };\n\n        var instance = instanceRef.current;\n        return onHooks.map(function (hook) {\n          return hook(instance, eventName, listener);\n        }).filter(Boolean);\n      }); // init\n\n      initHooks.forEach(function (hook) {\n        hook(instance, props);\n      });\n    },\n    destroy: function () {\n      // off events\n      offHooksList.forEach(function (offHooks) {\n        offHooks.forEach(function (hook) {\n          hook();\n        });\n      }); // destroy\n\n      eventEmitter.off();\n      var instance = instanceRef.current;\n      var props = getProps();\n      destroyHooks.forEach(function (hook) {\n        hook(instance, props);\n      });\n    },\n    methods: function () {\n      return withReactiveMethods(instanceRef, methodNames);\n    },\n    on: function (eventName, listener) {\n      eventEmitter.on(eventName, listener);\n    },\n    off: function (eventName, listener) {\n      eventEmitter.off(eventName, listener);\n    }\n  };\n}\n\n/**\n * @description `Computed` is a property decorator.\n * Changes in computed state values are also recognized according to changes in observers used within the getter function.\n * You can detect its status through `.subscribe`.\n * @hidden\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n * ```ts\nconst ob1 = observe(0);\nconst ob2 = observe(1);\n\n// When\n@ReactiveSubscribe\nclass TestComputed {\n  @Computed\n  get ob3() {\n    return ob1.current + ob2.current;\n  }\n}\nconst inst = new TestComputed();\n\ninst.subscribe(\"ob3\", ob3 => {\n  console.log(ob3);\n});\n\nob1.current = 1;\n```\n */\n\nfunction Computed(prototype, memberName, attributes) {\n  var get = attributes.get;\n\n  function getComputed() {\n    var observers = getObservers(this, true);\n\n    if (!(memberName in observers)) {\n      observers[memberName] = computed(get.bind(this));\n    }\n\n    return getObserver(this, memberName).current;\n  }\n\n  var nextAttributes = {\n    configurable: true,\n    get: getComputed\n  };\n  prototype[COMPUTED_PATH] || (prototype[COMPUTED_PATH] = []);\n  var computedList = prototype[COMPUTED_PATH];\n\n  if (computedList.indexOf(memberName) === -1) {\n    computedList.push(memberName);\n  }\n\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  return nextAttributes;\n}\n\n\n//# sourceMappingURL=cfcs.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNmY3MvY29yZS9kaXN0L2NmY3MuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7O0FBRUEsb0VBQW9FOzs7QUFHcEU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsdURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZ1c7QUFDaFciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFkbWluLy4vbm9kZV9tb2R1bGVzL0BjZmNzL2NvcmUvZGlzdC9jZmNzLmVzbS5qcz80MjJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIE5BVkVSIENyb3AuXG5uYW1lOiBAY2Zjcy9jb3JlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ3JvcC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9jZmNzXG52ZXJzaW9uOiAwLjAuMjZcbiovXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BlZ2pzL2NvbXBvbmVudCc7XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xccy1fXShbYS16XSkvZywgZnVuY3Rpb24gKGFsbCwgbGV0dGVyKSB7XG4gICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGZpbmRUYXJnZXQodGFyZ2V0KSB7XG4gIHZhciBlbDtcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcbiAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgZWwgPSB0YXJnZXQ7XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIHRhcmdldCB8fCBcImN1cnJlbnRcIiBpbiB0YXJnZXQpIHtcbiAgICBlbCA9IHRhcmdldC52YWx1ZSB8fCB0YXJnZXQuY3VycmVudDtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIG5hbWUgb2YgdGhlIGNsYXNzIG1ldGhvZCB0byBiZSBleHBvc2VkIHRvIHRoZSBvdXRzaWRlLlxuICogQGNhdGVnb3J5IERPTVxuICogQHJldHVybiBQcm9wZXJ0eSBEZWNvcmF0b3JcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgd2l0aENsYXNzTWV0aG9kcyB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG4gKlxuICogY2xhc3MgWW91ckZyYW1ld29ya0NvbXBvbmVudCB7XG4gKiAgIEB3aXRoQ2xhc3NNZXRob2QoTUVUSE9EX05BTUVTKVxuICogICBpbnN0ID0gbmV3IFlvdXJDb21wb25lbnQoKTtcbiAqIH1cbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHdpdGhDbGFzc01ldGhvZHMobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgbWVtYmVyTmFtZSkge1xuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gcHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSAoX2EgPSB0aGlzW21lbWJlck5hbWVdKVtuYW1lXS5hcHBseShfYSwgYXJncyk7IC8vIGZpeCBgdGhpc2AgdHlwZSB0byByZXR1cm4geW91ciBvd24gYGNsYXNzYCBpbnN0YW5jZSB0byB0aGUgaW5zdGFuY2UgdXNpbmcgdGhlIGRlY29yYXRvci5cblxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHRoaXNbbWVtYmVyTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xufVxuXG52YXIgT0JTRVJWRVJTX1BBVEggPSBcIl9fb2JzZXJ2ZXJzX19cIjtcbnZhciBDT01QVVRFRF9QQVRIID0gXCJfX2NvbXB1dGVkX19cIjtcbnZhciBDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OID0gMTtcbnZhciBDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFUyA9IFwiX19DRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19fXCI7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmZ1bmN0aW9uIGdldERldGVjdGVkU3RhY2soKSB7XG4gIC8vIFZlcnNpb24gaXNzdWVzIGRvIG5vdCBvY2N1ciB3aGVuIHlvdSBhY2Nlc3MgdGhlIG5hdGl2ZSBvYmplY3QgaW4gdGhlIGdsb2JhbC5cbiAgT2JqZWN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTXSA9IE9iamVjdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU10gfHwge307XG4gIHZhciB2ZXJzaW9uTGlzdCA9IE9iamVjdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU107XG4gIHZlcnNpb25MaXN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT05dID0gdmVyc2lvbkxpc3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTl0gfHwgW107XG4gIHJldHVybiB2ZXJzaW9uTGlzdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnREZXRlY3RlZCgpIHtcbiAgdmFyIHN0YWNrID0gZ2V0RGV0ZWN0ZWRTdGFjaygpO1xuICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBkZXRlY3REZXBlbmRlbmNpZXMoaG9zdCkge1xuICB2YXIgc3RhY2sgPSBnZXREZXRlY3RlZFN0YWNrKCk7XG4gIHZhciBvYnNlcnZlcnMgPSBbXTtcbiAgdmFyIGRldGVjdGVkID0ge1xuICAgIGhvc3Q6IGhvc3QsXG4gICAgb2JzZXJ2ZXJzOiBvYnNlcnZlcnMsXG4gICAgcHVzaDogZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICBpZiAoaG9zdCAhPT0gb2JzZXJ2ZXIgJiYgb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpID09PSAtMSkge1xuICAgICAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGFjay5wdXNoKGRldGVjdGVkKTtcbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuZnVuY3Rpb24gZW5kRGV0ZWN0RGVwZW5kZW5jaWVzKCkge1xuICB2YXIgc3RhY2sgPSBnZXREZXRlY3RlZFN0YWNrKCk7XG4gIHJldHVybiBzdGFjay5wb3AoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbXV0YWJsZSByZWYgb2JqZWN0LiBZb3UgY2FuIGFjY2VzcyB0aGUgYC5jdXJyZW50YCB2YWx1ZSBhbmQgZGV0ZWN0IHRoZSB2YWx1ZSBjaGFuZ2UgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBzZWUgb2JzZXJ2ZVxuICovXG5cbnZhciBPYnNlcnZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IENvbXBvbmVudCgpO1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gT2JzZXJ2ZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjdXJyZW50XCIsIHtcbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudERldGVjdGVkID0gZ2V0Q3VycmVudERldGVjdGVkKCk7XG4gICAgICBjdXJyZW50RGV0ZWN0ZWQgPT09IG51bGwgfHwgY3VycmVudERldGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RGV0ZWN0ZWQucHVzaCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldEN1cnJlbnQodmFsdWUpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogV2hlbiB0aGUgY3VycmVudCB2YWx1ZSBjaGFuZ2VzLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKi9cblxuICBfX3Byb3RvLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuY3VycmVudDtcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oXCJ1cGRhdGVcIiwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIHJlZ2lzdGVyZWQgc3Vic2NyaXB0aW9uIHRocm91Z2ggY2FsbGJhY2suXG4gICAqL1xuXG5cbiAgX19wcm90by51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKFwidXBkYXRlXCIsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NldEN1cnJlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcHJldlZhbHVlID0gdGhpcy5fY3VycmVudDtcbiAgICB2YXIgaXNVcGRhdGUgPSB2YWx1ZSAhPT0gcHJldlZhbHVlO1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcblxuICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fZW1pdHRlci50cmlnZ2VyKFwidXBkYXRlXCIsIHZhbHVlLCBwcmV2VmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICovXG5cblxuICBfX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmN1cnJlbnQpO1xuICB9O1xuICAvKipcbiAgICogQGhpZGRlblxuICAgKi9cblxuXG4gIF9fcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcblxuLyoqXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBoaWRkZW5cbiAqL1xuXG52YXIgQ29tcHV0ZWRPYnNlcnZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDb21wdXRlZE9ic2VydmVyLCBfc3VwZXIpO1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBuZXcgY29tcHV0ZWQgb2JzZXJ2ZXIgZnJvbSB0aGUgdmFsdWVzIG9mIG90aGVyIG9ic2VydmVycy5cbiAgICogSXQgaXMgcmVhZC1vbmx5IGFuZCBpZiB5b3UgY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgb2JzZXJ2ZXIgdXNlZCBpbnNpZGUgdGhlIGNhbGxiYWNrLCBpdHMgdmFsdWUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBfY29tcHV0ZWRDYWxsYmFjayBBIGZ1bmN0aW9uIGZvciBvYnNlcnZlcnMgdG8gYmUgY29tcHV0ZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gQ29tcHV0ZWRPYnNlcnZlcihfY29tcHV0ZWRDYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5fY29tcHV0ZWRDYWxsYmFjayA9IF9jb21wdXRlZENhbGxiYWNrO1xuICAgIF90aGlzLl9yZWdpc3RlcmVkID0gW107XG5cbiAgICBfdGhpcy5fb25DaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9zZXRDdXJyZW50KF90aGlzLmN1cnJlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fY3VycmVudCA9IF90aGlzLmN1cnJlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDb21wdXRlZE9ic2VydmVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY3VycmVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBkZXRlY3REZXBlbmRlbmNpZXModGhpcyk7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2NvbXB1dGVkQ2FsbGJhY2soKTtcblxuICAgICAgdmFyIHJlc3VsdHMgPSBlbmREZXRlY3REZXBlbmRlbmNpZXMoKTtcblxuICAgICAgdGhpcy5fcmVnaXN0ZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci51bnN1YnNjcmliZShfdGhpcy5fb25DaGVja1VwZGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0cy5vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKF90aGlzLl9vbkNoZWNrVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZCA9IHJlc3VsdHMub2JzZXJ2ZXJzO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gQ29tcHV0ZWRPYnNlcnZlcjtcbn0oT2JzZXJ2ZXIpO1xuXG5mdW5jdGlvbiBpbmplY3RPYnNlcnZlKHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgcHVibGljTmFtZSkge1xuICBpZiAocHVibGljTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgcHVibGljTmFtZSA9IG1lbWJlck5hbWU7XG4gIH1cblxuICB2YXIgbmV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldE9ic2VydmVyKHRoaXMsIHB1YmxpY05hbWUpLmN1cnJlbnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZ2V0T2JzZXJ2ZXIodGhpcywgcHVibGljTmFtZSwgdmFsdWUpLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIG5leHRBdHRyaWJ1dGVzKTtcblxuICBpZiAocHVibGljTmFtZSAhPT0gbWVtYmVyTmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHB1YmxpY05hbWUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0T2JzZXJ2ZXIodGhpcywgcHVibGljTmFtZSkuY3VycmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gYE9ic2VydmVgIGlzIGEgcHJvcGVydHkgZGVjb3JhdG9yIGFuZCBjb252ZXJ0cyB0aGUgcHJvcGVydHkgaW50byBhIGByZWFjdGl2ZSBzdGF0ZWAuIFlvdSBjYW4gZGV0ZWN0IGl0cyBzdGF0dXMgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmUtRGVjb3JhdG9yXG4gKiBAc2VlIFJlYWN0aXZlU3Vic2NyaWJlXG4gKiBAZXhhbXBsZVxuKiBgYGB0c1xuaW1wb3J0IHsgUmVhY3RpdmVTdWJzY3JpYmUsIE9ic2VydmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuXG5AUmVhY3RpdmVTdWJzY3JpYmVcbmNsYXNzIENvbXBvbmVudCB7XG4gIC8vIFRoZSBwdWJsaWMgbmFtZSBhbmQgc3RhdGUgbmFtZSBhcmUgdGhlIHNhbWUuXG4gIEBPYnNlcnZlIHZhbHVlMSA9IDE7XG4gIC8vIElmIHlvdSB3YW50IHRvIHNldCBwdWJsaWMgbmFtZSBhbmQgcHJpdmF0ZSBwcm9wZXJ0aWVzIHNlcGFyYXRlbHlcbiAgQE9ic2VydmUoXCJ2YWx1ZTJcIikgX3ZhbHVlMiA9IDE7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMudmFsdWUxID0gMjtcbiAgICB9KTtcbiAgfVxufVxuaW50ZXJmYWNlIENcbmBgYFxuICovXG5cblxuZnVuY3Rpb24gT2JzZXJ2ZSgpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gaW5qZWN0T2JzZXJ2ZShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBtZW1iZXJOYW1lKSB7XG4gICAgcmV0dXJuIGluamVjdE9ic2VydmUocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBhcmdzWzBdKTtcbiAgfTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIFJlYWN0aXZlKCkge1xuICB2YXIgYXJncyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgcmV0dXJuIE9ic2VydmUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0UmVhY3RpdmVTdWJzY3JpYmUob2JqZWN0KSB7XG4gIG9iamVjdFtcInN1YnNjcmliZVwiXSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXNbbmFtZV07XG4gICAgZ2V0T2JzZXJ2ZXIodGhpcywgbmFtZSkuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgfTtcblxuICBvYmplY3RbXCJ1bnN1YnNjcmliZVwiXSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIGtleXMoZ2V0T2JzZXJ2ZXJzKHRoaXMpKS5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlck5hbWUpIHtcbiAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUob2JzZXJ2ZXJOYW1lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKG5hbWUgaW4gdGhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRPYnNlcnZlcih0aGlzLCBuYW1lKS51bnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH07XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBgUmVhY3RpdmVTdWJzY3JpYmVgIGlzIGEgY2xhc3MgZGVjb3JhdG9yIGFuZCBhZGRzIGAuc3Vic2NyaWJlYCBhbmQgYC51bnN1YnNjcmliZWAgbWV0aG9kcy5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZS1EZWNvcmF0b3JcbiAqIEBzZWUgT2JzZXJ2ZVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG5pbXBvcnQgeyBSZWFjdGl2ZVN1YnNjcmliZSwgT2JzZXJ2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG5cbkBSZWFjdGl2ZVN1YnNjcmliZVxuY2xhc3MgQ29tcG9uZW50IHtcbiAgQE9ic2VydmUgdmFsdWUxID0gMTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZTEgPSAyO1xuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBDb21wb25lbnQgZXh0ZW5kcyBSZWFjdGl2ZVN1YnNjcmliZTx7XG4gIHZhbHVlMTogbnVtYmVyO1xuICB2YWx1ZTI6IG51bWJlcjtcbn0+IHt9XG5cbmNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoKTtcblxuLy8gMVxuY29uc29sZS5sb2coY29tcG9uZW50LnZhbHVlMSk7XG5cbmNvbXBvbmVudC5zdWJzY3JpYmUoXCJ2YWx1ZTFcIiwgbmV4dFZhbHVlID0+IHtcbiAgLy8gV2hlbiB0aGUgY2hhbmdlIGV2ZW50IG9jY3VycyA9PiAoMiwgMilcbiAgY29uc29sZS5sb2cobmV4dFZhbHVlLCBjb21wb25lbnQudmFsdWUyKTtcbn0pO1xuYGBgXG4gKi9cblxuZnVuY3Rpb24gUmVhY3RpdmVTdWJzY3JpYmUoQ29uc3RydWN0b3IpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaW5qZWN0UmVhY3RpdmVTdWJzY3JpYmUocHJvdG90eXBlKTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlYWN0aXZlT2JqZWN0KHNldHVwLCBhbGwpIHtcbiAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24oc2V0dXApID8gc2V0dXAoKSA6IHNldHVwO1xuICB2YXIgcmVhY3RpdmVPYmplY3QgPSB7fTtcbiAgZGVmaW5lT2JzZXJ2ZXJzKHJlYWN0aXZlT2JqZWN0KTtcbiAga2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSByZXN1bHRbbmFtZV07XG5cbiAgICBpZiAoaXNPYnNlcnZlcih2YWx1ZSkpIHtcbiAgICAgIHNldE9ic2VydmVyKHJlYWN0aXZlT2JqZWN0LCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldE9ic2VydmVyKHJlYWN0aXZlT2JqZWN0LCBuYW1lLCBvYnNlcnZlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgT2JzZXJ2ZShuYW1lKShyZWFjdGl2ZU9iamVjdCwgbmFtZSk7XG4gIH0pO1xuICBpbmplY3RSZWFjdGl2ZVN1YnNjcmliZShyZWFjdGl2ZU9iamVjdCk7XG4gIHJldHVybiByZWFjdGl2ZU9iamVjdDtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIE1ha2UgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBvYmplY3Qgb3IgZnVuY3Rpb24gYSByZWFjdGl2ZSBvYmplY3QuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBwYXJhbSBzZXR1cCAtIFRoZSB0YXJnZXQgb2JqZWN0IG9yIGZ1bmN0aW9uIHRvIHdoaWNoIHJlYWN0aXZlIGlzIGFwcGxpZWRcbiAqIEByZXR1cm5zIE1ha2VzIGFsbCB2YWx1ZXMgaW50byByZWFjdGl2ZSBvYmplY3RzLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyByZWFjdGl2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG4gKlxuICogY29uc3Qgb2JqID0gcmVhY3RpdmUoe1xuICogIHZhbHVlMTogMSxcbiAqICB2YWx1ZTI6IDIsXG4gKiB9KTtcbiAqXG4gKiBvYmouc3Vic2NyaWJlKFwidmFsdWUxXCIsIHZhbHVlMSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlMSk7XG4gKiB9KTtcbiAqIG9iai52YWx1ZTEgPSAyO1xuICogYGBgXG4gKi9cblxuXG5mdW5jdGlvbiByZWFjdGl2ZShzZXR1cCkge1xuICByZXR1cm4gbWFrZVJlYWN0aXZlT2JqZWN0KHNldHVwKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIE1ha2UgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBvYmplY3Qgb3IgZnVuY3Rpb24gYSByZWFjdGl2ZSBvYmplY3QuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBwYXJhbSBzZXR1cCAtIFRoZSB0YXJnZXQgb2JqZWN0IG9yIGZ1bmN0aW9uIHRvIHdoaWNoIHJlYWN0aXZlIGlzIGFwcGxpZWRcbiAqIEByZXR1cm5zIE9ubHkgdGhlIHZhbHVlcyB0byB3aGljaCBvYnNlcnZlciBpcyBhcHBsaWVkIGFyZSBvYmplY3RzIHRvIHdoaWNoIHJlYWN0aXZlIGlzIGFwcGxpZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHBhcnRpYWxSZWFjdGl2ZSwgb2JzZXJ2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG4gKlxuICogY29uc3QgdmFsdWUxID0gb2JzZXJ2ZSgxKTtcbiAqIGNvbnN0IHZhbHVlMiA9IG9ic2VydmUoMik7XG4gKiBjb25zdCBvYmogPSBwYXJ0aWFsUmVhY3RpdmUoe1xuICogIHZhbHVlMSxcbiAqICB2YWx1ZTIsXG4gKiB9KTtcbiAqXG4gKiBvYmouc3Vic2NyaWJlKFwidmFsdWUxXCIsIHZhbHVlMSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlMSk7XG4gKiB9KTtcbiAqIHZhbHVlMS5jdXJyZW50ID0gMjtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHBhcnRpYWxSZWFjdGl2ZShzZXR1cCkge1xuICByZXR1cm4gbWFrZVJlYWN0aXZlT2JqZWN0KHNldHVwKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QuIFlvdSBjYW4gYWNjZXNzIHRoZSBgLmN1cnJlbnRgIHZhbHVlIGFuZCBkZXRlY3QgdGhlIHZhbHVlIGNoYW5nZSB0aHJvdWdoIGAuc3Vic2NyaWJlYC5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvYnNlcnZlIH0gZnJvbSBcIkBjZmNzL2NvcmVcIjtcbiAqXG4gKiBjb25zdCBvYjEgPSBvYnNlcnZlKDEpO1xuICpcbiAqIG9iMS5zdWJzY3JpYmUobmV4dFZhbHVlID0+IHtcbiAqICAgY29uc29sZS5sb2cobmV4dFZhbHVlKTtcbiAqIH0pO1xuICpcbiAqIG9iMS5jdXJyZW50ID0gMjtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIG9ic2VydmUoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIoZGVmYXVsdFZhbHVlKTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVkKGNvbXB1dGVkQ2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBDb21wdXRlZE9ic2VydmVyKGNvbXB1dGVkQ2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiB3aXRoUmVhY3RpdmVNZXRob2RzKHJlZiwgbWV0aG9kcykge1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKCFtZXRob2RzKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnQgPSByZWYuY3VycmVudCB8fCByZWYudmFsdWU7XG4gICAgICByZXR1cm4gY3VycmVudFtuYW1lXS5hcHBseShjdXJyZW50LCBhcmdzKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGRlZmluZU9ic2VydmVycyhpbnN0YW5jZSkge1xuICB2YXIgb2JzZXJ2ZXJzID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgT0JTRVJWRVJTX1BBVEgsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlcnM7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9ic2VydmVycztcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGdldE9ic2VydmVycyhpbnN0YW5jZSwgaXNDb21wdXRlZCkge1xuICB2YXIgX2EsIF9iO1xuXG4gIGlmICghaW5zdGFuY2VbT0JTRVJWRVJTX1BBVEhdKSB7XG4gICAgZGVmaW5lT2JzZXJ2ZXJzKGluc3RhbmNlKTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlcnMgPSBpbnN0YW5jZVtPQlNFUlZFUlNfUEFUSF07XG5cbiAgaWYgKCFpc0NvbXB1dGVkKSB7XG4gICAgdmFyIGNvbXB1dGVkTGlzdCA9IChfYiA9IChfYSA9IGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnN0YW5jZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW0NPTVBVVEVEX1BBVEhdO1xuXG4gICAgaWYgKGNvbXB1dGVkTGlzdCkge1xuICAgICAgY29tcHV0ZWRMaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBvYnNlcnZlcnMpICYmIG5hbWUgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9ic2VydmVycztcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGdldE9ic2VydmVyKGluc3RhbmNlLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIG9ic2VydmVycyA9IGdldE9ic2VydmVycyhpbnN0YW5jZSk7XG5cbiAgaWYgKCFvYnNlcnZlcnNbbmFtZV0pIHtcbiAgICBvYnNlcnZlcnNbbmFtZV0gPSBvYnNlcnZlKGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gb2JzZXJ2ZXJzW25hbWVdO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gc2V0T2JzZXJ2ZXIoaW5zdGFuY2UsIG5hbWUsIG9ic2VydmVyKSB7XG4gIHZhciBvYnNlcnZlcnMgPSBnZXRPYnNlcnZlcnMoaW5zdGFuY2UpO1xuICBvYnNlcnZlcnNbbmFtZV0gPSBvYnNlcnZlcjtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdGhhdCBvYmplY3QgaXMgYW4gb2JzZXJ2ZXIgaW5zdGFuY2VcbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JzZXJ2ZXIodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgaXNPYmplY3QodmFsKSAmJiBcImN1cnJlbnRcIiBpbiB2YWwgJiYgXCJzdWJzY3JpYmVcIiBpbiB2YWwgJiYgXCJ1bnN1YnNjcmliZVwiIGluIHZhbDtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdGhlIG9iamVjdCBpcyByZWFjdGl2ZVxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKi9cblxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAhaXNPYnNlcnZlcih2YWwpICYmIFwic3Vic2NyaWJlXCIgaW4gdmFsICYmIFwidW5zdWJzY3JpYmVcIiBpbiB2YWw7XG59XG5cbi8qKlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gYWRhcHRSZWFjdGl2ZShhZGFwdGVyLCBwcm9wcykge1xuICB2YXIgb2JqZWN0QWRhcHRlciA9IGlzRnVuY3Rpb24oYWRhcHRlcikgPyB7XG4gICAgc2V0dXA6IGFkYXB0ZXJcbiAgfSA6IGFkYXB0ZXI7XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcHMoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcblxuICAgIHJldHVybiAoX2UgPSAoX2MgPSAoX2EgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gb2JqZWN0QWRhcHRlci5wcm9wcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwob2JqZWN0QWRhcHRlcikpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IG9iamVjdEFkYXB0ZXIuZGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwob2JqZWN0QWRhcHRlcikpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHt9O1xuICB9XG5cbiAgdmFyIGV2ZW50RW1pdHRlciA9IG5ldyBDb21wb25lbnQoKTtcbiAgdmFyIG1vdW50ZWRIb29rcyA9IFtdO1xuICB2YXIgaW5pdEhvb2tzID0gW107XG4gIHZhciBkZXN0cm95SG9va3MgPSBbXTtcbiAgdmFyIG9uSG9va3MgPSBbXTtcbiAgdmFyIGluc3RhbmNlUmVmID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAgdmFyIG9mZkhvb2tzTGlzdCA9IFtdO1xuICB2YXIgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgdmFyIGV2ZW50TmFtZXMgPSBbXTtcbiAgdmFyIG1ldGhvZE5hbWVzID0gW107XG5cbiAgdmFyIG9uTW91bnRlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIG1vdW50ZWRIb29rcy5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcblxuICB2YXIgb25Jbml0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaW5pdEhvb2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xuXG4gIHZhciBvbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBkZXN0cm95SG9va3MucHVzaChjYWxsYmFjayk7XG4gIH07XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgb25Ib29rcy5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcblxuICB2YXIgZW1pdCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGV2ZW50RW1pdHRlci50cmlnZ2VyLmFwcGx5KGV2ZW50RW1pdHRlciwgX19zcHJlYWRBcnJheShbZXZlbnROYW1lXSwgcGFyYW1zLCBmYWxzZSkpO1xuICB9O1xuXG4gIHZhciBzZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBzdGF0ZTtcbiAgfTtcblxuICB2YXIgc2V0RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGV2ZW50TmFtZXMgPSBldmVudHM7XG4gIH07XG5cbiAgdmFyIHNldE1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgIG1ldGhvZE5hbWVzID0gbWV0aG9kcztcbiAgfTtcblxuICBpZiAob2JqZWN0QWRhcHRlci5zZXR1cCkge1xuICAgIGluc3RhbmNlUmVmLmN1cnJlbnQgPSBvYmplY3RBZGFwdGVyLnNldHVwKHtcbiAgICAgIGdldFByb3BzOiBnZXRQcm9wcyxcbiAgICAgIHNldEluaXRpYWxTdGF0ZTogc2V0SW5pdGlhbFN0YXRlLFxuICAgICAgc2V0RXZlbnRzOiBzZXRFdmVudHMsXG4gICAgICBzZXRNZXRob2RzOiBzZXRNZXRob2RzLFxuICAgICAgb25Nb3VudGVkOiBvbk1vdW50ZWQsXG4gICAgICBvbkRlc3Ryb3k6IG9uRGVzdHJveSxcbiAgICAgIG9uSW5pdDogb25Jbml0LFxuICAgICAgZW1pdDogZW1pdCxcbiAgICAgIG9uOiBvblxuICAgIH0pIHx8IG51bGw7XG4gIH1cblxuICBpZiAob2JqZWN0QWRhcHRlci5jcmVhdGVkKSB7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudCA9IG9iamVjdEFkYXB0ZXIuY3JlYXRlZChnZXRQcm9wcygpKSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKG9iamVjdEFkYXB0ZXIuZXZlbnRzKSB7XG4gICAgc2V0RXZlbnRzKG9iamVjdEFkYXB0ZXIuZXZlbnRzKTtcbiAgfVxuXG4gIGlmIChvYmplY3RBZGFwdGVyLnN0YXRlKSB7XG4gICAgc2V0SW5pdGlhbFN0YXRlKG9iamVjdEFkYXB0ZXIuc3RhdGUpO1xuICB9XG5cbiAgaWYgKG9iamVjdEFkYXB0ZXIubWV0aG9kcykge1xuICAgIHNldE1ldGhvZHMob2JqZWN0QWRhcHRlci5tZXRob2RzKTtcbiAgfVxuXG4gIGlmIChvYmplY3RBZGFwdGVyLm1vdW50ZWQpIHtcbiAgICBvbk1vdW50ZWQob2JqZWN0QWRhcHRlci5tb3VudGVkKTtcbiAgfVxuXG4gIGlmIChvYmplY3RBZGFwdGVyLmRlc3Ryb3kpIHtcbiAgICBkZXN0cm95SG9va3MucHVzaChvYmplY3RBZGFwdGVyLmRlc3Ryb3kpO1xuICB9XG5cbiAgaWYgKG9iamVjdEFkYXB0ZXIuaW5pdCkge1xuICAgIGluaXRIb29rcy5wdXNoKG9iamVjdEFkYXB0ZXIuaW5pdCk7XG4gIH1cblxuICBpZiAob2JqZWN0QWRhcHRlci5vbikge1xuICAgIG9uSG9va3MucHVzaChmdW5jdGlvbiAoaW5zdGFuY2UsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBvZmYgPSBvYmplY3RBZGFwdGVyLm9uKGluc3RhbmNlLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcblxuICAgICAgICBvZmYgJiYgb2ZmKCk7XG4gICAgICAgIChfYSA9IG9iamVjdEFkYXB0ZXIub2ZmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvYmplY3RBZGFwdGVyLCBpbnN0YW5jZSwgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBldmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBldmVudE5hbWVzO1xuICAgIH0sXG4gICAgc3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnN0ID0gaW5zdGFuY2VSZWYuY3VycmVudDtcblxuICAgICAgaWYgKGluaXRpYWxTdGF0ZSkge1xuICAgICAgICByZXR1cm4gaW5pdGlhbFN0YXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzXzEgPSBnZXRPYnNlcnZlcnMoaW5zdCk7XG4gICAgICAgIHNldEluaXRpYWxTdGF0ZShrZXlzKG9ic2VydmVyc18xKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgICAgIHByZXZbY3VyXSA9IG9ic2VydmVyc18xW2N1cl0uY3VycmVudDtcbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwge30pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZSB8fCB7fTtcbiAgICB9LFxuICAgIGluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VSZWYuY3VycmVudDtcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm9wcyA9IGdldFByb3BzKCk7XG4gICAgICBtb3VudGVkSG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICBpbnN0YW5jZVJlZi5jdXJyZW50ID0gaG9vayhwcm9wcywgaW5zdGFuY2VSZWYuY3VycmVudCkgfHwgaW5zdGFuY2VSZWYuY3VycmVudDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gb24gZXZlbnRzXG4gICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZVJlZi5jdXJyZW50O1xuICAgICAgdmFyIHByb3BzID0gZ2V0UHJvcHMoKTtcbiAgICAgIG9mZkhvb2tzTGlzdCA9IGV2ZW50TmFtZXMubWFwKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoX2EgPSBldmVudEVtaXR0ZXIpLnRyaWdnZXIuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW2V2ZW50TmFtZV0sIHBhcmFtcywgZmFsc2UpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZVJlZi5jdXJyZW50O1xuICAgICAgICByZXR1cm4gb25Ib29rcy5tYXAoZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICByZXR1cm4gaG9vayhpbnN0YW5jZSwgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIH0pOyAvLyBpbml0XG5cbiAgICAgIGluaXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgIGhvb2soaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gb2ZmIGV2ZW50c1xuICAgICAgb2ZmSG9va3NMaXN0LmZvckVhY2goZnVuY3Rpb24gKG9mZkhvb2tzKSB7XG4gICAgICAgIG9mZkhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICBob29rKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIGRlc3Ryb3lcblxuICAgICAgZXZlbnRFbWl0dGVyLm9mZigpO1xuICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VSZWYuY3VycmVudDtcbiAgICAgIHZhciBwcm9wcyA9IGdldFByb3BzKCk7XG4gICAgICBkZXN0cm95SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICBob29rKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB3aXRoUmVhY3RpdmVNZXRob2RzKGluc3RhbmNlUmVmLCBtZXRob2ROYW1lcyk7XG4gICAgfSxcbiAgICBvbjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50RW1pdHRlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBgQ29tcHV0ZWRgIGlzIGEgcHJvcGVydHkgZGVjb3JhdG9yLlxuICogQ2hhbmdlcyBpbiBjb21wdXRlZCBzdGF0ZSB2YWx1ZXMgYXJlIGFsc28gcmVjb2duaXplZCBhY2NvcmRpbmcgdG8gY2hhbmdlcyBpbiBvYnNlcnZlcnMgdXNlZCB3aXRoaW4gdGhlIGdldHRlciBmdW5jdGlvbi5cbiAqIFlvdSBjYW4gZGV0ZWN0IGl0cyBzdGF0dXMgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAaGlkZGVuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmUtRGVjb3JhdG9yXG4gKiBAc2VlIFJlYWN0aXZlU3Vic2NyaWJlXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbmNvbnN0IG9iMSA9IG9ic2VydmUoMCk7XG5jb25zdCBvYjIgPSBvYnNlcnZlKDEpO1xuXG4vLyBXaGVuXG5AUmVhY3RpdmVTdWJzY3JpYmVcbmNsYXNzIFRlc3RDb21wdXRlZCB7XG4gIEBDb21wdXRlZFxuICBnZXQgb2IzKCkge1xuICAgIHJldHVybiBvYjEuY3VycmVudCArIG9iMi5jdXJyZW50O1xuICB9XG59XG5jb25zdCBpbnN0ID0gbmV3IFRlc3RDb21wdXRlZCgpO1xuXG5pbnN0LnN1YnNjcmliZShcIm9iM1wiLCBvYjMgPT4ge1xuICBjb25zb2xlLmxvZyhvYjMpO1xufSk7XG5cbm9iMS5jdXJyZW50ID0gMTtcbmBgYFxuICovXG5cbmZ1bmN0aW9uIENvbXB1dGVkKHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgYXR0cmlidXRlcykge1xuICB2YXIgZ2V0ID0gYXR0cmlidXRlcy5nZXQ7XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcHV0ZWQoKSB7XG4gICAgdmFyIG9ic2VydmVycyA9IGdldE9ic2VydmVycyh0aGlzLCB0cnVlKTtcblxuICAgIGlmICghKG1lbWJlck5hbWUgaW4gb2JzZXJ2ZXJzKSkge1xuICAgICAgb2JzZXJ2ZXJzW21lbWJlck5hbWVdID0gY29tcHV0ZWQoZ2V0LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPYnNlcnZlcih0aGlzLCBtZW1iZXJOYW1lKS5jdXJyZW50O1xuICB9XG5cbiAgdmFyIG5leHRBdHRyaWJ1dGVzID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGdldENvbXB1dGVkXG4gIH07XG4gIHByb3RvdHlwZVtDT01QVVRFRF9QQVRIXSB8fCAocHJvdG90eXBlW0NPTVBVVEVEX1BBVEhdID0gW10pO1xuICB2YXIgY29tcHV0ZWRMaXN0ID0gcHJvdG90eXBlW0NPTVBVVEVEX1BBVEhdO1xuXG4gIGlmIChjb21wdXRlZExpc3QuaW5kZXhPZihtZW1iZXJOYW1lKSA9PT0gLTEpIHtcbiAgICBjb21wdXRlZExpc3QucHVzaChtZW1iZXJOYW1lKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIG5leHRBdHRyaWJ1dGVzKTtcbiAgcmV0dXJuIG5leHRBdHRyaWJ1dGVzO1xufVxuXG5leHBvcnQgeyBDb21wdXRlZCwgQ29tcHV0ZWRPYnNlcnZlciwgT2JzZXJ2ZSwgT2JzZXJ2ZXIsIFJlYWN0aXZlLCBSZWFjdGl2ZVN1YnNjcmliZSwgYWRhcHRSZWFjdGl2ZSwgY2FtZWxpemUsIGNvbXB1dGVkLCBkZWZpbmVPYnNlcnZlcnMsIGZpbmRUYXJnZXQsIGdldE9ic2VydmVyLCBnZXRPYnNlcnZlcnMsIGluamVjdFJlYWN0aXZlU3Vic2NyaWJlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNPYnNlcnZlciwgaXNSZWFjdGl2ZSwgaXNTdHJpbmcsIGtleXMsIG9ic2VydmUsIHBhcnRpYWxSZWFjdGl2ZSwgcmVhY3RpdmUsIHNldE9ic2VydmVyLCB3aXRoQ2xhc3NNZXRob2RzLCB3aXRoUmVhY3RpdmVNZXRob2RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZmNzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cfcs/core/dist/cfcs.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cfcs/react/dist/cfcs.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/@cfcs/react/dist/cfcs.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useReactive: () => (/* binding */ useReactive)\n/* harmony export */ });\n/* harmony import */ var _cfcs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cfcs/core */ \"(ssr)/./node_modules/@cfcs/core/dist/cfcs.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/*\nCopyright (c) NAVER Corp.\nname: @cfcs/react\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-conveyer\nversion: 0.0.6\n*/\n\n\n\nfunction useReactive(reactiveProps) {\n  var adaptResult = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n    return (0,_cfcs_core__WEBPACK_IMPORTED_MODULE_0__.adaptReactive)(reactiveProps);\n  }, []);\n  var reactiveState = adaptResult.state();\n  var names = (0,_cfcs_core__WEBPACK_IMPORTED_MODULE_0__.keys)(reactiveState);\n  var states = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({})[0];\n\n  for (var name in reactiveState) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    var state = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(reactiveState[name]);\n    states[name] = {\n      getter: false,\n      set: state[1],\n      value: state[0]\n    };\n  }\n\n  var methods = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n    return adaptResult.methods();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    adaptResult.mounted();\n    var inst = adaptResult.instance();\n    names.forEach(function (name) {\n      inst.subscribe(name, function (value) {\n        if (states[name].getter) {\n          states[name].set(value);\n        }\n      });\n    });\n    adaptResult.init();\n    return function () {\n      adaptResult.destroy();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var result = names.reduce(function (result, name) {\n    Object.defineProperty(result, name, {\n      enumerable: true,\n      get: function () {\n        states[name].getter = true;\n        return states[name].value;\n      }\n    });\n    return result;\n  }, {});\n  var reactiveEvents = reactiveProps.events || [];\n  reactiveEvents.forEach(function (name) {\n    result[(0,_cfcs_core__WEBPACK_IMPORTED_MODULE_0__.camelize)(\"on \".concat(name))] = function (callback, dependencies) {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        adaptResult.on(name, callback);\n        return function () {\n          adaptResult.off(name, callback);\n        }; // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, dependencies);\n    };\n  });\n  (0,_cfcs_core__WEBPACK_IMPORTED_MODULE_0__.keys)(methods).forEach(function (name) {\n    result[name] = methods[name];\n  });\n  return result;\n}\n\n\n//# sourceMappingURL=cfcs.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNmY3MvcmVhY3QvZGlzdC9jZmNzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUNOOztBQUVyRDtBQUNBLG9CQUFvQiw4Q0FBTztBQUMzQixXQUFXLHlEQUFhO0FBQ3hCLEdBQUc7QUFDSDtBQUNBLGNBQWMsZ0RBQUk7QUFDbEIsZUFBZSwrQ0FBUSxHQUFHOztBQUUxQjtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsOENBQU87QUFDdkI7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLFdBQVcsb0RBQVE7QUFDbkI7QUFDQSxNQUFNLGdEQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFJO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFkbWluLy4vbm9kZV9tb2R1bGVzL0BjZmNzL3JlYWN0L2Rpc3QvY2Zjcy5lc20uanM/NGU2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSBOQVZFUiBDb3JwLlxubmFtZTogQGNmY3MvcmVhY3RcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29udmV5ZXJcbnZlcnNpb246IDAuMC42XG4qL1xuaW1wb3J0IHsgYWRhcHRSZWFjdGl2ZSwga2V5cywgY2FtZWxpemUgfSBmcm9tICdAY2Zjcy9jb3JlJztcbmltcG9ydCB7IHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIHVzZVJlYWN0aXZlKHJlYWN0aXZlUHJvcHMpIHtcbiAgdmFyIGFkYXB0UmVzdWx0ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFkYXB0UmVhY3RpdmUocmVhY3RpdmVQcm9wcyk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlYWN0aXZlU3RhdGUgPSBhZGFwdFJlc3VsdC5zdGF0ZSgpO1xuICB2YXIgbmFtZXMgPSBrZXlzKHJlYWN0aXZlU3RhdGUpO1xuICB2YXIgc3RhdGVzID0gdXNlU3RhdGUoe30pWzBdO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcmVhY3RpdmVTdGF0ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHZhciBzdGF0ZSA9IHVzZVN0YXRlKHJlYWN0aXZlU3RhdGVbbmFtZV0pO1xuICAgIHN0YXRlc1tuYW1lXSA9IHtcbiAgICAgIGdldHRlcjogZmFsc2UsXG4gICAgICBzZXQ6IHN0YXRlWzFdLFxuICAgICAgdmFsdWU6IHN0YXRlWzBdXG4gICAgfTtcbiAgfVxuXG4gIHZhciBtZXRob2RzID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFkYXB0UmVzdWx0Lm1ldGhvZHMoKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGFkYXB0UmVzdWx0Lm1vdW50ZWQoKTtcbiAgICB2YXIgaW5zdCA9IGFkYXB0UmVzdWx0Lmluc3RhbmNlKCk7XG4gICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaW5zdC5zdWJzY3JpYmUobmFtZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChzdGF0ZXNbbmFtZV0uZ2V0dGVyKSB7XG4gICAgICAgICAgc3RhdGVzW25hbWVdLnNldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFkYXB0UmVzdWx0LmluaXQoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgYWRhcHRSZXN1bHQuZGVzdHJveSgpO1xuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICB2YXIgcmVzdWx0ID0gbmFtZXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBuYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0YXRlc1tuYW1lXS5nZXR0ZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RhdGVzW25hbWVdLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgdmFyIHJlYWN0aXZlRXZlbnRzID0gcmVhY3RpdmVQcm9wcy5ldmVudHMgfHwgW107XG4gIHJlYWN0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXN1bHRbY2FtZWxpemUoXCJvbiBcIi5jb25jYXQobmFtZSkpXSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkYXB0UmVzdWx0Lm9uKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhZGFwdFJlc3VsdC5vZmYobmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICB9LCBkZXBlbmRlbmNpZXMpO1xuICAgIH07XG4gIH0pO1xuICBrZXlzKG1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBtZXRob2RzW25hbWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgdXNlUmVhY3RpdmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNmY3MuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cfcs/react/dist/cfcs.esm.js\n");

/***/ })

};
;