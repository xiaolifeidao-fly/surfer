"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@egjs";
exports.ids = ["vendor-chunks/@egjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@egjs/agent/dist/agent.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/@egjs/agent/dist/agent.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getAccurateAgent: () => (/* binding */ getAccurateAgent),\n/* harmony export */   getLegacyAgent: () => (/* binding */ getLegacyAgent)\n/* harmony export */ });\n/*\nCopyright (c) 2015 NAVER Corp.\nname: @egjs/agent\nlicense: MIT\nauthor: NAVER Corp.\nrepository: git+https://github.com/naver/egjs-agent.git\nversion: 2.4.4\n*/\nfunction some(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction find(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\nfunction getUserAgentString(agent) {\n  var userAgent = agent;\n\n  if (typeof userAgent === \"undefined\") {\n    if (typeof navigator === \"undefined\" || !navigator) {\n      return \"\";\n    }\n\n    userAgent = navigator.userAgent || \"\";\n  }\n\n  return userAgent.toLowerCase();\n}\nfunction execRegExp(pattern, text) {\n  try {\n    return new RegExp(pattern, \"g\").exec(text);\n  } catch (e) {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator === \"undefined\" || !navigator || !navigator.userAgentData) {\n    return false;\n  }\n\n  var userAgentData = navigator.userAgentData;\n  var brands = userAgentData.brands || userAgentData.uaList;\n  return !!(brands && brands.length);\n}\nfunction findVersion(versionTest, userAgent) {\n  var result = execRegExp(\"(\" + versionTest + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", userAgent);\n  return result ? result[3] : \"\";\n}\nfunction convertVersion(text) {\n  return text.replace(/_/g, \".\");\n}\nfunction findPreset(presets, userAgent) {\n  var userPreset = null;\n  var version = \"-1\";\n  some(presets, function (preset) {\n    var result = execRegExp(\"(\" + preset.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", userAgent);\n\n    if (!result || preset.brand) {\n      return false;\n    }\n\n    userPreset = preset;\n    version = result[3] || \"-1\";\n\n    if (preset.versionAlias) {\n      version = preset.versionAlias;\n    } else if (preset.versionTest) {\n      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;\n    }\n\n    version = convertVersion(version);\n    return true;\n  });\n  return {\n    preset: userPreset,\n    version: version\n  };\n}\nfunction findPresetBrand(presets, brands) {\n  var brandInfo = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  some(presets, function (preset) {\n    var result = findBrand(brands, preset);\n\n    if (!result) {\n      return false;\n    }\n\n    brandInfo.brand = preset.id;\n    brandInfo.version = preset.versionAlias || result.version;\n    return brandInfo.version !== \"-1\";\n  });\n  return brandInfo;\n}\nfunction findBrand(brands, preset) {\n  return find(brands, function (_a) {\n    var brand = _a.brand;\n    return execRegExp(\"\" + preset.test, brand.toLowerCase());\n  });\n}\n\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}]; // chromium's engine(blink) is based on applewebkit 537.36.\n\nvar CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: true\n}];\nvar WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}];\nvar WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}];\nvar OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\n\nfunction isWebView(userAgent) {\n  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;\n}\nfunction getLegacyAgent(userAgent) {\n  var nextAgent = getUserAgentString(userAgent);\n  var isMobile = !!/mobi/g.exec(nextAgent);\n  var browser = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(nextAgent),\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webkit: false,\n    webkitVersion: \"-1\"\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n\n  var _a = findPreset(BROWSER_PRESETS, nextAgent),\n      browserPreset = _a.preset,\n      browserVersion = _a.version;\n\n  var _b = findPreset(OS_PRESETS, nextAgent),\n      osPreset = _b.preset,\n      osVersion = _b.version;\n\n  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);\n  browser.chromium = !!chromiumPreset.preset;\n  browser.chromiumVersion = chromiumPreset.version;\n\n  if (!browser.chromium) {\n    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);\n    browser.webkit = !!webkitPreset.preset;\n    browser.webkitVersion = webkitPreset.version;\n  }\n\n  if (osPreset) {\n    os.name = osPreset.id;\n    os.version = osVersion;\n    os.majorVersion = parseInt(osVersion, 10);\n  }\n\n  if (browserPreset) {\n    browser.name = browserPreset.id;\n    browser.version = browserVersion; // Early whale bugs\n\n    if (browser.webview && os.name === \"ios\" && browser.name !== \"safari\") {\n      browser.webview = false;\n    }\n  }\n\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser: browser,\n    os: os,\n    isMobile: isMobile,\n    isHints: false\n  };\n}\n\nfunction getClientHintsAgent(osData) {\n  var userAgentData = navigator.userAgentData;\n  var brands = (userAgentData.uaList || userAgentData.brands).slice();\n  var fullVersionList = osData && osData.fullVersionList;\n  var isMobile = userAgentData.mobile || false;\n  var firstBrand = brands[0];\n  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();\n  var browser = {\n    name: firstBrand.brand,\n    version: firstBrand.version,\n    majorVersion: -1,\n    webkit: false,\n    webkitVersion: \"-1\",\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {\n    return findBrand(brands, preset);\n  });\n  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);\n  browser.chromium = !!chromiumBrand.brand;\n  browser.chromiumVersion = chromiumBrand.version || \"-1\";\n\n  if (!browser.chromium) {\n    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);\n    browser.webkit = !!webkitBrand.brand;\n    browser.webkitVersion = webkitBrand.version || \"-1\";\n  }\n\n  var platfomResult = find(OS_PRESETS, function (preset) {\n    return new RegExp(\"\" + preset.test, \"g\").exec(platform);\n  });\n  os.name = platfomResult ? platfomResult.id : \"\";\n\n  if (osData) {\n    os.version = osData.platformVersion || \"-1\";\n  }\n\n  if (fullVersionList && fullVersionList.length) {\n    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);\n    browser.name = browserBrandByFullVersionList.brand || browser.name;\n    browser.version = browserBrandByFullVersionList.version || browser.version;\n  } else {\n    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);\n    browser.name = browserBrand.brand || browser.name;\n    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;\n  }\n\n  if (browser.webkit) {\n    os.name = isMobile ? \"ios\" : \"mac\";\n  }\n\n  if (os.name === \"ios\" && browser.webview) {\n    browser.version = \"-1\";\n  }\n\n  os.version = convertVersion(os.version);\n  browser.version = convertVersion(browser.version);\n  os.majorVersion = parseInt(os.version, 10);\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser: browser,\n    os: os,\n    isMobile: isMobile,\n    isHints: true\n  };\n}\n\n/**\n * @namespace eg.agent\n */\n\n/**\n* Extracts accuate browser and operating system information from the user agent string or client hints.\n* @ko 유저 에이전트 문자열 또는 client hints에서 정확한 브라우저와 운영체제 정보를 추출한다.\n* @function eg.agent#getAccurateAgent\n* @param - Callback function to get the accuate agent <ko>정확한 에이전트를 가져오기 위한 callback 함수</ko>\n* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko> 정확한 에이전트 promise를 가져온다. Promise를 지원 하지 않는 경우, null을 반환한다. </ko>\n* @example\nimport { getAccurateAgent } from \"@egjs/agent\";\n// eg.agent.getAccurateAgent()\ngetAccurateAgent().then(agent => {\n   const { os, browser, isMobile } = agent;\n});\ngetAccurateAgent(agent => {\n    const { os, browser, isMobile } = agent;\n});\n*/\n\nfunction getAccurateAgent(callback) {\n  if (hasUserAgentData()) {\n    return navigator.userAgentData.getHighEntropyValues([\"architecture\", \"model\", \"platform\", \"platformVersion\", \"uaFullVersion\", \"fullVersionList\"]).then(function (info) {\n      var agentInfo = getClientHintsAgent(info);\n      callback && callback(agentInfo);\n      return agentInfo;\n    });\n  }\n\n  callback && callback(agent());\n\n  if (typeof Promise === \"undefined\" || !Promise) {\n    return null;\n  }\n\n  return Promise.resolve(agent());\n}\n/**\n * Extracts browser and operating system information from the user agent string.\n * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.\n * @function eg.agent#agent\n * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>\n * @return - agent Info <ko> 에이전트 정보 </ko>\n * @example\nimport agent from \"@egjs/agent\";\n// eg.agent();\nconst { os, browser, isMobile } = agent();\n */\n\nfunction agent(userAgent) {\n  if (typeof userAgent === \"undefined\" && hasUserAgentData()) {\n    return getClientHintsAgent();\n  } else {\n    return getLegacyAgent(userAgent);\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (agent);\n\n//# sourceMappingURL=agent.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvYWdlbnQvZGlzdC9hZ2VudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFEQUFxRDtBQUNyRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxDQUFDO0FBQ0Q7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQyxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUM7QUFDdUI7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFkbWluLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL2FnZW50L2Rpc3QvYWdlbnQuZXNtLmpzP2Q4ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvYWdlbnRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWFnZW50LmdpdFxudmVyc2lvbjogMi40LjRcbiovXG5mdW5jdGlvbiBzb21lKGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmaW5kKGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGkpKSB7XG4gICAgICByZXR1cm4gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50U3RyaW5nKGFnZW50KSB7XG4gIHZhciB1c2VyQWdlbnQgPSBhZ2VudDtcblxuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8ICFuYXZpZ2F0b3IpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgXCJcIjtcbiAgfVxuXG4gIHJldHVybiB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGV4ZWNSZWdFeHAocGF0dGVybiwgdGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIFwiZ1wiKS5leGVjKHRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1VzZXJBZ2VudERhdGEoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8ICFuYXZpZ2F0b3IgfHwgIW5hdmlnYXRvci51c2VyQWdlbnREYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHVzZXJBZ2VudERhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgdmFyIGJyYW5kcyA9IHVzZXJBZ2VudERhdGEuYnJhbmRzIHx8IHVzZXJBZ2VudERhdGEudWFMaXN0O1xuICByZXR1cm4gISEoYnJhbmRzICYmIGJyYW5kcy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZmluZFZlcnNpb24odmVyc2lvblRlc3QsIHVzZXJBZ2VudCkge1xuICB2YXIgcmVzdWx0ID0gZXhlY1JlZ0V4cChcIihcIiArIHZlcnNpb25UZXN0ICsgXCIpKCg/OlxcXFwvfFxcXFxzfDopKFswLTl8XFxcXC58X10rKSlcIiwgdXNlckFnZW50KTtcbiAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdFszXSA6IFwiXCI7XG59XG5mdW5jdGlvbiBjb252ZXJ0VmVyc2lvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoL18vZywgXCIuXCIpO1xufVxuZnVuY3Rpb24gZmluZFByZXNldChwcmVzZXRzLCB1c2VyQWdlbnQpIHtcbiAgdmFyIHVzZXJQcmVzZXQgPSBudWxsO1xuICB2YXIgdmVyc2lvbiA9IFwiLTFcIjtcbiAgc29tZShwcmVzZXRzLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWNSZWdFeHAoXCIoXCIgKyBwcmVzZXQudGVzdCArIFwiKSgoPzpcXFxcL3xcXFxcc3w6KShbMC05fFxcXFwufF9dKykpP1wiLCB1c2VyQWdlbnQpO1xuXG4gICAgaWYgKCFyZXN1bHQgfHwgcHJlc2V0LmJyYW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdXNlclByZXNldCA9IHByZXNldDtcbiAgICB2ZXJzaW9uID0gcmVzdWx0WzNdIHx8IFwiLTFcIjtcblxuICAgIGlmIChwcmVzZXQudmVyc2lvbkFsaWFzKSB7XG4gICAgICB2ZXJzaW9uID0gcHJlc2V0LnZlcnNpb25BbGlhcztcbiAgICB9IGVsc2UgaWYgKHByZXNldC52ZXJzaW9uVGVzdCkge1xuICAgICAgdmVyc2lvbiA9IGZpbmRWZXJzaW9uKHByZXNldC52ZXJzaW9uVGVzdC50b0xvd2VyQ2FzZSgpLCB1c2VyQWdlbnQpIHx8IHZlcnNpb247XG4gICAgfVxuXG4gICAgdmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKHZlcnNpb24pO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcmVzZXQ6IHVzZXJQcmVzZXQsXG4gICAgdmVyc2lvbjogdmVyc2lvblxuICB9O1xufVxuZnVuY3Rpb24gZmluZFByZXNldEJyYW5kKHByZXNldHMsIGJyYW5kcykge1xuICB2YXIgYnJhbmRJbmZvID0ge1xuICAgIGJyYW5kOiBcIlwiLFxuICAgIHZlcnNpb246IFwiLTFcIlxuICB9O1xuICBzb21lKHByZXNldHMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmluZEJyYW5kKGJyYW5kcywgcHJlc2V0KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYnJhbmRJbmZvLmJyYW5kID0gcHJlc2V0LmlkO1xuICAgIGJyYW5kSW5mby52ZXJzaW9uID0gcHJlc2V0LnZlcnNpb25BbGlhcyB8fCByZXN1bHQudmVyc2lvbjtcbiAgICByZXR1cm4gYnJhbmRJbmZvLnZlcnNpb24gIT09IFwiLTFcIjtcbiAgfSk7XG4gIHJldHVybiBicmFuZEluZm87XG59XG5mdW5jdGlvbiBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpIHtcbiAgcmV0dXJuIGZpbmQoYnJhbmRzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYnJhbmQgPSBfYS5icmFuZDtcbiAgICByZXR1cm4gZXhlY1JlZ0V4cChcIlwiICsgcHJlc2V0LnRlc3QsIGJyYW5kLnRvTG93ZXJDYXNlKCkpO1xuICB9KTtcbn1cblxudmFyIEJST1dTRVJfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwicGhhbnRvbWpzXCIsXG4gIGlkOiBcInBoYW50b21qc1wiXG59LCB7XG4gIHRlc3Q6IFwid2hhbGVcIixcbiAgaWQ6IFwid2hhbGVcIlxufSwge1xuICB0ZXN0OiBcImVkZ2lvc3xlZGdlfGVkZ1wiLFxuICBpZDogXCJlZGdlXCJcbn0sIHtcbiAgdGVzdDogXCJtc2llfHRyaWRlbnR8d2luZG93cyBwaG9uZVwiLFxuICBpZDogXCJpZVwiLFxuICB2ZXJzaW9uVGVzdDogXCJpZW1vYmlsZXxtc2llfHJ2XCJcbn0sIHtcbiAgdGVzdDogXCJtaXVpYnJvd3NlclwiLFxuICBpZDogXCJtaXVpIGJyb3dzZXJcIlxufSwge1xuICB0ZXN0OiBcInNhbXN1bmdicm93c2VyXCIsXG4gIGlkOiBcInNhbXN1bmcgaW50ZXJuZXRcIlxufSwge1xuICB0ZXN0OiBcInNhbXN1bmdcIixcbiAgaWQ6IFwic2Ftc3VuZyBpbnRlcm5ldFwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn0sIHtcbiAgdGVzdDogXCJjaHJvbWV8Y3Jpb3NcIixcbiAgaWQ6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJmaXJlZm94fGZ4aW9zXCIsXG4gIGlkOiBcImZpcmVmb3hcIlxufSwge1xuICB0ZXN0OiBcImFuZHJvaWRcIixcbiAgaWQ6IFwiYW5kcm9pZCBicm93c2VyXCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufSwge1xuICB0ZXN0OiBcInNhZmFyaXxpcGhvbmV8aXBhZHxpcG9kXCIsXG4gIGlkOiBcInNhZmFyaVwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn1dOyAvLyBjaHJvbWl1bSdzIGVuZ2luZShibGluaykgaXMgYmFzZWQgb24gYXBwbGV3ZWJraXQgNTM3LjM2LlxuXG52YXIgQ0hST01JVU1fUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiKD89LiphcHBsZXdlYmtpdC8oNTNbMC03XXw1WzAtMl18WzAtNF0pKSg/PS4qXFxcXHNjaHJvbWUpXCIsXG4gIGlkOiBcImNocm9tZVwiLFxuICB2ZXJzaW9uVGVzdDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcImNocm9taXVtXCIsXG4gIGlkOiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwid2hhbGVcIixcbiAgaWQ6IFwiY2hyb21lXCIsXG4gIHZlcnNpb25BbGlhczogXCItMVwiLFxuICBicmFuZDogdHJ1ZVxufV07XG52YXIgV0VCS0lUX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcImFwcGxld2Via2l0XCIsXG4gIGlkOiBcIndlYmtpdFwiLFxuICB2ZXJzaW9uVGVzdDogXCJhcHBsZXdlYmtpdHxzYWZhcmlcIlxufV07XG52YXIgV0VCVklFV19QUkVTRVRTID0gW3tcbiAgdGVzdDogXCIoPz0oaXBob25lfGlwYWQpKSg/ISguKnZlcnNpb24pKVwiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn0sIHtcbiAgdGVzdDogXCIoPz0oYW5kcm9pZHxpcGhvbmV8aXBhZCkpKD89LioobmF2ZXJ8ZGF1bXw7IHd2KSlcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59LCB7XG4gIC8vIHRlc3Qgd2Vidmlld1xuICB0ZXN0OiBcIndlYnZpZXdcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59XTtcbnZhciBPU19QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJ3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcIndpbmRvd3MgcGhvbmVcIlxufSwge1xuICB0ZXN0OiBcIndpbmRvd3MgMjAwMFwiLFxuICBpZDogXCJ3aW5kb3dcIixcbiAgdmVyc2lvbkFsaWFzOiBcIjUuMFwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyBudFwiLFxuICBpZDogXCJ3aW5kb3dcIlxufSwge1xuICB0ZXN0OiBcIndpbjMyfHdpbmRvd3NcIixcbiAgaWQ6IFwid2luZG93XCJcbn0sIHtcbiAgdGVzdDogXCJpcGhvbmV8aXBhZHxpcG9kXCIsXG4gIGlkOiBcImlvc1wiLFxuICB2ZXJzaW9uVGVzdDogXCJpcGhvbmUgb3N8Y3B1IG9zXCJcbn0sIHtcbiAgdGVzdDogXCJtYWNvc3xtYWNpbnRlbHxtYWMgb3MgeFwiLFxuICBpZDogXCJtYWNcIlxufSwge1xuICB0ZXN0OiBcImFuZHJvaWR8bGludXggYXJtdjgxXCIsXG4gIGlkOiBcImFuZHJvaWRcIlxufSwge1xuICB0ZXN0OiBcInRpemVuXCIsXG4gIGlkOiBcInRpemVuXCJcbn0sIHtcbiAgdGVzdDogXCJ3ZWJvc3x3ZWIwc1wiLFxuICBpZDogXCJ3ZWJvc1wiXG59XTtcblxuZnVuY3Rpb24gaXNXZWJWaWV3KHVzZXJBZ2VudCkge1xuICByZXR1cm4gISFmaW5kUHJlc2V0KFdFQlZJRVdfUFJFU0VUUywgdXNlckFnZW50KS5wcmVzZXQ7XG59XG5mdW5jdGlvbiBnZXRMZWdhY3lBZ2VudCh1c2VyQWdlbnQpIHtcbiAgdmFyIG5leHRBZ2VudCA9IGdldFVzZXJBZ2VudFN0cmluZyh1c2VyQWdlbnQpO1xuICB2YXIgaXNNb2JpbGUgPSAhIS9tb2JpL2cuZXhlYyhuZXh0QWdlbnQpO1xuICB2YXIgYnJvd3NlciA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJ2aWV3OiBpc1dlYlZpZXcobmV4dEFnZW50KSxcbiAgICBjaHJvbWl1bTogZmFsc2UsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2Via2l0OiBmYWxzZSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCJcbiAgfTtcbiAgdmFyIG9zID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xXG4gIH07XG5cbiAgdmFyIF9hID0gZmluZFByZXNldChCUk9XU0VSX1BSRVNFVFMsIG5leHRBZ2VudCksXG4gICAgICBicm93c2VyUHJlc2V0ID0gX2EucHJlc2V0LFxuICAgICAgYnJvd3NlclZlcnNpb24gPSBfYS52ZXJzaW9uO1xuXG4gIHZhciBfYiA9IGZpbmRQcmVzZXQoT1NfUFJFU0VUUywgbmV4dEFnZW50KSxcbiAgICAgIG9zUHJlc2V0ID0gX2IucHJlc2V0LFxuICAgICAgb3NWZXJzaW9uID0gX2IudmVyc2lvbjtcblxuICB2YXIgY2hyb21pdW1QcmVzZXQgPSBmaW5kUHJlc2V0KENIUk9NSVVNX1BSRVNFVFMsIG5leHRBZ2VudCk7XG4gIGJyb3dzZXIuY2hyb21pdW0gPSAhIWNocm9taXVtUHJlc2V0LnByZXNldDtcbiAgYnJvd3Nlci5jaHJvbWl1bVZlcnNpb24gPSBjaHJvbWl1bVByZXNldC52ZXJzaW9uO1xuXG4gIGlmICghYnJvd3Nlci5jaHJvbWl1bSkge1xuICAgIHZhciB3ZWJraXRQcmVzZXQgPSBmaW5kUHJlc2V0KFdFQktJVF9QUkVTRVRTLCBuZXh0QWdlbnQpO1xuICAgIGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXRQcmVzZXQucHJlc2V0O1xuICAgIGJyb3dzZXIud2Via2l0VmVyc2lvbiA9IHdlYmtpdFByZXNldC52ZXJzaW9uO1xuICB9XG5cbiAgaWYgKG9zUHJlc2V0KSB7XG4gICAgb3MubmFtZSA9IG9zUHJlc2V0LmlkO1xuICAgIG9zLnZlcnNpb24gPSBvc1ZlcnNpb247XG4gICAgb3MubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQob3NWZXJzaW9uLCAxMCk7XG4gIH1cblxuICBpZiAoYnJvd3NlclByZXNldCkge1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJQcmVzZXQuaWQ7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gYnJvd3NlclZlcnNpb247IC8vIEVhcmx5IHdoYWxlIGJ1Z3NcblxuICAgIGlmIChicm93c2VyLndlYnZpZXcgJiYgb3MubmFtZSA9PT0gXCJpb3NcIiAmJiBicm93c2VyLm5hbWUgIT09IFwic2FmYXJpXCIpIHtcbiAgICAgIGJyb3dzZXIud2VidmlldyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGJyb3dzZXIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgaXNNb2JpbGU6IGlzTW9iaWxlLFxuICAgIGlzSGludHM6IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudEhpbnRzQWdlbnQob3NEYXRhKSB7XG4gIHZhciB1c2VyQWdlbnREYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHZhciBicmFuZHMgPSAodXNlckFnZW50RGF0YS51YUxpc3QgfHwgdXNlckFnZW50RGF0YS5icmFuZHMpLnNsaWNlKCk7XG4gIHZhciBmdWxsVmVyc2lvbkxpc3QgPSBvc0RhdGEgJiYgb3NEYXRhLmZ1bGxWZXJzaW9uTGlzdDtcbiAgdmFyIGlzTW9iaWxlID0gdXNlckFnZW50RGF0YS5tb2JpbGUgfHwgZmFsc2U7XG4gIHZhciBmaXJzdEJyYW5kID0gYnJhbmRzWzBdO1xuICB2YXIgcGxhdGZvcm0gPSAob3NEYXRhICYmIG9zRGF0YS5wbGF0Zm9ybSB8fCB1c2VyQWdlbnREYXRhLnBsYXRmb3JtIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSkudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgbmFtZTogZmlyc3RCcmFuZC5icmFuZCxcbiAgICB2ZXJzaW9uOiBmaXJzdEJyYW5kLnZlcnNpb24sXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJraXQ6IGZhbHNlLFxuICAgIHdlYmtpdFZlcnNpb246IFwiLTFcIixcbiAgICBjaHJvbWl1bTogZmFsc2UsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2VidmlldzogISFmaW5kUHJlc2V0QnJhbmQoV0VCVklFV19QUkVTRVRTLCBicmFuZHMpLmJyYW5kIHx8IGlzV2ViVmlldyhnZXRVc2VyQWdlbnRTdHJpbmcoKSlcbiAgfTtcbiAgdmFyIG9zID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xXG4gIH07XG4gIGJyb3dzZXIud2Via2l0ID0gIWJyb3dzZXIuY2hyb21pdW0gJiYgc29tZShXRUJLSVRfUFJFU0VUUywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHJldHVybiBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpO1xuICB9KTtcbiAgdmFyIGNocm9taXVtQnJhbmQgPSBmaW5kUHJlc2V0QnJhbmQoQ0hST01JVU1fUFJFU0VUUywgYnJhbmRzKTtcbiAgYnJvd3Nlci5jaHJvbWl1bSA9ICEhY2hyb21pdW1CcmFuZC5icmFuZDtcbiAgYnJvd3Nlci5jaHJvbWl1bVZlcnNpb24gPSBjaHJvbWl1bUJyYW5kLnZlcnNpb24gfHwgXCItMVwiO1xuXG4gIGlmICghYnJvd3Nlci5jaHJvbWl1bSkge1xuICAgIHZhciB3ZWJraXRCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChXRUJLSVRfUFJFU0VUUywgYnJhbmRzKTtcbiAgICBicm93c2VyLndlYmtpdCA9ICEhd2Via2l0QnJhbmQuYnJhbmQ7XG4gICAgYnJvd3Nlci53ZWJraXRWZXJzaW9uID0gd2Via2l0QnJhbmQudmVyc2lvbiB8fCBcIi0xXCI7XG4gIH1cblxuICB2YXIgcGxhdGZvbVJlc3VsdCA9IGZpbmQoT1NfUFJFU0VUUywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXCIgKyBwcmVzZXQudGVzdCwgXCJnXCIpLmV4ZWMocGxhdGZvcm0pO1xuICB9KTtcbiAgb3MubmFtZSA9IHBsYXRmb21SZXN1bHQgPyBwbGF0Zm9tUmVzdWx0LmlkIDogXCJcIjtcblxuICBpZiAob3NEYXRhKSB7XG4gICAgb3MudmVyc2lvbiA9IG9zRGF0YS5wbGF0Zm9ybVZlcnNpb24gfHwgXCItMVwiO1xuICB9XG5cbiAgaWYgKGZ1bGxWZXJzaW9uTGlzdCAmJiBmdWxsVmVyc2lvbkxpc3QubGVuZ3RoKSB7XG4gICAgdmFyIGJyb3dzZXJCcmFuZEJ5RnVsbFZlcnNpb25MaXN0ID0gZmluZFByZXNldEJyYW5kKEJST1dTRVJfUFJFU0VUUywgZnVsbFZlcnNpb25MaXN0KTtcbiAgICBicm93c2VyLm5hbWUgPSBicm93c2VyQnJhbmRCeUZ1bGxWZXJzaW9uTGlzdC5icmFuZCB8fCBicm93c2VyLm5hbWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gYnJvd3NlckJyYW5kQnlGdWxsVmVyc2lvbkxpc3QudmVyc2lvbiB8fCBicm93c2VyLnZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJyb3dzZXJCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChCUk9XU0VSX1BSRVNFVFMsIGJyYW5kcyk7XG4gICAgYnJvd3Nlci5uYW1lID0gYnJvd3NlckJyYW5kLmJyYW5kIHx8IGJyb3dzZXIubmFtZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBicm93c2VyQnJhbmQuYnJhbmQgJiYgb3NEYXRhID8gb3NEYXRhLnVhRnVsbFZlcnNpb24gOiBicm93c2VyQnJhbmQudmVyc2lvbjtcbiAgfVxuXG4gIGlmIChicm93c2VyLndlYmtpdCkge1xuICAgIG9zLm5hbWUgPSBpc01vYmlsZSA/IFwiaW9zXCIgOiBcIm1hY1wiO1xuICB9XG5cbiAgaWYgKG9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYnJvd3Nlci53ZWJ2aWV3KSB7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gXCItMVwiO1xuICB9XG5cbiAgb3MudmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKG9zLnZlcnNpb24pO1xuICBicm93c2VyLnZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbihicm93c2VyLnZlcnNpb24pO1xuICBvcy5tYWpvclZlcnNpb24gPSBwYXJzZUludChvcy52ZXJzaW9uLCAxMCk7XG4gIGJyb3dzZXIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgaXNNb2JpbGU6IGlzTW9iaWxlLFxuICAgIGlzSGludHM6IHRydWVcbiAgfTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGVnLmFnZW50XG4gKi9cblxuLyoqXG4qIEV4dHJhY3RzIGFjY3VhdGUgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZyBvciBjbGllbnQgaGludHMuXG4qIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtCDrmJDripQgY2xpZW50IGhpbnRz7JeQ7IScIOygle2Zle2VnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4qIEBmdW5jdGlvbiBlZy5hZ2VudCNnZXRBY2N1cmF0ZUFnZW50XG4qIEBwYXJhbSAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGdldCB0aGUgYWNjdWF0ZSBhZ2VudCA8a28+7KCV7ZmV7ZWcIOyXkOydtOyghO2KuOulvCDqsIDsoLjsmKTquLAg7JyE7ZWcIGNhbGxiYWNrIO2VqOyImDwva28+XG4qIEByZXR1cm4gLSBnZXQgdGhlIGFjY3VhdGUgYWdlbnQgcHJvbWlzZS4gSWYgUHJvbWlzZSBhcmUgbm90IHN1cHBvcnRlZCwgbnVsbCBpcyByZXR1cm5lZC4gPGtvPiDsoJXtmZXtlZwg7JeQ7J207KCE7Yq4IHByb21pc2Xrpbwg6rCA7KC47Jio64ukLiBQcm9taXNl66W8IOyngOybkCDtlZjsp4Ag7JWK64qUIOqyveyasCwgbnVsbOydhCDrsJjtmZjtlZzri6QuIDwva28+XG4qIEBleGFtcGxlXG5pbXBvcnQgeyBnZXRBY2N1cmF0ZUFnZW50IH0gZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG4vLyBlZy5hZ2VudC5nZXRBY2N1cmF0ZUFnZW50KClcbmdldEFjY3VyYXRlQWdlbnQoKS50aGVuKGFnZW50ID0+IHtcbiAgIGNvbnN0IHsgb3MsIGJyb3dzZXIsIGlzTW9iaWxlIH0gPSBhZ2VudDtcbn0pO1xuZ2V0QWNjdXJhdGVBZ2VudChhZ2VudCA9PiB7XG4gICAgY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50O1xufSk7XG4qL1xuXG5mdW5jdGlvbiBnZXRBY2N1cmF0ZUFnZW50KGNhbGxiYWNrKSB7XG4gIGlmIChoYXNVc2VyQWdlbnREYXRhKCkpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuZ2V0SGlnaEVudHJvcHlWYWx1ZXMoW1wiYXJjaGl0ZWN0dXJlXCIsIFwibW9kZWxcIiwgXCJwbGF0Zm9ybVwiLCBcInBsYXRmb3JtVmVyc2lvblwiLCBcInVhRnVsbFZlcnNpb25cIiwgXCJmdWxsVmVyc2lvbkxpc3RcIl0pLnRoZW4oZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHZhciBhZ2VudEluZm8gPSBnZXRDbGllbnRIaW50c0FnZW50KGluZm8pO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soYWdlbnRJbmZvKTtcbiAgICAgIHJldHVybiBhZ2VudEluZm87XG4gICAgfSk7XG4gIH1cblxuICBjYWxsYmFjayAmJiBjYWxsYmFjayhhZ2VudCgpKTtcblxuICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwidW5kZWZpbmVkXCIgfHwgIVByb21pc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWdlbnQoKSk7XG59XG4vKipcbiAqIEV4dHJhY3RzIGJyb3dzZXIgYW5kIG9wZXJhdGluZyBzeXN0ZW0gaW5mb3JtYXRpb24gZnJvbSB0aGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBAa28g7Jyg7KCAIOyXkOydtOyghO2KuCDrrLjsnpDsl7Tsl5DshJwg67iM65287Jqw7KCA7JmAIOyatOyYgeyytOygnCDsoJXrs7Trpbwg7LaU7Lac7ZWc64ukLlxuICogQGZ1bmN0aW9uIGVnLmFnZW50I2FnZW50XG4gKiBAcGFyYW0gLSB1c2VyIGFnZW50IHN0cmluZyB0byBwYXJzZSA8a28+7YyM7Iux7ZWgIOycoOyggOyXkOydtOyghO2KuCDrrLjsnpDsl7Q8L2tvPlxuICogQHJldHVybiAtIGFnZW50IEluZm8gPGtvPiDsl5DsnbTsoITtirgg7KCV67O0IDwva28+XG4gKiBAZXhhbXBsZVxuaW1wb3J0IGFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuLy8gZWcuYWdlbnQoKTtcbmNvbnN0IHsgb3MsIGJyb3dzZXIsIGlzTW9iaWxlIH0gPSBhZ2VudCgpO1xuICovXG5cbmZ1bmN0aW9uIGFnZW50KHVzZXJBZ2VudCkge1xuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gXCJ1bmRlZmluZWRcIiAmJiBoYXNVc2VyQWdlbnREYXRhKCkpIHtcbiAgICByZXR1cm4gZ2V0Q2xpZW50SGludHNBZ2VudCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRMZWdhY3lBZ2VudCh1c2VyQWdlbnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFnZW50O1xuZXhwb3J0IHsgZ2V0QWNjdXJhdGVBZ2VudCwgZ2V0TGVnYWN5QWdlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/agent/dist/agent.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/children-differ/dist/children-differ.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@egjs/children-differ/dist/children-differ.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   diff: () => (/* binding */ diff)\n/* harmony export */ });\n/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/list-differ */ \"(ssr)/./node_modules/@egjs/list-differ/dist/list-differ.esm.js\");\n/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/children-differ\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-children-differ\nversion: 1.0.1\n*/\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar findKeyCallback = typeof Map === \"function\" ? undefined : function () {\n  var childrenCount = 0;\n  return function (el) {\n    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);\n  };\n}();\n\n/**\n * A module that checks diff when child are added, removed, or changed .\n * @ko 자식 노드들에서 자식 노드가 추가되거나 삭제되거나 순서가 변경된 사항을 체크하는 모듈입니다.\n * @memberof eg\n * @extends eg.ListDiffer\n */\n\nvar ChildrenDiffer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ChildrenDiffer, _super);\n  /**\n   * @param - Initializing Children <ko> 초기 설정할 자식 노드들</ko>\n   */\n\n\n  function ChildrenDiffer(list) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    return _super.call(this, list, findKeyCallback) || this;\n  }\n\n  return ChildrenDiffer;\n}(_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n/**\n *\n * @memberof eg.ChildrenDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/children-differ\";\n * // script => eg.ChildrenDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\n\nfunction diff(prevList, list) {\n  return (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_0__.diff)(prevList, list, findKeyCallback);\n}\n\n/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChildrenDiffer);\n\n//# sourceMappingURL=children-differ.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvY2hpbGRyZW4tZGlmZmVyL2Rpc3QvY2hpbGRyZW4tZGlmZmVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytEOztBQUUvRDtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMsQ0FBQyx5REFBVTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsdURBQU07QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGNBQWMsRUFBQztBQUNkO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi8uL25vZGVfbW9kdWxlcy9AZWdqcy9jaGlsZHJlbi1kaWZmZXIvZGlzdC9jaGlsZHJlbi1kaWZmZXIuZXNtLmpzPzljNTkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9jaGlsZHJlbi1kaWZmZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY2hpbGRyZW4tZGlmZmVyXG52ZXJzaW9uOiAxLjAuMVxuKi9cbmltcG9ydCBMaXN0RGlmZmVyLCB7IGRpZmYgYXMgZGlmZiQxIH0gZnJvbSAnQGVnanMvbGlzdC1kaWZmZXInO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuLypcbmVnanMtY2hpbGRyZW4tZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgZmluZEtleUNhbGxiYWNrID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRyZW5Db3VudCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuX19ESUZGX0tFWV9fIHx8IChlbC5fX0RJRkZfS0VZX18gPSArK2NoaWxkcmVuQ291bnQpO1xuICB9O1xufSgpO1xuXG4vKipcbiAqIEEgbW9kdWxlIHRoYXQgY2hlY2tzIGRpZmYgd2hlbiBjaGlsZCBhcmUgYWRkZWQsIHJlbW92ZWQsIG9yIGNoYW5nZWQgLlxuICogQGtvIOyekOyLnSDrhbjrk5zrk6Tsl5DshJwg7J6Q7IudIOuFuOuTnOqwgCDstpTqsIDrkJjqsbDrgpgg7IKt7KCc65CY6rGw64KYIOyInOyEnOqwgCDrs4Dqsr3rkJwg7IKs7ZWt7J2EIOyytO2BrO2VmOuKlCDrqqjrk4jsnoXri4jri6QuXG4gKiBAbWVtYmVyb2YgZWdcbiAqIEBleHRlbmRzIGVnLkxpc3REaWZmZXJcbiAqL1xuXG52YXIgQ2hpbGRyZW5EaWZmZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ2hpbGRyZW5EaWZmZXIsIF9zdXBlcik7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbml0aWFsaXppbmcgQ2hpbGRyZW4gPGtvPiDstIjquLAg7ISk7KCV7ZWgIOyekOyLnSDrhbjrk5zrk6Q8L2tvPlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENoaWxkcmVuRGlmZmVyKGxpc3QpIHtcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGxpc3QsIGZpbmRLZXlDYWxsYmFjaykgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBDaGlsZHJlbkRpZmZlcjtcbn0oTGlzdERpZmZlcik7XG5cbi8qXG5lZ2pzLWNoaWxkcmVuLWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xuLyoqXG4gKlxuICogQG1lbWJlcm9mIGVnLkNoaWxkcmVuRGlmZmVyXG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSAtIFByZXZpb3VzIExpc3QgPGtvPiDsnbTsoIQg66qp66GdIDwva28+XG4gKiBAcGFyYW0gLSBMaXN0IHRvIFVwZGF0ZSA8a28+IOyXheuNsOydtO2KuCDtlaAg66qp66GdIDwva28+XG4gKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlmZiBiZXR3ZWVuIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCA8a28+IGBwcmV2TGlzdGDsmYAgYGxpc3Rg7J2YIOuLpOuluCDsoJDsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZGlmZiB9IGZyb20gXCJAZWdqcy9jaGlsZHJlbi1kaWZmZXJcIjtcbiAqIC8vIHNjcmlwdCA9PiBlZy5DaGlsZHJlbkRpZmZlci5kaWZmXG4gKiBjb25zdCByZXN1bHQgPSBkaWZmKFswLCAxLCAyLCAzLCA0LCA1XSwgWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdKTtcbiAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICogLy8gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHJldkxpc3QpO1xuICogLy8gVXBkYXRlZCBsaXN0XG4gKiAvLyBbNCwgMywgNiwgMiwgMV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5saXN0KTtcbiAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGBcbiAqIC8vIFswLCAxLCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LmFkZGVkKTtcbiAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyByZW1vdmVkIGluIGBwcmV2TGlzdGBcbiAqIC8vIFs1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHdpdGggZGlmZmVyZW50IGluZGV4ZXMgZnJvbSBgcHJldkxpc3RgIGFuZCBgbGlzdGBcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkKTtcbiAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAqIC8vIFtbNCwgM10sIFszLCA0XSwgWzIsIDZdXVxuICogY29uc29sZS5sb2cocmVzdWx0LnB1cmVDaGFuZ2VkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAqIC8vIFtbNCwgMV0sIFs0LCAyXSwgWzQsIDNdXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm9yZGVyZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubWFpbnRhaW5lZCk7XG4gKi9cblxuZnVuY3Rpb24gZGlmZihwcmV2TGlzdCwgbGlzdCkge1xuICByZXR1cm4gZGlmZiQxKHByZXZMaXN0LCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spO1xufVxuXG4vKlxuZWdqcy1jaGlsZHJlbi1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZXhwb3J0IGRlZmF1bHQgQ2hpbGRyZW5EaWZmZXI7XG5leHBvcnQgeyBkaWZmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGlsZHJlbi1kaWZmZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/children-differ/dist/children-differ.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/component/dist/component.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/@egjs/component/dist/component.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentEvent: () => (/* binding */ ComponentEvent$1),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\nCopyright (c) NAVER Corp.\nname: @egjs/component\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-component\nversion: 3.0.5\n*/\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nvar isUndefined = function (value) {\n  return typeof value === \"undefined\";\n};\n\n// This class name is not matched to file name intentionally\n/**\n * Event class to provide additional properties\n * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스\n */\nvar ComponentEvent = /*#__PURE__*/function () {\n  /**\n   * Create a new instance of ComponentEvent.\n   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.\n   * @param eventType The name of the event.<ko>이벤트 이름.</ko>\n   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>\n   */\n  function ComponentEvent(eventType, props) {\n    var e_1, _a;\n    this._canceled = false;\n    if (props) {\n      try {\n        for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          this[key] = props[key];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    this.eventType = eventType;\n  }\n  /**\n   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.\n   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.\n   */\n  var __proto = ComponentEvent.prototype;\n  __proto.stop = function () {\n    this._canceled = true;\n  };\n  /**\n   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.\n   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.\n   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>\n   */\n  __proto.isCanceled = function () {\n    return this._canceled;\n  };\n  return ComponentEvent;\n}();\n\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n */\nvar Component = /*#__PURE__*/function () {\n  /**\n   * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n   */\n  function Component() {\n    this._eventHandler = {};\n  }\n  /**\n   * Trigger a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>\n   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;\n   *   hi: { foo: { a: number; b: boolean } };\n   *   someEvent: (foo: number, bar: string) => void;\n   *   someOtherEvent: void; // When there's no event argument\n   * }> {\n   *   some(){\n   *     if(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n   *       this.trigger(\"hi\");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on(\"beforeHi\", e => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   *\n   *   typeof e.foo; // number\n   *   typeof e.bar; // string\n   * });\n   * some.on(\"hi\", e => {\n   *   typeof e.foo.b; // boolean\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   * ```\n   */\n  var __proto = Component.prototype;\n  __proto.trigger = function (event) {\n    var params = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      params[_i - 1] = arguments[_i];\n    }\n    var eventName = event instanceof ComponentEvent ? event.eventType : event;\n    var handlers = __spread(this._eventHandler[eventName] || []);\n    if (handlers.length <= 0) {\n      return this;\n    }\n    if (event instanceof ComponentEvent) {\n      event.currentTarget = this;\n      handlers.forEach(function (handler) {\n        handler(event);\n      });\n    } else {\n      handlers.forEach(function (handler) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        handler.apply(void 0, __spread(params));\n      });\n    }\n    return this;\n  };\n  /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: ComponentEvent;\n   * }> {\n   *   hi() {\n   *     alert(\"hi\");\n   *   }\n   *   thing() {\n   *     this.once(\"hi\", this.hi);\n   *   }\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger(new ComponentEvent(\"hi\"));\n   * // fire alert(\"hi\");\n   * some.trigger(new ComponentEvent(\"hi\"));\n   * // Nothing happens\n   * ```\n   */\n  __proto.once = function (eventName, handlerToAttach) {\n    var _this = this;\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      var eventHash = eventName;\n      for (var key in eventHash) {\n        this.once(key, eventHash[key]);\n      }\n      return this;\n    } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n      var listener_1 = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        handlerToAttach.apply(void 0, __spread(args));\n        _this.off(eventName, listener_1);\n      };\n      this.on(eventName, listener_1);\n    }\n    return this;\n  };\n  /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * ```ts\n   * import Component from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   some() {\n   *     this.hasOn(\"hi\");// check hi event.\n   *   }\n   * }\n   * ```\n   */\n  __proto.hasOn = function (eventName) {\n    return !!this._eventHandler[eventName];\n  };\n  /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.on(\"hi\",this.hi); //attach event\n   *   }\n   * }\n   * ```\n   */\n  __proto.on = function (eventName, handlerToAttach) {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      var eventHash = eventName;\n      for (var name in eventHash) {\n        this.on(name, eventHash[name]);\n      }\n      return this;\n    } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n      var handlerList = this._eventHandler[eventName];\n      if (isUndefined(handlerList)) {\n        this._eventHandler[eventName] = [];\n        handlerList = this._eventHandler[eventName];\n      }\n      handlerList.push(handlerToAttach);\n    }\n    return this;\n  };\n  /**\n   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.\n   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.off(\"hi\",this.hi); //detach event\n   *   }\n   * }\n   * ```\n   */\n  __proto.off = function (eventName, handlerToDetach) {\n    // Detach all event handlers.\n    if (isUndefined(eventName)) {\n      this._eventHandler = {};\n      return this;\n    }\n    // Detach all handlers for eventname or detach event handlers by object.\n    if (isUndefined(handlerToDetach)) {\n      if (typeof eventName === \"string\") {\n        delete this._eventHandler[eventName];\n        return this;\n      } else {\n        var eventHash = eventName;\n        for (var name in eventHash) {\n          this.off(name, eventHash[name]);\n        }\n        return this;\n      }\n    }\n    // Detach single event handler\n    var handlerList = this._eventHandler[eventName];\n    if (handlerList) {\n      var length = handlerList.length;\n      for (var i = 0; i < length; ++i) {\n        if (handlerList[i] === handlerToDetach) {\n          handlerList.splice(i, 1);\n          if (length <= 1) {\n            delete this._eventHandler[eventName];\n          }\n          break;\n        }\n      }\n    }\n    return this;\n  };\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @example\n   * Component.VERSION;  // ex) 3.0.0\n   * @memberof Component\n   */\n  Component.VERSION = \"3.0.5\";\n  return Component;\n}();\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-assignment\nvar ComponentEvent$1 = ComponentEvent;\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);\n\n//# sourceMappingURL=component.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvY29tcG9uZW50L2Rpc3QvY29tcG9uZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQsd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMkJBQTJCO0FBQ2hGLFVBQVUsMEJBQTBCO0FBQ3BDLGNBQWMsU0FBUyx3Q0FBd0MsMkJBQTJCLDBCQUEwQiwwQkFBMEI7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBLGtDQUFrQyxhQUFhLGFBQWE7QUFDNUQsYUFBYSxPQUFPLFdBQVc7QUFDL0I7QUFDQSw2QkFBNkI7QUFDN0IsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDO0FBQ3ZDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixNQUFNO0FBQ047QUFDQSx1QkFBdUI7QUFDdkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFNBQVMsRUFBQztBQUNxQjtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4vLi9ub2RlX21vZHVsZXMvQGVnanMvY29tcG9uZW50L2Rpc3QvY29tcG9uZW50LmVzbS5qcz85Nzg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9jb21wb25lbnRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50XG52ZXJzaW9uOiAzLjAuNVxuKi9cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvcixcbiAgICBtID0gcyAmJiBvW3NdLFxuICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICByLFxuICAgIGFyID0gW10sXG4gICAgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlID0ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5mdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59O1xuXG4vLyBUaGlzIGNsYXNzIG5hbWUgaXMgbm90IG1hdGNoZWQgdG8gZmlsZSBuYW1lIGludGVudGlvbmFsbHlcbi8qKlxuICogRXZlbnQgY2xhc3MgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBrbyBDb21wb25lbnTsl5DshJwg7LaU6rCA7KCB7J24IO2UhOuhnO2NvO2LsOulvCDsoJzqs7XtlZjripQg7J2067Kk7Yq4IO2BtOuemOyKpFxuICovXG52YXIgQ29tcG9uZW50RXZlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIENvbXBvbmVudEV2ZW50LlxuICAgKiBAa28gQ29tcG9uZW50RXZlbnTsnZgg7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlZzri6QuXG4gICAqIEBwYXJhbSBldmVudFR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50Ljxrbz7snbTrsqTtirgg7J2066aELjwva28+XG4gICAqIEBwYXJhbSBwcm9wcyBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhZGRpdGlvbmFsIGV2ZW50IHByb3BlcnRpZXMuPGtvPuy2lOqwgOyggeyduCDsnbTrsqTtirgg7ZSE66Gc7Y287YuwIOyYpOu4jOygne2KuC48L2tvPlxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50RXZlbnQoZXZlbnRUeXBlLCBwcm9wcykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKHByb3BzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGUgZXZlbnQuIHtAbGluayBDb21wb25lbnRFdmVudCNpc0NhbmNlbGVkfSB3aWxsIHJldHVybiBgdHJ1ZWAgYWZ0ZXIuXG4gICAqIEBrbyDsnbTrsqTtirjrpbwg7KSR64uo7ZWc64ukLiDsnbTtm4Qge0BsaW5rIENvbXBvbmVudEV2ZW50I2lzQ2FuY2VsZWR96rCAIGB0cnVlYOulvCDrsJjtmZjtlZzri6QuXG4gICAqL1xuICB2YXIgX19wcm90byA9IENvbXBvbmVudEV2ZW50LnByb3RvdHlwZTtcbiAgX19wcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B9IGlzIGNhbGxlZCBiZWZvcmUuXG4gICAqIEBrbyB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH3snbQg7Zi47Lac65CY7JeI64qU7KeAIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfSBpcyBjYWxsZWQgYmVmb3JlLjxrbz7snbTsoITsl5Age0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B97J20IOu2iOugpOyhjOuKlOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqL1xuICBfX3Byb3RvLmlzQ2FuY2VsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbGVkO1xuICB9O1xuICByZXR1cm4gQ29tcG9uZW50RXZlbnQ7XG59KCk7XG5cbi8qKlxuICogQSBjbGFzcyB1c2VkIHRvIG1hbmFnZSBldmVudHMgaW4gYSBjb21wb25lbnRcbiAqIEBrbyDsu7Ttj6zrhIztirjsnZgg7J2067Kk7Yq47J2EIOq0gOumrO2VoCDsiJgg7J6I6rKMIO2VmOuKlCDtgbTrnpjsiqRcbiAqL1xudmFyIENvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAc3VwcG9ydCB7XCJpZVwiOiBcIjcrXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiMi4xKyAoZXhjZXB0IDMueClcIn1cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudCgpIHtcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSB7fTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhIGN1c3RvbSBldmVudC5cbiAgICogQGtvIOy7pOyKpO2FgCDsnbTrsqTtirjrpbwg67Cc7IOd7Iuc7YKo64ukXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgQ29tcG9uZW50RXZlbnR9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgdG8gYmUgdHJpZ2dlcmVkIG9yIGFuIGluc3RhbmNlIG9mIHRoZSBDb21wb25lbnRFdmVudDxrbz7rsJzsg53tlaAg7Luk7Iqk7YWAIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIENvbXBvbmVudEV2ZW507J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBwYXJhbSB7YW55W119IHBhcmFtcyBFdmVudCBkYXRhIHRvIGJlIHNlbnQgd2hlbiB0cmlnZ2VyaW5nIGEgY3VzdG9tIGV2ZW50IDxrbz7su6TsiqTthYAg7J2067Kk7Yq46rCAIOuwnOyDne2VoCDrlYwg7KCE64us7ZWgIOuNsOydtO2EsDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBiZWZvcmVIaTogQ29tcG9uZW50RXZlbnQ8eyBmb286IG51bWJlcjsgYmFyOiBzdHJpbmcgfT47XG4gICAqICAgaGk6IHsgZm9vOiB7IGE6IG51bWJlcjsgYjogYm9vbGVhbiB9IH07XG4gICAqICAgc29tZUV2ZW50OiAoZm9vOiBudW1iZXIsIGJhcjogc3RyaW5nKSA9PiB2b2lkO1xuICAgKiAgIHNvbWVPdGhlckV2ZW50OiB2b2lkOyAvLyBXaGVuIHRoZXJlJ3Mgbm8gZXZlbnQgYXJndW1lbnRcbiAgICogfT4ge1xuICAgKiAgIHNvbWUoKXtcbiAgICogICAgIGlmKHRoaXMudHJpZ2dlcihcImJlZm9yZUhpXCIpKXsgLy8gV2hlbiBldmVudCBjYWxsIHRvIHN0b3AgcmV0dXJuIGZhbHNlLlxuICAgKiAgICAgICB0aGlzLnRyaWdnZXIoXCJoaVwiKTsvLyBmaXJlIGhpIGV2ZW50LlxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBzb21lID0gbmV3IFNvbWUoKTtcbiAgICogc29tZS5vbihcImJlZm9yZUhpXCIsIGUgPT4ge1xuICAgKiAgIGlmKGNvbmRpdGlvbil7XG4gICAqICAgICBlLnN0b3AoKTsgLy8gV2hlbiBldmVudCBjYWxsIHRvIHN0b3AsIGBoaWAgZXZlbnQgbm90IGNhbGwuXG4gICAqICAgfVxuICAgKiAgIC8vIGBjdXJyZW50VGFyZ2V0YCBpcyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqICAgY29uc29sZS5sb2coc29tZSA9PT0gZS5jdXJyZW50VGFyZ2V0KTsgLy8gdHJ1ZVxuICAgKlxuICAgKiAgIHR5cGVvZiBlLmZvbzsgLy8gbnVtYmVyXG4gICAqICAgdHlwZW9mIGUuYmFyOyAvLyBzdHJpbmdcbiAgICogfSk7XG4gICAqIHNvbWUub24oXCJoaVwiLCBlID0+IHtcbiAgICogICB0eXBlb2YgZS5mb28uYjsgLy8gYm9vbGVhblxuICAgKiB9KTtcbiAgICogLy8gSWYgeW91IHdhbnQgdG8gbW9yZSBrbm93IGV2ZW50IGRlc2lnbi4gWW91IGNhbiBzZWUgYXJ0aWNsZS5cbiAgICogLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50L3dpa2kvSG93LXRvLW1ha2UtQ29tcG9uZW50LWV2ZW50LWRlc2lnbiUzRlxuICAgKiBgYGBcbiAgICovXG4gIHZhciBfX3Byb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgX19wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBwYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBldmVudE5hbWUgPSBldmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEV2ZW50ID8gZXZlbnQuZXZlbnRUeXBlIDogZXZlbnQ7XG4gICAgdmFyIGhhbmRsZXJzID0gX19zcHJlYWQodGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV0gfHwgW10pO1xuICAgIGlmIChoYW5kbGVycy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEV2ZW50KSB7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChwYXJhbXMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEV4ZWN1dGVkIGV2ZW50IGp1c3Qgb25lIHRpbWUuXG4gICAqIEBrbyDsnbTrsqTtirjqsIAg7ZWc67KI66eMIOyLpO2WieuQnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgb3IgYW4gZXZlbnQgbmFtZSAtIGV2ZW50IGhhbmRsZXIgbWFwcGVkIG9iamVjdC48a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIOydtOuypO2KuCDsnbTrpoQt7ZW465Ok65+sIOyYpOu4jOygne2KuDwva28+XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJUb0F0dGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBoaTogQ29tcG9uZW50RXZlbnQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGFsZXJ0KFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHRoaW5nKCkge1xuICAgKiAgICAgdGhpcy5vbmNlKFwiaGlcIiwgdGhpcy5oaSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIHZhciBzb21lID0gbmV3IFNvbWUoKTtcbiAgICogc29tZS50aGluZygpO1xuICAgKiBzb21lLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50KFwiaGlcIikpO1xuICAgKiAvLyBmaXJlIGFsZXJ0KFwiaGlcIik7XG4gICAqIHNvbWUudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQoXCJoaVwiKSk7XG4gICAqIC8vIE5vdGhpbmcgaGFwcGVuc1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8ub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0F0dGFjaCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIgJiYgaXNVbmRlZmluZWQoaGFuZGxlclRvQXR0YWNoKSkge1xuICAgICAgdmFyIGV2ZW50SGFzaCA9IGV2ZW50TmFtZTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgdGhpcy5vbmNlKGtleSwgZXZlbnRIYXNoW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaGFuZGxlclRvQXR0YWNoLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpO1xuICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcl8xKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZXZlbnQgaGFzIGJlZW4gYXR0YWNoZWQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq46rCAIOuTseuhneuQkOuKlOyngCDtmZXsnbjtlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ0g7Jes67aA66W8IO2ZleyduO2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IGlzIGF0dGFjaGVkLiA8a28+7J2067Kk7Yq4IOuTseuhnSDsl6zrtoA8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5oYXNPbihcImhpXCIpOy8vIGNoZWNrIGhpIGV2ZW50LlxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uaGFzT24gPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gIH07XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhbiBldmVudCB0byBhIGNvbXBvbmVudC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDsnbTrsqTtirjrpbwg65Ox66Gd7ZWc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCBvciBhbiBldmVudCBuYW1lIC0gZXZlbnQgaGFuZGxlciBtYXBwZWQgb2JqZWN0Ljxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIOydtOumhCDrmJDripQg7J2067Kk7Yq4IOydtOumhC3tlbjrk6Trn6wg7Jik67iM7KCd7Yq4PC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBoaTogdm9pZDtcbiAgICogfT4ge1xuICAgKiAgIGhpKCkge1xuICAgKiAgICAgY29uc29sZS5sb2coXCJoaVwiKTtcbiAgICogICB9XG4gICAqICAgc29tZSgpIHtcbiAgICogICAgIHRoaXMub24oXCJoaVwiLHRoaXMuaGkpOyAvL2F0dGFjaCBldmVudFxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9BdHRhY2gpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIiAmJiBpc1VuZGVmaW5lZChoYW5kbGVyVG9BdHRhY2gpKSB7XG4gICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgdGhpcy5vbihuYW1lLCBldmVudEhhc2hbbmFtZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdID0gW107XG4gICAgICAgIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgICBoYW5kbGVyTGlzdC5wdXNoKGhhbmRsZXJUb0F0dGFjaCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGV0YWNoZXMgYW4gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50Ljxici8+SWYgdGhlIGBldmVudE5hbWVgIGlzIG5vdCBnaXZlbiB0aGlzIHdpbGwgZGV0YWNoIGFsbCBldmVudCBoYW5kbGVycyBhdHRhY2hlZC48YnIvPklmIHRoZSBgaGFuZGxlclRvRGV0YWNoYCBpcyBub3QgZ2l2ZW4sIHRoaXMgd2lsbCBkZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzIGZvciBgZXZlbnROYW1lYC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDrk7HroZ3rkJwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC48YnIvPmBldmVudE5hbWVg7J20IOyjvOyWtOyngOyngCDslYrslZjsnYQg6rK97JqwIOuqqOuToCDsnbTrsqTtirgg7ZW465Ok65+s66W8IOygnOqxsO2VnOuLpC48YnIvPmBoYW5kbGVyVG9BdHRhY2hg6rCAIOyjvOyWtOyngOyngCDslYrslZjsnYQg6rK97JqwIGBldmVudE5hbWVg7JeQIO2VtOuLue2VmOuKlCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nP30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uP30gaGFuZGxlclRvRGV0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGYgPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLm9mZihcImhpXCIsdGhpcy5oaSk7IC8vZGV0YWNoIGV2ZW50XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9EZXRhY2gpIHtcbiAgICAvLyBEZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzLlxuICAgIGlmIChpc1VuZGVmaW5lZChldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBEZXRhY2ggYWxsIGhhbmRsZXJzIGZvciBldmVudG5hbWUgb3IgZGV0YWNoIGV2ZW50IGhhbmRsZXJzIGJ5IG9iamVjdC5cbiAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlclRvRGV0YWNoKSkge1xuICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgICAgdGhpcy5vZmYobmFtZSwgZXZlbnRIYXNoW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0YWNoIHNpbmdsZSBldmVudCBoYW5kbGVyXG4gICAgdmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgaWYgKGhhbmRsZXJMaXN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gaGFuZGxlckxpc3QubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaGFuZGxlckxpc3RbaV0gPT09IGhhbmRsZXJUb0RldGFjaCkge1xuICAgICAgICAgIGhhbmRsZXJMaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpZiAobGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBWZXJzaW9uIGluZm8gc3RyaW5nXG4gICAqIEBrbyDrsoTsoITsoJXrs7Qg66y47J6Q7Je0XG4gICAqIEBuYW1lIFZFUlNJT05cbiAgICogQHN0YXRpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBDb21wb25lbnQuVkVSU0lPTjsgIC8vIGV4KSAzLjAuMFxuICAgKiBAbWVtYmVyb2YgQ29tcG9uZW50XG4gICAqL1xuICBDb21wb25lbnQuVkVSU0lPTiA9IFwiMy4wLjVcIjtcbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxudmFyIENvbXBvbmVudEV2ZW50JDEgPSBDb21wb25lbnRFdmVudDtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xuZXhwb3J0IHsgQ29tcG9uZW50RXZlbnQkMSBhcyBDb21wb25lbnRFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/component/dist/component.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/list-differ/dist/list-differ.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@egjs/list-differ/dist/list-differ.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   diff: () => (/* binding */ diff)\n/* harmony export */ });\n/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/list-differ\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-list-differ\nversion: 1.0.1\n*/\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar PolyMap =\n/*#__PURE__*/\nfunction () {\n  function PolyMap() {\n    this.keys = [];\n    this.values = [];\n  }\n\n  var __proto = PolyMap.prototype;\n\n  __proto.get = function (key) {\n    return this.values[this.keys.indexOf(key)];\n  };\n\n  __proto.set = function (key, value) {\n    var keys = this.keys;\n    var values = this.values;\n    var prevIndex = keys.indexOf(key);\n    var index = prevIndex === -1 ? keys.length : prevIndex;\n    keys[index] = key;\n    values[index] = value;\n  };\n\n  return PolyMap;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar HashMap =\n/*#__PURE__*/\nfunction () {\n  function HashMap() {\n    this.object = {};\n  }\n\n  var __proto = HashMap.prototype;\n\n  __proto.get = function (key) {\n    return this.object[key];\n  };\n\n  __proto.set = function (key, value) {\n    this.object[key] = value;\n  };\n\n  return HashMap;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar SUPPORT_MAP = typeof Map === \"function\";\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar Link =\n/*#__PURE__*/\nfunction () {\n  function Link() {}\n\n  var __proto = Link.prototype;\n\n  __proto.connect = function (prevLink, nextLink) {\n    this.prev = prevLink;\n    this.next = nextLink;\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  };\n\n  __proto.disconnect = function () {\n    // In double linked list, diconnect the interconnected relationship.\n    var prevLink = this.prev;\n    var nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  };\n\n  __proto.getIndex = function () {\n    var link = this;\n    var index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n\n    return index;\n  };\n\n  return Link;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\nfunction orderChanged(changed, fixed) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7\n\n  var toLinks = [];\n  changed.forEach(function (_a) {\n    var from = _a[0],\n        to = _a[1];\n    var link = new Link();\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  }); // `fromLinks` are connected to each other by double linked list.\n\n  fromLinks.forEach(function (link, i) {\n    link.connect(fromLinks[i - 1]);\n  });\n  return changed.filter(function (_, i) {\n    return !fixed[i];\n  }).map(function (_a, i) {\n    var from = _a[0],\n        to = _a[1];\n\n    if (from === to) {\n      return [0, 0];\n    }\n\n    var fromLink = fromLinks[from];\n    var toLink = toLinks[to - 1];\n    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.\n\n    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.\n\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n\n    var toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nvar Result =\n/*#__PURE__*/\nfunction () {\n  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n\n  var __proto = Result.prototype;\n  Object.defineProperty(__proto, \"ordered\", {\n    get: function () {\n      if (!this.cacheOrdered) {\n        this.caculateOrdered();\n      }\n\n      return this.cacheOrdered;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"pureChanged\", {\n    get: function () {\n      if (!this.cachePureChanged) {\n        this.caculateOrdered();\n      }\n\n      return this.cachePureChanged;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __proto.caculateOrdered = function () {\n    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    var changed = this.changed;\n    var pureChanged = [];\n    this.cacheOrdered = ordered.filter(function (_a, i) {\n      var from = _a[0],\n          to = _a[1];\n      var _b = changed[i],\n          fromBefore = _b[0],\n          toBefore = _b[1];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  };\n\n  return Result;\n}();\n\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\n\nfunction diff(prevList, list, findKeyCallback) {\n  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;\n\n  var callback = findKeyCallback || function (e) {\n    return e;\n  };\n\n  var added = [];\n  var removed = [];\n  var maintained = [];\n  var prevKeys = prevList.map(callback);\n  var keys = list.map(callback);\n  var prevKeyMap = new mapClass();\n  var keyMap = new mapClass();\n  var changedBeforeAdded = [];\n  var fixed = [];\n  var removedMap = {};\n  var changed = [];\n  var addedCount = 0;\n  var removedCount = 0; // Add prevKeys and keys to the hashmap.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach(function (key, listIndex) {\n    keyMap.set(key, listIndex);\n  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.\n\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n\n  keys.forEach(function (key, listIndex) {\n    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.\n\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);\n      fixed.push(listIndex === prevListIndex);\n\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  }); // Sort by ascending order of 'to(list's index).\n\n  removed.reverse();\n  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);\n}\n\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.\n * @memberof eg\n */\n\nvar ListDiffer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>\n   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  function ListDiffer(list, findKeyCallback) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    this.findKeyCallback = findKeyCallback;\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko 리스트를 업데이트를 합니다.\n   * @param - List to update <ko> 업데이트할 리스트 </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>\n   */\n\n\n  var __proto = ListDiffer.prototype;\n\n  __proto.update = function (list) {\n    var newData = [].slice.call(list);\n    var result = diff(this.list, newData, this.findKeyCallback);\n    this.list = newData;\n    return result;\n  };\n\n  return ListDiffer;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListDiffer);\n\n//# sourceMappingURL=list-differ.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvbGlzdC1kaWZmZXIvZGlzdC9saXN0LWRpZmZlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsVUFBVSxFQUFDO0FBQ1Y7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFkbWluLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL2xpc3QtZGlmZmVyL2Rpc3QvbGlzdC1kaWZmZXIuZXNtLmpzPzY0ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9saXN0LWRpZmZlclxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1saXN0LWRpZmZlclxudmVyc2lvbjogMS4wLjFcbiovXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFBvbHlNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb2x5TWFwKCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gIH1cblxuICB2YXIgX19wcm90byA9IFBvbHlNYXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmtleXMuaW5kZXhPZihrZXkpXTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBwcmV2SW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICB2YXIgaW5kZXggPSBwcmV2SW5kZXggPT09IC0xID8ga2V5cy5sZW5ndGggOiBwcmV2SW5kZXg7XG4gICAga2V5c1tpbmRleF0gPSBrZXk7XG4gICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBQb2x5TWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIEhhc2hNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIYXNoTWFwKCkge1xuICAgIHRoaXMub2JqZWN0ID0ge307XG4gIH1cblxuICB2YXIgX19wcm90byA9IEhhc2hNYXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFtrZXldO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdFtrZXldID0gdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hNYXA7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgU1VQUE9SVF9NQVAgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCI7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgTGluayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmsoKSB7fVxuXG4gIHZhciBfX3Byb3RvID0gTGluay5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jb25uZWN0ID0gZnVuY3Rpb24gKHByZXZMaW5rLCBuZXh0TGluaykge1xuICAgIHRoaXMucHJldiA9IHByZXZMaW5rO1xuICAgIHRoaXMubmV4dCA9IG5leHRMaW5rO1xuICAgIHByZXZMaW5rICYmIChwcmV2TGluay5uZXh0ID0gdGhpcyk7XG4gICAgbmV4dExpbmsgJiYgKG5leHRMaW5rLnByZXYgPSB0aGlzKTtcbiAgfTtcblxuICBfX3Byb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSW4gZG91YmxlIGxpbmtlZCBsaXN0LCBkaWNvbm5lY3QgdGhlIGludGVyY29ubmVjdGVkIHJlbGF0aW9uc2hpcC5cbiAgICB2YXIgcHJldkxpbmsgPSB0aGlzLnByZXY7XG4gICAgdmFyIG5leHRMaW5rID0gdGhpcy5uZXh0O1xuICAgIHByZXZMaW5rICYmIChwcmV2TGluay5uZXh0ID0gbmV4dExpbmspO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gcHJldkxpbmspO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKGxpbmspIHtcbiAgICAgIGxpbmsgPSBsaW5rLnByZXY7XG4gICAgICArK2luZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICByZXR1cm4gTGluaztcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZnVuY3Rpb24gb3JkZXJDaGFuZ2VkKGNoYW5nZWQsIGZpeGVkKSB7XG4gIC8vIEl0IGlzIHJvdWdobHkgaW4gdGhlIG9yZGVyIG9mIHRoZXNlIGV4YW1wbGVzLlxuICAvLyA0LCA2LCAwLCAyLCAxLCAzLCA1LCA3XG4gIHZhciBmcm9tTGlua3MgPSBbXTsgLy8gMCwgMSwgMiwgMywgNCwgNSwgNiwgN1xuXG4gIHZhciB0b0xpbmtzID0gW107XG4gIGNoYW5nZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICB0byA9IF9hWzFdO1xuICAgIHZhciBsaW5rID0gbmV3IExpbmsoKTtcbiAgICBmcm9tTGlua3NbZnJvbV0gPSBsaW5rO1xuICAgIHRvTGlua3NbdG9dID0gbGluaztcbiAgfSk7IC8vIGBmcm9tTGlua3NgIGFyZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciBieSBkb3VibGUgbGlua2VkIGxpc3QuXG5cbiAgZnJvbUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmssIGkpIHtcbiAgICBsaW5rLmNvbm5lY3QoZnJvbUxpbmtzW2kgLSAxXSk7XG4gIH0pO1xuICByZXR1cm4gY2hhbmdlZC5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICByZXR1cm4gIWZpeGVkW2ldO1xuICB9KS5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUxpbmsgPSBmcm9tTGlua3NbZnJvbV07XG4gICAgdmFyIHRvTGluayA9IHRvTGlua3NbdG8gLSAxXTtcbiAgICB2YXIgZnJvbUluZGV4ID0gZnJvbUxpbmsuZ2V0SW5kZXgoKTsgLy8gRGlzY29ubmVjdCB0aGUgbGluayBjb25uZWN0ZWQgdG8gYGZyb21MaW5rYC5cblxuICAgIGZyb21MaW5rLmRpc2Nvbm5lY3QoKTsgLy8gQ29ubmVjdCBgZnJvbUxpbmtgIHRvIHRoZSByaWdodCBvZiBgdG9MaW5rYC5cblxuICAgIGlmICghdG9MaW5rKSB7XG4gICAgICBmcm9tTGluay5jb25uZWN0KHVuZGVmaW5lZCwgZnJvbUxpbmtzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh0b0xpbmssIHRvTGluay5uZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgdG9JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7XG4gICAgcmV0dXJuIFtmcm9tSW5kZXgsIHRvSW5kZXhdO1xuICB9KTtcbn1cblxudmFyIFJlc3VsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdChwcmV2TGlzdCwgbGlzdCwgYWRkZWQsIHJlbW92ZWQsIGNoYW5nZWQsIG1haW50YWluZWQsIGNoYW5nZWRCZWZvcmVBZGRlZCwgZml4ZWQpIHtcbiAgICB0aGlzLnByZXZMaXN0ID0gcHJldkxpc3Q7XG4gICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB0aGlzLmFkZGVkID0gYWRkZWQ7XG4gICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB0aGlzLmNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgIHRoaXMubWFpbnRhaW5lZCA9IG1haW50YWluZWQ7XG4gICAgdGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQgPSBjaGFuZ2VkQmVmb3JlQWRkZWQ7XG4gICAgdGhpcy5maXhlZCA9IGZpeGVkO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBSZXN1bHQucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJvcmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZU9yZGVyZWQpIHtcbiAgICAgICAgdGhpcy5jYWN1bGF0ZU9yZGVyZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVPcmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInB1cmVDaGFuZ2VkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZVB1cmVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUHVyZUNoYW5nZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmNhY3VsYXRlT3JkZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JkZXJlZCA9IG9yZGVyQ2hhbmdlZCh0aGlzLmNoYW5nZWRCZWZvcmVBZGRlZCwgdGhpcy5maXhlZCk7XG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgdmFyIHB1cmVDaGFuZ2VkID0gW107XG4gICAgdGhpcy5jYWNoZU9yZGVyZWQgPSBvcmRlcmVkLmZpbHRlcihmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgICAgdG8gPSBfYVsxXTtcbiAgICAgIHZhciBfYiA9IGNoYW5nZWRbaV0sXG4gICAgICAgICAgZnJvbUJlZm9yZSA9IF9iWzBdLFxuICAgICAgICAgIHRvQmVmb3JlID0gX2JbMV07XG5cbiAgICAgIGlmIChmcm9tICE9PSB0bykge1xuICAgICAgICBwdXJlQ2hhbmdlZC5wdXNoKFtmcm9tQmVmb3JlLCB0b0JlZm9yZV0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlUHVyZUNoYW5nZWQgPSBwdXJlQ2hhbmdlZDtcbiAgfTtcblxuICByZXR1cm4gUmVzdWx0O1xufSgpO1xuXG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgZWcuTGlzdERpZmZlclxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gLSBQcmV2aW91cyBMaXN0IDxrbz4g7J207KCEIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gTGlzdCB0byBVcGRhdGUgPGtvPiDsl4XrjbDsnbTtirgg7ZWgIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpZmYgYmV0d2VlbiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgPGtvPiBgcHJldkxpc3Rg7JmAIGBsaXN0YOydmCDri6Trpbgg7KCQ7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRpZmYgfSBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAqIC8vIHNjcmlwdCA9PiBlZy5MaXN0RGlmZmVyLmRpZmZcbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmYoWzAsIDEsIDIsIDMsIDQsIDVdLCBbNywgOCwgMCwgNCwgMywgNiwgMiwgMV0sIGUgPT4gZSk7XG4gKiAvLyBMaXN0IGJlZm9yZSB1cGRhdGVcbiAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAqIC8vIFVwZGF0ZWQgbGlzdFxuICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgYWRkZWQgdG8gYGxpc3RgXG4gKiAvLyBbMCwgMSwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgXG4gKiAvLyBbNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5yZW1vdmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gKiAvLyBUaGUgc3Vic2V0IG9mIGBjaGFuZ2VkYCBhbmQgYW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdGhhdCBtb3ZlZCBkYXRhIGRpcmVjdGx5LiBJbmRpY2F0ZSBhbiBhcnJheSBvZiBhYnNvbHV0ZSBpbmRleCBwYWlycyBvZiBgb3JkZXJlZGAuKEZvcm1hdHRlZCBieTogQXJyYXk8W2luZGV4IG9mIHByZXZMaXN0LCBpbmRleCBvZiBsaXN0XT4pXG4gKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyB0byBiZSBgb3JkZXJlZGAgdGhhdCBjYW4gc3luY2hyb25pemUgYGxpc3RgIGJlZm9yZSBhZGRpbmcgZGF0YS4gKEZvcm1hdHRlZCBieTogQXJyYXk8W3ByZXZJbmRleCwgbmV4dEluZGV4XT4pXG4gKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB0aGF0IGhhdmUgbm90IGJlZW4gYWRkZWQvcmVtb3ZlZCBzbyBkYXRhIGlzIHByZXNlcnZlZFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICovXG5cbmZ1bmN0aW9uIGRpZmYocHJldkxpc3QsIGxpc3QsIGZpbmRLZXlDYWxsYmFjaykge1xuICB2YXIgbWFwQ2xhc3MgPSBTVVBQT1JUX01BUCA/IE1hcCA6IGZpbmRLZXlDYWxsYmFjayA/IEhhc2hNYXAgOiBQb2x5TWFwO1xuXG4gIHZhciBjYWxsYmFjayA9IGZpbmRLZXlDYWxsYmFjayB8fCBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlO1xuICB9O1xuXG4gIHZhciBhZGRlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuICB2YXIgbWFpbnRhaW5lZCA9IFtdO1xuICB2YXIgcHJldktleXMgPSBwcmV2TGlzdC5tYXAoY2FsbGJhY2spO1xuICB2YXIga2V5cyA9IGxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIHByZXZLZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGtleU1hcCA9IG5ldyBtYXBDbGFzcygpO1xuICB2YXIgY2hhbmdlZEJlZm9yZUFkZGVkID0gW107XG4gIHZhciBmaXhlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZE1hcCA9IHt9O1xuICB2YXIgY2hhbmdlZCA9IFtdO1xuICB2YXIgYWRkZWRDb3VudCA9IDA7XG4gIHZhciByZW1vdmVkQ291bnQgPSAwOyAvLyBBZGQgcHJldktleXMgYW5kIGtleXMgdG8gdGhlIGhhc2htYXAuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgcHJldktleU1hcC5zZXQoa2V5LCBwcmV2TGlzdEluZGV4KTtcbiAgfSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICBrZXlNYXAuc2V0KGtleSwgbGlzdEluZGV4KTtcbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgcmVtb3ZlZGAgaWYgdGhleSBhcmUgbm90IGluIGBrZXlzYC5cblxuICBwcmV2S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHByZXZMaXN0SW5kZXgpIHtcbiAgICB2YXIgbGlzdEluZGV4ID0ga2V5TWFwLmdldChrZXkpOyAvLyBJbiBwcmV2TGlzdCwgYnV0IG5vdCBpbiBsaXN0LCBpdCBpcyByZW1vdmVkLlxuXG4gICAgaWYgKHR5cGVvZiBsaXN0SW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICsrcmVtb3ZlZENvdW50O1xuICAgICAgcmVtb3ZlZC5wdXNoKHByZXZMaXN0SW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVkTWFwW2xpc3RJbmRleF0gPSByZW1vdmVkQ291bnQ7XG4gICAgfVxuICB9KTsgLy8gQ29tcGFyZSBgcHJldktleXNgIGFuZCBga2V5c2AgYW5kIGFkZCB0aGVtIHRvIGBhZGRlZGAgaWYgdGhleSBhcmUgbm90IGluIGBwcmV2S2V5c2AuXG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGxpc3RJbmRleCkge1xuICAgIHZhciBwcmV2TGlzdEluZGV4ID0gcHJldktleU1hcC5nZXQoa2V5KTsgLy8gSW4gbGlzdCwgYnV0IG5vdCBpbiBwcmV2TGlzdCwgaXQgaXMgYWRkZWQuXG5cbiAgICBpZiAodHlwZW9mIHByZXZMaXN0SW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGFkZGVkLnB1c2gobGlzdEluZGV4KTtcbiAgICAgICsrYWRkZWRDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFpbnRhaW5lZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIHJlbW92ZWRDb3VudCA9IHJlbW92ZWRNYXBbbGlzdEluZGV4XSB8fCAwO1xuICAgICAgY2hhbmdlZEJlZm9yZUFkZGVkLnB1c2goW3ByZXZMaXN0SW5kZXggLSByZW1vdmVkQ291bnQsIGxpc3RJbmRleCAtIGFkZGVkQ291bnRdKTtcbiAgICAgIGZpeGVkLnB1c2gobGlzdEluZGV4ID09PSBwcmV2TGlzdEluZGV4KTtcblxuICAgICAgaWYgKHByZXZMaXN0SW5kZXggIT09IGxpc3RJbmRleCkge1xuICAgICAgICBjaGFuZ2VkLnB1c2goW3ByZXZMaXN0SW5kZXgsIGxpc3RJbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFNvcnQgYnkgYXNjZW5kaW5nIG9yZGVyIG9mICd0byhsaXN0J3MgaW5kZXgpLlxuXG4gIHJlbW92ZWQucmV2ZXJzZSgpO1xuICByZXR1cm4gbmV3IFJlc3VsdChwcmV2TGlzdCwgbGlzdCwgYWRkZWQsIHJlbW92ZWQsIGNoYW5nZWQsIG1haW50YWluZWQsIGNoYW5nZWRCZWZvcmVBZGRlZCwgZml4ZWQpO1xufVxuXG4vKipcbiAqIEEgbW9kdWxlIHRoYXQgY2hlY2tzIGRpZmYgd2hlbiB2YWx1ZXMgYXJlIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIGluIGFuIGFycmF5LlxuICogQGtvIOuwsOyXtCDrmJDripQg7Jik67iM7KCd7Yq47JeQ7IScIOqwkuydtCDstpTqsIDrkJjqsbDrgpgg7IKt7KCc65CY6rGw64KYIOyInOyEnOqwgCDrs4Dqsr3sgqztla3snYQg7LK07YGs7ZWY64qUIOuqqOuTiOyeheuLiOuLpC5cbiAqIEBtZW1iZXJvZiBlZ1xuICovXG5cbnZhciBMaXN0RGlmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSAtIEluaXRpYWxpemluZyBEYXRhIEFycmF5LiA8a28+IOy0iOq4sCDshKTsoJXtlaAg642w7J207YSwIOuwsOyXtC48L2tvPlxuICAgKiBAcGFyYW0gLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbS4gPGtvPiDslYTsnbTthZzsnZgg7YKk66W8IOuwmO2ZmO2VmOuKlCDsvZzrsLEg7ZWo7IiY7J6F64uI64ukLjwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBMaXN0RGlmZmVyIGZyb20gXCJAZWdqcy9saXN0LWRpZmZlclwiO1xuICAgKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlclxuICAgKiBjb25zdCBkaWZmZXIgPSBuZXcgTGlzdERpZmZlcihbMCwgMSwgMiwgMywgNCwgNV0sIGUgPT4gZSk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlci51cGRhdGUoWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdKTtcbiAgICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gICAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucHJldkxpc3QpO1xuICAgKiAvLyBVcGRhdGVkIGxpc3RcbiAgICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5saXN0KTtcbiAgICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YC5cbiAgICogLy8gWzAsIDEsIDVdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyByZW1vdmVkIGluIGBwcmV2TGlzdGAuXG4gICAqIC8vIFs1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkKTtcbiAgICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICAgKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnB1cmVDaGFuZ2VkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICAgKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lm9yZGVyZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWQuXG4gICAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICAgKi9cbiAgZnVuY3Rpb24gTGlzdERpZmZlcihsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5maW5kS2V5Q2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2s7XG4gICAgdGhpcy5saXN0ID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGxpc3QuXG4gICAqIEBrbyDrpqzsiqTtirjrpbwg7JeF642w7J207Yq466W8IO2VqeuLiOuLpC5cbiAgICogQHBhcmFtIC0gTGlzdCB0byB1cGRhdGUgPGtvPiDsl4XrjbDsnbTtirjtlaAg66as7Iqk7Yq4IDwva28+XG4gICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFuIHVwZGF0ZSBmcm9tIGBwcmV2TGlzdGAgdG8gYGxpc3RgLjxrbz4gYHByZXZMaXN0YOyXkOyEnCBgbGlzdGDroZwg7JeF642w7J207Yq47ZWcIOqysOqzvOulvCDrsJjtmZjtlZzri6QuIDwva28+XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBMaXN0RGlmZmVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIG5ld0RhdGEgPSBbXS5zbGljZS5jYWxsKGxpc3QpO1xuICAgIHZhciByZXN1bHQgPSBkaWZmKHRoaXMubGlzdCwgbmV3RGF0YSwgdGhpcy5maW5kS2V5Q2FsbGJhY2spO1xuICAgIHRoaXMubGlzdCA9IG5ld0RhdGE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gTGlzdERpZmZlcjtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZXhwb3J0IGRlZmF1bHQgTGlzdERpZmZlcjtcbmV4cG9ydCB7IGRpZmYgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QtZGlmZmVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/list-differ/dist/list-differ.esm.js\n");

/***/ })

};
;