"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfast";
exports.ids = ["vendor-chunks/pdfast"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfast/src/helper.js":
/*!*******************************************!*\
  !*** ./node_modules/pdfast/src/helper.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\n\nvar self = module.exports;\n\nmodule.exports.isNumber = function (x) {\n  return (typeof x === 'number');\n};\n\nmodule.exports.findMin = function (arr) {\n  if (arr.length === 0) {\n    return Infinity;\n  }\n\n  var curr = arr[0];\n  for (var i = 1; i < arr.length; i++) {\n    curr = Math.min(curr, arr[i]);\n  }\n  return curr;\n};\n\nmodule.exports.findMax = function (arr) {\n  if (arr.length === 0) {\n    return -Infinity;\n  }\n\n  var curr = arr[0];\n  for (var i = 1; i < arr.length; i++) {\n    curr = Math.max(curr, arr[i]);\n  }\n  return curr;\n};\n\nmodule.exports.findMinMulti = function (arr) {\n  var curr = self.findMin(arr[0]);\n  for (var i = 1; i < arr.length; i++) {\n    curr = Math.min(curr, self.findMin(arr[i]));\n  }\n  return curr;\n};\n\nmodule.exports.findMaxMulti = function (arr) {\n  var curr = self.findMax(arr[0]);\n  for (var i = 1; i < arr.length; i++) {\n    curr = Math.max(curr, self.findMax(arr[i]));\n  }\n  return curr;\n};\n\nmodule.exports.inside = function (min, max, x) {\n  return (min <= x) && (x <= max);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmYXN0L3NyYy9oZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi8uL25vZGVfbW9kdWxlcy9wZGZhc3Qvc3JjL2hlbHBlci5qcz8wMmQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHNlbGYgPSBtb2R1bGUuZXhwb3J0cztcblxubW9kdWxlLmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gKHR5cGVvZiB4ID09PSAnbnVtYmVyJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kTWluID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIHZhciBjdXJyID0gYXJyWzBdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGN1cnIgPSBNYXRoLm1pbihjdXJyLCBhcnJbaV0pO1xuICB9XG4gIHJldHVybiBjdXJyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZmluZE1heCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLUluZmluaXR5O1xuICB9XG5cbiAgdmFyIGN1cnIgPSBhcnJbMF07XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyciA9IE1hdGgubWF4KGN1cnIsIGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIGN1cnI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kTWluTXVsdGkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBjdXJyID0gc2VsZi5maW5kTWluKGFyclswXSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyciA9IE1hdGgubWluKGN1cnIsIHNlbGYuZmluZE1pbihhcnJbaV0pKTtcbiAgfVxuICByZXR1cm4gY3Vycjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZpbmRNYXhNdWx0aSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGN1cnIgPSBzZWxmLmZpbmRNYXgoYXJyWzBdKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyID0gTWF0aC5tYXgoY3Vyciwgc2VsZi5maW5kTWF4KGFycltpXSkpO1xuICB9XG4gIHJldHVybiBjdXJyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaW5zaWRlID0gZnVuY3Rpb24gKG1pbiwgbWF4LCB4KSB7XG4gIHJldHVybiAobWluIDw9IHgpICYmICh4IDw9IG1heCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfast/src/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pdfast/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/pdfast/src/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_WIDTH = 2;\n\nvar LN_2 = Math.log(2);\nvar self = module.exports;\n\nvar helper = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/pdfast/src/helper.js\");\n\n// Triangle\nfunction kernel(x) {\n  return 1 - Math.abs(x);\n}\n\n/**\n * Get min and max value for the pdf, covering all arr data range while respecting options' data\n * @param arr\n * @param options\n * @returns {*}\n */\nmodule.exports.getUnifiedMinMax = function (arr, options) {\n  return self.getUnifiedMinMaxMulti([arr], options);\n};\n\nmodule.exports.getUnifiedMinMaxMulti = function (arrMulti, options) {\n  options = options || {};\n\n  var relaxMin = false;\n  var relaxMax = false;\n\n  var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;\n  var size = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;\n  var min = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));\n  var max = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));\n\n  var range = max - min;\n  var step = range / (size - 1);\n\n  // Relax?\n  if (relaxMin) {\n    min = min - 2 * width * step;\n  }\n  if (relaxMax) {\n    max = max + 2 * width * step;\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n};\n\nmodule.exports.create = function (arr, options) {\n  options = options || {};\n\n  if (!arr || (arr.length === 0)) {\n    return [];\n  }\n\n  var size = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;\n  var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;\n  var normalizedMinMax = self.getUnifiedMinMax(arr, {\n    size: size,\n    width: width,\n    min: options.min,\n    max: options.max\n  });\n\n  var min = normalizedMinMax.min;\n  var max = normalizedMinMax.max;\n\n  var range = max - min;\n  var step = range / (size - 1);\n  if (range === 0) {\n    // Special case...\n    return [{x: min, y: 1}];\n  }\n\n  // Good to go\n\n  var buckets = [];\n  for (var i = 0; i < size; i++) {\n    buckets.push({\n      x: min + i * step,\n      y: 0\n    });\n  }\n\n  var xToBucket = function (x) {\n    return Math.floor((x - min) / step);\n  };\n\n  var partialArea = generatePartialAreas(kernel, width);\n  var fullArea = partialArea[width];\n  var c = partialArea[width-1] - partialArea[width-2];\n\n  var initalValue = 0;\n  arr.forEach(function (x) {\n    var bucket = xToBucket(x);\n\n    // Totally outside?\n    if ((bucket + width < 0) || (bucket - width >= buckets.length)) {\n      return;\n    }\n\n    var start = Math.max(bucket - width, 0);\n    var mid = bucket;\n    var end = Math.min(bucket + width, buckets.length - 1);\n\n    var leftBlockCount = start - (bucket - width);\n    var rightBlockCount = (bucket + width) - end;\n    var spilledAreaLeft = partialArea[-width-1 + leftBlockCount] || 0;\n    var spilledAreaRight = partialArea[-width-1 + rightBlockCount] || 0;\n    var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);\n\n    if (leftBlockCount > 0) {\n      initalValue += weight * (leftBlockCount - 1) * c;\n    }\n\n    // Add grads\n    var startGradPos = Math.max(0, bucket-width+1);\n    if (helper.inside(0, buckets.length-1, startGradPos)) {\n      buckets[startGradPos].y += weight * 1 * c;\n    }\n    if (helper.inside(0, buckets.length-1, mid + 1)) {\n      buckets[mid + 1].y -= weight * 2 * c;\n    }\n    if (helper.inside(0, buckets.length-1, end + 1)) {\n      buckets[end + 1].y += weight * 1 * c;\n    }\n  });\n\n  var accumulator = initalValue;\n  var gradAccumulator = 0;\n  var area = 0;\n  buckets.forEach(function (bucket) {\n    gradAccumulator += bucket.y;\n    accumulator += gradAccumulator;\n\n    bucket.y = accumulator;\n    area += accumulator;\n  });\n\n  // Normalize\n  if (area > 0) {\n    buckets.forEach(function (bucket) {\n      bucket.y /= area;\n    });\n  }\n\n  return buckets;\n};\n\nfunction generatePartialAreas(kernel, width) {\n  var partialAreas = {};\n\n  var accumulator = 0;\n  for (var i = -width; i <= width; i++) {\n    accumulator += kernel(i/width);\n    partialAreas[i] = accumulator;\n  }\n\n  return partialAreas;\n}\n\nmodule.exports.getExpectedValueFromPdf = function (pdf) {\n  if (!pdf || (pdf.length === 0)) {\n    return undefined;\n  }\n\n  var expected = 0;\n\n  pdf.forEach(function (obj) {\n    expected += obj.x * obj.y;\n  });\n\n  return expected;\n};\n\nmodule.exports.getXWithLeftTailArea = function (pdf, area) {\n  if (!pdf || (pdf.length === 0)) {\n    return undefined;\n  }\n\n  var accumulator = 0;\n  var last = 0;\n  for (var i = 0; i < pdf.length; i++) {\n    last = i;\n    accumulator += pdf[i].y;\n\n    if (accumulator >= area) {\n      break;\n    }\n  }\n\n  return pdf[last].x;\n};\n\nmodule.exports.getPerplexity = function (pdf) {\n  if (!pdf || (pdf.length === 0)) {\n    return undefined;\n  }\n\n  var entropy = 0;\n  pdf.forEach(function (obj) {\n    var ln = Math.log(obj.y);\n\n    if (isFinite(ln)) {\n      entropy += obj.y * ln;\n    }\n  });\n  entropy = -entropy / LN_2;\n\n  return Math.pow(2, entropy);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmYXN0L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDJEQUFVOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi8uL25vZGVfbW9kdWxlcy9wZGZhc3Qvc3JjL2luZGV4LmpzP2NkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgREVGQVVMVF9TSVpFID0gNTA7XG52YXIgREVGQVVMVF9XSURUSCA9IDI7XG5cbnZhciBMTl8yID0gTWF0aC5sb2coMik7XG52YXIgc2VsZiA9IG1vZHVsZS5leHBvcnRzO1xuXG52YXIgaGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXInKTtcblxuLy8gVHJpYW5nbGVcbmZ1bmN0aW9uIGtlcm5lbCh4KSB7XG4gIHJldHVybiAxIC0gTWF0aC5hYnMoeCk7XG59XG5cbi8qKlxuICogR2V0IG1pbiBhbmQgbWF4IHZhbHVlIGZvciB0aGUgcGRmLCBjb3ZlcmluZyBhbGwgYXJyIGRhdGEgcmFuZ2Ugd2hpbGUgcmVzcGVjdGluZyBvcHRpb25zJyBkYXRhXG4gKiBAcGFyYW0gYXJyXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbm1vZHVsZS5leHBvcnRzLmdldFVuaWZpZWRNaW5NYXggPSBmdW5jdGlvbiAoYXJyLCBvcHRpb25zKSB7XG4gIHJldHVybiBzZWxmLmdldFVuaWZpZWRNaW5NYXhNdWx0aShbYXJyXSwgb3B0aW9ucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRVbmlmaWVkTWluTWF4TXVsdGkgPSBmdW5jdGlvbiAoYXJyTXVsdGksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJlbGF4TWluID0gZmFsc2U7XG4gIHZhciByZWxheE1heCA9IGZhbHNlO1xuXG4gIHZhciB3aWR0aCA9IGhlbHBlci5pc051bWJlcihvcHRpb25zLndpZHRoKSA/IG9wdGlvbnMud2lkdGggOiBERUZBVUxUX1dJRFRIO1xuICB2YXIgc2l6ZSA9IGhlbHBlci5pc051bWJlcihvcHRpb25zLnNpemUpID8gb3B0aW9ucy5zaXplIDogREVGQVVMVF9TSVpFO1xuICB2YXIgbWluID0gaGVscGVyLmlzTnVtYmVyKG9wdGlvbnMubWluKSA/IG9wdGlvbnMubWluIDogKHJlbGF4TWluID0gdHJ1ZSwgaGVscGVyLmZpbmRNaW5NdWx0aShhcnJNdWx0aSkpO1xuICB2YXIgbWF4ID0gaGVscGVyLmlzTnVtYmVyKG9wdGlvbnMubWF4KSA/IG9wdGlvbnMubWF4IDogKHJlbGF4TWF4ID0gdHJ1ZSwgaGVscGVyLmZpbmRNYXhNdWx0aShhcnJNdWx0aSkpO1xuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgdmFyIHN0ZXAgPSByYW5nZSAvIChzaXplIC0gMSk7XG5cbiAgLy8gUmVsYXg/XG4gIGlmIChyZWxheE1pbikge1xuICAgIG1pbiA9IG1pbiAtIDIgKiB3aWR0aCAqIHN0ZXA7XG4gIH1cbiAgaWYgKHJlbGF4TWF4KSB7XG4gICAgbWF4ID0gbWF4ICsgMiAqIHdpZHRoICogc3RlcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcnIsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFhcnIgfHwgKGFyci5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHNpemUgPSBoZWxwZXIuaXNOdW1iZXIob3B0aW9ucy5zaXplKSA/IG9wdGlvbnMuc2l6ZSA6IERFRkFVTFRfU0laRTtcbiAgdmFyIHdpZHRoID0gaGVscGVyLmlzTnVtYmVyKG9wdGlvbnMud2lkdGgpID8gb3B0aW9ucy53aWR0aCA6IERFRkFVTFRfV0lEVEg7XG4gIHZhciBub3JtYWxpemVkTWluTWF4ID0gc2VsZi5nZXRVbmlmaWVkTWluTWF4KGFyciwge1xuICAgIHNpemU6IHNpemUsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgbWF4OiBvcHRpb25zLm1heFxuICB9KTtcblxuICB2YXIgbWluID0gbm9ybWFsaXplZE1pbk1heC5taW47XG4gIHZhciBtYXggPSBub3JtYWxpemVkTWluTWF4Lm1heDtcblxuICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gIHZhciBzdGVwID0gcmFuZ2UgLyAoc2l6ZSAtIDEpO1xuICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UuLi5cbiAgICByZXR1cm4gW3t4OiBtaW4sIHk6IDF9XTtcbiAgfVxuXG4gIC8vIEdvb2QgdG8gZ29cblxuICB2YXIgYnVja2V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGJ1Y2tldHMucHVzaCh7XG4gICAgICB4OiBtaW4gKyBpICogc3RlcCxcbiAgICAgIHk6IDBcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB4VG9CdWNrZXQgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKCh4IC0gbWluKSAvIHN0ZXApO1xuICB9O1xuXG4gIHZhciBwYXJ0aWFsQXJlYSA9IGdlbmVyYXRlUGFydGlhbEFyZWFzKGtlcm5lbCwgd2lkdGgpO1xuICB2YXIgZnVsbEFyZWEgPSBwYXJ0aWFsQXJlYVt3aWR0aF07XG4gIHZhciBjID0gcGFydGlhbEFyZWFbd2lkdGgtMV0gLSBwYXJ0aWFsQXJlYVt3aWR0aC0yXTtcblxuICB2YXIgaW5pdGFsVmFsdWUgPSAwO1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgIHZhciBidWNrZXQgPSB4VG9CdWNrZXQoeCk7XG5cbiAgICAvLyBUb3RhbGx5IG91dHNpZGU/XG4gICAgaWYgKChidWNrZXQgKyB3aWR0aCA8IDApIHx8IChidWNrZXQgLSB3aWR0aCA+PSBidWNrZXRzLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChidWNrZXQgLSB3aWR0aCwgMCk7XG4gICAgdmFyIG1pZCA9IGJ1Y2tldDtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4oYnVja2V0ICsgd2lkdGgsIGJ1Y2tldHMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgbGVmdEJsb2NrQ291bnQgPSBzdGFydCAtIChidWNrZXQgLSB3aWR0aCk7XG4gICAgdmFyIHJpZ2h0QmxvY2tDb3VudCA9IChidWNrZXQgKyB3aWR0aCkgLSBlbmQ7XG4gICAgdmFyIHNwaWxsZWRBcmVhTGVmdCA9IHBhcnRpYWxBcmVhWy13aWR0aC0xICsgbGVmdEJsb2NrQ291bnRdIHx8IDA7XG4gICAgdmFyIHNwaWxsZWRBcmVhUmlnaHQgPSBwYXJ0aWFsQXJlYVstd2lkdGgtMSArIHJpZ2h0QmxvY2tDb3VudF0gfHwgMDtcbiAgICB2YXIgd2VpZ2h0ID0gZnVsbEFyZWEgLyAoZnVsbEFyZWEgLSBzcGlsbGVkQXJlYUxlZnQgLSBzcGlsbGVkQXJlYVJpZ2h0KTtcblxuICAgIGlmIChsZWZ0QmxvY2tDb3VudCA+IDApIHtcbiAgICAgIGluaXRhbFZhbHVlICs9IHdlaWdodCAqIChsZWZ0QmxvY2tDb3VudCAtIDEpICogYztcbiAgICB9XG5cbiAgICAvLyBBZGQgZ3JhZHNcbiAgICB2YXIgc3RhcnRHcmFkUG9zID0gTWF0aC5tYXgoMCwgYnVja2V0LXdpZHRoKzEpO1xuICAgIGlmIChoZWxwZXIuaW5zaWRlKDAsIGJ1Y2tldHMubGVuZ3RoLTEsIHN0YXJ0R3JhZFBvcykpIHtcbiAgICAgIGJ1Y2tldHNbc3RhcnRHcmFkUG9zXS55ICs9IHdlaWdodCAqIDEgKiBjO1xuICAgIH1cbiAgICBpZiAoaGVscGVyLmluc2lkZSgwLCBidWNrZXRzLmxlbmd0aC0xLCBtaWQgKyAxKSkge1xuICAgICAgYnVja2V0c1ttaWQgKyAxXS55IC09IHdlaWdodCAqIDIgKiBjO1xuICAgIH1cbiAgICBpZiAoaGVscGVyLmluc2lkZSgwLCBidWNrZXRzLmxlbmd0aC0xLCBlbmQgKyAxKSkge1xuICAgICAgYnVja2V0c1tlbmQgKyAxXS55ICs9IHdlaWdodCAqIDEgKiBjO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGFjY3VtdWxhdG9yID0gaW5pdGFsVmFsdWU7XG4gIHZhciBncmFkQWNjdW11bGF0b3IgPSAwO1xuICB2YXIgYXJlYSA9IDA7XG4gIGJ1Y2tldHMuZm9yRWFjaChmdW5jdGlvbiAoYnVja2V0KSB7XG4gICAgZ3JhZEFjY3VtdWxhdG9yICs9IGJ1Y2tldC55O1xuICAgIGFjY3VtdWxhdG9yICs9IGdyYWRBY2N1bXVsYXRvcjtcblxuICAgIGJ1Y2tldC55ID0gYWNjdW11bGF0b3I7XG4gICAgYXJlYSArPSBhY2N1bXVsYXRvcjtcbiAgfSk7XG5cbiAgLy8gTm9ybWFsaXplXG4gIGlmIChhcmVhID4gMCkge1xuICAgIGJ1Y2tldHMuZm9yRWFjaChmdW5jdGlvbiAoYnVja2V0KSB7XG4gICAgICBidWNrZXQueSAvPSBhcmVhO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJ1Y2tldHM7XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVBhcnRpYWxBcmVhcyhrZXJuZWwsIHdpZHRoKSB7XG4gIHZhciBwYXJ0aWFsQXJlYXMgPSB7fTtcblxuICB2YXIgYWNjdW11bGF0b3IgPSAwO1xuICBmb3IgKHZhciBpID0gLXdpZHRoOyBpIDw9IHdpZHRoOyBpKyspIHtcbiAgICBhY2N1bXVsYXRvciArPSBrZXJuZWwoaS93aWR0aCk7XG4gICAgcGFydGlhbEFyZWFzW2ldID0gYWNjdW11bGF0b3I7XG4gIH1cblxuICByZXR1cm4gcGFydGlhbEFyZWFzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5nZXRFeHBlY3RlZFZhbHVlRnJvbVBkZiA9IGZ1bmN0aW9uIChwZGYpIHtcbiAgaWYgKCFwZGYgfHwgKHBkZi5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBleHBlY3RlZCA9IDA7XG5cbiAgcGRmLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGV4cGVjdGVkICs9IG9iai54ICogb2JqLnk7XG4gIH0pO1xuXG4gIHJldHVybiBleHBlY3RlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFhXaXRoTGVmdFRhaWxBcmVhID0gZnVuY3Rpb24gKHBkZiwgYXJlYSkge1xuICBpZiAoIXBkZiB8fCAocGRmLmxlbmd0aCA9PT0gMCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGFjY3VtdWxhdG9yID0gMDtcbiAgdmFyIGxhc3QgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBkZi5sZW5ndGg7IGkrKykge1xuICAgIGxhc3QgPSBpO1xuICAgIGFjY3VtdWxhdG9yICs9IHBkZltpXS55O1xuXG4gICAgaWYgKGFjY3VtdWxhdG9yID49IGFyZWEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwZGZbbGFzdF0ueDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFBlcnBsZXhpdHkgPSBmdW5jdGlvbiAocGRmKSB7XG4gIGlmICghcGRmIHx8IChwZGYubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZW50cm9weSA9IDA7XG4gIHBkZi5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgbG4gPSBNYXRoLmxvZyhvYmoueSk7XG5cbiAgICBpZiAoaXNGaW5pdGUobG4pKSB7XG4gICAgICBlbnRyb3B5ICs9IG9iai55ICogbG47XG4gICAgfVxuICB9KTtcbiAgZW50cm9weSA9IC1lbnRyb3B5IC8gTE5fMjtcblxuICByZXR1cm4gTWF0aC5wb3coMiwgZW50cm9weSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfast/src/index.js\n");

/***/ })

};
;