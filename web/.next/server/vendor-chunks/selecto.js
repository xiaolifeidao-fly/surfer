"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/selecto";
exports.ids = ["vendor-chunks/selecto"];
exports.modules = {

/***/ "(ssr)/./node_modules/selecto/dist/selecto.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/selecto/dist/selecto.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLASS_NAME: () => (/* binding */ CLASS_NAME),\n/* harmony export */   EVENTS: () => (/* binding */ EVENTS),\n/* harmony export */   METHODS: () => (/* binding */ METHODS),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   OPTION_TYPES: () => (/* binding */ OPTION_TYPES),\n/* harmony export */   PROPERTIES: () => (/* binding */ PROPERTIES),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @scena/event-emitter */ \"(ssr)/./node_modules/@scena/event-emitter/dist/event-emitter.esm.js\");\n/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gesto */ \"(ssr)/./node_modules/gesto/dist/gesto.esm.js\");\n/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! framework-utils */ \"(ssr)/./node_modules/framework-utils/dist/utils.esm.js\");\n/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @daybrush/utils */ \"(ssr)/./node_modules/@daybrush/utils/dist/utils.esm.js\");\n/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @egjs/children-differ */ \"(ssr)/./node_modules/@egjs/children-differ/dist/children-differ.esm.js\");\n/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scena/dragscroll */ \"(ssr)/./node_modules/@scena/dragscroll/dist/dragscroll.esm.js\");\n/* harmony import */ var keycon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! keycon */ \"(ssr)/./node_modules/keycon/dist/keycon.esm.js\");\n/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! overlap-area */ \"(ssr)/./node_modules/overlap-area/dist/overlap-area.esm.js\");\n/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-to-mat */ \"(ssr)/./node_modules/css-to-mat/dist/css-to-mat.esm.js\");\n/* harmony import */ var css_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! css-styled */ \"(ssr)/./node_modules/css-styled/dist/styled.esm.js\");\n/*\nCopyright (c) 2020 Daybrush\nname: selecto\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/selecto.git\nversion: 1.26.3\n*/\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction getClient(e) {\n  if (\"touches\" in e) {\n    var touch = e.touches[0] || e.changedTouches[0];\n    return {\n      clientX: touch.clientX,\n      clientY: touch.clientY\n    };\n  } else {\n    return {\n      clientX: e.clientX,\n      clientY: e.clientY\n    };\n  }\n}\nfunction filterDuplicated(arr) {\n  if (typeof Map === \"undefined\") {\n    return arr.filter(function (value, index) {\n      return arr.indexOf(value) === index;\n    });\n  }\n\n  var map = new Map();\n  return arr.filter(function (value) {\n    if (map.has(value)) {\n      return false;\n    }\n\n    map.set(value, true);\n    return true;\n  });\n}\nfunction elementFromPoint(baseNode, clientX, clientY) {\n  var doc = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(baseNode);\n  return doc.elementFromPoint && doc.elementFromPoint(clientX, clientY) || null;\n}\nfunction createElement(jsx, prevTarget, container) {\n  var tag = jsx.tag,\n      children = jsx.children,\n      attributes = jsx.attributes,\n      className = jsx.className,\n      style = jsx.style;\n  var el = prevTarget || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).createElement(tag);\n\n  for (var name in attributes) {\n    el.setAttribute(name, attributes[name]);\n  }\n\n  var elChildren = el.children;\n  children.forEach(function (child, i) {\n    createElement(child, elChildren[i], el);\n  });\n\n  if (className) {\n    className.split(/\\s+/g).forEach(function (name) {\n      if (name && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.hasClass)(el, name)) {\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addClass)(el, name);\n      }\n    });\n  }\n\n  if (style) {\n    var elStyle = el.style;\n\n    for (var name in style) {\n      elStyle[name] = style[name];\n    }\n  }\n\n  if (!prevTarget && container) {\n    container.appendChild(el);\n  }\n\n  return el;\n}\nfunction h(tag, attrs) {\n  var children = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    children[_i - 2] = arguments[_i];\n  }\n\n  var _a = attrs || {},\n      _b = _a.className,\n      className = _b === void 0 ? \"\" : _b,\n      _c = _a.style,\n      style = _c === void 0 ? {} : _c,\n      attributes = __rest(_a, [\"className\", \"style\"]);\n\n  return {\n    tag: tag,\n    className: className,\n    style: style,\n    attributes: attributes,\n    children: children\n  };\n}\nfunction diffValue(prev, cur, func) {\n  if (prev !== cur) {\n    func(prev, cur);\n  }\n}\nfunction getRect(e, ratio, boundArea) {\n  var _a;\n\n  if (boundArea === void 0) {\n    boundArea = e.data.boundArea;\n  }\n\n  var _b = e.distX,\n      distX = _b === void 0 ? 0 : _b,\n      _c = e.distY,\n      distY = _c === void 0 ? 0 : _c;\n  var _d = e.data,\n      startX = _d.startX,\n      startY = _d.startY;\n\n  if (ratio > 0) {\n    var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));\n    var nextWidth = ratio * nextHeight;\n    distX = (distX >= 0 ? 1 : -1) * nextWidth;\n    distY = (distY >= 0 ? 1 : -1) * nextHeight;\n  }\n\n  var width = Math.abs(distX);\n  var height = Math.abs(distY);\n  var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n  var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n  _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.calculateBoundSize)([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a[0], height = _a[1];\n  distX = (distX >= 0 ? 1 : -1) * width;\n  distY = (distY >= 0 ? 1 : -1) * height;\n  var tx = Math.min(0, distX);\n  var ty = Math.min(0, distY);\n  var left = startX + tx;\n  var top = startY + ty;\n  return {\n    left: left,\n    top: top,\n    right: left + width,\n    bottom: top + height,\n    width: width,\n    height: height\n  };\n}\nfunction getDefaultElementRect(el) {\n  var rect = el.getBoundingClientRect();\n  var left = rect.left,\n      top = rect.top,\n      width = rect.width,\n      height = rect.height;\n  return {\n    pos1: [left, top],\n    pos2: [left + width, top],\n    pos3: [left, top + height],\n    pos4: [left + width, top + height]\n  };\n}\nfunction passTargets(beforeTargets, afterTargets, continueSelectWithoutDeselect) {\n  var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeTargets, afterTargets),\n      list = _a.list,\n      prevList = _a.prevList,\n      added = _a.added,\n      removed = _a.removed,\n      maintained = _a.maintained;\n\n  return __spreadArray(__spreadArray(__spreadArray([], added.map(function (index) {\n    return list[index];\n  }), true), removed.map(function (index) {\n    return prevList[index];\n  }), true), continueSelectWithoutDeselect ? maintained.map(function (_a) {\n    var nextIndex = _a[1];\n    return list[nextIndex];\n  }) : [], true);\n}\nfunction getLineSize(points) {\n  var size = 0;\n  var length = points.length;\n\n  for (var i = 1; i < length; ++i) {\n    size = Math.max((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDist)(points[i], points[i - 1]), size);\n  }\n\n  return size;\n}\n\nvar injector = (0,css_styled__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"\\n:host {\\n    position: fixed;\\n    display: none;\\n    border: 1px solid #4af;\\n    background: rgba(68, 170, 255, 0.5);\\n    pointer-events: none;\\n    will-change: transform;\\n    z-index: 100;\\n}\\n\");\n/**\n * @memberof Selecto\n */\n\nvar CLASS_NAME = \"selecto-selection \".concat(injector.className);\nvar PROPERTIES = [\"className\", \"boundContainer\", \"selectableTargets\", \"selectByClick\", \"selectFromInside\", \"continueSelect\", \"continueSelectWithoutDeselect\", \"toggleContinueSelect\", \"toggleContinueSelectWithoutDeselect\", \"keyContainer\", \"hitRate\", \"scrollOptions\", \"checkInput\", \"preventDefault\", \"ratio\", \"getElementRect\", \"preventDragFromInside\", \"rootContainer\", \"dragCondition\", \"clickBySelectEnd\", \"checkOverflow\", \"innerScrollOptions\"];\n/**\n * @memberof Selecto\n */\n\nvar OPTIONS = __spreadArray([// ignore target, container,\n\"dragContainer\", \"cspNonce\", \"preventClickEventOnDrag\", \"preventClickEventOnDragStart\", \"preventRightClick\"], PROPERTIES, true);\nvar OPTION_TYPES = {\n  className: String,\n  boundContainer: null,\n  portalContainer: null,\n  container: null,\n  dragContainer: null,\n  selectableTargets: Array,\n  selectByClick: Boolean,\n  selectFromInside: Boolean,\n  continueSelect: Boolean,\n  toggleContinueSelect: Array,\n  toggleContinueSelectWithoutDeselect: Array,\n  keyContainer: null,\n  hitRate: Number,\n  scrollOptions: Object,\n  checkInput: Boolean,\n  preventDefault: Boolean,\n  cspNonce: String,\n  ratio: Number,\n  getElementRect: Function,\n  preventDragFromInside: Boolean,\n  rootContainer: Object,\n  dragCondition: Function,\n  clickBySelectEnd: Boolean,\n  continueSelectWithoutDeselect: Boolean,\n  preventClickEventOnDragStart: Boolean,\n  preventClickEventOnDrag: Boolean,\n  checkOverflow: Boolean,\n  innerScrollOptions: Object\n};\n/**\n * @memberof Selecto\n */\n\nvar EVENTS = [\"dragStart\", \"drag\", \"dragEnd\", \"selectStart\", \"select\", \"selectEnd\", \"keydown\", \"keyup\", \"scroll\", \"innerScroll\"];\n/**\n * @memberof Selecto\n */\n\nvar METHODS = [\"clickTarget\", \"getSelectableElements\", \"setSelectedTargets\", \"getElementPoints\", \"getSelectedTargets\", \"findSelectableTargets\", \"triggerDragStart\", \"checkScroll\", \"selectTargetsByPoints\", \"setSelectedTargetsByPoints\"];\n\n/**\n * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.\n * @sort 1\n * @extends EventEmitter\n */\n\nvar Selecto =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Selecto, _super);\n  /**\n   *\n   */\n\n\n  function Selecto(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.selectedTargets = [];\n    _this.dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n\n    _this._onDragStart = function (e, clickedTarget) {\n      var data = e.data,\n          clientX = e.clientX,\n          clientY = e.clientY,\n          inputEvent = e.inputEvent;\n      var _a = _this.options,\n          selectFromInside = _a.selectFromInside,\n          selectByClick = _a.selectByClick,\n          rootContainer = _a.rootContainer,\n          boundContainer = _a.boundContainer,\n          _b = _a.preventDragFromInside,\n          preventDragFromInside = _b === void 0 ? true : _b,\n          clickBySelectEnd = _a.clickBySelectEnd,\n          dragCondition = _a.dragCondition;\n\n      if (dragCondition && !dragCondition(e)) {\n        e.stop();\n        return;\n      }\n\n      data.data = {};\n      var win = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(_this.container);\n      data.innerWidth = win.innerWidth;\n      data.innerHeight = win.innerHeight;\n\n      _this.findSelectableTargets(data);\n\n      data.startSelectedTargets = _this.selectedTargets;\n      data.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.createMatrix)();\n      data.containerX = 0;\n      data.containerY = 0;\n      var container = _this.container;\n      var boundArea = {\n        left: -Infinity,\n        top: -Infinity,\n        right: Infinity,\n        bottom: Infinity\n      };\n\n      if (rootContainer) {\n        var containerRect = _this.container.getBoundingClientRect();\n\n        data.containerX = containerRect.left;\n        data.containerY = containerRect.top;\n        data.scaleMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.getDistElementMatrix)(_this.container, rootContainer);\n      }\n\n      if (boundContainer) {\n        var boundInfo = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(boundContainer) && \"element\" in boundContainer ? __assign({\n          left: true,\n          top: true,\n          bottom: true,\n          right: true\n        }, boundContainer) : {\n          element: boundContainer,\n          left: true,\n          top: true,\n          bottom: true,\n          right: true\n        };\n        var boundElement = boundInfo.element;\n        var rectElement = void 0;\n\n        if (boundElement) {\n          if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(boundElement)) {\n            rectElement = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).querySelector(boundElement);\n          } else if (boundElement === true) {\n            rectElement = _this.container;\n          } else {\n            rectElement = boundElement;\n          }\n\n          var rect = rectElement.getBoundingClientRect();\n\n          if (boundInfo.left) {\n            boundArea.left = rect.left;\n          }\n\n          if (boundInfo.top) {\n            boundArea.top = rect.top;\n          }\n\n          if (boundInfo.right) {\n            boundArea.right = rect.right;\n          }\n\n          if (boundInfo.bottom) {\n            boundArea.bottom = rect.bottom;\n          }\n        }\n      }\n\n      data.boundArea = boundArea;\n      var hitRect = {\n        left: clientX,\n        top: clientY,\n        right: clientX,\n        bottom: clientY,\n        width: 0,\n        height: 0\n      };\n      var firstPassedTargets = []; // allow click on select\n\n      var allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n      var hasInsideTargets = false;\n\n      if (!selectFromInside || allowClickBySelectEnd) {\n        var pointTarget = _this._findElement(clickedTarget || inputEvent.target, // elementFromPoint(clientX, clientY),\n        data.selectableTargets);\n\n        hasInsideTargets = !!pointTarget;\n\n        if (allowClickBySelectEnd) {\n          firstPassedTargets = pointTarget ? [pointTarget] : [];\n        }\n      }\n\n      var isPreventSelect = !selectFromInside && hasInsideTargets; // prevent drag from inside when selectByClick is false\n\n      if (isPreventSelect && !selectByClick) {\n        e.stop();\n        return false;\n      }\n\n      var type = inputEvent.type;\n      var isTrusted = type === \"mousedown\" || type === \"touchstart\";\n      /**\n       * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n       * Call the stop () function if you have a specific element or don't want to raise a select\n       * @memberof Selecto\n       * @event dragStart\n       * @param {OnDragStart} - Parameters for the dragStart event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"dragStart\", e => {\n       *   if (e.inputEvent.target.tagName === \"SPAN\") {\n       *     e.stop();\n       *   }\n       * }).on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n\n      var result = !e.isClick && isTrusted ? _this.emit(\"dragStart\", __assign(__assign({}, e), {\n        data: data.data\n      })) : true;\n\n      if (!result) {\n        e.stop();\n        return false;\n      }\n\n      if (_this.continueSelect) {\n        firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets, _this.continueSelectWithoutDeselect);\n        data.startPassedTargets = _this.selectedTargets;\n      } else {\n        data.startPassedTargets = [];\n      }\n\n      _this._select(firstPassedTargets, hitRect, e, true, isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside);\n\n      data.startX = clientX;\n      data.startY = clientY;\n      data.selectFlag = false;\n      data.preventDragFromInside = false;\n\n      if (inputEvent.target) {\n        var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(data.scaleMatrix, [clientX - data.containerX, clientY - data.containerY]);\n        _this.target.style.cssText += \"position: \".concat(rootContainer ? \"absolute\" : \"fixed\", \";\") + \"left:0px;top:0px;\" + \"transform: translate(\".concat(offsetPos[0], \"px, \").concat(offsetPos[1], \"px)\");\n      }\n\n      if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n        inputEvent.preventDefault(); // prevent drag from inside when selectByClick is true and force call `selectEnd`\n\n        if (preventDragFromInside) {\n          _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, hitRect, e, true);\n\n          data.preventDragFromInside = true;\n        }\n      } else {\n        data.selectFlag = true; // why?\n        // if (type === \"touchstart\") {\n        //     inputEvent.preventDefault();\n        // }\n\n        var _c = _this.options,\n            scrollOptions = _c.scrollOptions,\n            innerScrollOptions = _c.innerScrollOptions;\n        var isInnerScroll = false;\n\n        if (innerScrollOptions) {\n          var inputEvent_1 = e.inputEvent;\n          var target = inputEvent_1.target;\n          var innerScrollElement = null;\n          var parentElement = target;\n\n          while (parentElement && parentElement !== (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).body) {\n            var overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n            if (overflow) {\n              innerScrollElement = parentElement;\n              break;\n            }\n\n            parentElement = parentElement.parentElement;\n          }\n\n          if (innerScrollElement) {\n            data.innerScrollOptions = __assign({\n              container: innerScrollElement,\n              checkScrollEvent: true\n            }, innerScrollOptions === true ? {} : innerScrollOptions);\n\n            _this.dragScroll.dragStart(e, data.innerScrollOptions);\n\n            isInnerScroll = true;\n          }\n        }\n\n        if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n          _this.dragScroll.dragStart(e, scrollOptions);\n        }\n\n        if (isPreventSelect && selectByClick && clickBySelectEnd) {\n          data.selectFlag = false;\n          e.preventDrag();\n        }\n      }\n\n      return true;\n    };\n\n    _this._onDrag = function (e) {\n      if (e.data.selectFlag) {\n        var scrollOptions = _this.scrollOptions;\n        var innerScrollOptions = e.data.innerScrollOptions;\n        var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container); // If it is a scrolling position, pass drag\n\n        if (hasScrollOptions && !e.isScroll && _this.dragScroll.drag(e, innerScrollOptions || scrollOptions)) {\n          return;\n        }\n      }\n\n      _this._checkSelected(e);\n    };\n\n    _this._onDragEnd = function (e) {\n      var data = e.data,\n          inputEvent = e.inputEvent;\n      var rect = getRect(e, _this.options.ratio);\n      var selectFlag = data.selectFlag;\n      var container = _this.container;\n      /**\n       * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n       * @memberof Selecto\n       * @event dragEnd\n       * @param {OnDragEnd} - Parameters for the dragEnd event\n       */\n\n      if (inputEvent) {\n        _this.emit(\"dragEnd\", __assign(__assign({\n          isDouble: !!e.isDouble,\n          isClick: !!e.isClick,\n          isDrag: false,\n          isSelect: selectFlag\n        }, e), {\n          data: data.data,\n          rect: rect\n        }));\n      }\n\n      _this.target.style.cssText += \"display: none;\";\n\n      if (selectFlag) {\n        data.selectFlag = false;\n\n        _this.dragScroll.dragEnd();\n      } else if (_this.selectByClick && _this.clickBySelectEnd) {\n        // only clickBySelectEnd\n        var pointTarget = _this._findElement((inputEvent === null || inputEvent === void 0 ? void 0 : inputEvent.target) || elementFromPoint(container, e.clientX, e.clientY), data.selectableTargets);\n\n        _this._select(pointTarget ? [pointTarget] : [], rect, e);\n      }\n\n      if (!data.preventDragFromInside) {\n        _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, rect, e);\n      }\n    };\n\n    _this._onKeyDown = function (e) {\n      var options = _this.options;\n      var isKeyDown = false;\n\n      if (!_this._keydownContinueSelect) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelect);\n\n        _this._keydownContinueSelect = result;\n        isKeyDown || (isKeyDown = result);\n      }\n\n      if (!_this._keydownContinueSelectWithoutDeselection) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect);\n\n        _this._keydownContinueSelectWithoutDeselection = result;\n        isKeyDown || (isKeyDown = result);\n      }\n\n      if (!isKeyDown) {\n        return;\n      }\n      /**\n       * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.\n       * @memberof Selecto\n       * @event keydown\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   toggleContinueSelect: \"shift\";\n       *   keyContainer: window,\n       * });\n       *\n       * selecto.on(\"keydown\", () => {\n       *   document.querySelector(\".button\").classList.add(\"selected\");\n       * }).on(\"keyup\", () => {\n       *   document.querySelector(\".button\").classList.remove(\"selected\");\n       * }).on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n\n\n      _this.emit(\"keydown\", {\n        keydownContinueSelect: _this._keydownContinueSelect,\n        keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection\n      });\n    };\n\n    _this._onKeyUp = function (e) {\n      var options = _this.options;\n      var isKeyUp = false;\n\n      if (_this._keydownContinueSelect) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelect, true);\n\n        _this._keydownContinueSelect = !result;\n        isKeyUp || (isKeyUp = result);\n      }\n\n      if (_this._keydownContinueSelectWithoutDeselection) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect, true);\n\n        _this._keydownContinueSelectWithoutDeselection = !result;\n        isKeyUp || (isKeyUp = result);\n      }\n\n      if (!isKeyUp) {\n        return;\n      }\n      /**\n       * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.\n       * @memberof Selecto\n       * @event keyup\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   toggleContinueSelect: \"shift\";\n       *   keyContainer: window,\n       * });\n       *\n       * selecto.on(\"keydown\", () => {\n       *   document.querySelector(\".button\").classList.add(\"selected\");\n       * }).on(\"keyup\", () => {\n       *   document.querySelector(\".button\").classList.remove(\"selected\");\n       * }).on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n\n\n      _this.emit(\"keyup\", {\n        keydownContinueSelect: _this._keydownContinueSelect,\n        keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection\n      });\n    };\n\n    _this._onBlur = function () {\n      if (_this._keydownContinueSelect || _this._keydownContinueSelectWithoutDeselection) {\n        _this._keydownContinueSelect = false;\n        _this._keydownContinueSelectWithoutDeselection = false;\n\n        _this.emit(\"keyup\", {\n          keydownContinueSelect: _this._keydownContinueSelect,\n          keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection\n        });\n      }\n    };\n\n    _this._onDocumentSelectStart = function (e) {\n      var doc = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(_this.container);\n\n      if (!_this.gesto.isFlag()) {\n        return;\n      }\n\n      var dragContainer = _this.dragContainer;\n\n      if (dragContainer === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(_this.container)) {\n        dragContainer = doc.documentElement;\n      }\n\n      var containers = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)(dragContainer) ? [dragContainer] : [].slice.call(dragContainer);\n      var target = e.target;\n      containers.some(function (container) {\n        if (container === target || container.contains(target)) {\n          e.preventDefault();\n          return true;\n        }\n      });\n    };\n\n    _this.target = options.portalContainer;\n    var container = options.container;\n    _this.options = __assign({\n      className: \"\",\n      portalContainer: null,\n      container: null,\n      dragContainer: null,\n      selectableTargets: [],\n      selectByClick: true,\n      selectFromInside: true,\n      clickBySelectEnd: false,\n      hitRate: 100,\n      continueSelect: false,\n      continueSelectWithoutDeselect: false,\n      toggleContinueSelect: null,\n      toggleContinueSelectWithoutDeselect: null,\n      keyContainer: null,\n      scrollOptions: null,\n      checkInput: false,\n      preventDefault: false,\n      boundContainer: false,\n      preventDragFromInside: true,\n      dragCondition: null,\n      rootContainer: null,\n      checkOverflow: false,\n      innerScrollOptions: false,\n      getElementRect: getDefaultElementRect,\n      cspNonce: \"\",\n      ratio: 0\n    }, options);\n    var portalContainer = _this.options.portalContainer;\n\n    if (portalContainer) {\n      container = portalContainer.parentElement;\n    }\n\n    _this.container = container || document.body;\n\n    _this.initElement();\n\n    _this.initDragScroll();\n\n    _this.setKeyController();\n\n    return _this;\n  }\n  /**\n   * You can set the currently selected targets.\n   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n   */\n\n\n  var __proto = Selecto.prototype;\n\n  __proto.setSelectedTargets = function (selectedTargets) {\n    var beforeSelected = this.selectedTargets;\n\n    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(beforeSelected, selectedTargets),\n        added = _a.added,\n        removed = _a.removed,\n        prevList = _a.prevList,\n        list = _a.list;\n\n    this.selectedTargets = selectedTargets;\n    return {\n      added: added.map(function (index) {\n        return list[index];\n      }),\n      removed: removed.map(function (index) {\n        return prevList[index];\n      }),\n      beforeSelected: beforeSelected,\n      selected: selectedTargets\n    };\n  };\n  /**\n   * You can set the currently selected targets by points\n   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n   */\n\n\n  __proto.setSelectedTargetsByPoints = function (point1, point2) {\n    var left = Math.min(point1[0], point2[0]);\n    var top = Math.min(point1[1], point2[1]);\n    var right = Math.max(point1[0], point2[0]);\n    var bottom = Math.max(point1[1], point2[1]);\n    var rect = {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: right - left,\n      height: bottom - top\n    };\n    var data = {\n      ignoreClick: true\n    };\n    this.findSelectableTargets(data);\n    var selectedElements = this.hitTest(rect, data, true, null);\n    var result = this.setSelectedTargets(selectedElements);\n    return __assign(__assign({}, result), {\n      rect: rect\n    });\n  };\n  /**\n   * Select target by virtual drag from startPoint to endPoint.\n   * The target of inputEvent is null.\n   */\n\n\n  __proto.selectTargetsByPoints = function (startPoint, endPoint) {\n    var mousedown = new MouseEvent(\"mousedown\", {\n      clientX: startPoint[0],\n      clientY: startPoint[1],\n      cancelable: true,\n      bubbles: true\n    });\n    var mousemove = new MouseEvent(\"mousemove\", {\n      clientX: endPoint[0],\n      clientY: endPoint[1],\n      cancelable: true,\n      bubbles: true\n    });\n    var mouseup = new MouseEvent(\"mousemove\", {\n      clientX: endPoint[0],\n      clientY: endPoint[1],\n      cancelable: true,\n      bubbles: true\n    });\n    var gesto = this.gesto;\n    var result = gesto.onDragStart(mousedown);\n\n    if (result !== false) {\n      gesto.onDrag(mousemove);\n      gesto.onDragEnd(mouseup);\n    }\n  };\n  /**\n   * You can get the currently selected targets.\n   */\n\n\n  __proto.getSelectedTargets = function () {\n    return this.selectedTargets;\n  };\n  /**\n   * `OnDragStart` is triggered by an external event.\n   * @param - external event\n   * @example\n   * import Selecto from \"selecto\";\n   *\n   * const selecto = new Selecto();\n   *\n   * window.addEventListener(\"mousedown\", e => {\n   *   selecto.triggerDragStart(e);\n   * });\n   */\n\n\n  __proto.triggerDragStart = function (e) {\n    this.gesto.triggerDragStart(e);\n    return this;\n  };\n  /**\n   * Destroy elements, properties, and events.\n   */\n\n\n  __proto.destroy = function () {\n    var _a;\n\n    this.off();\n    this.keycon && this.keycon.destroy();\n    this.gesto.unset();\n    this.injectResult.destroy();\n    this.dragScroll.dragEnd();\n    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.removeEvent)(document, \"selectstart\", this._onDocumentSelectStart);\n\n    if (!this.options.portalContainer) {\n      (_a = this.target.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.target);\n    }\n\n    this.keycon = null;\n    this.gesto = null;\n    this.injectResult = null;\n    this.target = null;\n    this.container = null;\n    this.options = null;\n  };\n\n  __proto.getElementPoints = function (target) {\n    var getElementRect = this.getElementRect || getDefaultElementRect;\n    var info = getElementRect(target);\n    var points = [info.pos1, info.pos2, info.pos4, info.pos3];\n\n    if (getElementRect !== getDefaultElementRect) {\n      var rect = target.getBoundingClientRect();\n      return (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.fitPoints)(points, rect);\n    }\n\n    return points;\n  };\n  /**\n   * Get all elements set in `selectableTargets`.\n   */\n\n\n  __proto.getSelectableElements = function () {\n    var container = this.container;\n    var selectableElements = [];\n    this.options.selectableTargets.forEach(function (target) {\n      if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) {\n        var result = target();\n\n        if (result) {\n          selectableElements.push.apply(selectableElements, [].slice.call(result));\n        }\n      } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)(target)) {\n        selectableElements.push(target);\n      } else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {\n        selectableElements.push(target.value || target.current);\n      } else {\n        var elements = [].slice.call((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).querySelectorAll(target));\n        selectableElements.push.apply(selectableElements, elements);\n      }\n    });\n    return selectableElements;\n  };\n  /**\n   * If scroll occurs during dragging, you can manually call this method to check the position again.\n   */\n\n\n  __proto.checkScroll = function () {\n    if (!this.gesto.isFlag()) {\n      return;\n    }\n\n    var scrollOptions = this.scrollOptions;\n    var innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n    var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container); // If it is a scrolling position, pass drag\n\n    if (hasScrollOptions) {\n      this.dragScroll.checkScroll(__assign({\n        inputEvent: this.gesto.getCurrentEvent()\n      }, innerScrollOptions || scrollOptions));\n    }\n  };\n  /**\n   * Find for selectableTargets again during drag event\n   * You can update selectable targets during an event.\n   */\n\n\n  __proto.findSelectableTargets = function (data) {\n    var _this = this;\n\n    if (data === void 0) {\n      data = this.gesto.getEventData();\n    }\n\n    var selectableTargets = this.getSelectableElements();\n    var selectablePoints = selectableTargets.map(function (target) {\n      return _this.getElementPoints(target);\n    });\n    data.selectableTargets = selectableTargets;\n    data.selectablePoints = selectablePoints;\n    data.selectableParentMap = null;\n    var options = this.options;\n    var hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n    var doc = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(this.container);\n\n    if (hasIndexesMap) {\n      var parentMap_1 = new Map();\n      data.selectableInnerScrollParentMap = parentMap_1;\n      data.selectableInnerScrollPathsList = selectableTargets.map(function (target, index) {\n        var parentElement = target.parentElement;\n        var parents = [];\n        var paths = [];\n\n        var _loop_1 = function () {\n          var info = parentMap_1.get(parentElement);\n\n          if (!info) {\n            var overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n            if (overflow) {\n              var rect = getDefaultElementRect(parentElement);\n              info = {\n                parentElement: parentElement,\n                indexes: [],\n                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                paths: __spreadArray([], paths, true)\n              };\n              parents.push(parentElement);\n              parents.forEach(function (prevParentElement) {\n                parentMap_1.set(prevParentElement, info);\n              });\n              parents = [];\n            }\n          }\n\n          if (info) {\n            parentElement = info.parentElement;\n            parentMap_1.get(parentElement).indexes.push(index);\n            paths.push(parentElement);\n          } else {\n            parents.push(parentElement);\n          }\n\n          parentElement = parentElement.parentElement;\n        };\n\n        while (parentElement && parentElement !== doc.body) {\n          _loop_1();\n        }\n\n        return paths;\n      });\n    }\n\n    if (!options.checkOverflow) {\n      data.selectableInners = selectableTargets.map(function () {\n        return true;\n      });\n    }\n\n    this._refreshGroups(data);\n\n    return selectableTargets;\n  };\n  /**\n   * External click or mouse events can be applied to the selecto.\n   * @params - Extenal click or mouse event\n   * @params - Specify the clicked target directly.\n   */\n\n\n  __proto.clickTarget = function (e, clickedTarget) {\n    var _a = getClient(e),\n        clientX = _a.clientX,\n        clientY = _a.clientY;\n\n    var dragEvent = {\n      data: {\n        selectFlag: false\n      },\n      clientX: clientX,\n      clientY: clientY,\n      inputEvent: e,\n      isClick: true,\n      isTrusted: false,\n      stop: function () {\n        return false;\n      }\n    };\n\n    if (this._onDragStart(dragEvent, clickedTarget)) {\n      this._onDragEnd(dragEvent);\n    }\n\n    return this;\n  };\n\n  __proto.setKeyController = function () {\n    var _a = this.options,\n        keyContainer = _a.keyContainer,\n        toggleContinueSelect = _a.toggleContinueSelect,\n        toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n\n    if (this.keycon) {\n      this.keycon.destroy();\n      this.keycon = null;\n    }\n\n    if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {\n      this.keycon = new keycon__WEBPACK_IMPORTED_MODULE_6__[\"default\"](keyContainer || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(this.container));\n      this.keycon.keydown(this._onKeyDown).keyup(this._onKeyUp).on(\"blur\", this._onBlur);\n    }\n  };\n\n  __proto.setClassName = function (nextClassName) {\n    this.options.className = nextClassName;\n    this.target.setAttribute(\"class\", \"\".concat(CLASS_NAME, \" \").concat(nextClassName || \"\"));\n  };\n\n  __proto.setKeyEvent = function () {\n    var _a = this.options,\n        toggleContinueSelect = _a.toggleContinueSelect,\n        toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n\n    if (!toggleContinueSelect && !toggleContinueSelectWithoutDeselect || this.keycon) {\n      return;\n    }\n\n    this.setKeyController();\n  }; // with getter, setter property\n\n\n  __proto.setKeyContainer = function (keyContainer) {\n    var _this = this;\n\n    var options = this.options;\n    diffValue(options.keyContainer, keyContainer, function () {\n      options.keyContainer = keyContainer;\n\n      _this.setKeyController();\n    });\n  };\n\n  __proto.getContinueSelect = function () {\n    var _a = this.options,\n        continueSelect = _a.continueSelect,\n        toggleContinueSelect = _a.toggleContinueSelect;\n\n    if (!toggleContinueSelect || !this._keydownContinueSelect) {\n      return continueSelect;\n    }\n\n    return !continueSelect;\n  };\n\n  __proto.getContinueSelectWithoutDeselect = function () {\n    var _a = this.options,\n        continueSelectWithoutDeselect = _a.continueSelectWithoutDeselect,\n        toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n\n    if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {\n      return continueSelectWithoutDeselect;\n    }\n\n    return !continueSelectWithoutDeselect;\n  };\n\n  __proto.setToggleContinueSelect = function (toggleContinueSelect) {\n    var _this = this;\n\n    var options = this.options;\n    diffValue(options.toggleContinueSelect, toggleContinueSelect, function () {\n      options.toggleContinueSelect = toggleContinueSelect;\n\n      _this.setKeyEvent();\n    });\n  };\n\n  __proto.setToggleContinueSelectWithoutDeselect = function (toggleContinueSelectWithoutDeselect) {\n    var _this = this;\n\n    var options = this.options;\n    diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, function () {\n      options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;\n\n      _this.setKeyEvent();\n    });\n  };\n\n  __proto.setPreventDefault = function (value) {\n    this.gesto.options.preventDefault = value;\n  };\n\n  __proto.setCheckInput = function (value) {\n    this.gesto.options.checkInput = value;\n  };\n\n  __proto.initElement = function () {\n    var _a = this.options,\n        dragContainer = _a.dragContainer,\n        checkInput = _a.checkInput,\n        preventDefault = _a.preventDefault,\n        preventClickEventOnDragStart = _a.preventClickEventOnDragStart,\n        preventClickEventOnDrag = _a.preventClickEventOnDrag,\n        preventClickEventByCondition = _a.preventClickEventByCondition,\n        _b = _a.preventRightClick,\n        preventRightClick = _b === void 0 ? true : _b,\n        className = _a.className;\n    var container = this.container;\n    this.target = createElement(h(\"div\", {\n      className: \"\".concat(CLASS_NAME, \" \").concat(className || \"\")\n    }), this.target, container);\n    var target = this.target;\n    this.dragContainer = typeof dragContainer === \"string\" ? [].slice.call((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(container).querySelectorAll(dragContainer)) : dragContainer || this.target.parentNode;\n    this.gesto = new gesto__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.dragContainer, {\n      checkWindowBlur: true,\n      container: (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)(container),\n      checkInput: checkInput,\n      preventDefault: preventDefault,\n      preventClickEventOnDragStart: preventClickEventOnDragStart,\n      preventClickEventOnDrag: preventClickEventOnDrag,\n      preventClickEventByCondition: preventClickEventByCondition,\n      preventRightClick: preventRightClick\n    }).on({\n      dragStart: this._onDragStart,\n      drag: this._onDrag,\n      dragEnd: this._onDragEnd\n    });\n    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.addEvent)(document, \"selectstart\", this._onDocumentSelectStart);\n    this.injectResult = injector.inject(target, {\n      nonce: this.options.cspNonce\n    });\n  };\n\n  __proto.hitTest = function (selectRect, data, isDrag, gestoEvent) {\n    var _a = this.options,\n        hitRate = _a.hitRate,\n        selectByClick = _a.selectByClick;\n    var left = selectRect.left,\n        top = selectRect.top,\n        right = selectRect.right,\n        bottom = selectRect.bottom;\n    var innerGroups = data.innerGroups;\n    var innerWidth = data.innerWidth;\n    var innerHeight = data.innerHeight;\n    var clientX = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientX;\n    var clientY = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientY;\n    var ignoreClick = data.ignoreClick;\n    var rectPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];\n\n    var isHit = function (points, el) {\n      var hitRateValue = typeof hitRate === \"function\" ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(\"\".concat(hitRate(el))) : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.splitUnit)(\"\".concat(hitRate));\n      var inArea = ignoreClick ? false : (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.isInside)([clientX, clientY], points);\n\n      if (!isDrag && selectByClick && inArea) {\n        return true;\n      }\n\n      var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(rectPoints, points);\n\n      if (!overlapPoints.length) {\n        return false;\n      }\n\n      var overlapSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(overlapPoints); // Line\n\n      var targetSize = 0;\n\n      if (overlapSize === 0 && (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points) === 0) {\n        targetSize = getLineSize(points);\n        overlapSize = getLineSize(overlapPoints);\n      } else {\n        targetSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getAreaSize)(points);\n      }\n\n      if (hitRateValue.unit === \"px\") {\n        return overlapSize >= hitRateValue.value;\n      } else {\n        var rate = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.between)(Math.round(overlapSize / targetSize * 100), 0, 100);\n        return rate >= Math.min(100, hitRateValue.value);\n      }\n    };\n\n    var selectableTargets = data.selectableTargets;\n    var selectablePoints = data.selectablePoints;\n    var selectableInners = data.selectableInners;\n\n    if (!innerGroups) {\n      return selectableTargets.filter(function (_, i) {\n        if (!selectableInners[i]) {\n          return false;\n        }\n\n        return isHit(selectablePoints[i], selectableTargets[i]);\n      });\n    }\n\n    var selectedTargets = [];\n    var minX = Math.floor(left / innerWidth);\n    var maxX = Math.floor(right / innerWidth);\n    var minY = Math.floor(top / innerHeight);\n    var maxY = Math.floor(bottom / innerHeight);\n\n    for (var x = minX; x <= maxX; ++x) {\n      var yGroups = innerGroups[x];\n\n      if (!yGroups) {\n        continue;\n      }\n\n      for (var y = minY; y <= maxY; ++y) {\n        var group = yGroups[y];\n\n        if (!group) {\n          continue;\n        }\n\n        group.forEach(function (index) {\n          var points = selectablePoints[index];\n          var inner = selectableInners[index];\n          var target = selectableTargets[index];\n\n          if (inner && isHit(points, target)) {\n            selectedTargets.push(target);\n          }\n        });\n      }\n    }\n\n    return filterDuplicated(selectedTargets);\n  };\n\n  __proto.initDragScroll = function () {\n    var _this = this;\n\n    this.dragScroll.on(\"scrollDrag\", function (_a) {\n      var next = _a.next;\n      next(_this.gesto.getCurrentEvent());\n    }).on(\"scroll\", function (_a) {\n      var container = _a.container,\n          direction = _a.direction;\n\n      var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;\n\n      if (innerScrollOptions) {\n        _this.emit(\"innerScroll\", {\n          container: container,\n          direction: direction\n        });\n      } else {\n        _this.emit(\"scroll\", {\n          container: container,\n          direction: direction\n        });\n      }\n    }).on(\"move\", function (_a) {\n      var offsetX = _a.offsetX,\n          offsetY = _a.offsetY,\n          inputEvent = _a.inputEvent;\n      var gesto = _this.gesto;\n\n      if (!gesto || !gesto.isFlag()) {\n        return;\n      }\n\n      var data = _this.gesto.getEventData();\n\n      var boundArea = data.boundArea;\n      data.startX -= offsetX;\n      data.startY -= offsetY;\n\n      var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;\n\n      var container = innerScrollOptions === null || innerScrollOptions === void 0 ? void 0 : innerScrollOptions.container;\n      var isMoveInnerScroll = false;\n\n      if (container) {\n        var parentMap_2 = data.selectableInnerScrollParentMap;\n        var parentInfo = parentMap_2.get(container);\n\n        if (parentInfo) {\n          parentInfo.paths.forEach(function (scrollContainer) {\n            var containerInfo = parentMap_2.get(scrollContainer);\n            containerInfo.points.forEach(function (pos) {\n              pos[0] -= offsetX;\n              pos[1] -= offsetY;\n            });\n          });\n          parentInfo.indexes.forEach(function (index) {\n            data.selectablePoints[index].forEach(function (pos) {\n              pos[0] -= offsetX;\n              pos[1] -= offsetY;\n            });\n          });\n          isMoveInnerScroll = true;\n        }\n      }\n\n      if (!isMoveInnerScroll) {\n        data.selectablePoints.forEach(function (points) {\n          points.forEach(function (pos) {\n            pos[0] -= offsetX;\n            pos[1] -= offsetY;\n          });\n        });\n      }\n\n      _this._refreshGroups(data);\n\n      boundArea.left -= offsetX;\n      boundArea.right -= offsetX;\n      boundArea.top -= offsetY;\n      boundArea.bottom -= offsetY;\n\n      _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent);\n\n      _this._checkSelected(_this.gesto.getCurrentEvent());\n    });\n  };\n\n  __proto._select = function (selectedTargets, rect, e, isStart, isDragStartEnd) {\n    if (isDragStartEnd === void 0) {\n      isDragStartEnd = false;\n    }\n\n    var inputEvent = e.inputEvent;\n    var data = e.data;\n    var result = this.setSelectedTargets(selectedTargets);\n\n    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(data.startSelectedTargets, selectedTargets),\n        added = _a.added,\n        removed = _a.removed,\n        prevList = _a.prevList,\n        list = _a.list;\n\n    var startResult = {\n      startSelected: prevList,\n      startAdded: added.map(function (i) {\n        return list[i];\n      }),\n      startRemoved: removed.map(function (i) {\n        return prevList[i];\n      })\n    };\n\n    if (isStart) {\n      /**\n       * When the select(drag) starts, the selectStart event is called.\n       * @memberof Selecto\n       * @event selectStart\n       * @param {Selecto.OnSelect} - Parameters for the selectStart event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"selectStart\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * }).on(\"selectEnd\", e => {\n       *   e.afterAdded.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.afterRemoved.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n      this.emit(\"selectStart\", __assign(__assign(__assign({}, result), startResult), {\n        rect: rect,\n        inputEvent: inputEvent,\n        data: data.data,\n        isTrusted: e.isTrusted,\n        isDragStartEnd: isDragStartEnd\n      }));\n    }\n\n    if (result.added.length || result.removed.length) {\n      /**\n       * When the select in real time, the select event is called.\n       * @memberof Selecto\n       * @event select\n       * @param {Selecto.OnSelect} - Parameters for the select event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n      this.emit(\"select\", __assign(__assign(__assign({}, result), startResult), {\n        rect: rect,\n        inputEvent: inputEvent,\n        data: data.data,\n        isTrusted: e.isTrusted,\n        isDragStartEnd: isDragStartEnd\n      }));\n    }\n  };\n\n  __proto._selectEnd = function (startSelectedTargets, startPassedTargets, rect, e, isDragStartEnd) {\n    if (isDragStartEnd === void 0) {\n      isDragStartEnd = false;\n    }\n\n    var inputEvent = e.inputEvent,\n        isDouble = e.isDouble,\n        data = e.data;\n    var type = inputEvent && inputEvent.type;\n    var isDragStart = type === \"mousedown\" || type === \"touchstart\";\n\n    var _a = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startSelectedTargets, this.selectedTargets),\n        added = _a.added,\n        removed = _a.removed,\n        prevList = _a.prevList,\n        list = _a.list;\n\n    var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_1__.diff)(startPassedTargets, this.selectedTargets),\n        afterAdded = _b.added,\n        afterRemoved = _b.removed,\n        afterPrevList = _b.prevList,\n        afterList = _b.list;\n    /**\n     * When the select(dragEnd or click) ends, the selectEnd event is called.\n     * @memberof Selecto\n     * @event selectEnd\n     * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"selectStart\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * }).on(\"selectEnd\", e => {\n     *   e.afterAdded.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.afterRemoved.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n\n\n    this.emit(\"selectEnd\", {\n      startSelected: startSelectedTargets,\n      beforeSelected: startPassedTargets,\n      selected: this.selectedTargets,\n      added: added.map(function (index) {\n        return list[index];\n      }),\n      removed: removed.map(function (index) {\n        return prevList[index];\n      }),\n      afterAdded: afterAdded.map(function (index) {\n        return afterList[index];\n      }),\n      afterRemoved: afterRemoved.map(function (index) {\n        return afterPrevList[index];\n      }),\n      isDragStart: isDragStart && isDragStartEnd,\n      isDragStartEnd: isDragStart && isDragStartEnd,\n      isClick: !!e.isClick,\n      isDouble: !!isDouble,\n      rect: rect,\n      inputEvent: inputEvent,\n      data: data.data,\n      isTrusted: e.isTrusted\n    });\n  };\n\n  __proto._checkSelected = function (e, rect) {\n    if (rect === void 0) {\n      rect = getRect(e, this.options.ratio);\n    }\n\n    var data = e.data;\n    var top = rect.top,\n        left = rect.left,\n        width = rect.width,\n        height = rect.height;\n    var selectFlag = data.selectFlag;\n    var containerX = data.containerX,\n        containerY = data.containerY,\n        scaleMatrix = data.scaleMatrix;\n    var offsetPos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [left - containerX, top - containerY]);\n    var offsetSize = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(scaleMatrix, [width, height]);\n    var selectedTargets = [];\n\n    if (selectFlag) {\n      this.target.style.cssText += \"display: block;\" + \"left:0px;top:0px;\" + \"transform: translate(\".concat(offsetPos[0], \"px, \").concat(offsetPos[1], \"px);\") + \"width:\".concat(offsetSize[0], \"px;height:\").concat(offsetSize[1], \"px;\");\n      var passedTargets = this.hitTest(rect, data, true, e);\n      selectedTargets = passTargets(data.startPassedTargets, passedTargets, this.continueSelect && this.continueSelectWithoutDeselect);\n    }\n    /**\n     * When the drag, the drag event is called.\n     * Call the stop () function if you have a specific element or don't want to raise a select\n     * @memberof Selecto\n     * @event drag\n     * @param {OnDrag} - Parameters for the drag event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"drag\", e => {\n     *   e.stop();\n     * }).on(\"select\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n\n\n    var result = this.emit(\"drag\", __assign(__assign({}, e), {\n      data: data.data,\n      isSelect: selectFlag,\n      rect: rect\n    }));\n\n    if (result === false) {\n      this.target.style.cssText += \"display: none;\";\n      e.stop();\n      return;\n    }\n\n    if (selectFlag) {\n      this._select(selectedTargets, rect, e);\n    }\n  };\n\n  __proto._sameCombiKey = function (e, keys, isKeyup) {\n    if (!keys) {\n      return false;\n    }\n\n    var combi = (0,keycon__WEBPACK_IMPORTED_MODULE_6__.getCombi)(e.inputEvent, e.key);\n    var nextKeys = [].concat(keys);\n    var toggleKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(nextKeys[0]) ? nextKeys : [nextKeys];\n\n    if (isKeyup) {\n      var singleKey_1 = e.key;\n      return toggleKeys.some(function (keys) {\n        return keys.some(function (key) {\n          return key === singleKey_1;\n        });\n      });\n    }\n\n    return toggleKeys.some(function (keys) {\n      return keys.every(function (key) {\n        return combi.indexOf(key) > -1;\n      });\n    });\n  };\n\n  __proto._findElement = function (clickedTarget, selectableTargets) {\n    var pointTarget = clickedTarget;\n\n    while (pointTarget) {\n      if (selectableTargets.indexOf(pointTarget) > -1) {\n        break;\n      }\n\n      pointTarget = pointTarget.parentElement;\n    }\n\n    return pointTarget;\n  };\n\n  __proto._refreshGroups = function (data) {\n    var _a;\n\n    var innerWidth = data.innerWidth;\n    var innerHeight = data.innerHeight;\n    var selectablePoints = data.selectablePoints;\n\n    if (this.options.checkOverflow) {\n      var innerScrollContainer_1 = (_a = this.gesto.getEventData().innerScrollOptions) === null || _a === void 0 ? void 0 : _a.container;\n      var parentMap_3 = data.selectableInnerScrollParentMap;\n      var innerScrollPathsList = data.selectableInnerScrollPathsList;\n      data.selectableInners = innerScrollPathsList.map(function (innerScrollPaths, i) {\n        var isAlwaysTrue = false;\n        return innerScrollPaths.every(function (target) {\n          if (isAlwaysTrue) {\n            return true;\n          }\n\n          if (target === innerScrollContainer_1) {\n            isAlwaysTrue = true;\n            return true;\n          }\n\n          var rect = parentMap_3.get(target);\n\n          if (rect) {\n            var points1 = selectablePoints[i];\n            var points2 = rect.points;\n            var overlapPoints = (0,overlap_area__WEBPACK_IMPORTED_MODULE_5__.getOverlapPoints)(points1, points2);\n\n            if (!overlapPoints.length) {\n              return false;\n            }\n          }\n\n          return true;\n        });\n      });\n    }\n\n    if (!innerWidth || !innerHeight) {\n      data.innerGroups = null;\n    } else {\n      var selectablePoints_1 = data.selectablePoints;\n      var groups_1 = {};\n      selectablePoints_1.forEach(function (points, i) {\n        var minX = Infinity;\n        var maxX = -Infinity;\n        var minY = Infinity;\n        var maxY = -Infinity;\n        points.forEach(function (pos) {\n          var x = Math.floor(pos[0] / innerWidth);\n          var y = Math.floor(pos[1] / innerHeight);\n          minX = Math.min(x, minX);\n          maxX = Math.max(x, maxX);\n          minY = Math.min(y, minY);\n          maxY = Math.max(y, maxY);\n        });\n\n        for (var x = minX; x <= maxX; ++x) {\n          for (var y = minY; y <= maxY; ++y) {\n            groups_1[x] = groups_1[x] || {};\n            groups_1[x][y] = groups_1[x][y] || [];\n            groups_1[x][y].push(i);\n          }\n        }\n      });\n      data.innerGroups = groups_1;\n    }\n  };\n\n  Selecto = __decorate([(0,framework_utils__WEBPACK_IMPORTED_MODULE_8__.Properties)(PROPERTIES, function (prototype, property) {\n    var attributes = {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return this.options[property];\n      }\n    };\n    var getter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)(\"get \".concat(property));\n\n    if (prototype[getter]) {\n      attributes.get = function () {\n        return this[getter]();\n      };\n    } else {\n      attributes.get = function () {\n        return this.options[property];\n      };\n    }\n\n    var setter = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_0__.camelize)(\"set \".concat(property));\n\n    if (prototype[setter]) {\n      attributes.set = function (value) {\n        this[setter](value);\n      };\n    } else {\n      attributes.set = function (value) {\n        this.options[property] = value;\n      };\n    }\n\n    Object.defineProperty(prototype, property, attributes);\n  })], Selecto);\n  return Selecto;\n}(_scena_event_emitter__WEBPACK_IMPORTED_MODULE_9__[\"default\"]);\n\nvar Selecto$1 =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Selecto, _super);\n\n  function Selecto() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return Selecto;\n}(Selecto);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Selecto$1);\n\n//# sourceMappingURL=selecto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VsZWN0by9kaXN0L3NlbGVjdG8uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUN0QjtBQUNtQjtBQUNtSztBQUNuSztBQUNGO0FBQ007QUFDaUM7QUFDRztBQUNyRDs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0SEFBNEgsY0FBYztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLHlDQUF5QyxRQUFRO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSw0REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFXOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsMkJBQTJCLFdBQVc7QUFDdEMsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDJEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFROztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIseURBQVE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLDREQUFZOztBQUVkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsU0FBUyxFQUFDO0FBQ2lEO0FBQzFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi8uL25vZGVfbW9kdWxlcy9zZWxlY3RvL2Rpc3Qvc2VsZWN0by5lc20uanM/YTU5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDIwIERheWJydXNoXG5uYW1lOiBzZWxlY3RvXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vZGF5YnJ1c2gvc2VsZWN0by5naXRcbnZlcnNpb246IDEuMjYuM1xuKi9cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IEdlc3RvIGZyb20gJ2dlc3RvJztcbmltcG9ydCB7IFByb3BlcnRpZXMgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQsIGhhc0NsYXNzLCBhZGRDbGFzcywgY2FsY3VsYXRlQm91bmRTaXplLCBnZXREaXN0LCBnZXRXaW5kb3csIGlzT2JqZWN0LCBpc1N0cmluZywgaXNOb2RlLCByZW1vdmVFdmVudCwgaXNGdW5jdGlvbiwgYWRkRXZlbnQsIGlzQXJyYXksIGNhbWVsaXplLCBzcGxpdFVuaXQsIGJldHdlZW4gfSBmcm9tICdAZGF5YnJ1c2gvdXRpbHMnO1xuaW1wb3J0IHsgZGlmZiB9IGZyb20gJ0BlZ2pzL2NoaWxkcmVuLWRpZmZlcic7XG5pbXBvcnQgRHJhZ1Njcm9sbCBmcm9tICdAc2NlbmEvZHJhZ3Njcm9sbCc7XG5pbXBvcnQgS2V5Q29udHJvbGxlciwgeyBnZXRDb21iaSB9IGZyb20gJ2tleWNvbic7XG5pbXBvcnQgeyBmaXRQb2ludHMsIGdldE92ZXJsYXBQb2ludHMsIGlzSW5zaWRlLCBnZXRBcmVhU2l6ZSB9IGZyb20gJ292ZXJsYXAtYXJlYSc7XG5pbXBvcnQgeyBjcmVhdGVNYXRyaXgsIGdldERpc3RFbGVtZW50TWF0cml4LCBjYWxjdWxhdGVNYXRyaXhEaXN0IH0gZnJvbSAnY3NzLXRvLW1hdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ2Nzcy1zdHlsZWQnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuXG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcblxuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYyxcbiAgICAgIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50KGUpIHtcbiAgaWYgKFwidG91Y2hlc1wiIGluIGUpIHtcbiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF0gfHwgZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICBjbGllbnRZOiBlLmNsaWVudFlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJEdXBsaWNhdGVkKGFycikge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBhcnIuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKG1hcC5oYXModmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbWFwLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChiYXNlTm9kZSwgY2xpZW50WCwgY2xpZW50WSkge1xuICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQoYmFzZU5vZGUpO1xuICByZXR1cm4gZG9jLmVsZW1lbnRGcm9tUG9pbnQgJiYgZG9jLmVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoanN4LCBwcmV2VGFyZ2V0LCBjb250YWluZXIpIHtcbiAgdmFyIHRhZyA9IGpzeC50YWcsXG4gICAgICBjaGlsZHJlbiA9IGpzeC5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBqc3guYXR0cmlidXRlcyxcbiAgICAgIGNsYXNzTmFtZSA9IGpzeC5jbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IGpzeC5zdHlsZTtcbiAgdmFyIGVsID0gcHJldlRhcmdldCB8fCBnZXREb2N1bWVudChjb250YWluZXIpLmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICBmb3IgKHZhciBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlc1tuYW1lXSk7XG4gIH1cblxuICB2YXIgZWxDaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgIGNyZWF0ZUVsZW1lbnQoY2hpbGQsIGVsQ2hpbGRyZW5baV0sIGVsKTtcbiAgfSk7XG5cbiAgaWYgKGNsYXNzTmFtZSkge1xuICAgIGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSAmJiAhaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzdHlsZSkge1xuICAgIHZhciBlbFN0eWxlID0gZWwuc3R5bGU7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgICBlbFN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwcmV2VGFyZ2V0ICYmIGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBoKHRhZywgYXR0cnMpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHZhciBfYSA9IGF0dHJzIHx8IHt9LFxuICAgICAgX2IgPSBfYS5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLFxuICAgICAgX2MgPSBfYS5zdHlsZSxcbiAgICAgIHN0eWxlID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2MsXG4gICAgICBhdHRyaWJ1dGVzID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiXSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZyxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZWYWx1ZShwcmV2LCBjdXIsIGZ1bmMpIHtcbiAgaWYgKHByZXYgIT09IGN1cikge1xuICAgIGZ1bmMocHJldiwgY3VyKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVjdChlLCByYXRpbywgYm91bmRBcmVhKSB7XG4gIHZhciBfYTtcblxuICBpZiAoYm91bmRBcmVhID09PSB2b2lkIDApIHtcbiAgICBib3VuZEFyZWEgPSBlLmRhdGEuYm91bmRBcmVhO1xuICB9XG5cbiAgdmFyIF9iID0gZS5kaXN0WCxcbiAgICAgIGRpc3RYID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgIF9jID0gZS5kaXN0WSxcbiAgICAgIGRpc3RZID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYztcbiAgdmFyIF9kID0gZS5kYXRhLFxuICAgICAgc3RhcnRYID0gX2Quc3RhcnRYLFxuICAgICAgc3RhcnRZID0gX2Quc3RhcnRZO1xuXG4gIGlmIChyYXRpbyA+IDApIHtcbiAgICB2YXIgbmV4dEhlaWdodCA9IE1hdGguc3FydCgoZGlzdFggKiBkaXN0WCArIGRpc3RZICogZGlzdFkpIC8gKDEgKyByYXRpbyAqIHJhdGlvKSk7XG4gICAgdmFyIG5leHRXaWR0aCA9IHJhdGlvICogbmV4dEhlaWdodDtcbiAgICBkaXN0WCA9IChkaXN0WCA+PSAwID8gMSA6IC0xKSAqIG5leHRXaWR0aDtcbiAgICBkaXN0WSA9IChkaXN0WSA+PSAwID8gMSA6IC0xKSAqIG5leHRIZWlnaHQ7XG4gIH1cblxuICB2YXIgd2lkdGggPSBNYXRoLmFicyhkaXN0WCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLmFicyhkaXN0WSk7XG4gIHZhciBtYXhXaWR0aCA9IGRpc3RYIDwgMCA/IHN0YXJ0WCAtIGJvdW5kQXJlYS5sZWZ0IDogYm91bmRBcmVhLnJpZ2h0IC0gc3RhcnRYO1xuICB2YXIgbWF4SGVpZ2h0ID0gZGlzdFkgPCAwID8gc3RhcnRZIC0gYm91bmRBcmVhLnRvcCA6IGJvdW5kQXJlYS5ib3R0b20gLSBzdGFydFk7XG4gIF9hID0gY2FsY3VsYXRlQm91bmRTaXplKFt3aWR0aCwgaGVpZ2h0XSwgWzAsIDBdLCBbbWF4V2lkdGgsIG1heEhlaWdodF0sICEhcmF0aW8pLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgZGlzdFggPSAoZGlzdFggPj0gMCA/IDEgOiAtMSkgKiB3aWR0aDtcbiAgZGlzdFkgPSAoZGlzdFkgPj0gMCA/IDEgOiAtMSkgKiBoZWlnaHQ7XG4gIHZhciB0eCA9IE1hdGgubWluKDAsIGRpc3RYKTtcbiAgdmFyIHR5ID0gTWF0aC5taW4oMCwgZGlzdFkpO1xuICB2YXIgbGVmdCA9IHN0YXJ0WCArIHR4O1xuICB2YXIgdG9wID0gc3RhcnRZICsgdHk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCxcbiAgICB0b3A6IHRvcCxcbiAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEVsZW1lbnRSZWN0KGVsKSB7XG4gIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICBwb3MxOiBbbGVmdCwgdG9wXSxcbiAgICBwb3MyOiBbbGVmdCArIHdpZHRoLCB0b3BdLFxuICAgIHBvczM6IFtsZWZ0LCB0b3AgKyBoZWlnaHRdLFxuICAgIHBvczQ6IFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhc3NUYXJnZXRzKGJlZm9yZVRhcmdldHMsIGFmdGVyVGFyZ2V0cywgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QpIHtcbiAgdmFyIF9hID0gZGlmZihiZWZvcmVUYXJnZXRzLCBhZnRlclRhcmdldHMpLFxuICAgICAgbGlzdCA9IF9hLmxpc3QsXG4gICAgICBwcmV2TGlzdCA9IF9hLnByZXZMaXN0LFxuICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgbWFpbnRhaW5lZCA9IF9hLm1haW50YWluZWQ7XG5cbiAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RbaW5kZXhdO1xuICB9KSwgdHJ1ZSksIHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gIH0pLCB0cnVlKSwgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPyBtYWludGFpbmVkLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gX2FbMV07XG4gICAgcmV0dXJuIGxpc3RbbmV4dEluZGV4XTtcbiAgfSkgOiBbXSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lU2l6ZShwb2ludHMpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgc2l6ZSA9IE1hdGgubWF4KGdldERpc3QocG9pbnRzW2ldLCBwb2ludHNbaSAtIDFdKSwgc2l6ZSk7XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn1cblxudmFyIGluamVjdG9yID0gc3R5bGVkKFwiXFxuOmhvc3Qge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICM0YWY7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoNjgsIDE3MCwgMjU1LCAwLjUpO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG4gICAgei1pbmRleDogMTAwO1xcbn1cXG5cIik7XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIENMQVNTX05BTUUgPSBcInNlbGVjdG8tc2VsZWN0aW9uIFwiLmNvbmNhdChpbmplY3Rvci5jbGFzc05hbWUpO1xudmFyIFBST1BFUlRJRVMgPSBbXCJjbGFzc05hbWVcIiwgXCJib3VuZENvbnRhaW5lclwiLCBcInNlbGVjdGFibGVUYXJnZXRzXCIsIFwic2VsZWN0QnlDbGlja1wiLCBcInNlbGVjdEZyb21JbnNpZGVcIiwgXCJjb250aW51ZVNlbGVjdFwiLCBcImNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0XCIsIFwidG9nZ2xlQ29udGludWVTZWxlY3RcIiwgXCJ0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdFwiLCBcImtleUNvbnRhaW5lclwiLCBcImhpdFJhdGVcIiwgXCJzY3JvbGxPcHRpb25zXCIsIFwiY2hlY2tJbnB1dFwiLCBcInByZXZlbnREZWZhdWx0XCIsIFwicmF0aW9cIiwgXCJnZXRFbGVtZW50UmVjdFwiLCBcInByZXZlbnREcmFnRnJvbUluc2lkZVwiLCBcInJvb3RDb250YWluZXJcIiwgXCJkcmFnQ29uZGl0aW9uXCIsIFwiY2xpY2tCeVNlbGVjdEVuZFwiLCBcImNoZWNrT3ZlcmZsb3dcIiwgXCJpbm5lclNjcm9sbE9wdGlvbnNcIl07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIE9QVElPTlMgPSBfX3NwcmVhZEFycmF5KFsvLyBpZ25vcmUgdGFyZ2V0LCBjb250YWluZXIsXG5cImRyYWdDb250YWluZXJcIiwgXCJjc3BOb25jZVwiLCBcInByZXZlbnRDbGlja0V2ZW50T25EcmFnXCIsIFwicHJldmVudENsaWNrRXZlbnRPbkRyYWdTdGFydFwiLCBcInByZXZlbnRSaWdodENsaWNrXCJdLCBQUk9QRVJUSUVTLCB0cnVlKTtcbnZhciBPUFRJT05fVFlQRVMgPSB7XG4gIGNsYXNzTmFtZTogU3RyaW5nLFxuICBib3VuZENvbnRhaW5lcjogbnVsbCxcbiAgcG9ydGFsQ29udGFpbmVyOiBudWxsLFxuICBjb250YWluZXI6IG51bGwsXG4gIGRyYWdDb250YWluZXI6IG51bGwsXG4gIHNlbGVjdGFibGVUYXJnZXRzOiBBcnJheSxcbiAgc2VsZWN0QnlDbGljazogQm9vbGVhbixcbiAgc2VsZWN0RnJvbUluc2lkZTogQm9vbGVhbixcbiAgY29udGludWVTZWxlY3Q6IEJvb2xlYW4sXG4gIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBBcnJheSxcbiAgdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Q6IEFycmF5LFxuICBrZXlDb250YWluZXI6IG51bGwsXG4gIGhpdFJhdGU6IE51bWJlcixcbiAgc2Nyb2xsT3B0aW9uczogT2JqZWN0LFxuICBjaGVja0lucHV0OiBCb29sZWFuLFxuICBwcmV2ZW50RGVmYXVsdDogQm9vbGVhbixcbiAgY3NwTm9uY2U6IFN0cmluZyxcbiAgcmF0aW86IE51bWJlcixcbiAgZ2V0RWxlbWVudFJlY3Q6IEZ1bmN0aW9uLFxuICBwcmV2ZW50RHJhZ0Zyb21JbnNpZGU6IEJvb2xlYW4sXG4gIHJvb3RDb250YWluZXI6IE9iamVjdCxcbiAgZHJhZ0NvbmRpdGlvbjogRnVuY3Rpb24sXG4gIGNsaWNrQnlTZWxlY3RFbmQ6IEJvb2xlYW4sXG4gIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0OiBCb29sZWFuLFxuICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZ1N0YXJ0OiBCb29sZWFuLFxuICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogQm9vbGVhbixcbiAgY2hlY2tPdmVyZmxvdzogQm9vbGVhbixcbiAgaW5uZXJTY3JvbGxPcHRpb25zOiBPYmplY3Rcbn07XG4vKipcbiAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gKi9cblxudmFyIEVWRU5UUyA9IFtcImRyYWdTdGFydFwiLCBcImRyYWdcIiwgXCJkcmFnRW5kXCIsIFwic2VsZWN0U3RhcnRcIiwgXCJzZWxlY3RcIiwgXCJzZWxlY3RFbmRcIiwgXCJrZXlkb3duXCIsIFwia2V5dXBcIiwgXCJzY3JvbGxcIiwgXCJpbm5lclNjcm9sbFwiXTtcbi8qKlxuICogQG1lbWJlcm9mIFNlbGVjdG9cbiAqL1xuXG52YXIgTUVUSE9EUyA9IFtcImNsaWNrVGFyZ2V0XCIsIFwiZ2V0U2VsZWN0YWJsZUVsZW1lbnRzXCIsIFwic2V0U2VsZWN0ZWRUYXJnZXRzXCIsIFwiZ2V0RWxlbWVudFBvaW50c1wiLCBcImdldFNlbGVjdGVkVGFyZ2V0c1wiLCBcImZpbmRTZWxlY3RhYmxlVGFyZ2V0c1wiLCBcInRyaWdnZXJEcmFnU3RhcnRcIiwgXCJjaGVja1Njcm9sbFwiLCBcInNlbGVjdFRhcmdldHNCeVBvaW50c1wiLCBcInNldFNlbGVjdGVkVGFyZ2V0c0J5UG9pbnRzXCJdO1xuXG4vKipcbiAqIFNlbGVjdG8uanMgaXMgYSBjb21wb25lbnQgdGhhdCBhbGxvd3MgeW91IHRvIHNlbGVjdCBlbGVtZW50cyBpbiB0aGUgZHJhZyBhcmVhIHVzaW5nIHRoZSBtb3VzZSBvciB0b3VjaC5cbiAqIEBzb3J0IDFcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5cbnZhciBTZWxlY3RvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNlbGVjdG8sIF9zdXBlcik7XG4gIC8qKlxuICAgKlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFNlbGVjdG8ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc2VsZWN0ZWRUYXJnZXRzID0gW107XG4gICAgX3RoaXMuZHJhZ1Njcm9sbCA9IG5ldyBEcmFnU2Nyb2xsKCk7XG5cbiAgICBfdGhpcy5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSwgY2xpY2tlZFRhcmdldCkge1xuICAgICAgdmFyIGRhdGEgPSBlLmRhdGEsXG4gICAgICAgICAgY2xpZW50WCA9IGUuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gZS5jbGllbnRZLFxuICAgICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgICB2YXIgX2EgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHNlbGVjdEZyb21JbnNpZGUgPSBfYS5zZWxlY3RGcm9tSW5zaWRlLFxuICAgICAgICAgIHNlbGVjdEJ5Q2xpY2sgPSBfYS5zZWxlY3RCeUNsaWNrLFxuICAgICAgICAgIHJvb3RDb250YWluZXIgPSBfYS5yb290Q29udGFpbmVyLFxuICAgICAgICAgIGJvdW5kQ29udGFpbmVyID0gX2EuYm91bmRDb250YWluZXIsXG4gICAgICAgICAgX2IgPSBfYS5wcmV2ZW50RHJhZ0Zyb21JbnNpZGUsXG4gICAgICAgICAgcHJldmVudERyYWdGcm9tSW5zaWRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYixcbiAgICAgICAgICBjbGlja0J5U2VsZWN0RW5kID0gX2EuY2xpY2tCeVNlbGVjdEVuZCxcbiAgICAgICAgICBkcmFnQ29uZGl0aW9uID0gX2EuZHJhZ0NvbmRpdGlvbjtcblxuICAgICAgaWYgKGRyYWdDb25kaXRpb24gJiYgIWRyYWdDb25kaXRpb24oZSkpIHtcbiAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YS5kYXRhID0ge307XG4gICAgICB2YXIgd2luID0gZ2V0V2luZG93KF90aGlzLmNvbnRhaW5lcik7XG4gICAgICBkYXRhLmlubmVyV2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgICAgIGRhdGEuaW5uZXJIZWlnaHQgPSB3aW4uaW5uZXJIZWlnaHQ7XG5cbiAgICAgIF90aGlzLmZpbmRTZWxlY3RhYmxlVGFyZ2V0cyhkYXRhKTtcblxuICAgICAgZGF0YS5zdGFydFNlbGVjdGVkVGFyZ2V0cyA9IF90aGlzLnNlbGVjdGVkVGFyZ2V0cztcbiAgICAgIGRhdGEuc2NhbGVNYXRyaXggPSBjcmVhdGVNYXRyaXgoKTtcbiAgICAgIGRhdGEuY29udGFpbmVyWCA9IDA7XG4gICAgICBkYXRhLmNvbnRhaW5lclkgPSAwO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLmNvbnRhaW5lcjtcbiAgICAgIHZhciBib3VuZEFyZWEgPSB7XG4gICAgICAgIGxlZnQ6IC1JbmZpbml0eSxcbiAgICAgICAgdG9wOiAtSW5maW5pdHksXG4gICAgICAgIHJpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgYm90dG9tOiBJbmZpbml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKHJvb3RDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBfdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgZGF0YS5jb250YWluZXJYID0gY29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICBkYXRhLmNvbnRhaW5lclkgPSBjb250YWluZXJSZWN0LnRvcDtcbiAgICAgICAgZGF0YS5zY2FsZU1hdHJpeCA9IGdldERpc3RFbGVtZW50TWF0cml4KF90aGlzLmNvbnRhaW5lciwgcm9vdENvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZENvbnRhaW5lcikge1xuICAgICAgICB2YXIgYm91bmRJbmZvID0gaXNPYmplY3QoYm91bmRDb250YWluZXIpICYmIFwiZWxlbWVudFwiIGluIGJvdW5kQ29udGFpbmVyID8gX19hc3NpZ24oe1xuICAgICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgICAgdG9wOiB0cnVlLFxuICAgICAgICAgIGJvdHRvbTogdHJ1ZSxcbiAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICB9LCBib3VuZENvbnRhaW5lcikgOiB7XG4gICAgICAgICAgZWxlbWVudDogYm91bmRDb250YWluZXIsXG4gICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICB0b3A6IHRydWUsXG4gICAgICAgICAgYm90dG9tOiB0cnVlLFxuICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZEVsZW1lbnQgPSBib3VuZEluZm8uZWxlbWVudDtcbiAgICAgICAgdmFyIHJlY3RFbGVtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChib3VuZEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoYm91bmRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmVjdEVsZW1lbnQgPSBnZXREb2N1bWVudChjb250YWluZXIpLnF1ZXJ5U2VsZWN0b3IoYm91bmRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJvdW5kRWxlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVjdEVsZW1lbnQgPSBfdGhpcy5jb250YWluZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY3RFbGVtZW50ID0gYm91bmRFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWN0ID0gcmVjdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAoYm91bmRJbmZvLmxlZnQpIHtcbiAgICAgICAgICAgIGJvdW5kQXJlYS5sZWZ0ID0gcmVjdC5sZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChib3VuZEluZm8udG9wKSB7XG4gICAgICAgICAgICBib3VuZEFyZWEudG9wID0gcmVjdC50b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJvdW5kSW5mby5yaWdodCkge1xuICAgICAgICAgICAgYm91bmRBcmVhLnJpZ2h0ID0gcmVjdC5yaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYm91bmRJbmZvLmJvdHRvbSkge1xuICAgICAgICAgICAgYm91bmRBcmVhLmJvdHRvbSA9IHJlY3QuYm90dG9tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhLmJvdW5kQXJlYSA9IGJvdW5kQXJlYTtcbiAgICAgIHZhciBoaXRSZWN0ID0ge1xuICAgICAgICBsZWZ0OiBjbGllbnRYLFxuICAgICAgICB0b3A6IGNsaWVudFksXG4gICAgICAgIHJpZ2h0OiBjbGllbnRYLFxuICAgICAgICBib3R0b206IGNsaWVudFksXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgZmlyc3RQYXNzZWRUYXJnZXRzID0gW107IC8vIGFsbG93IGNsaWNrIG9uIHNlbGVjdFxuXG4gICAgICB2YXIgYWxsb3dDbGlja0J5U2VsZWN0RW5kID0gc2VsZWN0QnlDbGljayAmJiAhY2xpY2tCeVNlbGVjdEVuZDtcbiAgICAgIHZhciBoYXNJbnNpZGVUYXJnZXRzID0gZmFsc2U7XG5cbiAgICAgIGlmICghc2VsZWN0RnJvbUluc2lkZSB8fCBhbGxvd0NsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgdmFyIHBvaW50VGFyZ2V0ID0gX3RoaXMuX2ZpbmRFbGVtZW50KGNsaWNrZWRUYXJnZXQgfHwgaW5wdXRFdmVudC50YXJnZXQsIC8vIGVsZW1lbnRGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSksXG4gICAgICAgIGRhdGEuc2VsZWN0YWJsZVRhcmdldHMpO1xuXG4gICAgICAgIGhhc0luc2lkZVRhcmdldHMgPSAhIXBvaW50VGFyZ2V0O1xuXG4gICAgICAgIGlmIChhbGxvd0NsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgICBmaXJzdFBhc3NlZFRhcmdldHMgPSBwb2ludFRhcmdldCA/IFtwb2ludFRhcmdldF0gOiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXNQcmV2ZW50U2VsZWN0ID0gIXNlbGVjdEZyb21JbnNpZGUgJiYgaGFzSW5zaWRlVGFyZ2V0czsgLy8gcHJldmVudCBkcmFnIGZyb20gaW5zaWRlIHdoZW4gc2VsZWN0QnlDbGljayBpcyBmYWxzZVxuXG4gICAgICBpZiAoaXNQcmV2ZW50U2VsZWN0ICYmICFzZWxlY3RCeUNsaWNrKSB7XG4gICAgICAgIGUuc3RvcCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gaW5wdXRFdmVudC50eXBlO1xuICAgICAgdmFyIGlzVHJ1c3RlZCA9IHR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgdHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIGRyYWcgc3RhcnRzICh0cmlnZ2VycyBvbiBtb3VzZWRvd24gb3IgdG91Y2hzdGFydCksIHRoZSBkcmFnU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQ2FsbCB0aGUgc3RvcCAoKSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGVsZW1lbnQgb3IgZG9uJ3Qgd2FudCB0byByYWlzZSBhIHNlbGVjdFxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBkcmFnU3RhcnRcbiAgICAgICAqIEBwYXJhbSB7T25EcmFnU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGRyYWdTdGFydCBldmVudFxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgKlxuICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAgICogICBzZWxlY3RGcm9tSW5zaWRlOiBmYWxzZSxcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIHNlbGVjdG8ub24oXCJkcmFnU3RhcnRcIiwgZSA9PiB7XG4gICAgICAgKiAgIGlmIChlLmlucHV0RXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09IFwiU1BBTlwiKSB7XG4gICAgICAgKiAgICAgZS5zdG9wKCk7XG4gICAgICAgKiAgIH1cbiAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cblxuICAgICAgdmFyIHJlc3VsdCA9ICFlLmlzQ2xpY2sgJiYgaXNUcnVzdGVkID8gX3RoaXMuZW1pdChcImRyYWdTdGFydFwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgICAgZGF0YTogZGF0YS5kYXRhXG4gICAgICB9KSkgOiB0cnVlO1xuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuY29udGludWVTZWxlY3QpIHtcbiAgICAgICAgZmlyc3RQYXNzZWRUYXJnZXRzID0gcGFzc1RhcmdldHMoX3RoaXMuc2VsZWN0ZWRUYXJnZXRzLCBmaXJzdFBhc3NlZFRhcmdldHMsIF90aGlzLmNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KTtcbiAgICAgICAgZGF0YS5zdGFydFBhc3NlZFRhcmdldHMgPSBfdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnN0YXJ0UGFzc2VkVGFyZ2V0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fc2VsZWN0KGZpcnN0UGFzc2VkVGFyZ2V0cywgaGl0UmVjdCwgZSwgdHJ1ZSwgaXNQcmV2ZW50U2VsZWN0ICYmIHNlbGVjdEJ5Q2xpY2sgJiYgIWNsaWNrQnlTZWxlY3RFbmQgJiYgcHJldmVudERyYWdGcm9tSW5zaWRlKTtcblxuICAgICAgZGF0YS5zdGFydFggPSBjbGllbnRYO1xuICAgICAgZGF0YS5zdGFydFkgPSBjbGllbnRZO1xuICAgICAgZGF0YS5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICBkYXRhLnByZXZlbnREcmFnRnJvbUluc2lkZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoaW5wdXRFdmVudC50YXJnZXQpIHtcbiAgICAgICAgdmFyIG9mZnNldFBvcyA9IGNhbGN1bGF0ZU1hdHJpeERpc3QoZGF0YS5zY2FsZU1hdHJpeCwgW2NsaWVudFggLSBkYXRhLmNvbnRhaW5lclgsIGNsaWVudFkgLSBkYXRhLmNvbnRhaW5lclldKTtcbiAgICAgICAgX3RoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJwb3NpdGlvbjogXCIuY29uY2F0KHJvb3RDb250YWluZXIgPyBcImFic29sdXRlXCIgOiBcImZpeGVkXCIsIFwiO1wiKSArIFwibGVmdDowcHg7dG9wOjBweDtcIiArIFwidHJhbnNmb3JtOiB0cmFuc2xhdGUoXCIuY29uY2F0KG9mZnNldFBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChvZmZzZXRQb3NbMV0sIFwicHgpXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcmV2ZW50U2VsZWN0ICYmIHNlbGVjdEJ5Q2xpY2sgJiYgIWNsaWNrQnlTZWxlY3RFbmQpIHtcbiAgICAgICAgaW5wdXRFdmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IGRyYWcgZnJvbSBpbnNpZGUgd2hlbiBzZWxlY3RCeUNsaWNrIGlzIHRydWUgYW5kIGZvcmNlIGNhbGwgYHNlbGVjdEVuZGBcblxuICAgICAgICBpZiAocHJldmVudERyYWdGcm9tSW5zaWRlKSB7XG4gICAgICAgICAgX3RoaXMuX3NlbGVjdEVuZChkYXRhLnN0YXJ0U2VsZWN0ZWRUYXJnZXRzLCBkYXRhLnN0YXJ0UGFzc2VkVGFyZ2V0cywgaGl0UmVjdCwgZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBkYXRhLnByZXZlbnREcmFnRnJvbUluc2lkZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuc2VsZWN0RmxhZyA9IHRydWU7IC8vIHdoeT9cbiAgICAgICAgLy8gaWYgKHR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XG4gICAgICAgIC8vICAgICBpbnB1dEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIgX2MgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgc2Nyb2xsT3B0aW9ucyA9IF9jLnNjcm9sbE9wdGlvbnMsXG4gICAgICAgICAgICBpbm5lclNjcm9sbE9wdGlvbnMgPSBfYy5pbm5lclNjcm9sbE9wdGlvbnM7XG4gICAgICAgIHZhciBpc0lubmVyU2Nyb2xsID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlubmVyU2Nyb2xsT3B0aW9ucykge1xuICAgICAgICAgIHZhciBpbnB1dEV2ZW50XzEgPSBlLmlucHV0RXZlbnQ7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGlucHV0RXZlbnRfMS50YXJnZXQ7XG4gICAgICAgICAgdmFyIGlubmVyU2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSB0YXJnZXQ7XG5cbiAgICAgICAgICB3aGlsZSAocGFyZW50RWxlbWVudCAmJiBwYXJlbnRFbGVtZW50ICE9PSBnZXREb2N1bWVudChjb250YWluZXIpLmJvZHkpIHtcbiAgICAgICAgICAgIHZhciBvdmVyZmxvdyA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50RWxlbWVudCkub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiO1xuXG4gICAgICAgICAgICBpZiAob3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgaW5uZXJTY3JvbGxFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlubmVyU2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgICAgZGF0YS5pbm5lclNjcm9sbE9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICAgICAgICAgIGNvbnRhaW5lcjogaW5uZXJTY3JvbGxFbGVtZW50LFxuICAgICAgICAgICAgICBjaGVja1Njcm9sbEV2ZW50OiB0cnVlXG4gICAgICAgICAgICB9LCBpbm5lclNjcm9sbE9wdGlvbnMgPT09IHRydWUgPyB7fSA6IGlubmVyU2Nyb2xsT3B0aW9ucyk7XG5cbiAgICAgICAgICAgIF90aGlzLmRyYWdTY3JvbGwuZHJhZ1N0YXJ0KGUsIGRhdGEuaW5uZXJTY3JvbGxPcHRpb25zKTtcblxuICAgICAgICAgICAgaXNJbm5lclNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0lubmVyU2Nyb2xsICYmIHNjcm9sbE9wdGlvbnMgJiYgc2Nyb2xsT3B0aW9ucy5jb250YWluZXIpIHtcbiAgICAgICAgICBfdGhpcy5kcmFnU2Nyb2xsLmRyYWdTdGFydChlLCBzY3JvbGxPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXZlbnRTZWxlY3QgJiYgc2VsZWN0QnlDbGljayAmJiBjbGlja0J5U2VsZWN0RW5kKSB7XG4gICAgICAgICAgZGF0YS5zZWxlY3RGbGFnID0gZmFsc2U7XG4gICAgICAgICAgZS5wcmV2ZW50RHJhZygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25EcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmRhdGEuc2VsZWN0RmxhZykge1xuICAgICAgICB2YXIgc2Nyb2xsT3B0aW9ucyA9IF90aGlzLnNjcm9sbE9wdGlvbnM7XG4gICAgICAgIHZhciBpbm5lclNjcm9sbE9wdGlvbnMgPSBlLmRhdGEuaW5uZXJTY3JvbGxPcHRpb25zO1xuICAgICAgICB2YXIgaGFzU2Nyb2xsT3B0aW9ucyA9IGlubmVyU2Nyb2xsT3B0aW9ucyB8fCAoc2Nyb2xsT3B0aW9ucyA9PT0gbnVsbCB8fCBzY3JvbGxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JvbGxPcHRpb25zLmNvbnRhaW5lcik7IC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcblxuICAgICAgICBpZiAoaGFzU2Nyb2xsT3B0aW9ucyAmJiAhZS5pc1Njcm9sbCAmJiBfdGhpcy5kcmFnU2Nyb2xsLmRyYWcoZSwgaW5uZXJTY3JvbGxPcHRpb25zIHx8IHNjcm9sbE9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9jaGVja1NlbGVjdGVkKGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBkYXRhID0gZS5kYXRhLFxuICAgICAgICAgIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgICB2YXIgcmVjdCA9IGdldFJlY3QoZSwgX3RoaXMub3B0aW9ucy5yYXRpbyk7XG4gICAgICB2YXIgc2VsZWN0RmxhZyA9IGRhdGEuc2VsZWN0RmxhZztcbiAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5jb250YWluZXI7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIGRyYWcgZW5kcyAodHJpZ2dlcnMgb24gbW91c2V1cCBvciB0b3VjaGVuZCBhZnRlciBkcmFnKSwgdGhlIGRyYWdFbmQgZXZlbnQgaXMgY2FsbGVkLlxuICAgICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgICAqIEBldmVudCBkcmFnRW5kXG4gICAgICAgKiBAcGFyYW0ge09uRHJhZ0VuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ0VuZCBldmVudFxuICAgICAgICovXG5cbiAgICAgIGlmIChpbnB1dEV2ZW50KSB7XG4gICAgICAgIF90aGlzLmVtaXQoXCJkcmFnRW5kXCIsIF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgICAgICBpc0RvdWJsZTogISFlLmlzRG91YmxlLFxuICAgICAgICAgIGlzQ2xpY2s6ICEhZS5pc0NsaWNrLFxuICAgICAgICAgIGlzRHJhZzogZmFsc2UsXG4gICAgICAgICAgaXNTZWxlY3Q6IHNlbGVjdEZsYWdcbiAgICAgICAgfSwgZSksIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLmRhdGEsXG4gICAgICAgICAgcmVjdDogcmVjdFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwiZGlzcGxheTogbm9uZTtcIjtcblxuICAgICAgaWYgKHNlbGVjdEZsYWcpIHtcbiAgICAgICAgZGF0YS5zZWxlY3RGbGFnID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuZHJhZ1Njcm9sbC5kcmFnRW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLnNlbGVjdEJ5Q2xpY2sgJiYgX3RoaXMuY2xpY2tCeVNlbGVjdEVuZCkge1xuICAgICAgICAvLyBvbmx5IGNsaWNrQnlTZWxlY3RFbmRcbiAgICAgICAgdmFyIHBvaW50VGFyZ2V0ID0gX3RoaXMuX2ZpbmRFbGVtZW50KChpbnB1dEV2ZW50ID09PSBudWxsIHx8IGlucHV0RXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0RXZlbnQudGFyZ2V0KSB8fCBlbGVtZW50RnJvbVBvaW50KGNvbnRhaW5lciwgZS5jbGllbnRYLCBlLmNsaWVudFkpLCBkYXRhLnNlbGVjdGFibGVUYXJnZXRzKTtcblxuICAgICAgICBfdGhpcy5fc2VsZWN0KHBvaW50VGFyZ2V0ID8gW3BvaW50VGFyZ2V0XSA6IFtdLCByZWN0LCBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnByZXZlbnREcmFnRnJvbUluc2lkZSkge1xuICAgICAgICBfdGhpcy5fc2VsZWN0RW5kKGRhdGEuc3RhcnRTZWxlY3RlZFRhcmdldHMsIGRhdGEuc3RhcnRQYXNzZWRUYXJnZXRzLCByZWN0LCBlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuX29uS2V5RG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgaXNLZXlEb3duID0gZmFsc2U7XG5cbiAgICAgIGlmICghX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuX3NhbWVDb21iaUtleShlLCBvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0KTtcblxuICAgICAgICBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0ID0gcmVzdWx0O1xuICAgICAgICBpc0tleURvd24gfHwgKGlzS2V5RG93biA9IHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuX3NhbWVDb21iaUtleShlLCBvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KTtcblxuICAgICAgICBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uID0gcmVzdWx0O1xuICAgICAgICBpc0tleURvd24gfHwgKGlzS2V5RG93biA9IHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNLZXlEb3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB5b3Uga2V5ZG93biB0aGUga2V5IHlvdSBzcGVjaWZpZWQgaW4gdG9nZ2xlQ29udGludWVTZWxlY3QsIHRoZSBrZXlkb3duIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQga2V5ZG93blxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICAgKlxuICAgICAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKHtcbiAgICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAgICogICB0b2dnbGVDb250aW51ZVNlbGVjdDogXCJzaGlmdFwiO1xuICAgICAgICogICBrZXlDb250YWluZXI6IHdpbmRvdyxcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIHNlbGVjdG8ub24oXCJrZXlkb3duXCIsICgpID0+IHtcbiAgICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5idXR0b25cIikuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAgICogfSkub24oXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cblxuXG4gICAgICBfdGhpcy5lbWl0KFwia2V5ZG93blwiLCB7XG4gICAgICAgIGtleWRvd25Db250aW51ZVNlbGVjdDogX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdCxcbiAgICAgICAga2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uOiBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX29uS2V5VXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGlzS2V5VXAgPSBmYWxzZTtcblxuICAgICAgaWYgKF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLl9zYW1lQ29tYmlLZXkoZSwgb3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdCwgdHJ1ZSk7XG5cbiAgICAgICAgX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdCA9ICFyZXN1bHQ7XG4gICAgICAgIGlzS2V5VXAgfHwgKGlzS2V5VXAgPSByZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuX3NhbWVDb21iaUtleShlLCBvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0LCB0cnVlKTtcblxuICAgICAgICBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0aW9uID0gIXJlc3VsdDtcbiAgICAgICAgaXNLZXlVcCB8fCAoaXNLZXlVcCA9IHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNLZXlVcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4geW91IGtleXVwIHRoZSBrZXkgeW91IHNwZWNpZmllZCBpbiB0b2dnbGVDb250aW51ZVNlbGVjdCwgdGhlIGtleXVwIGV2ZW50IGlzIGNhbGxlZC5cbiAgICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICAgKiBAZXZlbnQga2V5dXBcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgdG9nZ2xlQ29udGludWVTZWxlY3Q6IFwic2hpZnRcIjtcbiAgICAgICAqICAga2V5Q29udGFpbmVyOiB3aW5kb3csXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwia2V5ZG93blwiLCAoKSA9PiB7XG4gICAgICAgKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuYnV0dG9uXCIpLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqIH0pLm9uKFwia2V5dXBcIiwgKCkgPT4ge1xuICAgICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmJ1dHRvblwiKS5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiB9KS5vbihcInNlbGVjdFwiLCBlID0+IHtcbiAgICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgKiAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkXCIpO1xuICAgICAgICogICB9KTtcbiAgICAgICAqIH0pO1xuICAgICAgICovXG5cblxuICAgICAgX3RoaXMuZW1pdChcImtleXVwXCIsIHtcbiAgICAgICAga2V5ZG93bkNvbnRpbnVlU2VsZWN0OiBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0LFxuICAgICAgICBrZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb246IF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfdGhpcy5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3QgfHwgX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbikge1xuICAgICAgICBfdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5lbWl0KFwia2V5dXBcIiwge1xuICAgICAgICAgIGtleWRvd25Db250aW51ZVNlbGVjdDogX3RoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdCxcbiAgICAgICAgICBrZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb246IF90aGlzLl9rZXlkb3duQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLl9vbkRvY3VtZW50U2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRvYyA9IGdldERvY3VtZW50KF90aGlzLmNvbnRhaW5lcik7XG5cbiAgICAgIGlmICghX3RoaXMuZ2VzdG8uaXNGbGFnKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJhZ0NvbnRhaW5lciA9IF90aGlzLmRyYWdDb250YWluZXI7XG5cbiAgICAgIGlmIChkcmFnQ29udGFpbmVyID09PSBnZXRXaW5kb3coX3RoaXMuY29udGFpbmVyKSkge1xuICAgICAgICBkcmFnQ29udGFpbmVyID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRhaW5lcnMgPSBpc05vZGUoZHJhZ0NvbnRhaW5lcikgPyBbZHJhZ0NvbnRhaW5lcl0gOiBbXS5zbGljZS5jYWxsKGRyYWdDb250YWluZXIpO1xuICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgY29udGFpbmVycy5zb21lKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdGFyZ2V0IHx8IGNvbnRhaW5lci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3RoaXMudGFyZ2V0ID0gb3B0aW9ucy5wb3J0YWxDb250YWluZXI7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBjbGFzc05hbWU6IFwiXCIsXG4gICAgICBwb3J0YWxDb250YWluZXI6IG51bGwsXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBkcmFnQ29udGFpbmVyOiBudWxsLFxuICAgICAgc2VsZWN0YWJsZVRhcmdldHM6IFtdLFxuICAgICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgIHNlbGVjdEZyb21JbnNpZGU6IHRydWUsXG4gICAgICBjbGlja0J5U2VsZWN0RW5kOiBmYWxzZSxcbiAgICAgIGhpdFJhdGU6IDEwMCxcbiAgICAgIGNvbnRpbnVlU2VsZWN0OiBmYWxzZSxcbiAgICAgIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0OiBmYWxzZSxcbiAgICAgIHRvZ2dsZUNvbnRpbnVlU2VsZWN0OiBudWxsLFxuICAgICAgdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Q6IG51bGwsXG4gICAgICBrZXlDb250YWluZXI6IG51bGwsXG4gICAgICBzY3JvbGxPcHRpb25zOiBudWxsLFxuICAgICAgY2hlY2tJbnB1dDogZmFsc2UsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICBib3VuZENvbnRhaW5lcjogZmFsc2UsXG4gICAgICBwcmV2ZW50RHJhZ0Zyb21JbnNpZGU6IHRydWUsXG4gICAgICBkcmFnQ29uZGl0aW9uOiBudWxsLFxuICAgICAgcm9vdENvbnRhaW5lcjogbnVsbCxcbiAgICAgIGNoZWNrT3ZlcmZsb3c6IGZhbHNlLFxuICAgICAgaW5uZXJTY3JvbGxPcHRpb25zOiBmYWxzZSxcbiAgICAgIGdldEVsZW1lbnRSZWN0OiBnZXREZWZhdWx0RWxlbWVudFJlY3QsXG4gICAgICBjc3BOb25jZTogXCJcIixcbiAgICAgIHJhdGlvOiAwXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdmFyIHBvcnRhbENvbnRhaW5lciA9IF90aGlzLm9wdGlvbnMucG9ydGFsQ29udGFpbmVyO1xuXG4gICAgaWYgKHBvcnRhbENvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyID0gcG9ydGFsQ29udGFpbmVyLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICBfdGhpcy5pbml0RWxlbWVudCgpO1xuXG4gICAgX3RoaXMuaW5pdERyYWdTY3JvbGwoKTtcblxuICAgIF90aGlzLnNldEtleUNvbnRyb2xsZXIoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogWW91IGNhbiBzZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YXJnZXRzLlxuICAgKiBzZWxlY3RCeUNsaWNrLCBjb250aW51ZVNlbGVjdCwgYW5kIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0IGFyZSBub3QgYXBwbGllZC5cbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IFNlbGVjdG8ucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0U2VsZWN0ZWRUYXJnZXRzID0gZnVuY3Rpb24gKHNlbGVjdGVkVGFyZ2V0cykge1xuICAgIHZhciBiZWZvcmVTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRUYXJnZXRzO1xuXG4gICAgdmFyIF9hID0gZGlmZihiZWZvcmVTZWxlY3RlZCwgc2VsZWN0ZWRUYXJnZXRzKSxcbiAgICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsXG4gICAgICAgIHByZXZMaXN0ID0gX2EucHJldkxpc3QsXG4gICAgICAgIGxpc3QgPSBfYS5saXN0O1xuXG4gICAgdGhpcy5zZWxlY3RlZFRhcmdldHMgPSBzZWxlY3RlZFRhcmdldHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZGVkOiBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgIH0pLFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGJlZm9yZVNlbGVjdGVkOiBiZWZvcmVTZWxlY3RlZCxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFRhcmdldHNcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogWW91IGNhbiBzZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YXJnZXRzIGJ5IHBvaW50c1xuICAgKiBzZWxlY3RCeUNsaWNrLCBjb250aW51ZVNlbGVjdCwgYW5kIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0IGFyZSBub3QgYXBwbGllZC5cbiAgICovXG5cblxuICBfX3Byb3RvLnNldFNlbGVjdGVkVGFyZ2V0c0J5UG9pbnRzID0gZnVuY3Rpb24gKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbihwb2ludDFbMF0sIHBvaW50MlswXSk7XG4gICAgdmFyIHRvcCA9IE1hdGgubWluKHBvaW50MVsxXSwgcG9pbnQyWzFdKTtcbiAgICB2YXIgcmlnaHQgPSBNYXRoLm1heChwb2ludDFbMF0sIHBvaW50MlswXSk7XG4gICAgdmFyIGJvdHRvbSA9IE1hdGgubWF4KHBvaW50MVsxXSwgcG9pbnQyWzFdKTtcbiAgICB2YXIgcmVjdCA9IHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgfTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGlnbm9yZUNsaWNrOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmZpbmRTZWxlY3RhYmxlVGFyZ2V0cyhkYXRhKTtcbiAgICB2YXIgc2VsZWN0ZWRFbGVtZW50cyA9IHRoaXMuaGl0VGVzdChyZWN0LCBkYXRhLCB0cnVlLCBudWxsKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5zZXRTZWxlY3RlZFRhcmdldHMoc2VsZWN0ZWRFbGVtZW50cyk7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7XG4gICAgICByZWN0OiByZWN0XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBTZWxlY3QgdGFyZ2V0IGJ5IHZpcnR1YWwgZHJhZyBmcm9tIHN0YXJ0UG9pbnQgdG8gZW5kUG9pbnQuXG4gICAqIFRoZSB0YXJnZXQgb2YgaW5wdXRFdmVudCBpcyBudWxsLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uc2VsZWN0VGFyZ2V0c0J5UG9pbnRzID0gZnVuY3Rpb24gKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG4gICAgdmFyIG1vdXNlZG93biA9IG5ldyBNb3VzZUV2ZW50KFwibW91c2Vkb3duXCIsIHtcbiAgICAgIGNsaWVudFg6IHN0YXJ0UG9pbnRbMF0sXG4gICAgICBjbGllbnRZOiBzdGFydFBvaW50WzFdLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgbW91c2Vtb3ZlID0gbmV3IE1vdXNlRXZlbnQoXCJtb3VzZW1vdmVcIiwge1xuICAgICAgY2xpZW50WDogZW5kUG9pbnRbMF0sXG4gICAgICBjbGllbnRZOiBlbmRQb2ludFsxXSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIG1vdXNldXAgPSBuZXcgTW91c2VFdmVudChcIm1vdXNlbW92ZVwiLCB7XG4gICAgICBjbGllbnRYOiBlbmRQb2ludFswXSxcbiAgICAgIGNsaWVudFk6IGVuZFBvaW50WzFdLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgZ2VzdG8gPSB0aGlzLmdlc3RvO1xuICAgIHZhciByZXN1bHQgPSBnZXN0by5vbkRyYWdTdGFydChtb3VzZWRvd24pO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgIGdlc3RvLm9uRHJhZyhtb3VzZW1vdmUpO1xuICAgICAgZ2VzdG8ub25EcmFnRW5kKG1vdXNldXApO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFlvdSBjYW4gZ2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFyZ2V0cy5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldFNlbGVjdGVkVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZFRhcmdldHM7XG4gIH07XG4gIC8qKlxuICAgKiBgT25EcmFnU3RhcnRgIGlzIHRyaWdnZXJlZCBieSBhbiBleHRlcm5hbCBldmVudC5cbiAgICogQHBhcmFtIC0gZXh0ZXJuYWwgZXZlbnRcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICpcbiAgICogY29uc3Qgc2VsZWN0byA9IG5ldyBTZWxlY3RvKCk7XG4gICAqXG4gICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgKiAgIHNlbGVjdG8udHJpZ2dlckRyYWdTdGFydChlKTtcbiAgICogfSk7XG4gICAqL1xuXG5cbiAgX19wcm90by50cmlnZ2VyRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLmdlc3RvLnRyaWdnZXJEcmFnU3RhcnQoZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95IGVsZW1lbnRzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB0aGlzLm9mZigpO1xuICAgIHRoaXMua2V5Y29uICYmIHRoaXMua2V5Y29uLmRlc3Ryb3koKTtcbiAgICB0aGlzLmdlc3RvLnVuc2V0KCk7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQuZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ1Njcm9sbC5kcmFnRW5kKCk7XG4gICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsIFwic2VsZWN0c3RhcnRcIiwgdGhpcy5fb25Eb2N1bWVudFNlbGVjdFN0YXJ0KTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnBvcnRhbENvbnRhaW5lcikge1xuICAgICAgKF9hID0gdGhpcy50YXJnZXQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKHRoaXMudGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLmtleWNvbiA9IG51bGw7XG4gICAgdGhpcy5nZXN0byA9IG51bGw7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgfTtcblxuICBfX3Byb3RvLmdldEVsZW1lbnRQb2ludHMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGdldEVsZW1lbnRSZWN0ID0gdGhpcy5nZXRFbGVtZW50UmVjdCB8fCBnZXREZWZhdWx0RWxlbWVudFJlY3Q7XG4gICAgdmFyIGluZm8gPSBnZXRFbGVtZW50UmVjdCh0YXJnZXQpO1xuICAgIHZhciBwb2ludHMgPSBbaW5mby5wb3MxLCBpbmZvLnBvczIsIGluZm8ucG9zNCwgaW5mby5wb3MzXTtcblxuICAgIGlmIChnZXRFbGVtZW50UmVjdCAhPT0gZ2V0RGVmYXVsdEVsZW1lbnRSZWN0KSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBmaXRQb2ludHMocG9pbnRzLCByZWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuICAvKipcbiAgICogR2V0IGFsbCBlbGVtZW50cyBzZXQgaW4gYHNlbGVjdGFibGVUYXJnZXRzYC5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldFNlbGVjdGFibGVFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgdmFyIHNlbGVjdGFibGVFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldCgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBzZWxlY3RhYmxlRWxlbWVudHMucHVzaC5hcHBseShzZWxlY3RhYmxlRWxlbWVudHMsIFtdLnNsaWNlLmNhbGwocmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgc2VsZWN0YWJsZUVsZW1lbnRzLnB1c2godGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBzZWxlY3RhYmxlRWxlbWVudHMucHVzaCh0YXJnZXQudmFsdWUgfHwgdGFyZ2V0LmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChnZXREb2N1bWVudChjb250YWluZXIpLnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KSk7XG4gICAgICAgIHNlbGVjdGFibGVFbGVtZW50cy5wdXNoLmFwcGx5KHNlbGVjdGFibGVFbGVtZW50cywgZWxlbWVudHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RhYmxlRWxlbWVudHM7XG4gIH07XG4gIC8qKlxuICAgKiBJZiBzY3JvbGwgb2NjdXJzIGR1cmluZyBkcmFnZ2luZywgeW91IGNhbiBtYW51YWxseSBjYWxsIHRoaXMgbWV0aG9kIHRvIGNoZWNrIHRoZSBwb3NpdGlvbiBhZ2Fpbi5cbiAgICovXG5cblxuICBfX3Byb3RvLmNoZWNrU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5nZXN0by5pc0ZsYWcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxPcHRpb25zID0gdGhpcy5zY3JvbGxPcHRpb25zO1xuICAgIHZhciBpbm5lclNjcm9sbE9wdGlvbnMgPSB0aGlzLmdlc3RvLmdldEV2ZW50RGF0YSgpLmlubmVyU2Nyb2xsT3B0aW9ucztcbiAgICB2YXIgaGFzU2Nyb2xsT3B0aW9ucyA9IGlubmVyU2Nyb2xsT3B0aW9ucyB8fCAoc2Nyb2xsT3B0aW9ucyA9PT0gbnVsbCB8fCBzY3JvbGxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JvbGxPcHRpb25zLmNvbnRhaW5lcik7IC8vIElmIGl0IGlzIGEgc2Nyb2xsaW5nIHBvc2l0aW9uLCBwYXNzIGRyYWdcblxuICAgIGlmIChoYXNTY3JvbGxPcHRpb25zKSB7XG4gICAgICB0aGlzLmRyYWdTY3JvbGwuY2hlY2tTY3JvbGwoX19hc3NpZ24oe1xuICAgICAgICBpbnB1dEV2ZW50OiB0aGlzLmdlc3RvLmdldEN1cnJlbnRFdmVudCgpXG4gICAgICB9LCBpbm5lclNjcm9sbE9wdGlvbnMgfHwgc2Nyb2xsT3B0aW9ucykpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEZpbmQgZm9yIHNlbGVjdGFibGVUYXJnZXRzIGFnYWluIGR1cmluZyBkcmFnIGV2ZW50XG4gICAqIFlvdSBjYW4gdXBkYXRlIHNlbGVjdGFibGUgdGFyZ2V0cyBkdXJpbmcgYW4gZXZlbnQuXG4gICAqL1xuXG5cbiAgX19wcm90by5maW5kU2VsZWN0YWJsZVRhcmdldHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBkYXRhID0gdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0YWJsZVRhcmdldHMgPSB0aGlzLmdldFNlbGVjdGFibGVFbGVtZW50cygpO1xuICAgIHZhciBzZWxlY3RhYmxlUG9pbnRzID0gc2VsZWN0YWJsZVRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5nZXRFbGVtZW50UG9pbnRzKHRhcmdldCk7XG4gICAgfSk7XG4gICAgZGF0YS5zZWxlY3RhYmxlVGFyZ2V0cyA9IHNlbGVjdGFibGVUYXJnZXRzO1xuICAgIGRhdGEuc2VsZWN0YWJsZVBvaW50cyA9IHNlbGVjdGFibGVQb2ludHM7XG4gICAgZGF0YS5zZWxlY3RhYmxlUGFyZW50TWFwID0gbnVsbDtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgaGFzSW5kZXhlc01hcCA9IG9wdGlvbnMuY2hlY2tPdmVyZmxvdyB8fCBvcHRpb25zLmlubmVyU2Nyb2xsT3B0aW9ucztcbiAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQodGhpcy5jb250YWluZXIpO1xuXG4gICAgaWYgKGhhc0luZGV4ZXNNYXApIHtcbiAgICAgIHZhciBwYXJlbnRNYXBfMSA9IG5ldyBNYXAoKTtcbiAgICAgIGRhdGEuc2VsZWN0YWJsZUlubmVyU2Nyb2xsUGFyZW50TWFwID0gcGFyZW50TWFwXzE7XG4gICAgICBkYXRhLnNlbGVjdGFibGVJbm5lclNjcm9sbFBhdGhzTGlzdCA9IHNlbGVjdGFibGVUYXJnZXRzLm1hcChmdW5jdGlvbiAodGFyZ2V0LCBpbmRleCkge1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgICB2YXIgcGF0aHMgPSBbXTtcblxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9IHBhcmVudE1hcF8xLmdldChwYXJlbnRFbGVtZW50KTtcblxuICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgdmFyIG92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbGVtZW50KS5vdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCI7XG5cbiAgICAgICAgICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdldERlZmF1bHRFbGVtZW50UmVjdChwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgICAgICAgICAgIHBvaW50czogW3JlY3QucG9zMSwgcmVjdC5wb3MyLCByZWN0LnBvczQsIHJlY3QucG9zM10sXG4gICAgICAgICAgICAgICAgcGF0aHM6IF9fc3ByZWFkQXJyYXkoW10sIHBhdGhzLCB0cnVlKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgIHBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocHJldlBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRNYXBfMS5zZXQocHJldlBhcmVudEVsZW1lbnQsIGluZm8pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gaW5mby5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgcGFyZW50TWFwXzEuZ2V0KHBhcmVudEVsZW1lbnQpLmluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAocGFyZW50RWxlbWVudCAmJiBwYXJlbnRFbGVtZW50ICE9PSBkb2MuYm9keSkge1xuICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5jaGVja092ZXJmbG93KSB7XG4gICAgICBkYXRhLnNlbGVjdGFibGVJbm5lcnMgPSBzZWxlY3RhYmxlVGFyZ2V0cy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZnJlc2hHcm91cHMoZGF0YSk7XG5cbiAgICByZXR1cm4gc2VsZWN0YWJsZVRhcmdldHM7XG4gIH07XG4gIC8qKlxuICAgKiBFeHRlcm5hbCBjbGljayBvciBtb3VzZSBldmVudHMgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIHNlbGVjdG8uXG4gICAqIEBwYXJhbXMgLSBFeHRlbmFsIGNsaWNrIG9yIG1vdXNlIGV2ZW50XG4gICAqIEBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBjbGlja2VkIHRhcmdldCBkaXJlY3RseS5cbiAgICovXG5cblxuICBfX3Byb3RvLmNsaWNrVGFyZ2V0ID0gZnVuY3Rpb24gKGUsIGNsaWNrZWRUYXJnZXQpIHtcbiAgICB2YXIgX2EgPSBnZXRDbGllbnQoZSksXG4gICAgICAgIGNsaWVudFggPSBfYS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gX2EuY2xpZW50WTtcblxuICAgIHZhciBkcmFnRXZlbnQgPSB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNlbGVjdEZsYWc6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IGNsaWVudFksXG4gICAgICBpbnB1dEV2ZW50OiBlLFxuICAgICAgaXNDbGljazogdHJ1ZSxcbiAgICAgIGlzVHJ1c3RlZDogZmFsc2UsXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX29uRHJhZ1N0YXJ0KGRyYWdFdmVudCwgY2xpY2tlZFRhcmdldCkpIHtcbiAgICAgIHRoaXMuX29uRHJhZ0VuZChkcmFnRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0S2V5Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGtleUNvbnRhaW5lciA9IF9hLmtleUNvbnRhaW5lcixcbiAgICAgICAgdG9nZ2xlQ29udGludWVTZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdCxcbiAgICAgICAgdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdDtcblxuICAgIGlmICh0aGlzLmtleWNvbikge1xuICAgICAgdGhpcy5rZXljb24uZGVzdHJveSgpO1xuICAgICAgdGhpcy5rZXljb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0b2dnbGVDb250aW51ZVNlbGVjdCB8fCB0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCkge1xuICAgICAgdGhpcy5rZXljb24gPSBuZXcgS2V5Q29udHJvbGxlcihrZXlDb250YWluZXIgfHwgZ2V0V2luZG93KHRoaXMuY29udGFpbmVyKSk7XG4gICAgICB0aGlzLmtleWNvbi5rZXlkb3duKHRoaXMuX29uS2V5RG93bikua2V5dXAodGhpcy5fb25LZXlVcCkub24oXCJibHVyXCIsIHRoaXMuX29uQmx1cik7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uc2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKG5leHRDbGFzc05hbWUpIHtcbiAgICB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lID0gbmV4dENsYXNzTmFtZTtcbiAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcIlwiLmNvbmNhdChDTEFTU19OQU1FLCBcIiBcIikuY29uY2F0KG5leHRDbGFzc05hbWUgfHwgXCJcIikpO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0S2V5RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICB0b2dnbGVDb250aW51ZVNlbGVjdCA9IF9hLnRvZ2dsZUNvbnRpbnVlU2VsZWN0LFxuICAgICAgICB0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCA9IF9hLnRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0O1xuXG4gICAgaWYgKCF0b2dnbGVDb250aW51ZVNlbGVjdCAmJiAhdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgfHwgdGhpcy5rZXljb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldEtleUNvbnRyb2xsZXIoKTtcbiAgfTsgLy8gd2l0aCBnZXR0ZXIsIHNldHRlciBwcm9wZXJ0eVxuXG5cbiAgX19wcm90by5zZXRLZXlDb250YWluZXIgPSBmdW5jdGlvbiAoa2V5Q29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGRpZmZWYWx1ZShvcHRpb25zLmtleUNvbnRhaW5lciwga2V5Q29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvcHRpb25zLmtleUNvbnRhaW5lciA9IGtleUNvbnRhaW5lcjtcblxuICAgICAgX3RoaXMuc2V0S2V5Q29udHJvbGxlcigpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0Q29udGludWVTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjb250aW51ZVNlbGVjdCA9IF9hLmNvbnRpbnVlU2VsZWN0LFxuICAgICAgICB0b2dnbGVDb250aW51ZVNlbGVjdCA9IF9hLnRvZ2dsZUNvbnRpbnVlU2VsZWN0O1xuXG4gICAgaWYgKCF0b2dnbGVDb250aW51ZVNlbGVjdCB8fCAhdGhpcy5fa2V5ZG93bkNvbnRpbnVlU2VsZWN0KSB7XG4gICAgICByZXR1cm4gY29udGludWVTZWxlY3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuICFjb250aW51ZVNlbGVjdDtcbiAgfTtcblxuICBfX3Byb3RvLmdldENvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBfYS5jb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCxcbiAgICAgICAgdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgPSBfYS50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdDtcblxuICAgIGlmICghdG9nZ2xlQ29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QgfHwgIXRoaXMuX2tleWRvd25Db250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0O1xuICAgIH1cblxuICAgIHJldHVybiAhY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3Q7XG4gIH07XG5cbiAgX19wcm90by5zZXRUb2dnbGVDb250aW51ZVNlbGVjdCA9IGZ1bmN0aW9uICh0b2dnbGVDb250aW51ZVNlbGVjdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBkaWZmVmFsdWUob3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdCwgdG9nZ2xlQ29udGludWVTZWxlY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9wdGlvbnMudG9nZ2xlQ29udGludWVTZWxlY3QgPSB0b2dnbGVDb250aW51ZVNlbGVjdDtcblxuICAgICAgX3RoaXMuc2V0S2V5RXZlbnQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLnNldFRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0ID0gZnVuY3Rpb24gKHRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGRpZmZWYWx1ZShvcHRpb25zLnRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0LCB0b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgb3B0aW9ucy50b2dnbGVDb250aW51ZVNlbGVjdFdpdGhvdXREZXNlbGVjdCA9IHRvZ2dsZUNvbnRpbnVlU2VsZWN0V2l0aG91dERlc2VsZWN0O1xuXG4gICAgICBfdGhpcy5zZXRLZXlFdmVudCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0UHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmdlc3RvLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSB2YWx1ZTtcbiAgfTtcblxuICBfX3Byb3RvLnNldENoZWNrSW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmdlc3RvLm9wdGlvbnMuY2hlY2tJbnB1dCA9IHZhbHVlO1xuICB9O1xuXG4gIF9fcHJvdG8uaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBkcmFnQ29udGFpbmVyID0gX2EuZHJhZ0NvbnRhaW5lcixcbiAgICAgICAgY2hlY2tJbnB1dCA9IF9hLmNoZWNrSW5wdXQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2EucHJldmVudERlZmF1bHQsXG4gICAgICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQgPSBfYS5wcmV2ZW50Q2xpY2tFdmVudE9uRHJhZ1N0YXJ0LFxuICAgICAgICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZyA9IF9hLnByZXZlbnRDbGlja0V2ZW50T25EcmFnLFxuICAgICAgICBwcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uID0gX2EucHJldmVudENsaWNrRXZlbnRCeUNvbmRpdGlvbixcbiAgICAgICAgX2IgPSBfYS5wcmV2ZW50UmlnaHRDbGljayxcbiAgICAgICAgcHJldmVudFJpZ2h0Q2xpY2sgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLFxuICAgICAgICBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gY3JlYXRlRWxlbWVudChoKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoQ0xBU1NfTkFNRSwgXCIgXCIpLmNvbmNhdChjbGFzc05hbWUgfHwgXCJcIilcbiAgICB9KSwgdGhpcy50YXJnZXQsIGNvbnRhaW5lcik7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIHRoaXMuZHJhZ0NvbnRhaW5lciA9IHR5cGVvZiBkcmFnQ29udGFpbmVyID09PSBcInN0cmluZ1wiID8gW10uc2xpY2UuY2FsbChnZXREb2N1bWVudChjb250YWluZXIpLnF1ZXJ5U2VsZWN0b3JBbGwoZHJhZ0NvbnRhaW5lcikpIDogZHJhZ0NvbnRhaW5lciB8fCB0aGlzLnRhcmdldC5wYXJlbnROb2RlO1xuICAgIHRoaXMuZ2VzdG8gPSBuZXcgR2VzdG8odGhpcy5kcmFnQ29udGFpbmVyLCB7XG4gICAgICBjaGVja1dpbmRvd0JsdXI6IHRydWUsXG4gICAgICBjb250YWluZXI6IGdldFdpbmRvdyhjb250YWluZXIpLFxuICAgICAgY2hlY2tJbnB1dDogY2hlY2tJbnB1dCxcbiAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQ6IHByZXZlbnRDbGlja0V2ZW50T25EcmFnU3RhcnQsXG4gICAgICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZzogcHJldmVudENsaWNrRXZlbnRPbkRyYWcsXG4gICAgICBwcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uOiBwcmV2ZW50Q2xpY2tFdmVudEJ5Q29uZGl0aW9uLFxuICAgICAgcHJldmVudFJpZ2h0Q2xpY2s6IHByZXZlbnRSaWdodENsaWNrXG4gICAgfSkub24oe1xuICAgICAgZHJhZ1N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcbiAgICAgIGRyYWc6IHRoaXMuX29uRHJhZyxcbiAgICAgIGRyYWdFbmQ6IHRoaXMuX29uRHJhZ0VuZFxuICAgIH0pO1xuICAgIGFkZEV2ZW50KGRvY3VtZW50LCBcInNlbGVjdHN0YXJ0XCIsIHRoaXMuX29uRG9jdW1lbnRTZWxlY3RTdGFydCk7XG4gICAgdGhpcy5pbmplY3RSZXN1bHQgPSBpbmplY3Rvci5pbmplY3QodGFyZ2V0LCB7XG4gICAgICBub25jZTogdGhpcy5vcHRpb25zLmNzcE5vbmNlXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5oaXRUZXN0ID0gZnVuY3Rpb24gKHNlbGVjdFJlY3QsIGRhdGEsIGlzRHJhZywgZ2VzdG9FdmVudCkge1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgaGl0UmF0ZSA9IF9hLmhpdFJhdGUsXG4gICAgICAgIHNlbGVjdEJ5Q2xpY2sgPSBfYS5zZWxlY3RCeUNsaWNrO1xuICAgIHZhciBsZWZ0ID0gc2VsZWN0UmVjdC5sZWZ0LFxuICAgICAgICB0b3AgPSBzZWxlY3RSZWN0LnRvcCxcbiAgICAgICAgcmlnaHQgPSBzZWxlY3RSZWN0LnJpZ2h0LFxuICAgICAgICBib3R0b20gPSBzZWxlY3RSZWN0LmJvdHRvbTtcbiAgICB2YXIgaW5uZXJHcm91cHMgPSBkYXRhLmlubmVyR3JvdXBzO1xuICAgIHZhciBpbm5lcldpZHRoID0gZGF0YS5pbm5lcldpZHRoO1xuICAgIHZhciBpbm5lckhlaWdodCA9IGRhdGEuaW5uZXJIZWlnaHQ7XG4gICAgdmFyIGNsaWVudFggPSBnZXN0b0V2ZW50ID09PSBudWxsIHx8IGdlc3RvRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlc3RvRXZlbnQuY2xpZW50WDtcbiAgICB2YXIgY2xpZW50WSA9IGdlc3RvRXZlbnQgPT09IG51bGwgfHwgZ2VzdG9FdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VzdG9FdmVudC5jbGllbnRZO1xuICAgIHZhciBpZ25vcmVDbGljayA9IGRhdGEuaWdub3JlQ2xpY2s7XG4gICAgdmFyIHJlY3RQb2ludHMgPSBbW2xlZnQsIHRvcF0sIFtyaWdodCwgdG9wXSwgW3JpZ2h0LCBib3R0b21dLCBbbGVmdCwgYm90dG9tXV07XG5cbiAgICB2YXIgaXNIaXQgPSBmdW5jdGlvbiAocG9pbnRzLCBlbCkge1xuICAgICAgdmFyIGhpdFJhdGVWYWx1ZSA9IHR5cGVvZiBoaXRSYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzcGxpdFVuaXQoXCJcIi5jb25jYXQoaGl0UmF0ZShlbCkpKSA6IHNwbGl0VW5pdChcIlwiLmNvbmNhdChoaXRSYXRlKSk7XG4gICAgICB2YXIgaW5BcmVhID0gaWdub3JlQ2xpY2sgPyBmYWxzZSA6IGlzSW5zaWRlKFtjbGllbnRYLCBjbGllbnRZXSwgcG9pbnRzKTtcblxuICAgICAgaWYgKCFpc0RyYWcgJiYgc2VsZWN0QnlDbGljayAmJiBpbkFyZWEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdmVybGFwUG9pbnRzID0gZ2V0T3ZlcmxhcFBvaW50cyhyZWN0UG9pbnRzLCBwb2ludHMpO1xuXG4gICAgICBpZiAoIW92ZXJsYXBQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG92ZXJsYXBTaXplID0gZ2V0QXJlYVNpemUob3ZlcmxhcFBvaW50cyk7IC8vIExpbmVcblxuICAgICAgdmFyIHRhcmdldFNpemUgPSAwO1xuXG4gICAgICBpZiAob3ZlcmxhcFNpemUgPT09IDAgJiYgZ2V0QXJlYVNpemUocG9pbnRzKSA9PT0gMCkge1xuICAgICAgICB0YXJnZXRTaXplID0gZ2V0TGluZVNpemUocG9pbnRzKTtcbiAgICAgICAgb3ZlcmxhcFNpemUgPSBnZXRMaW5lU2l6ZShvdmVybGFwUG9pbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFNpemUgPSBnZXRBcmVhU2l6ZShwb2ludHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGl0UmF0ZVZhbHVlLnVuaXQgPT09IFwicHhcIikge1xuICAgICAgICByZXR1cm4gb3ZlcmxhcFNpemUgPj0gaGl0UmF0ZVZhbHVlLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhdGUgPSBiZXR3ZWVuKE1hdGgucm91bmQob3ZlcmxhcFNpemUgLyB0YXJnZXRTaXplICogMTAwKSwgMCwgMTAwKTtcbiAgICAgICAgcmV0dXJuIHJhdGUgPj0gTWF0aC5taW4oMTAwLCBoaXRSYXRlVmFsdWUudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2VsZWN0YWJsZVRhcmdldHMgPSBkYXRhLnNlbGVjdGFibGVUYXJnZXRzO1xuICAgIHZhciBzZWxlY3RhYmxlUG9pbnRzID0gZGF0YS5zZWxlY3RhYmxlUG9pbnRzO1xuICAgIHZhciBzZWxlY3RhYmxlSW5uZXJzID0gZGF0YS5zZWxlY3RhYmxlSW5uZXJzO1xuXG4gICAgaWYgKCFpbm5lckdyb3Vwcykge1xuICAgICAgcmV0dXJuIHNlbGVjdGFibGVUYXJnZXRzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICBpZiAoIXNlbGVjdGFibGVJbm5lcnNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNIaXQoc2VsZWN0YWJsZVBvaW50c1tpXSwgc2VsZWN0YWJsZVRhcmdldHNbaV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGVkVGFyZ2V0cyA9IFtdO1xuICAgIHZhciBtaW5YID0gTWF0aC5mbG9vcihsZWZ0IC8gaW5uZXJXaWR0aCk7XG4gICAgdmFyIG1heFggPSBNYXRoLmZsb29yKHJpZ2h0IC8gaW5uZXJXaWR0aCk7XG4gICAgdmFyIG1pblkgPSBNYXRoLmZsb29yKHRvcCAvIGlubmVySGVpZ2h0KTtcbiAgICB2YXIgbWF4WSA9IE1hdGguZmxvb3IoYm90dG9tIC8gaW5uZXJIZWlnaHQpO1xuXG4gICAgZm9yICh2YXIgeCA9IG1pblg7IHggPD0gbWF4WDsgKyt4KSB7XG4gICAgICB2YXIgeUdyb3VwcyA9IGlubmVyR3JvdXBzW3hdO1xuXG4gICAgICBpZiAoIXlHcm91cHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHkgPSBtaW5ZOyB5IDw9IG1heFk7ICsreSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB5R3JvdXBzW3ldO1xuXG4gICAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHNlbGVjdGFibGVQb2ludHNbaW5kZXhdO1xuICAgICAgICAgIHZhciBpbm5lciA9IHNlbGVjdGFibGVJbm5lcnNbaW5kZXhdO1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBzZWxlY3RhYmxlVGFyZ2V0c1tpbmRleF07XG5cbiAgICAgICAgICBpZiAoaW5uZXIgJiYgaXNIaXQocG9pbnRzLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlckR1cGxpY2F0ZWQoc2VsZWN0ZWRUYXJnZXRzKTtcbiAgfTtcblxuICBfX3Byb3RvLmluaXREcmFnU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRyYWdTY3JvbGwub24oXCJzY3JvbGxEcmFnXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG5leHQgPSBfYS5uZXh0O1xuICAgICAgbmV4dChfdGhpcy5nZXN0by5nZXRDdXJyZW50RXZlbnQoKSk7XG4gICAgfSkub24oXCJzY3JvbGxcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX2EuY29udGFpbmVyLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcblxuICAgICAgdmFyIGlubmVyU2Nyb2xsT3B0aW9ucyA9IF90aGlzLmdlc3RvLmdldEV2ZW50RGF0YSgpLmlubmVyU2Nyb2xsT3B0aW9ucztcblxuICAgICAgaWYgKGlubmVyU2Nyb2xsT3B0aW9ucykge1xuICAgICAgICBfdGhpcy5lbWl0KFwiaW5uZXJTY3JvbGxcIiwge1xuICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkub24oXCJtb3ZlXCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIG9mZnNldFggPSBfYS5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfYS5vZmZzZXRZLFxuICAgICAgICAgIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xuICAgICAgdmFyIGdlc3RvID0gX3RoaXMuZ2VzdG87XG5cbiAgICAgIGlmICghZ2VzdG8gfHwgIWdlc3RvLmlzRmxhZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKTtcblxuICAgICAgdmFyIGJvdW5kQXJlYSA9IGRhdGEuYm91bmRBcmVhO1xuICAgICAgZGF0YS5zdGFydFggLT0gb2Zmc2V0WDtcbiAgICAgIGRhdGEuc3RhcnRZIC09IG9mZnNldFk7XG5cbiAgICAgIHZhciBpbm5lclNjcm9sbE9wdGlvbnMgPSBfdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKS5pbm5lclNjcm9sbE9wdGlvbnM7XG5cbiAgICAgIHZhciBjb250YWluZXIgPSBpbm5lclNjcm9sbE9wdGlvbnMgPT09IG51bGwgfHwgaW5uZXJTY3JvbGxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbm5lclNjcm9sbE9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgdmFyIGlzTW92ZUlubmVyU2Nyb2xsID0gZmFsc2U7XG5cbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIHBhcmVudE1hcF8yID0gZGF0YS5zZWxlY3RhYmxlSW5uZXJTY3JvbGxQYXJlbnRNYXA7XG4gICAgICAgIHZhciBwYXJlbnRJbmZvID0gcGFyZW50TWFwXzIuZ2V0KGNvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgICBwYXJlbnRJbmZvLnBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwYXJlbnRNYXBfMi5nZXQoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckluZm8ucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICBwb3NbMF0gLT0gb2Zmc2V0WDtcbiAgICAgICAgICAgICAgcG9zWzFdIC09IG9mZnNldFk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXJlbnRJbmZvLmluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0YWJsZVBvaW50c1tpbmRleF0uZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICAgIHBvc1swXSAtPSBvZmZzZXRYO1xuICAgICAgICAgICAgICBwb3NbMV0gLT0gb2Zmc2V0WTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzTW92ZUlubmVyU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTW92ZUlubmVyU2Nyb2xsKSB7XG4gICAgICAgIGRhdGEuc2VsZWN0YWJsZVBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICBwb3NbMF0gLT0gb2Zmc2V0WDtcbiAgICAgICAgICAgIHBvc1sxXSAtPSBvZmZzZXRZO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuX3JlZnJlc2hHcm91cHMoZGF0YSk7XG5cbiAgICAgIGJvdW5kQXJlYS5sZWZ0IC09IG9mZnNldFg7XG4gICAgICBib3VuZEFyZWEucmlnaHQgLT0gb2Zmc2V0WDtcbiAgICAgIGJvdW5kQXJlYS50b3AgLT0gb2Zmc2V0WTtcbiAgICAgIGJvdW5kQXJlYS5ib3R0b20gLT0gb2Zmc2V0WTtcblxuICAgICAgX3RoaXMuZ2VzdG8uc2Nyb2xsQnkob2Zmc2V0WCwgb2Zmc2V0WSwgaW5wdXRFdmVudC5pbnB1dEV2ZW50KTtcblxuICAgICAgX3RoaXMuX2NoZWNrU2VsZWN0ZWQoX3RoaXMuZ2VzdG8uZ2V0Q3VycmVudEV2ZW50KCkpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RlZFRhcmdldHMsIHJlY3QsIGUsIGlzU3RhcnQsIGlzRHJhZ1N0YXJ0RW5kKSB7XG4gICAgaWYgKGlzRHJhZ1N0YXJ0RW5kID09PSB2b2lkIDApIHtcbiAgICAgIGlzRHJhZ1N0YXJ0RW5kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQ7XG4gICAgdmFyIGRhdGEgPSBlLmRhdGE7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc2V0U2VsZWN0ZWRUYXJnZXRzKHNlbGVjdGVkVGFyZ2V0cyk7XG5cbiAgICB2YXIgX2EgPSBkaWZmKGRhdGEuc3RhcnRTZWxlY3RlZFRhcmdldHMsIHNlbGVjdGVkVGFyZ2V0cyksXG4gICAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgICBwcmV2TGlzdCA9IF9hLnByZXZMaXN0LFxuICAgICAgICBsaXN0ID0gX2EubGlzdDtcblxuICAgIHZhciBzdGFydFJlc3VsdCA9IHtcbiAgICAgIHN0YXJ0U2VsZWN0ZWQ6IHByZXZMaXN0LFxuICAgICAgc3RhcnRBZGRlZDogYWRkZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBsaXN0W2ldO1xuICAgICAgfSksXG4gICAgICBzdGFydFJlbW92ZWQ6IHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwcmV2TGlzdFtpXTtcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdGhlIHNlbGVjdChkcmFnKSBzdGFydHMsIHRoZSBzZWxlY3RTdGFydCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IHNlbGVjdFN0YXJ0XG4gICAgICAgKiBAcGFyYW0ge1NlbGVjdG8uT25TZWxlY3R9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHNlbGVjdFN0YXJ0IGV2ZW50XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgICAqXG4gICAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICAgKiAgIHNlbGVjdEJ5Q2xpY2s6IHRydWUsXG4gICAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogc2VsZWN0by5vbihcInNlbGVjdFN0YXJ0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSkub24oXCJzZWxlY3RFbmRcIiwgZSA9PiB7XG4gICAgICAgKiAgIGUuYWZ0ZXJBZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogICBlLmFmdGVyUmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdChcInNlbGVjdFN0YXJ0XCIsIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCBzdGFydFJlc3VsdCksIHtcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgICAgZGF0YTogZGF0YS5kYXRhLFxuICAgICAgICBpc1RydXN0ZWQ6IGUuaXNUcnVzdGVkLFxuICAgICAgICBpc0RyYWdTdGFydEVuZDogaXNEcmFnU3RhcnRFbmRcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmFkZGVkLmxlbmd0aCB8fCByZXN1bHQucmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0aGUgc2VsZWN0IGluIHJlYWwgdGltZSwgdGhlIHNlbGVjdCBldmVudCBpcyBjYWxsZWQuXG4gICAgICAgKiBAbWVtYmVyb2YgU2VsZWN0b1xuICAgICAgICogQGV2ZW50IHNlbGVjdFxuICAgICAgICogQHBhcmFtIHtTZWxlY3RvLk9uU2VsZWN0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBzZWxlY3QgZXZlbnRcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBpbXBvcnQgU2VsZWN0byBmcm9tIFwic2VsZWN0b1wiO1xuICAgICAgICpcbiAgICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICAgKiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBzZWxlY3RvLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAgICogICBlLmFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAgICogICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAqICAgfSk7XG4gICAgICAgKiAgIGUucmVtb3ZlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgKiAgIH0pO1xuICAgICAgICogfSk7XG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdChcInNlbGVjdFwiLCBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0KSwgc3RhcnRSZXN1bHQpLCB7XG4gICAgICAgIHJlY3Q6IHJlY3QsXG4gICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgaXNUcnVzdGVkOiBlLmlzVHJ1c3RlZCxcbiAgICAgICAgaXNEcmFnU3RhcnRFbmQ6IGlzRHJhZ1N0YXJ0RW5kXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8uX3NlbGVjdEVuZCA9IGZ1bmN0aW9uIChzdGFydFNlbGVjdGVkVGFyZ2V0cywgc3RhcnRQYXNzZWRUYXJnZXRzLCByZWN0LCBlLCBpc0RyYWdTdGFydEVuZCkge1xuICAgIGlmIChpc0RyYWdTdGFydEVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpc0RyYWdTdGFydEVuZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LFxuICAgICAgICBpc0RvdWJsZSA9IGUuaXNEb3VibGUsXG4gICAgICAgIGRhdGEgPSBlLmRhdGE7XG4gICAgdmFyIHR5cGUgPSBpbnB1dEV2ZW50ICYmIGlucHV0RXZlbnQudHlwZTtcbiAgICB2YXIgaXNEcmFnU3RhcnQgPSB0eXBlID09PSBcIm1vdXNlZG93blwiIHx8IHR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xuXG4gICAgdmFyIF9hID0gZGlmZihzdGFydFNlbGVjdGVkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgICAgcHJldkxpc3QgPSBfYS5wcmV2TGlzdCxcbiAgICAgICAgbGlzdCA9IF9hLmxpc3Q7XG5cbiAgICB2YXIgX2IgPSBkaWZmKHN0YXJ0UGFzc2VkVGFyZ2V0cywgdGhpcy5zZWxlY3RlZFRhcmdldHMpLFxuICAgICAgICBhZnRlckFkZGVkID0gX2IuYWRkZWQsXG4gICAgICAgIGFmdGVyUmVtb3ZlZCA9IF9iLnJlbW92ZWQsXG4gICAgICAgIGFmdGVyUHJldkxpc3QgPSBfYi5wcmV2TGlzdCxcbiAgICAgICAgYWZ0ZXJMaXN0ID0gX2IubGlzdDtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzZWxlY3QoZHJhZ0VuZCBvciBjbGljaykgZW5kcywgdGhlIHNlbGVjdEVuZCBldmVudCBpcyBjYWxsZWQuXG4gICAgICogQG1lbWJlcm9mIFNlbGVjdG9cbiAgICAgKiBAZXZlbnQgc2VsZWN0RW5kXG4gICAgICogQHBhcmFtIHtTZWxlY3RvLk9uU2VsZWN0RW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBzZWxlY3RFbmQgZXZlbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCBTZWxlY3RvIGZyb20gXCJzZWxlY3RvXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBzZWxlY3RvID0gbmV3IFNlbGVjdG8oe1xuICAgICAqICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5LFxuICAgICAqICAgc2VsZWN0QnlDbGljazogdHJ1ZSxcbiAgICAgKiAgIHNlbGVjdEZyb21JbnNpZGU6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2VsZWN0by5vbihcInNlbGVjdFN0YXJ0XCIsIGUgPT4ge1xuICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pLm9uKFwic2VsZWN0RW5kXCIsIGUgPT4ge1xuICAgICAqICAgZS5hZnRlckFkZGVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiAgIGUuYWZ0ZXJSZW1vdmVkLmZvckVhY2goZWwgPT4ge1xuICAgICAqICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRcIik7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuXG4gICAgdGhpcy5lbWl0KFwic2VsZWN0RW5kXCIsIHtcbiAgICAgIHN0YXJ0U2VsZWN0ZWQ6IHN0YXJ0U2VsZWN0ZWRUYXJnZXRzLFxuICAgICAgYmVmb3JlU2VsZWN0ZWQ6IHN0YXJ0UGFzc2VkVGFyZ2V0cyxcbiAgICAgIHNlbGVjdGVkOiB0aGlzLnNlbGVjdGVkVGFyZ2V0cyxcbiAgICAgIGFkZGVkOiBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICAgIH0pLFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGFmdGVyQWRkZWQ6IGFmdGVyQWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gYWZ0ZXJMaXN0W2luZGV4XTtcbiAgICAgIH0pLFxuICAgICAgYWZ0ZXJSZW1vdmVkOiBhZnRlclJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gYWZ0ZXJQcmV2TGlzdFtpbmRleF07XG4gICAgICB9KSxcbiAgICAgIGlzRHJhZ1N0YXJ0OiBpc0RyYWdTdGFydCAmJiBpc0RyYWdTdGFydEVuZCxcbiAgICAgIGlzRHJhZ1N0YXJ0RW5kOiBpc0RyYWdTdGFydCAmJiBpc0RyYWdTdGFydEVuZCxcbiAgICAgIGlzQ2xpY2s6ICEhZS5pc0NsaWNrLFxuICAgICAgaXNEb3VibGU6ICEhaXNEb3VibGUsXG4gICAgICByZWN0OiByZWN0LFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgIGlzVHJ1c3RlZDogZS5pc1RydXN0ZWRcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9jaGVja1NlbGVjdGVkID0gZnVuY3Rpb24gKGUsIHJlY3QpIHtcbiAgICBpZiAocmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZWN0ID0gZ2V0UmVjdChlLCB0aGlzLm9wdGlvbnMucmF0aW8pO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgIHZhciB0b3AgPSByZWN0LnRvcCxcbiAgICAgICAgbGVmdCA9IHJlY3QubGVmdCxcbiAgICAgICAgd2lkdGggPSByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB2YXIgc2VsZWN0RmxhZyA9IGRhdGEuc2VsZWN0RmxhZztcbiAgICB2YXIgY29udGFpbmVyWCA9IGRhdGEuY29udGFpbmVyWCxcbiAgICAgICAgY29udGFpbmVyWSA9IGRhdGEuY29udGFpbmVyWSxcbiAgICAgICAgc2NhbGVNYXRyaXggPSBkYXRhLnNjYWxlTWF0cml4O1xuICAgIHZhciBvZmZzZXRQb3MgPSBjYWxjdWxhdGVNYXRyaXhEaXN0KHNjYWxlTWF0cml4LCBbbGVmdCAtIGNvbnRhaW5lclgsIHRvcCAtIGNvbnRhaW5lclldKTtcbiAgICB2YXIgb2Zmc2V0U2l6ZSA9IGNhbGN1bGF0ZU1hdHJpeERpc3Qoc2NhbGVNYXRyaXgsIFt3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdmFyIHNlbGVjdGVkVGFyZ2V0cyA9IFtdO1xuXG4gICAgaWYgKHNlbGVjdEZsYWcpIHtcbiAgICAgIHRoaXMudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gXCJkaXNwbGF5OiBibG9jaztcIiArIFwibGVmdDowcHg7dG9wOjBweDtcIiArIFwidHJhbnNmb3JtOiB0cmFuc2xhdGUoXCIuY29uY2F0KG9mZnNldFBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChvZmZzZXRQb3NbMV0sIFwicHgpO1wiKSArIFwid2lkdGg6XCIuY29uY2F0KG9mZnNldFNpemVbMF0sIFwicHg7aGVpZ2h0OlwiKS5jb25jYXQob2Zmc2V0U2l6ZVsxXSwgXCJweDtcIik7XG4gICAgICB2YXIgcGFzc2VkVGFyZ2V0cyA9IHRoaXMuaGl0VGVzdChyZWN0LCBkYXRhLCB0cnVlLCBlKTtcbiAgICAgIHNlbGVjdGVkVGFyZ2V0cyA9IHBhc3NUYXJnZXRzKGRhdGEuc3RhcnRQYXNzZWRUYXJnZXRzLCBwYXNzZWRUYXJnZXRzLCB0aGlzLmNvbnRpbnVlU2VsZWN0ICYmIHRoaXMuY29udGludWVTZWxlY3RXaXRob3V0RGVzZWxlY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBkcmFnLCB0aGUgZHJhZyBldmVudCBpcyBjYWxsZWQuXG4gICAgICogQ2FsbCB0aGUgc3RvcCAoKSBmdW5jdGlvbiBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGVsZW1lbnQgb3IgZG9uJ3Qgd2FudCB0byByYWlzZSBhIHNlbGVjdFxuICAgICAqIEBtZW1iZXJvZiBTZWxlY3RvXG4gICAgICogQGV2ZW50IGRyYWdcbiAgICAgKiBAcGFyYW0ge09uRHJhZ30gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZyBldmVudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IFNlbGVjdG8gZnJvbSBcInNlbGVjdG9cIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IHNlbGVjdG8gPSBuZXcgU2VsZWN0byh7XG4gICAgICogICBjb250YWluZXI6IGRvY3VtZW50LmJvZHksXG4gICAgICogICBzZWxlY3RCeUNsaWNrOiB0cnVlLFxuICAgICAqICAgc2VsZWN0RnJvbUluc2lkZTogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzZWxlY3RvLm9uKFwiZHJhZ1wiLCBlID0+IHtcbiAgICAgKiAgIGUuc3RvcCgpO1xuICAgICAqIH0pLm9uKFwic2VsZWN0XCIsIGUgPT4ge1xuICAgICAqICAgZS5hZGRlZC5mb3JFYWNoKGVsID0+IHtcbiAgICAgKiAgICAgZWwuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpO1xuICAgICAqICAgfSk7XG4gICAgICogICBlLnJlbW92ZWQuZm9yRWFjaChlbCA9PiB7XG4gICAgICogICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZFwiKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbWl0KFwiZHJhZ1wiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHtcbiAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgIGlzU2VsZWN0OiBzZWxlY3RGbGFnLFxuICAgICAgcmVjdDogcmVjdFxuICAgIH0pKTtcblxuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnRhcmdldC5zdHlsZS5jc3NUZXh0ICs9IFwiZGlzcGxheTogbm9uZTtcIjtcbiAgICAgIGUuc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RGbGFnKSB7XG4gICAgICB0aGlzLl9zZWxlY3Qoc2VsZWN0ZWRUYXJnZXRzLCByZWN0LCBlKTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5fc2FtZUNvbWJpS2V5ID0gZnVuY3Rpb24gKGUsIGtleXMsIGlzS2V5dXApIHtcbiAgICBpZiAoIWtleXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYmkgPSBnZXRDb21iaShlLmlucHV0RXZlbnQsIGUua2V5KTtcbiAgICB2YXIgbmV4dEtleXMgPSBbXS5jb25jYXQoa2V5cyk7XG4gICAgdmFyIHRvZ2dsZUtleXMgPSBpc0FycmF5KG5leHRLZXlzWzBdKSA/IG5leHRLZXlzIDogW25leHRLZXlzXTtcblxuICAgIGlmIChpc0tleXVwKSB7XG4gICAgICB2YXIgc2luZ2xlS2V5XzEgPSBlLmtleTtcbiAgICAgIHJldHVybiB0b2dnbGVLZXlzLnNvbWUoZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGtleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleSA9PT0gc2luZ2xlS2V5XzE7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvZ2dsZUtleXMuc29tZShmdW5jdGlvbiAoa2V5cykge1xuICAgICAgcmV0dXJuIGtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY29tYmkuaW5kZXhPZihrZXkpID4gLTE7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9maW5kRWxlbWVudCA9IGZ1bmN0aW9uIChjbGlja2VkVGFyZ2V0LCBzZWxlY3RhYmxlVGFyZ2V0cykge1xuICAgIHZhciBwb2ludFRhcmdldCA9IGNsaWNrZWRUYXJnZXQ7XG5cbiAgICB3aGlsZSAocG9pbnRUYXJnZXQpIHtcbiAgICAgIGlmIChzZWxlY3RhYmxlVGFyZ2V0cy5pbmRleE9mKHBvaW50VGFyZ2V0KSA+IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb2ludFRhcmdldCA9IHBvaW50VGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50VGFyZ2V0O1xuICB9O1xuXG4gIF9fcHJvdG8uX3JlZnJlc2hHcm91cHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBpbm5lcldpZHRoID0gZGF0YS5pbm5lcldpZHRoO1xuICAgIHZhciBpbm5lckhlaWdodCA9IGRhdGEuaW5uZXJIZWlnaHQ7XG4gICAgdmFyIHNlbGVjdGFibGVQb2ludHMgPSBkYXRhLnNlbGVjdGFibGVQb2ludHM7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNoZWNrT3ZlcmZsb3cpIHtcbiAgICAgIHZhciBpbm5lclNjcm9sbENvbnRhaW5lcl8xID0gKF9hID0gdGhpcy5nZXN0by5nZXRFdmVudERhdGEoKS5pbm5lclNjcm9sbE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWluZXI7XG4gICAgICB2YXIgcGFyZW50TWFwXzMgPSBkYXRhLnNlbGVjdGFibGVJbm5lclNjcm9sbFBhcmVudE1hcDtcbiAgICAgIHZhciBpbm5lclNjcm9sbFBhdGhzTGlzdCA9IGRhdGEuc2VsZWN0YWJsZUlubmVyU2Nyb2xsUGF0aHNMaXN0O1xuICAgICAgZGF0YS5zZWxlY3RhYmxlSW5uZXJzID0gaW5uZXJTY3JvbGxQYXRoc0xpc3QubWFwKGZ1bmN0aW9uIChpbm5lclNjcm9sbFBhdGhzLCBpKSB7XG4gICAgICAgIHZhciBpc0Fsd2F5c1RydWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGlubmVyU2Nyb2xsUGF0aHMuZXZlcnkoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIGlmIChpc0Fsd2F5c1RydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGlubmVyU2Nyb2xsQ29udGFpbmVyXzEpIHtcbiAgICAgICAgICAgIGlzQWx3YXlzVHJ1ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjdCA9IHBhcmVudE1hcF8zLmdldCh0YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMxID0gc2VsZWN0YWJsZVBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciBwb2ludHMyID0gcmVjdC5wb2ludHM7XG4gICAgICAgICAgICB2YXIgb3ZlcmxhcFBvaW50cyA9IGdldE92ZXJsYXBQb2ludHMocG9pbnRzMSwgcG9pbnRzMik7XG5cbiAgICAgICAgICAgIGlmICghb3ZlcmxhcFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaW5uZXJXaWR0aCB8fCAhaW5uZXJIZWlnaHQpIHtcbiAgICAgIGRhdGEuaW5uZXJHcm91cHMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2VsZWN0YWJsZVBvaW50c18xID0gZGF0YS5zZWxlY3RhYmxlUG9pbnRzO1xuICAgICAgdmFyIGdyb3Vwc18xID0ge307XG4gICAgICBzZWxlY3RhYmxlUG9pbnRzXzEuZm9yRWFjaChmdW5jdGlvbiAocG9pbnRzLCBpKSB7XG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihwb3NbMF0gLyBpbm5lcldpZHRoKTtcbiAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IocG9zWzFdIC8gaW5uZXJIZWlnaHQpO1xuICAgICAgICAgIG1pblggPSBNYXRoLm1pbih4LCBtaW5YKTtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoeCwgbWF4WCk7XG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgICAgIG1heFkgPSBNYXRoLm1heCh5LCBtYXhZKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgeCA9IG1pblg7IHggPD0gbWF4WDsgKyt4KSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IG1pblk7IHkgPD0gbWF4WTsgKyt5KSB7XG4gICAgICAgICAgICBncm91cHNfMVt4XSA9IGdyb3Vwc18xW3hdIHx8IHt9O1xuICAgICAgICAgICAgZ3JvdXBzXzFbeF1beV0gPSBncm91cHNfMVt4XVt5XSB8fCBbXTtcbiAgICAgICAgICAgIGdyb3Vwc18xW3hdW3ldLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRhdGEuaW5uZXJHcm91cHMgPSBncm91cHNfMTtcbiAgICB9XG4gIH07XG5cbiAgU2VsZWN0byA9IF9fZGVjb3JhdGUoW1Byb3BlcnRpZXMoUFJPUEVSVElFUywgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHkpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ2V0dGVyID0gY2FtZWxpemUoXCJnZXQgXCIuY29uY2F0KHByb3BlcnR5KSk7XG5cbiAgICBpZiAocHJvdG90eXBlW2dldHRlcl0pIHtcbiAgICAgIGF0dHJpYnV0ZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tnZXR0ZXJdKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzZXR0ZXIgPSBjYW1lbGl6ZShcInNldCBcIi5jb25jYXQocHJvcGVydHkpKTtcblxuICAgIGlmIChwcm90b3R5cGVbc2V0dGVyXSkge1xuICAgICAgYXR0cmlidXRlcy5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpc1tzZXR0ZXJdKHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcGVydHksIGF0dHJpYnV0ZXMpO1xuICB9KV0sIFNlbGVjdG8pO1xuICByZXR1cm4gU2VsZWN0bztcbn0oRXZlbnRFbWl0dGVyKTtcblxudmFyIFNlbGVjdG8kMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTZWxlY3RvLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdG8oKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNlbGVjdG87XG59KFNlbGVjdG8pO1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RvJDE7XG5leHBvcnQgeyBDTEFTU19OQU1FLCBFVkVOVFMsIE1FVEhPRFMsIE9QVElPTlMsIE9QVElPTl9UWVBFUywgUFJPUEVSVElFUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0by5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/selecto/dist/selecto.esm.js\n");

/***/ })

};
;