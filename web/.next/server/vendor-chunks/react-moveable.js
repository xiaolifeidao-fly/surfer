"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-moveable";
exports.ids = ["vendor-chunks/react-moveable"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-moveable/dist/moveable.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-moveable/dist/moveable.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Clippable: () => (/* binding */ Clippable),\n/* harmony export */   DIRECTIONS: () => (/* binding */ DIRECTIONS),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   EdgeDraggable: () => (/* binding */ edgeDraggable),\n/* harmony export */   InitialMoveable: () => (/* binding */ InitialMoveable),\n/* harmony export */   MOVEABLE_ABLES: () => (/* binding */ MOVEABLE_ABLES),\n/* harmony export */   MOVEABLE_EVENTS: () => (/* binding */ MOVEABLE_EVENTS),\n/* harmony export */   MOVEABLE_METHODS: () => (/* binding */ MOVEABLE_METHODS),\n/* harmony export */   MOVEABLE_PROPS: () => (/* binding */ MOVEABLE_PROPS),\n/* harmony export */   Pinchable: () => (/* binding */ Pinchable),\n/* harmony export */   Resizable: () => (/* binding */ Resizable),\n/* harmony export */   Rotatable: () => (/* binding */ Rotatable),\n/* harmony export */   Roundable: () => (/* binding */ Roundable),\n/* harmony export */   Scalable: () => (/* binding */ Scalable),\n/* harmony export */   Snappable: () => (/* binding */ Snappable),\n/* harmony export */   Warpable: () => (/* binding */ Warpable),\n/* harmony export */   calculateElementPosition: () => (/* binding */ calculateElementPosition),\n/* harmony export */   \"default\": () => (/* binding */ Moveable),\n/* harmony export */   getElementInfo: () => (/* binding */ getElementInfo),\n/* harmony export */   makeAble: () => (/* binding */ makeAble),\n/* harmony export */   makeMoveable: () => (/* binding */ makeMoveable)\n/* harmony export */ });\n/* harmony import */ var _egjs_agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @egjs/agent */ \"(ssr)/./node_modules/@egjs/agent/dist/agent.esm.js\");\n/* harmony import */ var framework_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! framework-utils */ \"(ssr)/./node_modules/framework-utils/dist/utils.esm.js\");\n/* harmony import */ var _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @daybrush/utils */ \"(ssr)/./node_modules/@daybrush/utils/dist/utils.esm.js\");\n/* harmony import */ var _scena_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scena/matrix */ \"(ssr)/./node_modules/@scena/matrix/dist/matrix.esm.js\");\n/* harmony import */ var css_to_mat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! css-to-mat */ \"(ssr)/./node_modules/css-to-mat/dist/css-to-mat.esm.js\");\n/* harmony import */ var _egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @egjs/children-differ */ \"(ssr)/./node_modules/@egjs/children-differ/dist/children-differ.esm.js\");\n/* harmony import */ var _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @scena/dragscroll */ \"(ssr)/./node_modules/@scena/dragscroll/dist/dragscroll.esm.js\");\n/* harmony import */ var overlap_area__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! overlap-area */ \"(ssr)/./node_modules/overlap-area/dist/overlap-area.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var gesto__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gesto */ \"(ssr)/./node_modules/gesto/dist/gesto.esm.js\");\n/* harmony import */ var react_css_styled__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react-css-styled */ \"(ssr)/./node_modules/react-css-styled/dist/styled.esm.js\");\n/* harmony import */ var _scena_event_emitter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @scena/event-emitter */ \"(ssr)/./node_modules/@scena/event-emitter/dist/event-emitter.esm.js\");\n/* harmony import */ var _egjs_list_differ__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @egjs/list-differ */ \"(ssr)/./node_modules/@egjs/list-differ/dist/list-differ.esm.js\");\n/*\nCopyright (c) 2019 Daybrush\nname: react-moveable\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable\nversion: 0.56.0\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nfunction makeAble(name, able) {\r\n    return __assign({ events: [], props: [], name: name }, able);\r\n}\n\nvar DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"];\r\nvar DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\r\nfunction getSVGCursor(scale, degree) {\r\n    return \"data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\".concat(32 * scale, \"px\\\" height=\\\"\").concat(32 * scale, \"px\\\" viewBox=\\\"0 0 32 32\\\" ><path d=\\\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"1.2\\\" fill=\\\"black\\\" stroke=\\\"white\\\" style=\\\"transform:rotate(\").concat(degree, \"deg);transform-origin: 16px 16px\\\"></path></svg>\");\r\n}\r\nfunction getCursorCSS(degree) {\r\n    var x1 = getSVGCursor(1, degree);\r\n    // const x2 = getSVGCursor(2, degree);\r\n    var degree45 = (Math.round(degree / 45) * 45) % 180;\r\n    var defaultCursor = \"ns-resize\";\r\n    if (degree45 === 135) {\r\n        defaultCursor = \"nwse-resize\";\r\n    }\r\n    else if (degree45 === 45) {\r\n        defaultCursor = \"nesw-resize\";\r\n    }\r\n    else if (degree45 === 90) {\r\n        defaultCursor = \"ew-resize\";\r\n    }\r\n    // tslint:disable-next-line: max-line-length\r\n    return \"cursor:\".concat(defaultCursor, \";cursor: url('\").concat(x1, \"') 16 16, \").concat(defaultCursor, \";\");\r\n}\r\nvar agent = (0,_egjs_agent__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\r\nvar IS_WEBKIT = agent.browser.webkit;\r\nvar IS_WEBKIT605 = IS_WEBKIT && (function () {\r\n    var navi = typeof window === \"undefined\" ? { userAgent: \"\" } : window.navigator;\r\n    var res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\r\n    return res ? parseFloat(res[1]) < 605 : false;\r\n})();\r\nvar browserName = agent.browser.name;\r\nvar browserVersion = parseInt(agent.browser.version, 10);\r\nvar IS_CHROME = browserName === \"chrome\";\r\nvar IS_CHROMIUM = agent.browser.chromium;\r\nvar chromiumVersion = parseInt(agent.browser.chromiumVersion, 10) || 0;\r\nvar IS_CHROMIUM109 = (IS_CHROME && browserVersion >= 109)\r\n    || (IS_CHROMIUM && chromiumVersion >= 109);\r\nvar IS_FIREFOX = browserName === \"firefox\";\r\nvar IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612\r\n    || browserVersion >= 15;\r\nvar PREFIX = \"moveable-\";\r\nvar directionCSS = DIRECTIONS.map(function (dir) {\r\n    var top = \"\";\r\n    var left = \"\";\r\n    var originX = \"center\";\r\n    var originY = \"center\";\r\n    var offset = \"calc(var(--moveable-control-padding, 20) * -1px)\";\r\n    if (dir.indexOf(\"n\") > -1) {\r\n        top = \"top: \".concat(offset, \";\");\r\n        originY = \"bottom\";\r\n    }\r\n    if (dir.indexOf(\"s\") > -1) {\r\n        top = \"top: 0px;\";\r\n        originY = \"top\";\r\n    }\r\n    if (dir.indexOf(\"w\") > -1) {\r\n        left = \"left: \".concat(offset, \";\");\r\n        originX = \"right\";\r\n    }\r\n    if (dir.indexOf(\"e\") > -1) {\r\n        left = \"left: 0px;\";\r\n        originX = \"left\";\r\n    }\r\n    return \".around-control[data-direction*=\\\"\".concat(dir, \"\\\"] {\\n        \").concat(left).concat(top, \"\\n        transform-origin: \").concat(originX, \" \").concat(originY, \";\\n    }\");\r\n}).join(\"\\n\");\r\nvar MOVEABLE_CSS = \"\\n{\\nposition: absolute;\\nwidth: 1px;\\nheight: 1px;\\nleft: 0;\\ntop: 0;\\nz-index: 3000;\\n--moveable-color: #4af;\\n--zoom: 1;\\n--zoompx: 1px;\\n--moveable-line-padding: 0;\\n--moveable-control-padding: 0;\\nwill-change: transform;\\noutline: 1px solid transparent;\\n}\\n.control-box {\\nz-index: 0;\\n}\\n.line, .control {\\nposition: absolute;\\nleft: 0;\\ntop: 0;\\nwill-change: transform;\\n}\\n.control {\\nwidth: 14px;\\nheight: 14px;\\nborder-radius: 50%;\\nborder: 2px solid #fff;\\nbox-sizing: border-box;\\nbackground: #4af;\\nbackground: var(--moveable-color);\\nmargin-top: -7px;\\nmargin-left: -7px;\\nborder: 2px solid #fff;\\nz-index: 10;\\n}\\n.around-control {\\nposition: absolute;\\nwill-change: transform;\\nwidth: calc(var(--moveable-control-padding, 20) * 1px);\\nheight: calc(var(--moveable-control-padding, 20) * 1px);\\nleft: calc(var(--moveable-control-padding, 20) * -0.5px);\\ntop: calc(var(--moveable-control-padding, 20) * -0.5px);\\nbox-sizing: border-box;\\nbackground: transparent;\\nz-index: 8;\\ncursor: alias;\\ntransform-origin: center center;\\n}\\n\".concat(directionCSS, \"\\n.padding {\\nposition: absolute;\\ntop: 0px;\\nleft: 0px;\\nwidth: 100px;\\nheight: 100px;\\ntransform-origin: 0 0;\\n}\\n.line {\\nwidth: 1px;\\nheight: 1px;\\nbackground: #4af;\\nbackground: var(--moveable-color);\\ntransform-origin: 0px 50%;\\n}\\n.line.edge {\\nz-index: 1;\\nbackground: transparent;\\n}\\n.line.dashed {\\nbox-sizing: border-box;\\nbackground: transparent;\\n}\\n.line.dashed.horizontal {\\nborder-top: 1px dashed #4af;\\nborder-top-color: #4af;\\nborder-top-color: var(--moveable-color);\\n}\\n.line.dashed.vertical {\\nborder-left: 1px dashed #4af;\\nborder-left-color: #4af;\\nborder-left-color: var(--moveable-color);\\n}\\n.line.vertical {\\ntransform: translateX(-50%);\\n}\\n.line.horizontal {\\ntransform: translateY(-50%);\\n}\\n.line.vertical.bold {\\nwidth: 2px;\\n}\\n.line.horizontal.bold {\\nheight: 2px;\\n}\\n\\n.control.origin {\\nborder-color: #f55;\\nbackground: #fff;\\nwidth: 12px;\\nheight: 12px;\\nmargin-top: -6px;\\nmargin-left: -6px;\\npointer-events: none;\\n}\\n\").concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) { return \"\\n.direction[data-rotation=\\\"\".concat(degree, \"\\\"], :global .view-control-rotation\").concat(degree, \" {\\n\").concat(getCursorCSS(degree), \"\\n}\\n\"); }).join(\"\\n\"), \"\\n\\n.line.direction:before {\\ncontent: \\\"\\\";\\nposition: absolute;\\nwidth: 100%;\\nheight: calc(var(--moveable-line-padding, 0) * 1px);\\nbottom: 0;\\nleft: 0;\\n}\\n.group {\\nz-index: -1;\\n}\\n.area {\\nposition: absolute;\\n}\\n.area-pieces {\\nposition: absolute;\\ntop: 0;\\nleft: 0;\\ndisplay: none;\\n}\\n.area.avoid, .area.pass {\\npointer-events: none;\\n}\\n.area.avoid+.area-pieces {\\ndisplay: block;\\n}\\n.area-piece {\\nposition: absolute;\\n}\\n\\n\").concat(IS_WEBKIT605 ? \":global svg *:before {\\ncontent:\\\"\\\";\\ntransform-origin: inherit;\\n}\" : \"\", \"\\n\");\r\nvar NEARBY_POS = [\r\n    [0, 1, 2],\r\n    [1, 0, 3],\r\n    [2, 0, 3],\r\n    [3, 1, 2],\r\n];\r\nvar FLOAT_POINT_NUM = 0.0001;\r\nvar TINY_NUM = 0.0000001;\r\nvar MIN_SCALE = 0.000000001;\r\nvar MAX_NUM = Math.pow(10, 10);\r\nvar MIN_NUM = -MAX_NUM;\r\nvar DIRECTION_REGION_TO_DIRECTION = {\r\n    n: [0, -1],\r\n    e: [1, 0],\r\n    s: [0, 1],\r\n    w: [-1, 0],\r\n    nw: [-1, -1],\r\n    ne: [1, -1],\r\n    sw: [-1, 1],\r\n    se: [1, 1],\r\n};\r\nvar DIRECTION_INDEXES = {\r\n    n: [0, 1],\r\n    e: [1, 3],\r\n    s: [3, 2],\r\n    w: [2, 0],\r\n    nw: [0],\r\n    ne: [1],\r\n    sw: [2],\r\n    se: [3],\r\n};\r\nvar DIRECTION_ROTATIONS = {\r\n    n: 0,\r\n    s: 180,\r\n    w: 270,\r\n    e: 90,\r\n    nw: 315,\r\n    ne: 45,\r\n    sw: 225,\r\n    se: 135,\r\n};\r\nvar MOVEABLE_METHODS = [\r\n    \"isMoveableElement\",\r\n    \"updateRect\",\r\n    \"updateTarget\",\r\n    \"destroy\",\r\n    \"dragStart\",\r\n    \"isInside\",\r\n    \"hitTest\",\r\n    \"setState\",\r\n    \"getRect\",\r\n    \"request\",\r\n    \"isDragging\",\r\n    \"getManager\",\r\n    \"forceUpdate\",\r\n    \"waitToChangeTarget\",\r\n    \"updateSelectors\",\r\n    \"getTargets\",\r\n    \"stopDrag\",\r\n    \"getControlBoxElement\",\r\n    \"getMoveables\",\r\n    \"getDragElement\",\r\n];\n\nfunction setCustomDrag(e, state, delta, isPinch, isConvert, ableName) {\r\n    var _a, _b;\r\n    if (ableName === void 0) { ableName = \"draggable\"; }\r\n    var result = (_b = (_a = state.gestos[ableName]) === null || _a === void 0 ? void 0 : _a.move(delta, e.inputEvent)) !== null && _b !== void 0 ? _b : {};\r\n    var datas = result.originalDatas || result.datas;\r\n    var ableDatas = datas[ableName] || (datas[ableName] = {});\r\n    return __assign(__assign({}, (isConvert ? convertDragDist(state, result) : result)), { isPinch: !!isPinch, parentEvent: true, datas: ableDatas, originalDatas: e.originalDatas });\r\n}\r\nvar CustomGesto = /*#__PURE__*/ (function () {\r\n    function CustomGesto(ableName) {\r\n        var _a;\r\n        if (ableName === void 0) { ableName = \"draggable\"; }\r\n        this.ableName = ableName;\r\n        this.prevX = 0;\r\n        this.prevY = 0;\r\n        this.startX = 0;\r\n        this.startY = 0;\r\n        this.isDrag = false;\r\n        this.isFlag = false;\r\n        this.datas = {\r\n            draggable: {},\r\n        };\r\n        this.datas = (_a = {},\r\n            _a[ableName] = {},\r\n            _a);\r\n    }\r\n    CustomGesto.prototype.dragStart = function (client, e) {\r\n        this.isDrag = false;\r\n        this.isFlag = false;\r\n        var originalDatas = e.originalDatas;\r\n        this.datas = originalDatas;\r\n        if (!originalDatas[this.ableName]) {\r\n            originalDatas[this.ableName] = {};\r\n        }\r\n        return __assign(__assign({}, this.move(client, e.inputEvent)), { type: \"dragstart\" });\r\n    };\r\n    CustomGesto.prototype.drag = function (client, inputEvent) {\r\n        return this.move([\r\n            client[0] - this.prevX,\r\n            client[1] - this.prevY,\r\n        ], inputEvent);\r\n    };\r\n    CustomGesto.prototype.move = function (delta, inputEvent) {\r\n        var clientX;\r\n        var clientY;\r\n        var isFirstDrag = false;\r\n        if (!this.isFlag) {\r\n            this.prevX = delta[0];\r\n            this.prevY = delta[1];\r\n            this.startX = delta[0];\r\n            this.startY = delta[1];\r\n            clientX = delta[0];\r\n            clientY = delta[1];\r\n            this.isFlag = true;\r\n        }\r\n        else {\r\n            var isPrevDrag = this.isDrag;\r\n            clientX = this.prevX + delta[0];\r\n            clientY = this.prevY + delta[1];\r\n            if (delta[0] || delta[1]) {\r\n                this.isDrag = true;\r\n            }\r\n            if (!isPrevDrag && this.isDrag) {\r\n                isFirstDrag = true;\r\n            }\r\n        }\r\n        this.prevX = clientX;\r\n        this.prevY = clientY;\r\n        return {\r\n            type: \"drag\",\r\n            clientX: clientX,\r\n            clientY: clientY,\r\n            inputEvent: inputEvent,\r\n            isFirstDrag: isFirstDrag,\r\n            isDrag: this.isDrag,\r\n            distX: clientX - this.startX,\r\n            distY: clientY - this.startY,\r\n            deltaX: delta[0],\r\n            deltaY: delta[1],\r\n            datas: this.datas[this.ableName],\r\n            originalDatas: this.datas,\r\n            parentEvent: true,\r\n            parentGesto: this,\r\n        };\r\n    };\r\n    return CustomGesto;\r\n}());\n\nfunction calculateElementPosition(matrix, origin, width, height) {\r\n    var is3d = matrix.length === 16;\r\n    var n = is3d ? 4 : 3;\r\n    var poses = calculatePoses(matrix, width, height, n);\r\n    var _a = __read(poses, 4), _b = __read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a[1], 2), x2 = _c[0], y2 = _c[1], _d = __read(_a[2], 2), x3 = _d[0], y3 = _d[1], _e = __read(_a[3], 2), x4 = _e[0], y4 = _e[1];\r\n    var _f = __read(calculatePosition(matrix, origin, n), 2), originX = _f[0], originY = _f[1];\r\n    var left = Math.min(x1, x2, x3, x4);\r\n    var top = Math.min(y1, y2, y3, y4);\r\n    var right = Math.max(x1, x2, x3, x4);\r\n    var bottom = Math.max(y1, y2, y3, y4);\r\n    x1 = (x1 - left) || 0;\r\n    x2 = (x2 - left) || 0;\r\n    x3 = (x3 - left) || 0;\r\n    x4 = (x4 - left) || 0;\r\n    y1 = (y1 - top) || 0;\r\n    y2 = (y2 - top) || 0;\r\n    y3 = (y3 - top) || 0;\r\n    y4 = (y4 - top) || 0;\r\n    originX = (originX - left) || 0;\r\n    originY = (originY - top) || 0;\r\n    var sx = matrix[0];\r\n    var sy = matrix[n + 1];\r\n    var direction = sign(sx * sy);\r\n    return {\r\n        left: left,\r\n        top: top,\r\n        right: right,\r\n        bottom: bottom,\r\n        origin: [originX, originY],\r\n        pos1: [x1, y1],\r\n        pos2: [x2, y2],\r\n        pos3: [x3, y3],\r\n        pos4: [x4, y4],\r\n        direction: direction,\r\n    };\r\n}\n\nfunction calculatePointerDist(moveable, e) {\r\n    var clientX = e.clientX, clientY = e.clientY, datas = e.datas;\r\n    var _a = moveable.state, moveableClientRect = _a.moveableClientRect, rootMatrix = _a.rootMatrix, is3d = _a.is3d, pos1 = _a.pos1;\r\n    var left = moveableClientRect.left, top = moveableClientRect.top;\r\n    var n = is3d ? 4 : 3;\r\n    var _b = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1), 2), posX = _b[0], posY = _b[1];\r\n    var _c = __read(getDragDist({ datas: datas, distX: posX, distY: posY }), 2), distX = _c[0], distY = _c[1];\r\n    return [distX, distY];\r\n}\r\nfunction setDragStart(moveable, _a) {\r\n    var datas = _a.datas;\r\n    var _b = moveable.state, allMatrix = _b.allMatrix, beforeMatrix = _b.beforeMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, origin = _b.origin, offsetMatrix = _b.offsetMatrix, targetMatrix = _b.targetMatrix, transformOrigin = _b.transformOrigin;\r\n    var n = is3d ? 4 : 3;\r\n    datas.is3d = is3d;\r\n    datas.matrix = allMatrix;\r\n    datas.targetMatrix = targetMatrix;\r\n    datas.beforeMatrix = beforeMatrix;\r\n    datas.offsetMatrix = offsetMatrix;\r\n    datas.transformOrigin = transformOrigin;\r\n    datas.inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(allMatrix, n);\r\n    datas.inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(beforeMatrix, n);\r\n    datas.absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([left, top], origin), n);\r\n    datas.startDragBeforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\r\n    datas.startDragDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.inverseMatrix, datas.absoluteOrigin, n);\r\n}\r\nfunction getTransformDirection(e) {\r\n    return calculateElementPosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\r\n}\r\nfunction resolveTransformEvent(moveable, event, functionName) {\r\n    var datas = event.datas, originalDatas = event.originalDatas.beforeRenderable;\r\n    var index = datas.transformIndex;\r\n    var nextTransforms = originalDatas.nextTransforms;\r\n    var length = nextTransforms.length;\r\n    var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;\r\n    var nextIndex = -1;\r\n    if (index === -1) {\r\n        // translate => rotate => scale\r\n        if (functionName === \"translate\") {\r\n            nextIndex = 0;\r\n        }\r\n        else if (functionName === \"rotate\") {\r\n            nextIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(nextTransforms, function (text) { return text.match(/scale\\(/g); });\r\n        }\r\n        if (nextIndex === -1) {\r\n            nextIndex = nextTransforms.length;\r\n        }\r\n        datas.transformIndex = nextIndex;\r\n    }\r\n    else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(nextTransformAppendedIndexes, function (info) { return info.index === index && info.functionName === functionName; })) {\r\n        nextIndex = index;\r\n    }\r\n    else {\r\n        nextIndex = index + nextTransformAppendedIndexes.filter(function (info) { return info.index < index; }).length;\r\n    }\r\n    var result = convertTransformInfo(nextTransforms, moveable.state, nextIndex);\r\n    var targetFunction = result.targetFunction;\r\n    var matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\r\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\r\n    datas.afterFunctionTexts = result.afterFunctionTexts;\r\n    datas.beforeTransform = result.beforeFunctionMatrix;\r\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\r\n    datas.targetTansform = result.targetFunctionMatrix;\r\n    datas.afterTransform = result.afterFunctionMatrix;\r\n    datas.afterTransform2 = result.afterFunctionMatrix2;\r\n    datas.targetAllTransform = result.allFunctionMatrix;\r\n    if (targetFunction.functionName === matFunctionName) {\r\n        datas.afterFunctionTexts.splice(0, 1);\r\n        datas.isAppendTransform = false;\r\n    }\r\n    else if (length > nextIndex) {\r\n        datas.isAppendTransform = true;\r\n        originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], __read(nextTransformAppendedIndexes), false), [{\r\n                functionName: functionName,\r\n                index: nextIndex,\r\n                isAppend: true,\r\n            }], false);\r\n    }\r\n}\r\nfunction convertTransformFormat(datas, value, dist) {\r\n    return \"\".concat(datas.beforeFunctionTexts.join(\" \"), \" \").concat(datas.isAppendTransform ? dist : value, \" \").concat(datas.afterFunctionTexts.join(\" \"));\r\n}\r\nfunction getTransformDist(_a) {\r\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\r\n    var _b = __read(getBeforeDragDist({ datas: datas, distX: distX, distY: distY }), 2), bx = _b[0], by = _b[1];\r\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\r\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\r\n    var res = getTransfromMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.fromTranslation)([bx, by], 4));\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(res, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([0, 0, 0], 4), 4);\r\n}\r\nfunction getTransfromMatrix(datas, targetMatrix, isAfter) {\r\n    var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform, beforeTransform2 = datas.beforeTransform2, afterTransform2 = datas.afterTransform2, targetAllTransform = datas.targetAllTransform;\r\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\r\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\r\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\r\n    var nextTargetMatrix = isAfter\r\n        ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetAllTransform, targetMatrix, 4)\r\n        : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetMatrix, targetAllTransform, 4);\r\n    // res1 = B-1 * nextTargetMatrix\r\n    var res1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\r\n    // res3 = res2 * A-1\r\n    var afterTargetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(res1, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(isAfter ? afterTransform2 : afterTransform, 4), 4);\r\n    return afterTargetMatrix;\r\n}\r\nfunction getBeforeDragDist(_a) {\r\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\r\n    // TT = BT\r\n    var inverseBeforeMatrix = datas.inverseBeforeMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, absoluteOrigin = datas.absoluteOrigin;\r\n    var n = is3d ? 4 : 3;\r\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\r\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(inverseBeforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);\r\n}\r\nfunction getDragDist(_a, isBefore) {\r\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\r\n    var inverseBeforeMatrix = datas.inverseBeforeMatrix, inverseMatrix = datas.inverseMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;\r\n    var n = is3d ? 4 : 3;\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(isBefore ? inverseBeforeMatrix : inverseMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);\r\n}\r\nfunction getInverseDragDist(_a, isBefore) {\r\n    var datas = _a.datas, distX = _a.distX, distY = _a.distY;\r\n    var beforeMatrix = datas.beforeMatrix, matrix = datas.matrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;\r\n    var n = is3d ? 4 : 3;\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(isBefore ? beforeMatrix : matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);\r\n}\r\nfunction calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {\r\n    if (prevWidth === void 0) { prevWidth = width; }\r\n    if (prevHeight === void 0) { prevHeight = height; }\r\n    if (prevOrigin === void 0) { prevOrigin = [0, 0]; }\r\n    if (!transformOrigin) {\r\n        return prevOrigin;\r\n    }\r\n    return transformOrigin.map(function (pos, i) {\r\n        var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitUnit)(pos), value = _a.value, unit = _a.unit;\r\n        var prevSize = (i ? prevHeight : prevWidth);\r\n        var size = (i ? height : width);\r\n        if (pos === \"%\" || isNaN(value)) {\r\n            // no value but %\r\n            var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\r\n            return size * measureRatio;\r\n        }\r\n        else if (unit !== \"%\") {\r\n            return value;\r\n        }\r\n        return size * value / 100;\r\n    });\r\n}\r\nfunction getPosIndexesByDirection(direction) {\r\n    var indexes = [];\r\n    if (direction[1] >= 0) {\r\n        if (direction[0] >= 0) {\r\n            indexes.push(3);\r\n        }\r\n        if (direction[0] <= 0) {\r\n            indexes.push(2);\r\n        }\r\n    }\r\n    if (direction[1] <= 0) {\r\n        if (direction[0] >= 0) {\r\n            indexes.push(1);\r\n        }\r\n        if (direction[0] <= 0) {\r\n            indexes.push(0);\r\n        }\r\n    }\r\n    return indexes;\r\n}\r\nfunction getPosesByDirection(poses, direction) {\r\n    /*\r\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\r\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\r\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\r\n    */\r\n    return getPosIndexesByDirection(direction).map(function (index) { return poses[index]; });\r\n}\r\nfunction getPosBySingleDirection(poses, direction) {\r\n    var ratio = (direction + 1) / 2;\r\n    return [\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(poses[0][0], poses[1][0], ratio, 1 - ratio),\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(poses[0][1], poses[1][1], ratio, 1 - ratio),\r\n    ];\r\n}\r\nfunction getPosByDirection(poses, direction) {\r\n    var top = getPosBySingleDirection([poses[0], poses[1]], direction[0]);\r\n    var bottom = getPosBySingleDirection([poses[2], poses[3]], direction[0]);\r\n    return getPosBySingleDirection([top, bottom], direction[1]);\r\n}\r\nfunction getDist(startPos, matrix, width, height, n, fixedDirection) {\r\n    var poses = calculatePoses(matrix, width, height, n);\r\n    var fixedPos = getPosByDirection(poses, fixedDirection);\r\n    var distX = startPos[0] - fixedPos[0];\r\n    var distY = startPos[1] - fixedPos[1];\r\n    return [distX, distY];\r\n}\r\nfunction getNextMatrix(offsetMatrix, targetMatrix, origin, n) {\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\r\n}\r\nfunction getNextTransformMatrix(state, datas, transform, isAllTransform) {\r\n    var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d;\r\n    var n = is3d ? 4 : 3;\r\n    var targetTransform;\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(transform)) {\r\n        var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform;\r\n        if (isAllTransform) {\r\n            targetTransform = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)((0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(transform), 4, n);\r\n        }\r\n        else {\r\n            targetTransform = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(beforeTransform, (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)([transform]), 4), afterTransform, 4), 4, n);\r\n        }\r\n    }\r\n    else {\r\n        targetTransform = transform;\r\n    }\r\n    return getNextMatrix(offsetMatrix, targetTransform, transformOrigin, n);\r\n}\r\nfunction scaleMatrix(state, scale) {\r\n    var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, targetMatrix = state.targetMatrix, targetAllTransform = state.targetAllTransform;\r\n    var n = is3d ? 4 : 3;\r\n    return getNextMatrix(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetAllTransform || targetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)(scale, n), n), transformOrigin, n);\r\n}\r\nfunction fillTransformStartEvent(moveable, e) {\r\n    var originalDatas = getBeforeRenderableDatas(e);\r\n    return {\r\n        setTransform: function (transform, index) {\r\n            if (index === void 0) { index = -1; }\r\n            originalDatas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(transform);\r\n            setTransformIndex(moveable, e, index);\r\n        },\r\n        setTransformIndex: function (index) {\r\n            setTransformIndex(moveable, e, index);\r\n        },\r\n    };\r\n}\r\nfunction setDefaultTransformIndex(moveable, e, property) {\r\n    var originalDatas = getBeforeRenderableDatas(e);\r\n    var startTransforms = originalDatas.startTransforms;\r\n    setTransformIndex(moveable, e, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(startTransforms, function (func) { return func.indexOf(\"\".concat(property, \"(\")) === 0; }));\r\n}\r\nfunction setTransformIndex(moveable, e, index) {\r\n    var originalDatas = getBeforeRenderableDatas(e);\r\n    var datas = e.datas;\r\n    datas.transformIndex = index;\r\n    if (index === -1) {\r\n        return;\r\n    }\r\n    var transform = originalDatas.startTransforms[index];\r\n    if (!transform) {\r\n        return;\r\n    }\r\n    var state = moveable.state;\r\n    var info = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([transform], {\r\n        \"x%\": function (v) { return v / 100 * state.offsetWidth; },\r\n        \"y%\": function (v) { return v / 100 * state.offsetHeight; },\r\n    });\r\n    datas.startValue = info[0].functionValue;\r\n}\r\nfunction fillOriginalTransform(e, transform) {\r\n    var originalDatas = getBeforeRenderableDatas(e);\r\n    originalDatas.nextTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(transform);\r\n    // originalDatas.nextTargetMatrix = parseMat(transform);\r\n}\r\nfunction getBeforeRenderableDatas(e) {\r\n    return e.originalDatas.beforeRenderable;\r\n}\r\nfunction getNextTransforms(e) {\r\n    var originalDatas = e.originalDatas.beforeRenderable;\r\n    return originalDatas.nextTransforms;\r\n}\r\nfunction getNextTransformText(e) {\r\n    return (getNextTransforms(e) || []).join(\" \");\r\n}\r\nfunction getNextStyle(e) {\r\n    return getBeforeRenderableDatas(e).nextStyle;\r\n}\r\nfunction fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {\r\n    fillOriginalTransform(e, nextTransform);\r\n    var drag = Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false));\r\n    var afterTransform = drag ? drag.transform : nextTransform;\r\n    return __assign(__assign({ transform: nextTransform, drag: drag }, fillCSSObject({\r\n        transform: afterTransform,\r\n    }, e)), { afterTransform: afterTransform });\r\n}\r\nfunction getTranslateFixedPosition(moveable, transform, fixedDirection, fixedOffset, datas, isAllTransform) {\r\n    var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform, isAllTransform);\r\n    var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, fixedOffset, nextMatrix);\r\n    return nextFixedPosition;\r\n}\r\nfunction getTranslateDist(moveable, transform, fixedDirection, fixedPosition, fixedOffset, datas, isAllTransform) {\r\n    var nextFixedPosition = getTranslateFixedPosition(moveable, transform, fixedDirection, fixedOffset, datas, isAllTransform);\r\n    var state = moveable.state;\r\n    var left = state.left, top = state.top;\r\n    var groupable = moveable.props.groupable;\r\n    var groupLeft = groupable ? left : 0;\r\n    var groupTop = groupable ? top : 0;\r\n    var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedPosition, nextFixedPosition);\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, [groupLeft, groupTop]);\r\n}\r\nfunction getScaleDist(moveable, transform, fixedDirection, fixedPosition, fixedOffset, datas, isAllTransform) {\r\n    var dist = getTranslateDist(moveable, transform, fixedDirection, fixedPosition, fixedOffset, datas, isAllTransform);\r\n    return dist;\r\n}\r\nfunction getDirectionByPos(pos, width, height) {\r\n    return [\r\n        width ? -1 + pos[0] / (width / 2) : 0,\r\n        height ? -1 + pos[1] / (height / 2) : 0,\r\n    ];\r\n}\r\nfunction getDirectionOffset(moveable, fixedDirection, fixedOffset, nextMatrix) {\r\n    if (nextMatrix === void 0) { nextMatrix = moveable.state.allMatrix; }\r\n    var _a = moveable.state, width = _a.width, height = _a.height, is3d = _a.is3d;\r\n    var n = is3d ? 4 : 3;\r\n    var fixedOffsetPosition = [\r\n        width / 2 * (1 + fixedDirection[0]) + fixedOffset[0],\r\n        height / 2 * (1 + fixedDirection[1]) + fixedOffset[1],\r\n    ];\r\n    return calculatePosition(nextMatrix, fixedOffsetPosition, n);\r\n}\r\nfunction getRotateDist(moveable, rotateDist, datas) {\r\n    var fixedDirection = datas.fixedDirection;\r\n    var fixedPosition = datas.fixedPosition;\r\n    var fixedOffset = datas.fixedOffset;\r\n    return getTranslateDist(moveable, \"rotate(\".concat(rotateDist, \"deg)\"), fixedDirection, fixedPosition, fixedOffset, datas);\r\n}\r\nfunction getResizeDist(moveable, width, height, fixedPosition, transformOrigin, datas) {\r\n    var groupable = moveable.props.groupable;\r\n    var state = moveable.state;\r\n    var prevOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, prevWidth = state.width, prevHeight = state.height, left = state.left, top = state.top;\r\n    var fixedDirection = datas.fixedDirection;\r\n    var targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\r\n    var n = is3d ? 4 : 3;\r\n    var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);\r\n    var groupLeft = groupable ? left : 0;\r\n    var groupTop = groupable ? top : 0;\r\n    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\r\n    var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, [groupLeft, groupTop]);\r\n}\r\nfunction getAbsolutePosition(moveable, direction) {\r\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\r\n}\n\nfunction getGestoData(moveable, ableName) {\r\n    var targetGesto = moveable.targetGesto;\r\n    var controlGesto = moveable.controlGesto;\r\n    var data;\r\n    if (targetGesto === null || targetGesto === void 0 ? void 0 : targetGesto.isFlag()) {\r\n        data = targetGesto.getEventData()[ableName];\r\n    }\r\n    if (!data && (controlGesto === null || controlGesto === void 0 ? void 0 : controlGesto.isFlag())) {\r\n        data = controlGesto.getEventData()[ableName];\r\n    }\r\n    return data || {};\r\n}\n\nfunction getShadowRoot(parentElement) {\r\n    if (parentElement && parentElement.getRootNode) {\r\n        var rootNode = parentElement.getRootNode();\r\n        if (rootNode.nodeType === 11) {\r\n            return rootNode;\r\n        }\r\n    }\r\n    return;\r\n}\r\nfunction getIndividualTransforms(getStyle) {\r\n    var scale = getStyle(\"scale\");\r\n    var rotate = getStyle(\"rotate\");\r\n    var translate = getStyle(\"translate\");\r\n    var individualTransforms = [];\r\n    if (translate && translate !== \"0px\" && translate !== \"none\") {\r\n        individualTransforms.push(\"translate(\".concat(translate.split(/\\s+/).join(\",\"), \")\"));\r\n    }\r\n    if (rotate && rotate !== \"1\" && rotate !== \"none\") {\r\n        individualTransforms.push(\"rotate(\".concat(rotate, \")\"));\r\n    }\r\n    if (scale && scale !== \"1\" && scale !== \"none\") {\r\n        individualTransforms.push(\"scale(\".concat(scale.split(/\\s+/).join(\",\"), \")\"));\r\n    }\r\n    return individualTransforms;\r\n}\r\nfunction getMatrixStackInfo(target, container, checkContainer) {\r\n    var el = target;\r\n    var matrixes = [];\r\n    var documentElement = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentElement)(target) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(target);\r\n    var requestEnd = !checkContainer && target === container || target === documentElement;\r\n    var isEnd = requestEnd;\r\n    var is3d = false;\r\n    var n = 3;\r\n    var transformOrigin;\r\n    var targetTransformOrigin;\r\n    var targetMatrix;\r\n    var hasFixed = false;\r\n    var offsetContainer = getOffsetInfo(container, container, true).offsetParent;\r\n    var zoom = 1;\r\n    while (el && !isEnd) {\r\n        isEnd = requestEnd;\r\n        var getStyle = getCachedStyle(el);\r\n        var position = getStyle(\"position\");\r\n        var transform = getElementTransform(el);\r\n        var isFixed = position === \"fixed\";\r\n        var individualTransforms = getIndividualTransforms(getStyle);\r\n        var matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertCSStoMatrix)(getTransformMatrix(transform));\r\n        var offsetParent = void 0;\r\n        var isOffsetEnd = false;\r\n        var isStatic = false;\r\n        var parentClientLeft = 0;\r\n        var parentClientTop = 0;\r\n        var fixedClientLeft = 0;\r\n        var fixedClientTop = 0;\r\n        var fixedInfo = {\r\n            hasTransform: false,\r\n            fixedContainer: null,\r\n        };\r\n        if (isFixed) {\r\n            hasFixed = true;\r\n            fixedInfo = getPositionFixedInfo(el);\r\n            offsetContainer = fixedInfo.fixedContainer;\r\n        }\r\n        // convert 3 to 4\r\n        var length_1 = matrix.length;\r\n        if (!is3d && (length_1 === 16 || individualTransforms.length)) {\r\n            is3d = true;\r\n            n = 4;\r\n            convert3DMatrixes(matrixes);\r\n            if (targetMatrix) {\r\n                targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);\r\n            }\r\n        }\r\n        if (is3d && length_1 === 9) {\r\n            matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(matrix, 3, 4);\r\n        }\r\n        var _a = getOffsetPosInfo(el, target), tagName = _a.tagName, hasOffset = _a.hasOffset, isSVG = _a.isSVG, origin_1 = _a.origin, targetOrigin = _a.targetOrigin, offsetPos = _a.offset;\r\n        var _b = __read(offsetPos, 2), offsetLeft = _b[0], offsetTop = _b[1];\r\n        // no target with svg\r\n        if (tagName === \"svg\" && !el.ownerSVGElement && targetMatrix) {\r\n            // scale matrix for svg's SVGElements.\r\n            matrixes.push({\r\n                type: \"target\",\r\n                target: el,\r\n                matrix: getSVGMatrix(el, n),\r\n            });\r\n            matrixes.push({\r\n                type: \"offset\",\r\n                target: el,\r\n                matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\r\n            });\r\n        }\r\n        var targetZoom = parseFloat(getStyle(\"zoom\")) || 1;\r\n        if (isFixed) {\r\n            offsetParent = fixedInfo.fixedContainer;\r\n            isOffsetEnd = true;\r\n        }\r\n        else {\r\n            var offsetInfo = getOffsetInfo(el, container, false, true, getStyle);\r\n            var offsetZoom = offsetInfo.offsetZoom;\r\n            offsetParent = offsetInfo.offsetParent;\r\n            isOffsetEnd = offsetInfo.isEnd;\r\n            isStatic = offsetInfo.isStatic;\r\n            zoom *= offsetZoom;\r\n            if ((offsetInfo.isCustomElement || offsetZoom !== 1) && isStatic) {\r\n                offsetLeft -= offsetParent.offsetLeft;\r\n                offsetTop -= offsetParent.offsetTop;\r\n            }\r\n            else if (IS_FIREFOX || IS_CHROMIUM109) {\r\n                var parentSlotElement = offsetInfo.parentSlotElement;\r\n                if (parentSlotElement) {\r\n                    var customOffsetParent = offsetParent;\r\n                    var customOffsetLeft = 0;\r\n                    var customOffsetTop = 0;\r\n                    while (customOffsetParent) {\r\n                        if (!getShadowRoot(customOffsetParent)) {\r\n                            break;\r\n                        }\r\n                        customOffsetLeft += customOffsetParent.offsetLeft;\r\n                        customOffsetTop += customOffsetParent.offsetTop;\r\n                        customOffsetParent = customOffsetParent.offsetParent;\r\n                    }\r\n                    offsetLeft -= customOffsetLeft;\r\n                    offsetTop -= customOffsetTop;\r\n                }\r\n            }\r\n        }\r\n        if (IS_WEBKIT && !IS_SAFARI_ABOVE15\r\n            && hasOffset && !isSVG && isStatic\r\n            && (position === \"relative\" || position === \"static\")) {\r\n            offsetLeft -= offsetParent.offsetLeft;\r\n            offsetTop -= offsetParent.offsetTop;\r\n            requestEnd = requestEnd || isOffsetEnd;\r\n        }\r\n        if (isFixed) {\r\n            if (hasOffset && fixedInfo.hasTransform) {\r\n                // border\r\n                fixedClientLeft = offsetParent.clientLeft;\r\n                fixedClientTop = offsetParent.clientTop;\r\n            }\r\n        }\r\n        else {\r\n            if (hasOffset && offsetContainer !== offsetParent) {\r\n                // border\r\n                parentClientLeft = offsetParent.clientLeft;\r\n                parentClientTop = offsetParent.clientTop;\r\n            }\r\n            if (hasOffset && offsetParent === documentElement) {\r\n                var margin = getBodyOffset(el, false);\r\n                offsetLeft += margin[0];\r\n                offsetTop += margin[1];\r\n            }\r\n        }\r\n        matrixes.push({\r\n            type: \"target\",\r\n            target: el,\r\n            matrix: getAbsoluteMatrix(matrix, n, origin_1),\r\n        });\r\n        if (individualTransforms.length) {\r\n            matrixes.push({\r\n                type: \"offset\",\r\n                target: el,\r\n                matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n),\r\n            });\r\n            matrixes.push({\r\n                type: \"target\",\r\n                target: el,\r\n                matrix: getAbsoluteMatrix((0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(individualTransforms), n, origin_1),\r\n            });\r\n        }\r\n        if (hasOffset) {\r\n            var isElementTarget = el === target;\r\n            var scrollLeft = isElementTarget ? 0 : el.scrollLeft;\r\n            var scrollTop = isElementTarget ? 0 : el.scrollTop;\r\n            matrixes.push({\r\n                type: \"offset\",\r\n                target: el,\r\n                matrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)([\r\n                    offsetLeft - scrollLeft + parentClientLeft - fixedClientLeft,\r\n                    offsetTop - scrollTop + parentClientTop - fixedClientTop,\r\n                ], n),\r\n            });\r\n        }\r\n        else {\r\n            // svg\r\n            matrixes.push({\r\n                type: \"offset\",\r\n                target: el,\r\n                origin: origin_1,\r\n            });\r\n        }\r\n        // transform으로 계산되지 않는 zoom을 위한 (0, 0) 을 기준 matrix 추가.\r\n        if (targetZoom !== 1) {\r\n            matrixes.push({\r\n                type: \"zoom\",\r\n                target: el,\r\n                matrix: getAbsoluteMatrix((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)([targetZoom, targetZoom], n), n, [0, 0]),\r\n            });\r\n        }\r\n        if (!targetMatrix) {\r\n            targetMatrix = matrix;\r\n        }\r\n        if (!transformOrigin) {\r\n            transformOrigin = origin_1;\r\n        }\r\n        if (!targetTransformOrigin) {\r\n            targetTransformOrigin = targetOrigin;\r\n        }\r\n        if (isEnd || isFixed) {\r\n            break;\r\n        }\r\n        else {\r\n            el = offsetParent;\r\n            requestEnd = isOffsetEnd;\r\n        }\r\n        if (!checkContainer || el === documentElement) {\r\n            isEnd = requestEnd;\r\n        }\r\n    }\r\n    if (!targetMatrix) {\r\n        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\r\n    }\r\n    if (!transformOrigin) {\r\n        transformOrigin = [0, 0];\r\n    }\r\n    if (!targetTransformOrigin) {\r\n        targetTransformOrigin = [0, 0];\r\n    }\r\n    return {\r\n        zoom: zoom,\r\n        offsetContainer: offsetContainer,\r\n        matrixes: matrixes,\r\n        targetMatrix: targetMatrix,\r\n        transformOrigin: transformOrigin,\r\n        targetOrigin: targetTransformOrigin,\r\n        is3d: is3d,\r\n        hasFixed: hasFixed,\r\n    };\r\n}\n\nvar cacheStyleMap = null;\r\nvar clientRectStyleMap = null;\r\nvar matrixContainerInfos = null;\r\nfunction setStoreCache(useCache) {\r\n    if (useCache) {\r\n        if (window.Map) {\r\n            cacheStyleMap = new Map();\r\n            clientRectStyleMap = new Map();\r\n        }\r\n        matrixContainerInfos = [];\r\n    }\r\n    else {\r\n        cacheStyleMap = null;\r\n        matrixContainerInfos = null;\r\n        clientRectStyleMap = null;\r\n    }\r\n}\r\nfunction getCachedClientRect(el) {\r\n    var clientRect = clientRectStyleMap === null || clientRectStyleMap === void 0 ? void 0 : clientRectStyleMap.get(el);\r\n    if (clientRect) {\r\n        return clientRect;\r\n    }\r\n    var nextClientRect = getClientRect(el, true);\r\n    if (clientRectStyleMap) {\r\n        clientRectStyleMap.set(el, nextClientRect);\r\n    }\r\n    return nextClientRect;\r\n}\r\nfunction getCachedMatrixContainerInfo(target, container) {\r\n    if (matrixContainerInfos) {\r\n        var result_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(matrixContainerInfos, function (info) { return info[0][0] == target && info[0][1] == container; });\r\n        if (result_1) {\r\n            return result_1[1];\r\n        }\r\n    }\r\n    var result = getMatrixStackInfo(target, container, true);\r\n    if (matrixContainerInfos) {\r\n        matrixContainerInfos.push([[target, container], result]);\r\n    }\r\n    return result;\r\n}\r\nfunction getCachedStyle(element) {\r\n    var cache = cacheStyleMap === null || cacheStyleMap === void 0 ? void 0 : cacheStyleMap.get(element);\r\n    if (!cache) {\r\n        var nextStyle_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(element).getComputedStyle(element);\r\n        if (!cacheStyleMap) {\r\n            return function (property) {\r\n                return nextStyle_1[property];\r\n            };\r\n        }\r\n        cache = {\r\n            style: nextStyle_1,\r\n            cached: {},\r\n        };\r\n        cacheStyleMap.set(element, cache);\r\n    }\r\n    var cached = cache.cached;\r\n    var style = cache.style;\r\n    return function (property) {\r\n        if (!(property in cached)) {\r\n            cached[property] = style[property];\r\n        }\r\n        return cached[property];\r\n    };\r\n}\n\nfunction fillChildEvents(moveable, name, e) {\r\n    var datas = e.originalDatas;\r\n    datas.groupable = datas.groupable || {};\r\n    var groupableDatas = datas.groupable;\r\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\r\n    var childDatas = groupableDatas.childDatas;\r\n    return moveable.moveables.map(function (_, i) {\r\n        childDatas[i] = childDatas[i] || {};\r\n        childDatas[i][name] = childDatas[i][name] || {};\r\n        return __assign(__assign({}, e), { isRequestChild: true, datas: childDatas[i][name], originalDatas: childDatas[i] });\r\n    });\r\n}\r\nfunction triggerChildGesto(moveable, able, type, delta, e, isConvert, ableName) {\r\n    var isStart = !!type.match(/Start$/g);\r\n    var isEnd = !!type.match(/End$/g);\r\n    var isPinch = e.isPinch;\r\n    var datas = e.datas;\r\n    var events = fillChildEvents(moveable, able.name, e);\r\n    var moveables = moveable.moveables;\r\n    var childEvents = [];\r\n    var eventParams = events.map(function (ev, i) {\r\n        var childMoveable = moveables[i];\r\n        var state = childMoveable.state;\r\n        var gestos = state.gestos;\r\n        var childEvent = ev;\r\n        if (isStart) {\r\n            childEvent = new CustomGesto(ableName).dragStart(delta, ev);\r\n            childEvents.push(childEvent);\r\n        }\r\n        else {\r\n            if (!gestos[ableName]) {\r\n                gestos[ableName] = datas.childGestos[i];\r\n            }\r\n            if (!gestos[ableName]) {\r\n                return;\r\n            }\r\n            childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert, ableName);\r\n            childEvents.push(childEvent);\r\n        }\r\n        var result = able[type](childMoveable, __assign(__assign({}, childEvent), { parentFlag: true }));\r\n        if (isEnd) {\r\n            gestos[ableName] = null;\r\n        }\r\n        return result;\r\n    });\r\n    if (isStart) {\r\n        datas.childGestos = moveables.map(function (child) { return child.state.gestos[ableName]; });\r\n    }\r\n    return {\r\n        eventParams: eventParams,\r\n        childEvents: childEvents,\r\n    };\r\n}\r\nfunction triggerChildAbles(moveable, able, type, e, eachEvent, callback) {\r\n    if (eachEvent === void 0) { eachEvent = function (_, ev) { return ev; }; }\r\n    var isEnd = !!type.match(/End$/g);\r\n    var events = fillChildEvents(moveable, able.name, e);\r\n    var moveables = moveable.moveables;\r\n    var childs = events.map(function (ev, i) {\r\n        var childMoveable = moveables[i];\r\n        var childEvent = ev;\r\n        childEvent = eachEvent(childMoveable, ev);\r\n        var result = able[type](childMoveable, __assign(__assign({}, childEvent), { parentFlag: true }));\r\n        result && callback && callback(childMoveable, ev, result, i);\r\n        if (isEnd) {\r\n            childMoveable.state.gestos = {};\r\n        }\r\n        return result;\r\n    });\r\n    return childs;\r\n}\r\nfunction startChildDist(moveable, child, parentDatas, childEvent) {\r\n    var fixedDirection = parentDatas.fixedDirection;\r\n    var fixedPosition = parentDatas.fixedPosition;\r\n    var startPositions = childEvent.datas.startPositions || getAbsolutePosesByState(child.state);\r\n    var pos = getPosByDirection(startPositions, fixedDirection);\r\n    var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), 2), originalX = _a[0], originalY = _a[1];\r\n    childEvent.datas.originalX = originalX;\r\n    childEvent.datas.originalY = originalY;\r\n    return childEvent;\r\n}\n\nfunction renderDirectionControlsByInfos(moveable, ableName, renderDirections, React) {\r\n    var _a = moveable.getState(), renderPoses = _a.renderPoses, rotationRad = _a.rotation, direction = _a.direction;\r\n    var zoom = getProps(moveable.props, ableName).zoom;\r\n    var degRotation = absDegree(rotationRad / Math.PI * 180);\r\n    var directionMap = {};\r\n    var renderState = moveable.renderState;\r\n    if (!renderState.renderDirectionMap) {\r\n        renderState.renderDirectionMap = {};\r\n    }\r\n    var renderDirectionMap = renderState.renderDirectionMap;\r\n    renderDirections.forEach(function (_a) {\r\n        var dir = _a.dir;\r\n        directionMap[dir] = true;\r\n    });\r\n    var directionSign = sign(direction);\r\n    return renderDirections.map(function (_a) {\r\n        var data = _a.data, classNames = _a.classNames, dir = _a.dir;\r\n        var indexes = DIRECTION_INDEXES[dir];\r\n        if (!indexes || !directionMap[dir]) {\r\n            return null;\r\n        }\r\n        renderDirectionMap[dir] = true;\r\n        var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(degRotation, 15) + directionSign * DIRECTION_ROTATIONS[dir] + 720) % 180;\r\n        var dataAttrs = {};\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(data).forEach(function (name) {\r\n            dataAttrs[\"data-\".concat(name)] = data[name];\r\n        });\r\n        return (React.createElement(\"div\", __assign({ className: prefix.apply(void 0, __spreadArray([\"control\", \"direction\", dir, ableName], __read(classNames), false)), \"data-rotation\": directionRotation, \"data-direction\": dir }, dataAttrs, { key: \"direction-\".concat(dir), style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], __read(indexes.map(function (index) { return renderPoses[index]; })), false)) })));\r\n    });\r\n}\r\nfunction renderDirectionControls(moveable, defaultDirections, ableName, React) {\r\n    var _a = getProps(moveable.props, ableName), _b = _a.renderDirections, directions = _b === void 0 ? defaultDirections : _b, displayAroundControls = _a.displayAroundControls;\r\n    if (!directions) {\r\n        return [];\r\n    }\r\n    var renderDirections = directions === true ? DIRECTIONS : directions;\r\n    return __spreadArray(__spreadArray([], __read((displayAroundControls ? renderAroundControls(moveable, React, ableName, renderDirections) : [])), false), __read(renderDirectionControlsByInfos(moveable, ableName, renderDirections.map(function (dir) {\r\n        return {\r\n            data: {},\r\n            classNames: [],\r\n            dir: dir,\r\n        };\r\n    }), React)), false);\r\n}\r\nfunction renderLine(React, direction, pos1, pos2, zoom, key) {\r\n    var classNames = [];\r\n    for (var _i = 6; _i < arguments.length; _i++) {\r\n        classNames[_i - 6] = arguments[_i];\r\n    }\r\n    var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2);\r\n    var rotation = direction ? ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(rad / Math.PI * 180, 15)) % 180 : -1;\r\n    return React.createElement(\"div\", { key: \"line-\".concat(key), className: prefix.apply(void 0, __spreadArray([\"line\", \"direction\", direction ? \"edge\" : \"\", direction], __read(classNames), false)), \"data-rotation\": rotation, \"data-line-key\": key, \"data-direction\": direction, style: getLineStyle(pos1, pos2, zoom, rad) });\r\n}\r\nfunction renderEdgeLines(React, ableName, edge, poses, zoom) {\r\n    var directions = edge === true ? DIRECTIONS4 : edge;\r\n    return directions.map(function (direction, i) {\r\n        var _a = __read(DIRECTION_INDEXES[direction], 2), index1 = _a[0], index2 = _a[1];\r\n        if (index2 == null) {\r\n            return;\r\n        }\r\n        return renderLine(React, direction, poses[index1], poses[index2], zoom, \"\".concat(ableName, \"Edge\").concat(i), ableName);\r\n    }).filter(Boolean);\r\n}\r\nfunction getRenderDirections(ableName) {\r\n    return function (moveable, React) {\r\n        var edge = getProps(moveable.props, ableName).edge;\r\n        if (edge && (edge === true || edge.length)) {\r\n            return __spreadArray(__spreadArray([], __read(renderEdgeLines(React, ableName, edge, moveable.getState().renderPoses, moveable.props.zoom)), false), __read(renderDiagonalDirections(moveable, ableName, React)), false);\r\n        }\r\n        return renderAllDirections(moveable, ableName, React);\r\n    };\r\n}\r\nfunction renderAllDirections(moveable, ableName, React) {\r\n    return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\r\n}\r\nfunction renderDiagonalDirections(moveable, ableName, React) {\r\n    return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], ableName, React);\r\n}\r\nfunction renderAroundControls(moveable, React, ableName, renderDirections) {\r\n    var renderState = moveable.renderState;\r\n    if (!renderState.renderDirectionMap) {\r\n        renderState.renderDirectionMap = {};\r\n    }\r\n    var _a = moveable.getState(), renderPoses = _a.renderPoses, rotationRad = _a.rotation, direction = _a.direction;\r\n    var renderDirectionMap = renderState.renderDirectionMap;\r\n    var zoom = moveable.props.zoom;\r\n    var directionSign = sign(direction);\r\n    var degRotation = rotationRad / Math.PI * 180;\r\n    return (renderDirections || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(renderDirectionMap)).map(function (dir) {\r\n        var indexes = DIRECTION_INDEXES[dir];\r\n        if (!indexes) {\r\n            return null;\r\n        }\r\n        var directionRotation = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(degRotation, 15) + directionSign * DIRECTION_ROTATIONS[dir] + 720) % 180;\r\n        var classNames = [\"around-control\"];\r\n        if (ableName) {\r\n            classNames.push(\"direction\", ableName);\r\n        }\r\n        return (React.createElement(\"div\", { className: prefix.apply(void 0, __spreadArray([], __read(classNames), false)), \"data-rotation\": directionRotation, \"data-direction\": dir, key: \"direction-around-\".concat(dir), style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], __read(indexes.map(function (index) { return renderPoses[index]; })), false)) }));\r\n    });\r\n}\n\nfunction checkBoundPoses(bounds, verticalPoses, horizontalPoses) {\r\n    var _a = bounds || {}, _b = _a.position, position = _b === void 0 ? \"client\" : _b, _c = _a.left, left = _c === void 0 ? -Infinity : _c, _d = _a.top, top = _d === void 0 ? -Infinity : _d, _e = _a.right, right = _e === void 0 ? Infinity : _e, _f = _a.bottom, bottom = _f === void 0 ? Infinity : _f;\r\n    var nextBounds = {\r\n        position: position,\r\n        left: left,\r\n        top: top,\r\n        right: right,\r\n        bottom: bottom,\r\n    };\r\n    return {\r\n        vertical: checkBounds(nextBounds, verticalPoses, true),\r\n        horizontal: checkBounds(nextBounds, horizontalPoses, false),\r\n    };\r\n}\r\nfunction getBounds(moveable, externalBounds) {\r\n    var _a = moveable.state, _b = _a.containerClientRect, containerHeight = _b.clientHeight, containerWidth = _b.clientWidth, clientLeft = _b.clientLeft, clientTop = _b.clientTop, _c = _a.snapOffset, snapOffsetLeft = _c.left, snapOffsetTop = _c.top, snapOffsetRight = _c.right, snapOffsetBottom = _c.bottom;\r\n    var bounds = externalBounds || moveable.props.bounds || {};\r\n    var position = bounds.position || \"client\";\r\n    var isCSS = position === \"css\";\r\n    var _d = bounds.left, left = _d === void 0 ? -Infinity : _d, _e = bounds.top, top = _e === void 0 ? -Infinity : _e;\r\n    var _f = bounds.right, right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f, _g = bounds.bottom, bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;\r\n    if (isCSS) {\r\n        right = containerWidth + snapOffsetRight - snapOffsetLeft - right;\r\n        bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;\r\n    }\r\n    return {\r\n        left: left + snapOffsetLeft - clientLeft,\r\n        right: right + snapOffsetLeft - clientLeft,\r\n        top: top + snapOffsetTop - clientTop,\r\n        bottom: bottom + snapOffsetTop - clientTop,\r\n    };\r\n}\r\nfunction checkBoundKeepRatio(moveable, startPos, endPos) {\r\n    var _a = getBounds(moveable), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;\r\n    var _b = __read(endPos, 2), endX = _b[0], endY = _b[1];\r\n    var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endPos, startPos), 2), dx = _c[0], dy = _c[1];\r\n    if (abs(dx) < TINY_NUM) {\r\n        dx = 0;\r\n    }\r\n    if (abs(dy) < TINY_NUM) {\r\n        dy = 0;\r\n    }\r\n    var isBottom = dy > 0;\r\n    var isRight = dx > 0;\r\n    var verticalInfo = {\r\n        isBound: false,\r\n        offset: 0,\r\n        pos: 0,\r\n    };\r\n    var horizontalInfo = {\r\n        isBound: false,\r\n        offset: 0,\r\n        pos: 0,\r\n    };\r\n    if (dx === 0 && dy === 0) {\r\n        return {\r\n            vertical: verticalInfo,\r\n            horizontal: horizontalInfo,\r\n        };\r\n    }\r\n    else if (dx === 0) {\r\n        if (isBottom) {\r\n            if (bottom < endY) {\r\n                horizontalInfo.pos = bottom;\r\n                horizontalInfo.offset = endY - bottom;\r\n            }\r\n        }\r\n        else {\r\n            if (top > endY) {\r\n                horizontalInfo.pos = top;\r\n                horizontalInfo.offset = endY - top;\r\n            }\r\n        }\r\n    }\r\n    else if (dy === 0) {\r\n        if (isRight) {\r\n            if (right < endX) {\r\n                verticalInfo.pos = right;\r\n                verticalInfo.offset = endX - right;\r\n            }\r\n        }\r\n        else {\r\n            if (left > endX) {\r\n                verticalInfo.pos = left;\r\n                verticalInfo.offset = endX - left;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // y - y1 = a * (x - x1)\r\n        var a = dy / dx;\r\n        var b = endPos[1] - a * endX;\r\n        var y = 0;\r\n        var x = 0;\r\n        var isBound = false;\r\n        if (isRight && right <= endX) {\r\n            y = a * right + b;\r\n            x = right;\r\n            isBound = true;\r\n        }\r\n        else if (!isRight && endX <= left) {\r\n            y = a * left + b;\r\n            x = left;\r\n            isBound = true;\r\n        }\r\n        if (isBound) {\r\n            if (y < top || y > bottom) {\r\n                isBound = false;\r\n            }\r\n        }\r\n        if (!isBound) {\r\n            if (isBottom && bottom <= endY) {\r\n                y = bottom;\r\n                x = (y - b) / a;\r\n                isBound = true;\r\n            }\r\n            else if (!isBottom && endY <= top) {\r\n                y = top;\r\n                x = (y - b) / a;\r\n                isBound = true;\r\n            }\r\n        }\r\n        if (isBound) {\r\n            verticalInfo.isBound = true;\r\n            verticalInfo.pos = x;\r\n            verticalInfo.offset = endX - x;\r\n            horizontalInfo.isBound = true;\r\n            horizontalInfo.pos = y;\r\n            horizontalInfo.offset = endY - y;\r\n        }\r\n    }\r\n    return {\r\n        vertical: verticalInfo,\r\n        horizontal: horizontalInfo,\r\n    };\r\n}\r\nfunction checkBounds(bounds, poses, isVertical) {\r\n    // 0   [100 - 200]  300\r\n    var startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\r\n    var endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\r\n    // 450\r\n    var minPos = Math.min.apply(Math, __spreadArray([], __read(poses), false));\r\n    var maxPos = Math.max.apply(Math, __spreadArray([], __read(poses), false));\r\n    var boundInfos = [];\r\n    if (startBoundPos + 1 > minPos) {\r\n        boundInfos.push({\r\n            direction: \"start\",\r\n            isBound: true,\r\n            offset: minPos - startBoundPos,\r\n            pos: startBoundPos,\r\n        });\r\n    }\r\n    if (endBoundPos - 1 < maxPos) {\r\n        boundInfos.push({\r\n            direction: \"end\",\r\n            isBound: true,\r\n            offset: maxPos - endBoundPos,\r\n            pos: endBoundPos,\r\n        });\r\n    }\r\n    if (!boundInfos.length) {\r\n        boundInfos.push({\r\n            isBound: false,\r\n            offset: 0,\r\n            pos: 0,\r\n        });\r\n    }\r\n    return boundInfos.sort(function (a, b) { return abs(b.offset) - abs(a.offset); });\r\n}\r\nfunction isBoundRotate$1(relativePoses, boundRect, rad) {\r\n    var nextPoses = rad ? relativePoses.map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad); }) : relativePoses;\r\n    return nextPoses.some(function (pos) {\r\n        return (pos[0] < boundRect.left && abs(pos[0] - boundRect.left) > 0.1)\r\n            || (pos[0] > boundRect.right && abs(pos[0] - boundRect.right) > 0.1)\r\n            || (pos[1] < boundRect.top && abs(pos[1] - boundRect.top) > 0.1)\r\n            || (pos[1] > boundRect.bottom && abs(pos[1] - boundRect.bottom) > 0.1);\r\n    });\r\n}\r\nfunction boundRotate(vec, boundPos, index) {\r\n    var r = getDistSize(vec);\r\n    var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\r\n    return [nextPos, -nextPos].sort(function (a, b) {\r\n        return abs(a - vec[index ? 0 : 1]) - abs(b - vec[index ? 0 : 1]);\r\n    }).map(function (pos) {\r\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\r\n    });\r\n}\r\nfunction checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {\r\n    if (!moveable.props.bounds) {\r\n        return [];\r\n    }\r\n    var rad = rotation * Math.PI / 180;\r\n    var _a = getBounds(moveable), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;\r\n    var relativeLeft = left - origin[0];\r\n    var relativeRight = right - origin[0];\r\n    var relativeTop = top - origin[1];\r\n    var relativeBottom = bottom - origin[1];\r\n    var boundRect = {\r\n        left: relativeLeft,\r\n        top: relativeTop,\r\n        right: relativeRight,\r\n        bottom: relativeBottom,\r\n    };\r\n    if (!isBoundRotate$1(nextPoses, boundRect, 0)) {\r\n        return [];\r\n    }\r\n    var result = [];\r\n    [\r\n        [relativeLeft, 0],\r\n        [relativeRight, 0],\r\n        [relativeTop, 1],\r\n        [relativeBottom, 1],\r\n    ].forEach(function (_a) {\r\n        var _b = __read(_a, 2), boundPos = _b[0], index = _b[1];\r\n        nextPoses.forEach(function (nextPos) {\r\n            var relativeRad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], nextPos);\r\n            result.push.apply(result, __spreadArray([], __read(boundRotate(nextPos, boundPos, index)\r\n                .map(function (relativeRad2) { return rad + relativeRad2 - relativeRad1; })\r\n                .filter(function (nextRad) { return !isBoundRotate$1(prevPoses, boundRect, nextRad); })\r\n                .map(function (nextRad) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(nextRad * 180 / Math.PI, TINY_NUM); })), false));\r\n        });\r\n    });\r\n    return result;\r\n}\n\nvar VERTICAL_NAMES = [\"left\", \"right\", \"center\"];\r\nvar HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"];\r\nvar SNAP_SKIP_NAMES_MAP = {\r\n    \"left\": \"start\",\r\n    \"right\": \"end\",\r\n    \"center\": \"center\",\r\n    \"top\": \"start\",\r\n    \"bottom\": \"end\",\r\n    \"middle\": \"center\",\r\n};\r\nvar VERTICAL_NAMES_MAP = {\r\n    start: \"left\",\r\n    end: \"right\",\r\n    center: \"center\",\r\n};\r\nvar HORIZONTAL_NAMES_MAP = {\r\n    start: \"top\",\r\n    end: \"bottom\",\r\n    center: \"middle\",\r\n};\r\nfunction getInitialBounds() {\r\n    return {\r\n        left: false,\r\n        top: false,\r\n        right: false,\r\n        bottom: false,\r\n    };\r\n}\r\nfunction hasGuidelines(moveable, ableName) {\r\n    var _a = moveable.props, snappable = _a.snappable, bounds = _a.bounds, innerBounds = _a.innerBounds, verticalGuidelines = _a.verticalGuidelines, horizontalGuidelines = _a.horizontalGuidelines, snapGridWidth = _a.snapGridWidth, snapGridHeight = _a.snapGridHeight, _b = moveable.state, guidelines = _b.guidelines, enableSnap = _b.enableSnap;\r\n    if (!snappable ||\r\n        !enableSnap ||\r\n        (ableName && snappable !== true && snappable.indexOf(ableName) < 0)) {\r\n        return false;\r\n    }\r\n    if (snapGridWidth ||\r\n        snapGridHeight ||\r\n        bounds ||\r\n        innerBounds ||\r\n        (guidelines && guidelines.length) ||\r\n        (verticalGuidelines && verticalGuidelines.length) ||\r\n        (horizontalGuidelines && horizontalGuidelines.length)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction getSnapDirections(snapDirections) {\r\n    if (snapDirections === false) {\r\n        return {};\r\n    }\r\n    else if (snapDirections === true || !snapDirections) {\r\n        return { left: true, right: true, top: true, bottom: true };\r\n    }\r\n    return snapDirections;\r\n}\r\nfunction mapSnapDirectionPoses(snapDirections, snapPoses) {\r\n    var nextSnapDirections = getSnapDirections(snapDirections);\r\n    var nextSnapPoses = {};\r\n    for (var name_1 in nextSnapDirections) {\r\n        if (name_1 in snapPoses && nextSnapDirections[name_1]) {\r\n            nextSnapPoses[name_1] = snapPoses[name_1];\r\n        }\r\n    }\r\n    return nextSnapPoses;\r\n}\r\nfunction splitSnapDirectionPoses(snapDirections, snapPoses) {\r\n    var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\r\n    var horizontalNames = HORIZONTAL_NAMES.filter(function (name) { return name in nextSnapPoses; });\r\n    var verticalNames = VERTICAL_NAMES.filter(function (name) { return name in nextSnapPoses; });\r\n    return {\r\n        horizontalNames: horizontalNames,\r\n        verticalNames: verticalNames,\r\n        horizontal: horizontalNames.map(function (name) { return nextSnapPoses[name]; }),\r\n        vertical: verticalNames.map(function (name) { return nextSnapPoses[name]; }),\r\n    };\r\n}\r\nfunction calculateContainerPos(rootMatrix, containerRect, n) {\r\n    var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);\r\n    return [\r\n        containerRect.left + clientPos[0],\r\n        containerRect.top + clientPos[1],\r\n    ];\r\n}\r\nfunction solveLineConstants(_a) {\r\n    var _b = __read(_a, 2), point1 = _b[0], point2 = _b[1];\r\n    var dx = point2[0] - point1[0];\r\n    var dy = point2[1] - point1[1];\r\n    if (Math.abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\r\n        dx = 0;\r\n    }\r\n    if (Math.abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\r\n        dy = 0;\r\n    }\r\n    // b > 0\r\n    // ax + by + c = 0\r\n    var a = 0;\r\n    var b = 0;\r\n    var c = 0;\r\n    if (!dx) {\r\n        // -x + 1 = 0\r\n        a = -1;\r\n        c = point1[0];\r\n    }\r\n    else if (!dy) {\r\n        // y - 1 = 0\r\n        b = 1;\r\n        c = -point1[1];\r\n    }\r\n    else {\r\n        // y = -a(x - x1) + y1\r\n        // ax + y + a * x1 - y1 = 0\r\n        a = -dy / dx;\r\n        b = 1;\r\n        c = a * point1[0] - point1[1];\r\n    }\r\n    return [a, b, c].map(function (v) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(v, _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM); });\r\n}\n\nvar NAME_snapRotationThreshold = \"snapRotationThreshold\";\r\nvar NAME_snapRotationDegrees = \"snapRotationDegrees\";\r\nvar NAME_snapHorizontalThreshold = \"snapHorizontalThreshold\";\r\nvar NAME_snapVerticalThreshold = \"snapVerticalThreshold\";\n\nfunction checkMoveableSnapPoses(moveable, posesX, posesY, dirXs, dirYs, customSnapVerticalThreshold, customSnapHorizontalThreshold) {\r\n    var _a;\r\n    if (dirXs === void 0) { dirXs = []; }\r\n    if (dirYs === void 0) { dirYs = []; }\r\n    var props = moveable.props;\r\n    var snapThresholdMultiples = ((_a = moveable.state.snapThresholdInfo) === null || _a === void 0 ? void 0 : _a.multiples) || [1, 1];\r\n    var snapHorizontalThreshold = selectValue(customSnapHorizontalThreshold, props[NAME_snapHorizontalThreshold], 5);\r\n    var snapVerticalThreshold = selectValue(customSnapVerticalThreshold, props[NAME_snapVerticalThreshold], 5);\r\n    return checkSnapPoses(moveable.state.guidelines, posesX, posesY, dirXs, dirYs, snapHorizontalThreshold, snapVerticalThreshold, snapThresholdMultiples);\r\n}\r\nfunction checkSnapPoses(guidelines, posesX, posesY, dirXs, dirYs, snapHorizontalThreshold, snapVerticalThreshold, multiples) {\r\n    return {\r\n        vertical: checkSnap(guidelines, \"vertical\", posesX, snapVerticalThreshold * multiples[0], dirXs),\r\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapHorizontalThreshold * multiples[1], dirYs),\r\n    };\r\n}\r\nfunction checkSnapKeepRatio(moveable, startPos, endPos) {\r\n    var _a = __read(endPos, 2), endX = _a[0], endY = _a[1];\r\n    var _b = __read(startPos, 2), startX = _b[0], startY = _b[1];\r\n    var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endPos, startPos), 2), dx = _c[0], dy = _c[1];\r\n    var isBottom = dy > 0;\r\n    var isRight = dx > 0;\r\n    dx = getTinyDist(dx);\r\n    dy = getTinyDist(dy);\r\n    var verticalInfo = {\r\n        isSnap: false,\r\n        offset: 0,\r\n        pos: 0,\r\n    };\r\n    var horizontalInfo = {\r\n        isSnap: false,\r\n        offset: 0,\r\n        pos: 0,\r\n    };\r\n    if (dx === 0 && dy === 0) {\r\n        return {\r\n            vertical: verticalInfo,\r\n            horizontal: horizontalInfo,\r\n        };\r\n    }\r\n    var _d = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : [], [], [], undefined, undefined), verticalSnapInfo = _d.vertical, horizontalSnapInfo = _d.horizontal;\r\n    verticalSnapInfo.posInfos.filter(function (_a) {\r\n        var pos = _a.pos;\r\n        return isRight ? pos >= startX : pos <= startX;\r\n    });\r\n    horizontalSnapInfo.posInfos.filter(function (_a) {\r\n        var pos = _a.pos;\r\n        return isBottom ? pos >= startY : pos <= startY;\r\n    });\r\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\r\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\r\n    var _e = getNearestSnapGuidelineInfo(verticalSnapInfo), isVerticalSnap = _e.isSnap, verticalGuideline = _e.guideline;\r\n    var _f = getNearestSnapGuidelineInfo(horizontalSnapInfo), isHorizontalSnap = _f.isSnap, horizontalGuideline = _f.guideline;\r\n    var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;\r\n    var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;\r\n    if (dx === 0) {\r\n        if (isHorizontalSnap) {\r\n            horizontalInfo.isSnap = true;\r\n            horizontalInfo.pos = horizontalGuideline.pos[1];\r\n            horizontalInfo.offset = endY - horizontalInfo.pos;\r\n        }\r\n    }\r\n    else if (dy === 0) {\r\n        if (isVerticalSnap) {\r\n            verticalInfo.isSnap = true;\r\n            verticalInfo.pos = verticalPos;\r\n            verticalInfo.offset = endX - verticalPos;\r\n        }\r\n    }\r\n    else {\r\n        // y - y1 = a * (x - x1)\r\n        var a = dy / dx;\r\n        var b = endPos[1] - a * endX;\r\n        var y = 0;\r\n        var x = 0;\r\n        var isSnap = false;\r\n        if (isVerticalSnap) {\r\n            x = verticalPos;\r\n            y = a * x + b;\r\n            isSnap = true;\r\n        }\r\n        else if (isHorizontalSnap) {\r\n            y = horizontalPos;\r\n            x = (y - b) / a;\r\n            isSnap = true;\r\n        }\r\n        if (isSnap) {\r\n            verticalInfo.isSnap = true;\r\n            verticalInfo.pos = x;\r\n            verticalInfo.offset = endX - x;\r\n            horizontalInfo.isSnap = true;\r\n            horizontalInfo.pos = y;\r\n            horizontalInfo.offset = endY - y;\r\n        }\r\n    }\r\n    return {\r\n        vertical: verticalInfo,\r\n        horizontal: horizontalInfo,\r\n    };\r\n}\r\nfunction getStringDirection(dir) {\r\n    var stringDirection = \"\";\r\n    if (dir === -1 || dir === \"top\" || dir === \"left\") {\r\n        stringDirection = \"start\";\r\n    }\r\n    else if (dir === 0 || dir === \"center\" || dir === \"middle\") {\r\n        stringDirection = \"center\";\r\n    }\r\n    else if (dir === 1 || dir === \"right\" || dir === \"bottom\") {\r\n        stringDirection = \"end\";\r\n    }\r\n    return stringDirection;\r\n}\r\nfunction checkSnaps(moveable, rect, customSnapVerticalThreshold, customSnapHorizontalThreshold) {\r\n    var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\r\n    var result = checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, poses.verticalNames.map(function (name) { return getStringDirection(name); }), poses.horizontalNames.map(function (name) { return getStringDirection(name); }), customSnapVerticalThreshold, customSnapHorizontalThreshold);\r\n    var horizontalDirection = getStringDirection(poses.horizontalNames[result.horizontal.index]);\r\n    var verticalDirection = getStringDirection(poses.verticalNames[result.vertical.index]);\r\n    return {\r\n        vertical: __assign(__assign({}, result.vertical), { direction: verticalDirection }),\r\n        horizontal: __assign(__assign({}, result.horizontal), { direction: horizontalDirection }),\r\n    };\r\n}\r\nfunction getNearestSnapGuidelineInfo(snapInfo) {\r\n    var isSnap = snapInfo.isSnap;\r\n    if (!isSnap) {\r\n        return {\r\n            isSnap: false,\r\n            offset: 0,\r\n            dist: -1,\r\n            pos: 0,\r\n            guideline: null,\r\n        };\r\n    }\r\n    var posInfo = snapInfo.posInfos[0];\r\n    var guidelineInfo = posInfo.guidelineInfos[0];\r\n    var offset = guidelineInfo.offset;\r\n    var dist = guidelineInfo.dist;\r\n    var guideline = guidelineInfo.guideline;\r\n    return {\r\n        isSnap: isSnap,\r\n        offset: offset,\r\n        dist: dist,\r\n        pos: posInfo.pos,\r\n        guideline: guideline,\r\n    };\r\n}\r\nfunction checkSnap(guidelines, targetType, targetPoses, snapThreshold, dirs) {\r\n    var _a, _b;\r\n    if (dirs === void 0) { dirs = []; }\r\n    if (!guidelines || !guidelines.length) {\r\n        return {\r\n            isSnap: false,\r\n            index: -1,\r\n            direction: \"\",\r\n            posInfos: [],\r\n        };\r\n    }\r\n    var isVertical = targetType === \"vertical\";\r\n    var posType = isVertical ? 0 : 1;\r\n    var snapPosInfos = targetPoses.map(function (targetPos, index) {\r\n        var direction = dirs[index] || \"\";\r\n        var guidelineInfos = guidelines.map(function (guideline) {\r\n            var pos = guideline.pos;\r\n            var offset = targetPos - pos[posType];\r\n            return {\r\n                offset: offset,\r\n                dist: abs(offset),\r\n                guideline: guideline,\r\n                direction: direction,\r\n            };\r\n        }).filter(function (_a) {\r\n            var guideline = _a.guideline, dist = _a.dist;\r\n            var type = guideline.type;\r\n            if (type !== targetType\r\n                || dist > snapThreshold) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }).sort(function (a, b) { return a.dist - b.dist; });\r\n        return {\r\n            pos: targetPos,\r\n            index: index,\r\n            guidelineInfos: guidelineInfos,\r\n            direction: direction,\r\n        };\r\n    }).filter(function (snapPosInfo) {\r\n        return snapPosInfo.guidelineInfos.length > 0;\r\n    }).sort(function (a, b) {\r\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\r\n    });\r\n    var isSnap = snapPosInfos.length > 0;\r\n    return {\r\n        isSnap: isSnap,\r\n        index: isSnap ? snapPosInfos[0].index : -1,\r\n        direction: (_b = (_a = snapPosInfos[0]) === null || _a === void 0 ? void 0 : _a.direction) !== null && _b !== void 0 ? _b : \"\",\r\n        posInfos: snapPosInfos,\r\n    };\r\n}\r\nfunction getSnapInfosByDirection(moveable, \r\n// pos1 pos2 pos3 pos4\r\nposes, snapDirection, customSnapVerticalThreshold, customSnapHorizontalThreshold) {\r\n    var dirs = [];\r\n    if (snapDirection[0] && snapDirection[1]) {\r\n        dirs = [\r\n            snapDirection,\r\n            [-snapDirection[0], snapDirection[1]],\r\n            [snapDirection[0], -snapDirection[1]],\r\n        ];\r\n    }\r\n    else if (!snapDirection[0] && !snapDirection[1]) {\r\n        [\r\n            [-1, -1],\r\n            [1, -1],\r\n            [1, 1],\r\n            [-1, 1],\r\n        ].forEach(function (dir, i, arr) {\r\n            var nextDir = (arr[i + 1] || arr[0]);\r\n            dirs.push(dir);\r\n            dirs.push([\r\n                (dir[0] + nextDir[0]) / 2,\r\n                (dir[1] + nextDir[1]) / 2,\r\n            ]);\r\n        });\r\n    }\r\n    else {\r\n        if (moveable.props.keepRatio) {\r\n            dirs.push([-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection);\r\n        }\r\n        else {\r\n            dirs.push.apply(dirs, __spreadArray([], __read(getPosesByDirection([\r\n                [-1, -1],\r\n                [1, -1],\r\n                [-1, -1],\r\n                [1, 1],\r\n            ], snapDirection)), false));\r\n            if (dirs.length > 1) {\r\n                dirs.push([\r\n                    (dirs[0][0] + dirs[1][0]) / 2,\r\n                    (dirs[0][1] + dirs[1][1]) / 2,\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n    var nextPoses = dirs.map(function (dir) { return getPosByDirection(poses, dir); });\r\n    var xs = nextPoses.map(function (pos) { return pos[0]; });\r\n    var ys = nextPoses.map(function (pos) { return pos[1]; });\r\n    var result = checkMoveableSnapPoses(moveable, xs, ys, dirs.map(function (dir) { return getStringDirection(dir[0]); }), dirs.map(function (dir) { return getStringDirection(dir[1]); }), customSnapVerticalThreshold, customSnapHorizontalThreshold);\r\n    var verticalDirection = getStringDirection(dirs.map(function (dir) { return dir[0]; })[result.vertical.index]);\r\n    var horizontalDirection = getStringDirection(dirs.map(function (dir) { return dir[1]; })[result.horizontal.index]);\r\n    return {\r\n        vertical: __assign(__assign({}, result.vertical), { direction: verticalDirection }),\r\n        horizontal: __assign(__assign({}, result.horizontal), { direction: horizontalDirection }),\r\n    };\r\n}\r\nfunction checkSnapBoundPriority(a, b) {\r\n    var aDist = abs(a.offset);\r\n    var bDist = abs(b.offset);\r\n    if (a.isBound && b.isBound) {\r\n        return bDist - aDist;\r\n    }\r\n    else if (a.isBound) {\r\n        return -1;\r\n    }\r\n    else if (b.isBound) {\r\n        return 1;\r\n    }\r\n    else if (a.isSnap && b.isSnap) {\r\n        return bDist - aDist;\r\n    }\r\n    else if (a.isSnap) {\r\n        return -1;\r\n    }\r\n    else if (b.isSnap) {\r\n        return 1;\r\n    }\r\n    else if (aDist < TINY_NUM) {\r\n        return 1;\r\n    }\r\n    else if (bDist < TINY_NUM) {\r\n        return -1;\r\n    }\r\n    return aDist - bDist;\r\n}\r\nfunction getNearOffsetInfo(offsets, index) {\r\n    return offsets.slice().sort(function (a, b) {\r\n        var aSign = a.sign[index];\r\n        var bSign = b.sign[index];\r\n        var aOffset = a.offset[index];\r\n        var bOffset = b.offset[index];\r\n        // -1 The positions of a and b do not change.\r\n        // 1 The positions of a and b are reversed.\r\n        if (!aSign) {\r\n            return 1;\r\n        }\r\n        else if (!bSign) {\r\n            return -1;\r\n        }\r\n        return checkSnapBoundPriority({ isBound: a.isBound, isSnap: a.isSnap, offset: aOffset }, { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset });\r\n    })[0];\r\n}\r\nfunction getCheckSnapDirections(direction, fixedDirection, keepRatio) {\r\n    var directions = [];\r\n    // const fixedDirection = [-direction[0], -direction[1]];\r\n    if (keepRatio) {\r\n        if (abs(fixedDirection[0]) !== 1 || abs(fixedDirection[1]) !== 1) {\r\n            directions.push([fixedDirection, [-1, -1]], [fixedDirection, [-1, 1]], [fixedDirection, [1, -1]], [fixedDirection, [1, 1]]);\r\n        }\r\n        else {\r\n            directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);\r\n        }\r\n        directions.push([fixedDirection, direction]);\r\n    }\r\n    else {\r\n        if ((direction[0] && direction[1]) || (!direction[0] && !direction[1])) {\r\n            var endDirection_1 = direction[0] ? direction : [1, 1];\r\n            [1, -1].forEach(function (signX) {\r\n                [1, -1].forEach(function (signY) {\r\n                    var nextDirection = [signX * endDirection_1[0], signY * endDirection_1[1]];\r\n                    if (fixedDirection[0] === nextDirection[0]\r\n                        && fixedDirection[1] === nextDirection[1]) {\r\n                        return;\r\n                    }\r\n                    directions.push([fixedDirection, nextDirection]);\r\n                });\r\n            });\r\n        }\r\n        else if (direction[0]) {\r\n            var signs = abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\r\n            signs.forEach(function (sign) {\r\n                directions.push([\r\n                    [fixedDirection[0], -1],\r\n                    [sign * direction[0], -1],\r\n                ], [\r\n                    [fixedDirection[0], 0],\r\n                    [sign * direction[0], 0],\r\n                ], [\r\n                    [fixedDirection[0], 1],\r\n                    [sign * direction[0], 1],\r\n                ]);\r\n            });\r\n        }\r\n        else if (direction[1]) {\r\n            var signs = abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\r\n            signs.forEach(function (sign) {\r\n                directions.push([\r\n                    [-1, fixedDirection[1]],\r\n                    [-1, sign * direction[1]],\r\n                ], [\r\n                    [0, fixedDirection[1]],\r\n                    [0, sign * direction[1]],\r\n                ], [\r\n                    [1, fixedDirection[1]],\r\n                    [1, sign * direction[1]],\r\n                ]);\r\n            });\r\n        }\r\n    }\r\n    return directions;\r\n}\n\nfunction isStartLine(dot, line) {\r\n    // l    o     => true\r\n    // o    l    => false\r\n    var cx = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.average)([line[0][0], line[1][0]]);\r\n    var cy = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.average)([line[0][1], line[1][1]]);\r\n    return {\r\n        vertical: cx <= dot[0],\r\n        horizontal: cy <= dot[1],\r\n    };\r\n}\r\nfunction hitTestLine(dot, _a) {\r\n    var _b = __read(_a, 2), pos1 = _b[0], pos2 = _b[1];\r\n    var dx = pos2[0] - pos1[0];\r\n    var dy = pos2[1] - pos1[1];\r\n    if (abs(dx) < TINY_NUM) {\r\n        dx = 0;\r\n    }\r\n    if (abs(dy) < TINY_NUM) {\r\n        dy = 0;\r\n    }\r\n    var test1;\r\n    var test2;\r\n    if (!dx) {\r\n        test1 = pos1[0];\r\n        test2 = dot[0];\r\n    }\r\n    else if (!dy) {\r\n        test1 = pos1[1];\r\n        test2 = dot[1];\r\n    }\r\n    else {\r\n        var a = dy / dx;\r\n        // y = a * (x - pos1) + pos1\r\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\r\n        test2 = dot[1];\r\n    }\r\n    return test1 - test2;\r\n}\r\nfunction isSameStartLine(dots, line, centerSign, error) {\r\n    if (error === void 0) { error = TINY_NUM; }\r\n    return dots.every(function (dot) {\r\n        var value = hitTestLine(dot, line);\r\n        var sign = value <= 0;\r\n        return sign === centerSign || abs(value) <= error;\r\n    });\r\n}\r\nfunction checkInnerBoundDot(pos, start, end, isStart, threshold) {\r\n    if (threshold === void 0) { threshold = 0; }\r\n    if ((isStart && start - threshold <= pos)\r\n        || (!isStart && pos <= end + threshold)) {\r\n        // false 402 565 602 => 37 ([0, 37])\r\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\r\n        // true 400 410 600 => 10 ([10, 0])\r\n        return {\r\n            isBound: true,\r\n            offset: isStart ? start - pos : end - pos,\r\n        };\r\n    }\r\n    return {\r\n        isBound: false,\r\n        offset: 0,\r\n    };\r\n}\r\nfunction checkInnerBound(moveable, _a) {\r\n    var line = _a.line, centerSign = _a.centerSign, verticalSign = _a.verticalSign, horizontalSign = _a.horizontalSign, lineConstants = _a.lineConstants;\r\n    var bounds = moveable.props.innerBounds;\r\n    if (!bounds) {\r\n        return {\r\n            isAllBound: false,\r\n            isBound: false,\r\n            isVerticalBound: false,\r\n            isHorizontalBound: false,\r\n            offset: [0, 0],\r\n        };\r\n    }\r\n    var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;\r\n    var leftLine = [[left, top], [left, top + height]];\r\n    var topLine = [[left, top], [left + width, top]];\r\n    var rightLine = [[left + width, top], [left + width, top + height]];\r\n    var bottomLine = [[left, top + height], [left + width, top + height]];\r\n    if (isSameStartLine([\r\n        [left, top],\r\n        [left + width, top],\r\n        [left, top + height],\r\n        [left + width, top + height],\r\n    ], line, centerSign)) {\r\n        return {\r\n            isAllBound: false,\r\n            isBound: false,\r\n            isVerticalBound: false,\r\n            isHorizontalBound: false,\r\n            offset: [0, 0],\r\n        };\r\n    }\r\n    // test vertical\r\n    var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);\r\n    var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign);\r\n    // test horizontal\r\n    var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);\r\n    var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);\r\n    var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\r\n    var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\r\n    var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\r\n    var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\r\n    var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\r\n    var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\r\n    var offset = [0, 0];\r\n    var isBound = false;\r\n    var isAllBound = false;\r\n    if (abs(horizontalOffset) < abs(verticalOffset)) {\r\n        offset = [verticalOffset, 0];\r\n        isBound = isVerticalBound;\r\n        isAllBound = isAllVerticalBound;\r\n    }\r\n    else {\r\n        offset = [0, horizontalOffset];\r\n        isBound = isHorizontalBound;\r\n        isAllBound = isAllHorizontalBound;\r\n    }\r\n    return {\r\n        isAllBound: isAllBound,\r\n        isVerticalBound: isVerticalBound,\r\n        isHorizontalBound: isHorizontalBound,\r\n        isBound: isBound,\r\n        offset: offset,\r\n    };\r\n}\r\nfunction checkLineBoundCollision(line, _a, boundLine, isStart, threshold, isRender) {\r\n    var _b = __read(_a, 2), a = _b[0], b = _b[1];\r\n    var dot1 = line[0];\r\n    // const dot2 = line[1];\r\n    var boundDot1 = boundLine[0];\r\n    var boundDot2 = boundLine[1];\r\n    // const dy1 = getTinyDist(dot2[1] - dot1[1]);\r\n    // const dx1 = getTinyDist(dot2[0] - dot1[0]);\r\n    var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\r\n    var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\r\n    var hasDx = b;\r\n    var hasDy = a;\r\n    var slope = -a / b;\r\n    // lineConstants\r\n    // ax + by + c = 0\r\n    // dx2 or dy2 is zero\r\n    if (!dx2) {\r\n        // vertical\r\n        // by + c = 0\r\n        if (isRender && !hasDy) {\r\n            // 90deg\r\n            return {\r\n                isBound: false,\r\n                offset: 0,\r\n            };\r\n        }\r\n        else if (hasDx) {\r\n            // ax + by + c = 0\r\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\r\n            var y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\r\n            // boundDot1[1] <= y  <= boundDot2[1]\r\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\r\n        }\r\n        else {\r\n            // ax + c = 0\r\n            var offset = boundDot1[0] - dot1[0];\r\n            var isBound = abs(offset) <= (threshold || 0);\r\n            return {\r\n                isBound: isBound,\r\n                offset: isBound ? offset : 0,\r\n            };\r\n        }\r\n    }\r\n    else if (!dy2) {\r\n        // horizontal\r\n        if (isRender && !hasDx) {\r\n            // 90deg\r\n            return {\r\n                isBound: false,\r\n                offset: 0,\r\n            };\r\n        }\r\n        else if (hasDy) {\r\n            // y = a * (x - x1) + y1\r\n            // x = (y - y1) / a + x1\r\n            // const a = dy1 / dx1;\r\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\r\n            var x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\r\n            // boundDot1[0] <= x && x <= boundDot2[0]\r\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\r\n        }\r\n        else {\r\n            var offset = boundDot1[1] - dot1[1];\r\n            var isBound = abs(offset) <= (threshold || 0);\r\n            return {\r\n                isBound: isBound,\r\n                offset: isBound ? offset : 0,\r\n            };\r\n        }\r\n    }\r\n    return {\r\n        isBound: false,\r\n        offset: 0,\r\n    };\r\n}\r\nfunction getInnerBoundInfo(moveable, lineInfos, datas) {\r\n    return lineInfos.map(function (info) {\r\n        var _a = checkInnerBound(moveable, info), isBound = _a.isBound, offset = _a.offset, isVerticalBound = _a.isVerticalBound, isHorizontalBound = _a.isHorizontalBound;\r\n        var multiple = info.multiple;\r\n        var sizeOffset = getDragDist({\r\n            datas: datas,\r\n            distX: offset[0],\r\n            distY: offset[1],\r\n        }).map(function (size, i) { return size * (multiple[i] ? 2 / multiple[i] : 0); });\r\n        return {\r\n            sign: multiple,\r\n            isBound: isBound,\r\n            isVerticalBound: isVerticalBound,\r\n            isHorizontalBound: isHorizontalBound,\r\n            isSnap: false,\r\n            offset: sizeOffset,\r\n        };\r\n    });\r\n}\r\nfunction getInnerBoundDragInfo(moveable, poses, datas) {\r\n    var _a;\r\n    var lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(function (info) {\r\n        return __assign(__assign({}, info), { multiple: info.multiple.map(function (dir) { return abs(dir) * 2; }) });\r\n    });\r\n    var innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\r\n    var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\r\n    var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\r\n    var verticalOffset = 0;\r\n    var horizontalOffset = 0;\r\n    var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\r\n    var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\r\n    if (isVerticalBound || isHorizontalBound) {\r\n        _a = __read(getInverseDragDist({\r\n            datas: datas,\r\n            distX: -widthOffsetInfo.offset[0],\r\n            distY: -heightOffsetInfo.offset[1],\r\n        }), 2), verticalOffset = _a[0], horizontalOffset = _a[1];\r\n    }\r\n    return {\r\n        vertical: {\r\n            isBound: isVerticalBound,\r\n            offset: verticalOffset,\r\n        },\r\n        horizontal: {\r\n            isBound: isHorizontalBound,\r\n            offset: horizontalOffset,\r\n        },\r\n    };\r\n}\r\nfunction getCheckSnapLineDirections(direction, keepRatio) {\r\n    var lineDirections = [];\r\n    var x = direction[0];\r\n    var y = direction[1];\r\n    if (x && y) {\r\n        lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);\r\n    }\r\n    else if (x) {\r\n        // vertcal\r\n        lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);\r\n        if (keepRatio) {\r\n            lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);\r\n        }\r\n    }\r\n    else if (y) {\r\n        // horizontal\r\n        lineDirections.push([[0, y * 2], [1, y], [-1, y]]);\r\n        if (keepRatio) {\r\n            lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);\r\n        }\r\n    }\r\n    else {\r\n        // [0, 0] to all direction\r\n        lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);\r\n    }\r\n    return lineDirections;\r\n}\r\nfunction getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio) {\r\n    var _a = moveable.state, allMatrix = _a.allMatrix, is3d = _a.is3d;\r\n    var virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\r\n    var center = getPosByDirection(virtualPoses, [0, 0]);\r\n    return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {\r\n        var _b = __read(_a, 3), multiple = _b[0], dir1 = _b[1], dir2 = _b[2];\r\n        var virtualLine = [\r\n            getPosByDirection(virtualPoses, dir1),\r\n            getPosByDirection(virtualPoses, dir2),\r\n        ];\r\n        var lineConstants = solveLineConstants(virtualLine);\r\n        var _c = isStartLine(center, virtualLine), verticalSign = _c.vertical, horizontalSign = _c.horizontal;\r\n        var centerSign = hitTestLine(center, virtualLine) <= 0;\r\n        return {\r\n            multiple: multiple,\r\n            centerSign: centerSign,\r\n            verticalSign: verticalSign,\r\n            horizontalSign: horizontalSign,\r\n            lineConstants: lineConstants,\r\n            line: [\r\n                getPosByDirection(poses, dir1),\r\n                getPosByDirection(poses, dir2),\r\n            ],\r\n        };\r\n    });\r\n}\r\nfunction isBoundRotate(relativePoses, boundDots, center, rad) {\r\n    var nextPoses = rad ? relativePoses.map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad); }) : relativePoses;\r\n    return [\r\n        [nextPoses[0], nextPoses[1]],\r\n        [nextPoses[1], nextPoses[3]],\r\n        [nextPoses[3], nextPoses[2]],\r\n        [nextPoses[2], nextPoses[0]],\r\n    ].some(function (line) {\r\n        var centerSign = hitTestLine(center, line) <= 0;\r\n        return !isSameStartLine(boundDots, line, centerSign);\r\n    });\r\n}\r\nfunction getDistPointLine(_a) {\r\n    // x = 0, y = 0\r\n    // d = (ax + by + c) / root(a2 + b2)\r\n    var _b = __read(_a, 2), pos1 = _b[0], pos2 = _b[1];\r\n    var dx = pos2[0] - pos1[0];\r\n    var dy = pos2[1] - pos1[1];\r\n    if (!dx) {\r\n        return abs(pos1[0]);\r\n    }\r\n    if (!dy) {\r\n        return abs(pos1[1]);\r\n    }\r\n    // y - y1 = a(x - x1)\r\n    // 0 = ax -y + -a * x1 + y1\r\n    var a = dy / dx;\r\n    return abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\r\n}\r\nfunction solveReverseLine(_a) {\r\n    var _b = __read(_a, 2), pos1 = _b[0], pos2 = _b[1];\r\n    var dx = pos2[0] - pos1[0];\r\n    var dy = pos2[1] - pos1[1];\r\n    if (!dx) {\r\n        return [pos1[0], 0];\r\n    }\r\n    if (!dy) {\r\n        return [0, pos1[1]];\r\n    }\r\n    var a = dy / dx;\r\n    // y - y1 = a (x  - x1)\r\n    // y = ax - a * x1 + y1\r\n    var b = -a * pos1[0] + pos1[1];\r\n    // y = ax + b = -1/a x\r\n    // x = -b / (a + 1 / a)\r\n    // y = b / (1 + 1 / a^2)\r\n    return [\r\n        -b / (a + 1 / a),\r\n        b / ((a * a) + 1),\r\n    ];\r\n}\r\nfunction checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {\r\n    var bounds = moveable.props.innerBounds;\r\n    var rad = rotation * Math.PI / 180;\r\n    if (!bounds) {\r\n        return [];\r\n    }\r\n    var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;\r\n    var relativeLeft = left - origin[0];\r\n    var relativeRight = left + width - origin[0];\r\n    var relativeTop = top - origin[1];\r\n    var relativeBottom = top + height - origin[1];\r\n    var dots = [\r\n        [relativeLeft, relativeTop],\r\n        [relativeRight, relativeTop],\r\n        [relativeLeft, relativeBottom],\r\n        [relativeRight, relativeBottom],\r\n    ];\r\n    var center = getPosByDirection(nextPoses, [0, 0]);\r\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\r\n        return [];\r\n    }\r\n    var result = [];\r\n    var dotInfos = dots.map(function (dot) { return [\r\n        getDistSize(dot),\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], dot),\r\n    ]; });\r\n    [\r\n        [nextPoses[0], nextPoses[1]],\r\n        [nextPoses[1], nextPoses[3]],\r\n        [nextPoses[3], nextPoses[2]],\r\n        [nextPoses[2], nextPoses[0]],\r\n    ].forEach(function (line) {\r\n        var lineRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], solveReverseLine(line));\r\n        var lineDist = getDistPointLine(line);\r\n        result.push.apply(result, __spreadArray([], __read(dotInfos\r\n            .filter(function (_a) {\r\n            var _b = __read(_a, 1), dotDist = _b[0];\r\n            return dotDist && lineDist <= dotDist;\r\n        })\r\n            .map(function (_a) {\r\n            var _b = __read(_a, 2), dotDist = _b[0], dotRad = _b[1];\r\n            var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\r\n            var nextRad1 = dotRad + distRad;\r\n            var nextRad2 = dotRad - distRad;\r\n            return [\r\n                rad + nextRad1 - lineRad,\r\n                rad + nextRad2 - lineRad,\r\n            ];\r\n        })\r\n            .reduce(function (prev, cur) {\r\n            prev.push.apply(prev, __spreadArray([], __read(cur), false));\r\n            return prev;\r\n        }, [])\r\n            .filter(function (nextRad) { return !isBoundRotate(prevPoses, dots, center, nextRad); })\r\n            .map(function (nextRad) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(nextRad * 180 / Math.PI, TINY_NUM); })), false));\r\n    });\r\n    return result;\r\n}\r\nfunction checkInnerBoundPoses(moveable) {\r\n    var innerBounds = moveable.props.innerBounds;\r\n    var boundMap = getInitialBounds();\r\n    if (!innerBounds) {\r\n        return {\r\n            boundMap: boundMap,\r\n            vertical: [],\r\n            horizontal: [],\r\n        };\r\n    }\r\n    var _a = moveable.getRect(), pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4;\r\n    var poses = [pos1, pos2, pos3, pos4];\r\n    var center = getPosByDirection(poses, [0, 0]);\r\n    var left = innerBounds.left, top = innerBounds.top, width = innerBounds.width, height = innerBounds.height;\r\n    var leftLine = [[left, top], [left, top + height]];\r\n    var topLine = [[left, top], [left + width, top]];\r\n    var rightLine = [[left + width, top], [left + width, top + height]];\r\n    var bottomLine = [[left, top + height], [left + width, top + height]];\r\n    var lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);\r\n    var horizontalPoses = [];\r\n    var verticalPoses = [];\r\n    lineInfos.forEach(function (lineInfo) {\r\n        var line = lineInfo.line, lineConstants = lineInfo.lineConstants;\r\n        var _a = isStartLine(center, line), isHorizontalStart = _a.horizontal, isVerticalStart = _a.vertical;\r\n        // test vertical\r\n        var topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);\r\n        var bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true);\r\n        // test horizontal\r\n        var leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);\r\n        var rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);\r\n        if (topBoundInfo.isBound && !boundMap.top) {\r\n            horizontalPoses.push(top);\r\n            boundMap.top = true;\r\n        }\r\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\r\n            horizontalPoses.push(top + height);\r\n            boundMap.bottom = true;\r\n        }\r\n        if (leftBoundInfo.isBound && !boundMap.left) {\r\n            verticalPoses.push(left);\r\n            boundMap.left = true;\r\n        }\r\n        if (rightBoundInfo.isBound && !boundMap.right) {\r\n            verticalPoses.push(left + width);\r\n            boundMap.right = true;\r\n        }\r\n    });\r\n    return {\r\n        boundMap: boundMap,\r\n        horizontal: horizontalPoses,\r\n        vertical: verticalPoses,\r\n    };\r\n}\n\nfunction solveEquation(pos1, pos2, snapOffset, isVertical) {\r\n    var dx = pos2[0] - pos1[0];\r\n    var dy = pos2[1] - pos1[1];\r\n    if (abs(dx) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\r\n        dx = 0;\r\n    }\r\n    if (abs(dy) < _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\r\n        dy = 0;\r\n    }\r\n    if (!dx) {\r\n        // y = 0 * x + b\r\n        // only horizontal\r\n        if (!isVertical) {\r\n            return [0, snapOffset];\r\n        }\r\n        return [0, 0];\r\n    }\r\n    if (!dy) {\r\n        // only vertical\r\n        if (isVertical) {\r\n            return [snapOffset, 0];\r\n        }\r\n        return [0, 0];\r\n    }\r\n    // y = ax + b\r\n    var a = dy / dx;\r\n    var b = pos1[1] - a * pos1[0];\r\n    if (isVertical) {\r\n        // y = a * x + b\r\n        var y = a * (pos2[0] + snapOffset) + b;\r\n        return [snapOffset, y - pos2[1]];\r\n    }\r\n    else {\r\n        // x = (y - b) / a\r\n        var x = (pos2[1] + snapOffset - b) / a;\r\n        return [x - pos2[0], snapOffset];\r\n    }\r\n}\r\nfunction solveNextOffset(pos1, pos2, offset, isVertical, datas) {\r\n    var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\r\n    if (!sizeOffset) {\r\n        return {\r\n            isOutside: false,\r\n            offset: [0, 0],\r\n        };\r\n    }\r\n    var size = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(pos1, pos2);\r\n    var dist1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(sizeOffset, pos1);\r\n    var dist2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(sizeOffset, pos2);\r\n    var isOutside = dist1 > size || dist2 > size;\r\n    var _a = __read(getDragDist({\r\n        datas: datas,\r\n        distX: sizeOffset[0],\r\n        distY: sizeOffset[1],\r\n    }), 2), widthOffset = _a[0], heightOffset = _a[1];\r\n    return {\r\n        offset: [widthOffset, heightOffset],\r\n        isOutside: isOutside,\r\n    };\r\n}\r\nfunction getSnapBound(boundInfo, snapInfo) {\r\n    if (boundInfo.isBound) {\r\n        return boundInfo.offset;\r\n    }\r\n    else if (snapInfo.isSnap) {\r\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\r\n    }\r\n    return 0;\r\n}\r\nfunction checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {\r\n    var _e = __read(_a, 2), distX = _e[0], distY = _e[1];\r\n    var _f = __read(_b, 2), isVerticalBound = _f[0], isHorizontalBound = _f[1];\r\n    var _g = __read(_c, 2), isVerticalSnap = _g[0], isHorizontalSnap = _g[1];\r\n    var _h = __read(_d, 2), verticalOffset = _h[0], horizontalOffset = _h[1];\r\n    var offsetX = -verticalOffset;\r\n    var offsetY = -horizontalOffset;\r\n    if (throttleDragRotate && distX && distY) {\r\n        offsetX = 0;\r\n        offsetY = 0;\r\n        var adjustPoses = [];\r\n        if (isVerticalBound && isHorizontalBound) {\r\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\r\n        }\r\n        else if (isVerticalBound) {\r\n            adjustPoses.push([verticalOffset, 0]);\r\n        }\r\n        else if (isHorizontalBound) {\r\n            adjustPoses.push([0, horizontalOffset]);\r\n        }\r\n        else if (isVerticalSnap && isHorizontalSnap) {\r\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\r\n        }\r\n        else if (isVerticalSnap) {\r\n            adjustPoses.push([verticalOffset, 0]);\r\n        }\r\n        else if (isHorizontalSnap) {\r\n            adjustPoses.push([0, horizontalOffset]);\r\n        }\r\n        if (adjustPoses.length) {\r\n            adjustPoses.sort(function (a, b) {\r\n                return (getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([distX, distY], a)) -\r\n                    getDistSize((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([distX, distY], b)));\r\n            });\r\n            var adjustPos = adjustPoses[0];\r\n            if (adjustPos[0] && abs(distX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\r\n                offsetX = -adjustPos[0];\r\n                offsetY =\r\n                    (distY * abs(distX + offsetX)) / abs(distX) -\r\n                        distY;\r\n            }\r\n            else if (adjustPos[1] && abs(distY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM) {\r\n                var prevDistY = distY;\r\n                offsetY = -adjustPos[1];\r\n                offsetX =\r\n                    (distX * abs(distY + offsetY)) / abs(prevDistY) -\r\n                        distX;\r\n            }\r\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\r\n                if (abs(offsetX) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM &&\r\n                    abs(offsetX) < abs(verticalOffset)) {\r\n                    var scale = abs(verticalOffset) / abs(offsetX);\r\n                    offsetX *= scale;\r\n                    offsetY *= scale;\r\n                }\r\n                else if (abs(offsetY) > _daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.TINY_NUM &&\r\n                    abs(offsetY) < abs(horizontalOffset)) {\r\n                    var scale = abs(horizontalOffset) / abs(offsetY);\r\n                    offsetX *= scale;\r\n                    offsetY *= scale;\r\n                }\r\n                else {\r\n                    offsetX = maxOffset(-verticalOffset, offsetX);\r\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\r\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\r\n    }\r\n    return [offsetX, offsetY];\r\n}\r\nfunction checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, ignoreSnap, datas) {\r\n    if (!hasGuidelines(moveable, \"draggable\")) {\r\n        return [\r\n            {\r\n                isSnap: false,\r\n                isBound: false,\r\n                offset: 0,\r\n            },\r\n            {\r\n                isSnap: false,\r\n                isBound: false,\r\n                offset: 0,\r\n            },\r\n        ];\r\n    }\r\n    var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\r\n    var _a = getRect(poses), left = _a.left, right = _a.right, top = _a.top, bottom = _a.bottom;\r\n    var boundPoses = {\r\n        horizontal: poses.map(function (pos) { return pos[1]; }),\r\n        vertical: poses.map(function (pos) { return pos[0]; }),\r\n    };\r\n    var snapDirections = getSnapDirections(moveable.props.snapDirections);\r\n    var snapPoses = splitSnapDirectionPoses(snapDirections, {\r\n        left: left,\r\n        right: right,\r\n        top: top,\r\n        bottom: bottom,\r\n        center: (left + right) / 2,\r\n        middle: (top + bottom) / 2,\r\n    });\r\n    var _b = checkMoveableSnapBounds(moveable, ignoreSnap, snapPoses, boundPoses), verticalSnapBoundInfo = _b.vertical, horizontalSnapBoundInfo = _b.horizontal;\r\n    var _c = getInnerBoundDragInfo(moveable, poses, datas), verticalInnerBoundInfo = _c.vertical, horizontalInnerBoundInfo = _c.horizontal;\r\n    var isVerticalSnap = verticalSnapBoundInfo.isSnap;\r\n    var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\r\n    var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\r\n    var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\r\n    var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\r\n    var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\r\n    var _d = __read(checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]), 2), offsetX = _d[0], offsetY = _d[1];\r\n    return [\r\n        {\r\n            isBound: isVerticalBound,\r\n            isSnap: isVerticalSnap,\r\n            offset: offsetX,\r\n        },\r\n        {\r\n            isBound: isHorizontalBound,\r\n            isSnap: isHorizontalSnap,\r\n            offset: offsetY,\r\n        },\r\n    ];\r\n}\r\nfunction checkMoveableSnapBounds(moveable, ignoreSnap, poses, boundPoses) {\r\n    if (boundPoses === void 0) { boundPoses = poses; }\r\n    var _a = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal), horizontalBoundInfos = _a.horizontal, verticalBoundInfos = _a.vertical;\r\n    var _b = ignoreSnap ? {\r\n        horizontal: { isSnap: false, index: -1 },\r\n        vertical: { isSnap: false, index: -1 },\r\n    } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, undefined, undefined, undefined, undefined), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;\r\n    var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\r\n    var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\r\n    var horizontalDist = abs(horizontalOffset);\r\n    var verticalDist = abs(verticalOffset);\r\n    return {\r\n        horizontal: {\r\n            isBound: horizontalBoundInfos[0].isBound,\r\n            isSnap: horizontalSnapInfo.isSnap,\r\n            snapIndex: horizontalSnapInfo.index,\r\n            offset: horizontalOffset,\r\n            dist: horizontalDist,\r\n            bounds: horizontalBoundInfos,\r\n            snap: horizontalSnapInfo,\r\n        },\r\n        vertical: {\r\n            isBound: verticalBoundInfos[0].isBound,\r\n            isSnap: verticalSnapInfo.isSnap,\r\n            snapIndex: verticalSnapInfo.index,\r\n            offset: verticalOffset,\r\n            dist: verticalDist,\r\n            bounds: verticalBoundInfos,\r\n            snap: verticalSnapInfo,\r\n        },\r\n    };\r\n}\r\nfunction checkSnapBounds(guideines, bounds, posesX, posesY, snapHorizontalThreshold, snapVerticalThreshold, multiples) {\r\n    if (multiples === void 0) { multiples = [1, 1]; }\r\n    var _a = checkBoundPoses(bounds, posesX, posesY), horizontalBoundInfos = _a.horizontal, verticalBoundInfos = _a.vertical;\r\n    // options.isRequest ? {\r\n    //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\r\n    //     vertical: { isSnap: false, index: -1 } as SnapInfo,\r\n    // } :\r\n    var _b = checkSnapPoses(guideines, posesX, posesY, [], [], snapHorizontalThreshold, snapVerticalThreshold, multiples), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;\r\n    var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\r\n    var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\r\n    var horizontalDist = abs(horizontalOffset);\r\n    var verticalDist = abs(verticalOffset);\r\n    return {\r\n        horizontal: {\r\n            isBound: horizontalBoundInfos[0].isBound,\r\n            isSnap: horizontalSnapInfo.isSnap,\r\n            snapIndex: horizontalSnapInfo.index,\r\n            offset: horizontalOffset,\r\n            dist: horizontalDist,\r\n            bounds: horizontalBoundInfos,\r\n            snap: horizontalSnapInfo,\r\n        },\r\n        vertical: {\r\n            isBound: verticalBoundInfos[0].isBound,\r\n            isSnap: verticalSnapInfo.isSnap,\r\n            snapIndex: verticalSnapInfo.index,\r\n            offset: verticalOffset,\r\n            dist: verticalDist,\r\n            bounds: verticalBoundInfos,\r\n            snap: verticalSnapInfo,\r\n        },\r\n    };\r\n}\r\nfunction checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {\r\n    var rad = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(startPos, endPos) / Math.PI) * 180;\r\n    var _a = snapBoundInfo.vertical, isVerticalBound = _a.isBound, isVerticalSnap = _a.isSnap, verticalDist = _a.dist, _b = snapBoundInfo.horizontal, isHorizontalBound = _b.isBound, isHorizontalSnap = _b.isSnap, horizontalDist = _b.dist;\r\n    var rad180 = rad % 180;\r\n    var isHorizontalLine = rad180 < 3 || rad180 > 177;\r\n    var isVerticalLine = rad180 > 87 && rad180 < 93;\r\n    if (horizontalDist < verticalDist) {\r\n        if (isVerticalBound ||\r\n            (isVerticalSnap &&\r\n                !isVerticalLine &&\r\n                (!keepRatio || !isHorizontalLine))) {\r\n            return \"vertical\";\r\n        }\r\n    }\r\n    if (isHorizontalBound ||\r\n        (isHorizontalSnap &&\r\n            !isHorizontalLine &&\r\n            (!keepRatio || !isVerticalLine))) {\r\n        return \"horizontal\";\r\n    }\r\n    return \"\";\r\n}\r\nfunction getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {\r\n    return directions.map(function (_a) {\r\n        var _b = __read(_a, 2), startDirection = _b[0], endDirection = _b[1];\r\n        var otherStartPos = getPosByDirection(poses, startDirection);\r\n        var otherEndPos = getPosByDirection(poses, endDirection);\r\n        var snapBoundInfo = keepRatio\r\n            ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest)\r\n            : checkMoveableSnapBounds(moveable, isRequest, {\r\n                vertical: [otherEndPos[0]],\r\n                horizontal: [otherEndPos[1]],\r\n            });\r\n        var _c = snapBoundInfo.horizontal, \r\n        // dist: otherHorizontalDist,\r\n        otherHorizontalOffset = _c.offset, isOtherHorizontalBound = _c.isBound, isOtherHorizontalSnap = _c.isSnap, _d = snapBoundInfo.vertical, \r\n        // dist: otherVerticalDist,\r\n        otherVerticalOffset = _d.offset, isOtherVerticalBound = _d.isBound, isOtherVerticalSnap = _d.isSnap;\r\n        var multiple = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(endDirection, startDirection);\r\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\r\n            return {\r\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\r\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\r\n                sign: multiple,\r\n                offset: [0, 0],\r\n            };\r\n        }\r\n        var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);\r\n        if (!snapLine) {\r\n            return {\r\n                sign: multiple,\r\n                isBound: false,\r\n                isSnap: false,\r\n                offset: [0, 0],\r\n            };\r\n        }\r\n        var isVertical = snapLine === \"vertical\";\r\n        var sizeOffset = [0, 0];\r\n        if (!keepRatio\r\n            && abs(endDirection[0]) === 1\r\n            && abs(endDirection[1]) === 1\r\n            && startDirection[0] !== endDirection[0]\r\n            && startDirection[1] !== endDirection[1]) {\r\n            sizeOffset = getDragDist({\r\n                datas: datas,\r\n                distX: -otherVerticalOffset,\r\n                distY: -otherHorizontalOffset,\r\n            });\r\n        }\r\n        else {\r\n            sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset;\r\n        }\r\n        sizeOffset = sizeOffset.map(function (size, i) { return size * (multiple[i] ? 2 / multiple[i] : 0); });\r\n        return {\r\n            sign: multiple,\r\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\r\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\r\n            offset: sizeOffset,\r\n        };\r\n    });\r\n}\r\nfunction getSnapBoundOffset(boundInfo, snapInfo) {\r\n    if (boundInfo.isBound) {\r\n        return boundInfo.offset;\r\n    }\r\n    else if (snapInfo.isSnap) {\r\n        return snapInfo.offset;\r\n    }\r\n    return 0;\r\n}\r\nfunction checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {\r\n    var _a = checkBoundKeepRatio(moveable, startPos, endPos), horizontalBoundInfo = _a.horizontal, verticalBoundInfo = _a.vertical;\r\n    var _b = isRequest ? {\r\n        horizontal: { isSnap: false },\r\n        vertical: { isSnap: false },\r\n    } : checkSnapKeepRatio(moveable, startPos, endPos), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;\r\n    var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\r\n    var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\r\n    var horizontalDist = abs(horizontalOffset);\r\n    var verticalDist = abs(verticalOffset);\r\n    return {\r\n        horizontal: {\r\n            isBound: horizontalBoundInfo.isBound,\r\n            isSnap: horizontalSnapInfo.isSnap,\r\n            offset: horizontalOffset,\r\n            dist: horizontalDist,\r\n        },\r\n        vertical: {\r\n            isBound: verticalBoundInfo.isBound,\r\n            isSnap: verticalSnapInfo.isSnap,\r\n            offset: verticalOffset,\r\n            dist: verticalDist,\r\n        },\r\n    };\r\n}\r\nfunction checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {\r\n    var fixedDirection = [-direction[0], -direction[1]];\r\n    var _a = moveable.state, width = _a.width, height = _a.height;\r\n    var bounds = moveable.props.bounds;\r\n    var maxWidth = Infinity;\r\n    var maxHeight = Infinity;\r\n    if (bounds) {\r\n        var directions = [\r\n            [direction[0], -direction[1]],\r\n            [-direction[0], direction[1]],\r\n        ];\r\n        var _b = bounds.left, left_1 = _b === void 0 ? -Infinity : _b, _c = bounds.top, top_1 = _c === void 0 ? -Infinity : _c, _d = bounds.right, right_1 = _d === void 0 ? Infinity : _d, _e = bounds.bottom, bottom_1 = _e === void 0 ? Infinity : _e;\r\n        directions.forEach(function (otherDirection) {\r\n            var isCheckVertical = otherDirection[0] !== fixedDirection[0];\r\n            var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\r\n            var otherPos = getPosByDirection(poses, otherDirection);\r\n            var deg = ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(fixedPosition, otherPos) * 360) / Math.PI;\r\n            if (isCheckHorizontal) {\r\n                var nextOtherPos = otherPos.slice();\r\n                if (abs(deg - 360) < 2 || abs(deg - 180) < 2) {\r\n                    nextOtherPos[1] = fixedPosition[1];\r\n                }\r\n                var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) -\r\n                    otherPos[1], false, datas), _b = __read(_a.offset, 2), heightOffset = _b[1], isHeightOutside = _a.isOutside;\r\n                if (!isNaN(heightOffset)) {\r\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * abs(heightOffset);\r\n                }\r\n            }\r\n            if (isCheckVertical) {\r\n                var nextOtherPos = otherPos.slice();\r\n                if (abs(deg - 90) < 2 || abs(deg - 270) < 2) {\r\n                    nextOtherPos[0] = fixedPosition[0];\r\n                }\r\n                var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas), _d = __read(_c.offset, 1), widthOffset = _d[0], isWidthOutside = _c.isOutside;\r\n                if (!isNaN(widthOffset)) {\r\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * abs(widthOffset);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return {\r\n        maxWidth: maxWidth,\r\n        maxHeight: maxHeight,\r\n    };\r\n}\n\n/**\r\n * @namespace Draggable\r\n * @memberof Moveable\r\n * @description Draggable refers to the ability to drag and move targets.\r\n */\r\nvar Draggable = {\r\n    name: \"draggable\",\r\n    props: [\r\n        \"draggable\",\r\n        \"throttleDrag\",\r\n        \"throttleDragRotate\",\r\n        \"hideThrottleDragRotateLine\",\r\n        \"startDragRotate\",\r\n        \"edgeDraggable\",\r\n    ],\r\n    events: [\r\n        \"dragStart\",\r\n        \"drag\",\r\n        \"dragEnd\",\r\n        \"dragGroupStart\",\r\n        \"dragGroup\",\r\n        \"dragGroupEnd\",\r\n    ],\r\n    requestStyle: function () {\r\n        return [\"left\", \"top\", \"right\", \"bottom\"];\r\n    },\r\n    requestChildStyle: function () {\r\n        return [\"left\", \"top\", \"right\", \"bottom\"];\r\n    },\r\n    render: function (moveable, React) {\r\n        var _a = moveable.props, hideThrottleDragRotateLine = _a.hideThrottleDragRotateLine, throttleDragRotate = _a.throttleDragRotate, zoom = _a.zoom;\r\n        var _b = moveable.getState(), dragInfo = _b.dragInfo, beforeOrigin = _b.beforeOrigin;\r\n        if (hideThrottleDragRotateLine || !throttleDragRotate || !dragInfo) {\r\n            return [];\r\n        }\r\n        var dist = dragInfo.dist;\r\n        if (!dist[0] && !dist[1]) {\r\n            return [];\r\n        }\r\n        var width = getDistSize(dist);\r\n        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(dist, [0, 0]);\r\n        return [React.createElement(\"div\", { className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"), key: \"dragRotateGuideline\", style: {\r\n                    width: \"\".concat(width, \"px\"),\r\n                    transform: \"translate(\".concat(beforeOrigin[0], \"px, \").concat(beforeOrigin[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\"),\r\n                } })];\r\n    },\r\n    dragStart: function (moveable, e) {\r\n        var datas = e.datas, parentEvent = e.parentEvent, parentGesto = e.parentGesto;\r\n        var state = moveable.state;\r\n        var gestos = state.gestos, style = state.style;\r\n        if (gestos.draggable) {\r\n            return false;\r\n        }\r\n        gestos.draggable = parentGesto || moveable.targetGesto;\r\n        datas.datas = {};\r\n        datas.left = parseFloat(style.left || \"\") || 0;\r\n        datas.top = parseFloat(style.top || \"\") || 0;\r\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\r\n        datas.right = parseFloat(style.right || \"\") || 0;\r\n        datas.startValue = [0, 0];\r\n        setDragStart(moveable, e);\r\n        setDefaultTransformIndex(moveable, e, \"translate\");\r\n        startCheckSnapDrag(moveable, datas);\r\n        datas.prevDist = [0, 0];\r\n        datas.prevBeforeDist = [0, 0];\r\n        datas.isDrag = false;\r\n        datas.deltaOffset = [0, 0];\r\n        var params = fillParams(moveable, e, __assign({ set: function (translate) {\r\n                datas.startValue = translate;\r\n            } }, fillTransformStartEvent(moveable, e)));\r\n        var result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\r\n        if (result !== false) {\r\n            datas.isDrag = true;\r\n            moveable.state.dragInfo = {\r\n                startRect: moveable.getRect(),\r\n                dist: [0, 0],\r\n            };\r\n        }\r\n        else {\r\n            gestos.draggable = null;\r\n            datas.isPinch = false;\r\n        }\r\n        return datas.isDrag ? params : false;\r\n    },\r\n    drag: function (moveable, e) {\r\n        if (!e) {\r\n            return;\r\n        }\r\n        resolveTransformEvent(moveable, e, \"translate\");\r\n        var datas = e.datas, parentEvent = e.parentEvent, parentFlag = e.parentFlag, isPinch = e.isPinch, deltaOffset = e.deltaOffset, useSnap = e.useSnap, isRequest = e.isRequest, isGroup = e.isGroup, parentThrottleDrag = e.parentThrottleDrag;\r\n        var distX = e.distX, distY = e.distY;\r\n        var isDrag = datas.isDrag, prevDist = datas.prevDist, prevBeforeDist = datas.prevBeforeDist, startValue = datas.startValue;\r\n        if (!isDrag) {\r\n            return;\r\n        }\r\n        if (deltaOffset) {\r\n            distX += deltaOffset[0];\r\n            distY += deltaOffset[1];\r\n        }\r\n        var props = moveable.props;\r\n        var parentMoveable = props.parentMoveable;\r\n        var throttleDrag = isGroup ? 0 : (props.throttleDrag || parentThrottleDrag || 0);\r\n        var throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\r\n        var dragRotateRad = 0;\r\n        var isVerticalSnap = false;\r\n        var isVerticalBound = false;\r\n        var isHorizontalSnap = false;\r\n        var isHorizontalBound = false;\r\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\r\n            var startDragRotate = props.startDragRotate || 0;\r\n            var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startDragRotate + (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\r\n                - startDragRotate;\r\n            var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\r\n            var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\r\n            var r = getDistSize([rx, ry]);\r\n            dragRotateRad = deg * Math.PI / 180;\r\n            distX = r * Math.cos(dragRotateRad);\r\n            distY = r * Math.sin(dragRotateRad);\r\n        }\r\n        if (!isPinch && !parentEvent && !parentFlag) {\r\n            var _a = __read(checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, (!useSnap && isRequest) || deltaOffset, datas), 2), verticalInfo = _a[0], horizontalInfo = _a[1];\r\n            isVerticalSnap = verticalInfo.isSnap;\r\n            isVerticalBound = verticalInfo.isBound;\r\n            isHorizontalSnap = horizontalInfo.isSnap;\r\n            isHorizontalBound = horizontalInfo.isBound;\r\n            var verticalOffset = verticalInfo.offset;\r\n            var horizontalOffset = horizontalInfo.offset;\r\n            distX += verticalOffset;\r\n            distY += horizontalOffset;\r\n        }\r\n        var beforeTranslate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(getBeforeDragDist({ datas: datas, distX: distX, distY: distY }), startValue);\r\n        var translate = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(getTransformDist({ datas: datas, distX: distX, distY: distY }), startValue);\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttleArray)(translate, TINY_NUM);\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttleArray)(beforeTranslate, TINY_NUM);\r\n        if (!throttleDragRotate) {\r\n            if (!isVerticalSnap && !isVerticalBound) {\r\n                translate[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(translate[0], throttleDrag);\r\n                beforeTranslate[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(beforeTranslate[0], throttleDrag);\r\n            }\r\n            if (!isHorizontalSnap && !isHorizontalBound) {\r\n                translate[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(translate[1], throttleDrag);\r\n                beforeTranslate[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(beforeTranslate[1], throttleDrag);\r\n            }\r\n        }\r\n        var beforeDist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeTranslate, startValue);\r\n        var dist = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(translate, startValue);\r\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, prevDist);\r\n        var beforeDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeDist, prevBeforeDist);\r\n        datas.prevDist = dist;\r\n        datas.prevBeforeDist = beforeDist;\r\n        datas.passDelta = delta; //distX - (datas.passDistX || 0);\r\n        // datas.passDeltaY = distY - (datas.passDistY || 0);\r\n        datas.passDist = dist; //distX;\r\n        // datas.passDistY = distY;\r\n        var left = datas.left + beforeDist[0];\r\n        var top = datas.top + beforeDist[1];\r\n        var right = datas.right - beforeDist[0];\r\n        var bottom = datas.bottom - beforeDist[1];\r\n        var nextTransform = convertTransformFormat(datas, \"translate(\".concat(translate[0], \"px, \").concat(translate[1], \"px)\"), \"translate(\".concat(dist[0], \"px, \").concat(dist[1], \"px)\"));\r\n        fillOriginalTransform(e, nextTransform);\r\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\r\n        if (!parentEvent && !parentMoveable && delta.every(function (num) { return !num; }) && beforeDelta.some(function (num) { return !num; })) {\r\n            return;\r\n        }\r\n        var _b = moveable.state, width = _b.width, height = _b.height;\r\n        var params = fillParams(moveable, e, __assign({ transform: nextTransform, dist: dist, delta: delta, translate: translate, beforeDist: beforeDist, beforeDelta: beforeDelta, beforeTranslate: beforeTranslate, left: left, top: top, right: right, bottom: bottom, width: width, height: height, isPinch: isPinch }, fillCSSObject({\r\n            transform: nextTransform,\r\n        }, e)));\r\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\r\n        return params;\r\n    },\r\n    dragAfter: function (moveable, e) {\r\n        var datas = e.datas;\r\n        var deltaOffset = datas.deltaOffset;\r\n        if (deltaOffset[0] || deltaOffset[1]) {\r\n            datas.deltaOffset = [0, 0];\r\n            return this.drag(moveable, __assign(__assign({}, e), { deltaOffset: deltaOffset }));\r\n        }\r\n        return false;\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        var parentEvent = e.parentEvent, datas = e.datas;\r\n        moveable.state.dragInfo = null;\r\n        if (!datas.isDrag) {\r\n            return;\r\n        }\r\n        datas.isDrag = false;\r\n        var param = fillEndParams(moveable, e, {});\r\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\r\n        return param;\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        var _a, _b;\r\n        var datas = e.datas, clientX = e.clientX, clientY = e.clientY;\r\n        var params = this.dragStart(moveable, e);\r\n        if (!params) {\r\n            return false;\r\n        }\r\n        var _c = triggerChildGesto(moveable, this, \"dragStart\", [\r\n            clientX || 0,\r\n            clientY || 0,\r\n        ], e, false, \"draggable\"), childEvents = _c.childEvents, eventParams = _c.eventParams;\r\n        var nextParams = __assign(__assign({}, params), { targets: moveable.props.targets, events: eventParams });\r\n        var result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\r\n        datas.isDrag = result !== false;\r\n        // find data.startValue and based on first child moveable\r\n        var startValue = (_b = (_a = childEvents[0]) === null || _a === void 0 ? void 0 : _a.datas.startValue) !== null && _b !== void 0 ? _b : [0, 0];\r\n        datas.throttleOffset = [startValue[0] % 1, startValue[1] % 1];\r\n        return datas.isDrag ? params : false;\r\n    },\r\n    dragGroup: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isDrag) {\r\n            return;\r\n        }\r\n        var params = this.drag(moveable, __assign(__assign({}, e), { parentThrottleDrag: moveable.props.throttleDrag }));\r\n        var passDelta = e.datas.passDelta;\r\n        var eventParams = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false, \"draggable\").eventParams;\r\n        if (!params) {\r\n            return;\r\n        }\r\n        var nextParams = __assign({ targets: moveable.props.targets, events: eventParams }, params);\r\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\r\n        return nextParams;\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        var isDrag = e.isDrag, datas = e.datas;\r\n        if (!datas.isDrag) {\r\n            return;\r\n        }\r\n        this.dragEnd(moveable, e);\r\n        var eventParams = triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false, \"draggable\").eventParams;\r\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams(moveable, e, {\r\n            targets: moveable.props.targets,\r\n            events: eventParams,\r\n        }));\r\n        return isDrag;\r\n    },\r\n    /**\r\n     * @method Moveable.Draggable#request\r\n     * @param {object} [e] - the draggable's request parameter\r\n     * @param {number} [e.x] - x position\r\n     * @param {number} [e.y] - y position\r\n     * @param {number} [e.deltaX] - X number to move\r\n     * @param {number} [e.deltaY] - Y number to move\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * // Use Relative Value\r\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\r\n     * // Use Absolute Value\r\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"draggable\");\r\n     *\r\n     * // request\r\n     * // Use Relative Value\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * // Use Absolute Value\r\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\r\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\r\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */\r\n    request: function (moveable) {\r\n        var datas = {};\r\n        var rect = moveable.getRect();\r\n        var distX = 0;\r\n        var distY = 0;\r\n        var useSnap = false;\r\n        return {\r\n            isControl: false,\r\n            requestStart: function (e) {\r\n                useSnap = e.useSnap;\r\n                return { datas: datas, useSnap: useSnap };\r\n            },\r\n            request: function (e) {\r\n                if (\"x\" in e) {\r\n                    distX = e.x - rect.left;\r\n                }\r\n                else if (\"deltaX\" in e) {\r\n                    distX += e.deltaX;\r\n                }\r\n                if (\"y\" in e) {\r\n                    distY = e.y - rect.top;\r\n                }\r\n                else if (\"deltaY\" in e) {\r\n                    distY += e.deltaY;\r\n                }\r\n                return { datas: datas, distX: distX, distY: distY, useSnap: useSnap };\r\n            },\r\n            requestEnd: function () {\r\n                return { datas: datas, isDrag: true, useSnap: useSnap };\r\n            },\r\n        };\r\n    },\r\n    unset: function (moveable) {\r\n        moveable.state.gestos.draggable = null;\r\n        moveable.state.dragInfo = null;\r\n    },\r\n};\r\n/**\r\n * Whether or not target can be dragged. (default: false)\r\n * @name Moveable.Draggable#draggable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.draggable = true;\r\n */\r\n/**\r\n * throttle of x, y when drag.\r\n * @name Moveable.Draggable#throttleDrag\r\n * @default 0\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.throttleDrag = 1;\r\n */\r\n/**\r\n* throttle of angle of x, y when drag.\r\n* @name Moveable.Draggable#throttleDragRotate\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body);\r\n*\r\n* moveable.throttleDragRotate = 45;\r\n*/\r\n/**\r\n* start angle of throttleDragRotate of x, y when drag.\r\n* @name Moveable.Draggable#startDragRotate\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body);\r\n*\r\n* // 45, 135, 225, 315\r\n* moveable.throttleDragRotate = 90;\r\n* moveable.startDragRotate = 45;\r\n*/\r\n/**\r\n * When the drag starts, the dragStart event is called.\r\n * @memberof Moveable.Draggable\r\n * @event dragStart\r\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { draggable: true });\r\n * moveable.on(\"dragStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n * When dragging, the drag event is called.\r\n * @memberof Moveable.Draggable\r\n * @event drag\r\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { draggable: true });\r\n * moveable.on(\"drag\", ({ target, transform }) => {\r\n *     target.style.transform = transform;\r\n * });\r\n */\r\n/**\r\n * When the drag finishes, the dragEnd event is called.\r\n * @memberof Moveable.Draggable\r\n * @event dragEnd\r\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { draggable: true });\r\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */\r\n/**\r\n* When the group drag starts, the `dragGroupStart` event is called.\r\n* @memberof Moveable.Draggable\r\n* @event dragGroupStart\r\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     draggable: true\r\n* });\r\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\r\n*     console.log(\"onDragGroupStart\", targets);\r\n* });\r\n*/\r\n/**\r\n* When the group drag, the `dragGroup` event is called.\r\n* @memberof Moveable.Draggable\r\n* @event dragGroup\r\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     draggable: true\r\n* });\r\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\r\n*     console.log(\"onDragGroup\", targets);\r\n*     events.forEach(ev => {\r\n*          // drag event\r\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\r\n*          // ev.target!.style.left = `${ev.left}px`;\r\n*          // ev.target!.style.top = `${ev.top}px`;\r\n*          console.log(\"onDrag translate\", ev.dist);\r\n*          ev.target!.style.transform = ev.transform;)\r\n*     });\r\n* });\r\n*/\r\n/**\r\n * When the group drag finishes, the `dragGroupEnd` event is called.\r\n * @memberof Moveable.Draggable\r\n * @event dragGroupEnd\r\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     draggable: true\r\n * });\r\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\r\n * });\r\n */\n\nfunction getFixedDirectionInfo(startPositions, fixedDirection) {\r\n    var fixedPosition = getPosByDirection(startPositions, fixedDirection);\r\n    var fixedOffset = [0, 0];\r\n    return {\r\n        fixedPosition: fixedPosition,\r\n        fixedDirection: fixedDirection,\r\n        fixedOffset: fixedOffset,\r\n    };\r\n}\r\nfunction getOffsetFixedDirectionInfo(state, fixedDirection) {\r\n    // for start\r\n    var allMatrix = state.allMatrix, is3d = state.is3d, width = state.width, height = state.height;\r\n    var n = is3d ? 4 : 3;\r\n    var nextFixedOffset = [\r\n        width / 2 * (1 + fixedDirection[0]),\r\n        height / 2 * (1 + fixedDirection[1]),\r\n    ];\r\n    var fixedPosition = calculatePosition(allMatrix, nextFixedOffset, n);\r\n    var fixedOffset = [0, 0];\r\n    return {\r\n        fixedPosition: fixedPosition,\r\n        fixedDirection: fixedDirection,\r\n        fixedOffset: fixedOffset,\r\n    };\r\n}\r\nfunction getOffsetFixedPositionInfo(state, offsetFixedPosition) {\r\n    // for start\r\n    var allMatrix = state.allMatrix, is3d = state.is3d, width = state.width, height = state.height;\r\n    var n = is3d ? 4 : 3;\r\n    var fixedDirection = getDirectionByPos(offsetFixedPosition, width, height);\r\n    var nextFixedPosition = calculatePosition(allMatrix, offsetFixedPosition, n);\r\n    var fixedOffset = [\r\n        width ? 0 : offsetFixedPosition[0],\r\n        height ? 0 : offsetFixedPosition[1],\r\n    ];\r\n    return {\r\n        fixedPosition: nextFixedPosition,\r\n        fixedDirection: fixedDirection,\r\n        fixedOffset: fixedOffset,\r\n    };\r\n}\n\n/**\r\n * @namespace Resizable\r\n * @memberof Moveable\r\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\r\n */\r\nvar directionCondition$2 = getDirectionCondition(\"resizable\");\r\nvar Resizable = {\r\n    name: \"resizable\",\r\n    ableGroup: \"size\",\r\n    canPinch: true,\r\n    props: [\r\n        \"resizable\",\r\n        \"throttleResize\",\r\n        \"renderDirections\",\r\n        \"displayAroundControls\",\r\n        \"keepRatio\",\r\n        \"resizeFormat\",\r\n        \"keepRatioFinally\",\r\n        \"edge\",\r\n        \"checkResizableError\",\r\n    ],\r\n    events: [\r\n        \"resizeStart\",\r\n        \"beforeResize\",\r\n        \"resize\",\r\n        \"resizeEnd\",\r\n        \"resizeGroupStart\",\r\n        \"beforeResizeGroup\",\r\n        \"resizeGroup\",\r\n        \"resizeGroupEnd\",\r\n    ],\r\n    render: getRenderDirections(\"resizable\"),\r\n    dragControlCondition: directionCondition$2,\r\n    viewClassName: getDirectionViewClassName(\"resizable\"),\r\n    dragControlStart: function (moveable, e) {\r\n        var _a;\r\n        var inputEvent = e.inputEvent, isPinch = e.isPinch, isGroup = e.isGroup, parentDirection = e.parentDirection, parentGesto = e.parentGesto, datas = e.datas, parentFixedDirection = e.parentFixedDirection, parentEvent = e.parentEvent;\r\n        var direction = getTotalDirection(parentDirection, isPinch, inputEvent, datas);\r\n        var state = moveable.state;\r\n        var target = state.target, width = state.width, height = state.height, gestos = state.gestos;\r\n        if (!direction || !target) {\r\n            return false;\r\n        }\r\n        if (gestos.resizable) {\r\n            return false;\r\n        }\r\n        gestos.resizable = parentGesto || moveable.controlGesto;\r\n        !isPinch && setDragStart(moveable, e);\r\n        datas.datas = {};\r\n        datas.direction = direction;\r\n        datas.startOffsetWidth = width;\r\n        datas.startOffsetHeight = height;\r\n        datas.prevWidth = 0;\r\n        datas.prevHeight = 0;\r\n        datas.minSize = [0, 0];\r\n        datas.startWidth = state.inlineCSSWidth || state.cssWidth;\r\n        datas.startHeight = state.inlineCSSHeight || state.cssHeight;\r\n        datas.maxSize = [Infinity, Infinity];\r\n        if (!isGroup) {\r\n            datas.minSize = [\r\n                state.minOffsetWidth,\r\n                state.minOffsetHeight,\r\n            ];\r\n            datas.maxSize = [\r\n                state.maxOffsetWidth,\r\n                state.maxOffsetHeight,\r\n            ];\r\n        }\r\n        var transformOrigin = moveable.props.transformOrigin || \"% %\";\r\n        datas.transformOrigin = transformOrigin && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(transformOrigin)\r\n            ? transformOrigin.split(\" \")\r\n            : transformOrigin;\r\n        datas.startOffsetMatrix = state.offsetMatrix;\r\n        datas.startTransformOrigin = state.transformOrigin;\r\n        datas.isWidth = (_a = e === null || e === void 0 ? void 0 : e.parentIsWidth) !== null && _a !== void 0 ? _a : ((!direction[0] && !direction[1]) || direction[0] || !direction[1]);\r\n        function setRatio(ratio) {\r\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\r\n        }\r\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\r\n        function setFixedDirection(fixedDirection) {\r\n            var result = getFixedDirectionInfo(datas.startPositions, fixedDirection);\r\n            datas.fixedDirection = result.fixedDirection;\r\n            datas.fixedPosition = result.fixedPosition;\r\n            datas.fixedOffset = result.fixedOffset;\r\n        }\r\n        function setFixedPosition(fixedPosition) {\r\n            var result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\r\n            datas.fixedDirection = result.fixedDirection;\r\n            datas.fixedPosition = result.fixedPosition;\r\n            datas.fixedOffset = result.fixedOffset;\r\n        }\r\n        function setMin(minSize) {\r\n            datas.minSize = [\r\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(minSize[0]), 0) || 0,\r\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(minSize[1]), 0) || 0,\r\n            ];\r\n        }\r\n        function setMax(maxSize) {\r\n            var nextMaxSize = [\r\n                maxSize[0] || Infinity,\r\n                maxSize[1] || Infinity,\r\n            ];\r\n            if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\r\n                nextMaxSize[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(nextMaxSize[0]), 0) || Infinity;\r\n            }\r\n            if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\r\n                nextMaxSize[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(nextMaxSize[1]), 0) || Infinity;\r\n            }\r\n            datas.maxSize = nextMaxSize;\r\n        }\r\n        setRatio(width / height);\r\n        setFixedDirection(parentFixedDirection || [-direction[0], -direction[1]]);\r\n        datas.setFixedDirection = setFixedDirection;\r\n        datas.setFixedPosition = setFixedPosition;\r\n        datas.setMin = setMin;\r\n        datas.setMax = setMax;\r\n        var params = fillParams(moveable, e, {\r\n            direction: direction,\r\n            startRatio: datas.ratio,\r\n            set: function (_a) {\r\n                var _b = __read(_a, 2), startWidth = _b[0], startHeight = _b[1];\r\n                datas.startWidth = startWidth;\r\n                datas.startHeight = startHeight;\r\n            },\r\n            setMin: setMin,\r\n            setMax: setMax,\r\n            setRatio: setRatio,\r\n            setFixedDirection: setFixedDirection,\r\n            setFixedPosition: setFixedPosition,\r\n            setOrigin: function (origin) {\r\n                datas.transformOrigin = origin;\r\n            },\r\n            dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e)),\r\n        });\r\n        var result = parentEvent || triggerEvent(moveable, \"onResizeStart\", params);\r\n        datas.startFixedDirection = datas.fixedDirection;\r\n        datas.startFixedPosition = datas.fixedPosition;\r\n        if (result !== false) {\r\n            datas.isResize = true;\r\n            moveable.state.snapRenderInfo = {\r\n                request: e.isRequest,\r\n                direction: direction,\r\n            };\r\n        }\r\n        return datas.isResize ? params : false;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        var _a;\r\n        var datas = e.datas, parentFlag = e.parentFlag, isPinch = e.isPinch, parentKeepRatio = e.parentKeepRatio, dragClient = e.dragClient, parentDist = e.parentDist, useSnap = e.useSnap, isRequest = e.isRequest, isGroup = e.isGroup, parentEvent = e.parentEvent, resolveMatrix = e.resolveMatrix;\r\n        var isResize = datas.isResize, transformOrigin = datas.transformOrigin, startWidth = datas.startWidth, startHeight = datas.startHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight, minSize = datas.minSize, maxSize = datas.maxSize, ratio = datas.ratio, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, isWidth = datas.isWidth;\r\n        if (!isResize) {\r\n            return;\r\n        }\r\n        if (resolveMatrix) {\r\n            var is3d = moveable.state.is3d;\r\n            var startOffsetMatrix = datas.startOffsetMatrix, startTransformOrigin = datas.startTransformOrigin;\r\n            var n = is3d ? 4 : 3;\r\n            var targetMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(getNextTransforms(e));\r\n            var targetN = Math.sqrt(targetMatrix.length);\r\n            if (n !== targetN) {\r\n                targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, targetN, n);\r\n            }\r\n            var nextAllMatrix = getNextMatrix(startOffsetMatrix, targetMatrix, startTransformOrigin, n);\r\n            var poses = calculatePoses(nextAllMatrix, startOffsetWidth, startOffsetHeight, n);\r\n            datas.startPositions = poses;\r\n            datas.nextTargetMatrix = targetMatrix;\r\n            datas.nextAllMatrix = nextAllMatrix;\r\n        }\r\n        var props = getProps(moveable.props, \"resizable\");\r\n        var resizeFormat = props.resizeFormat, _b = props.throttleResize, throttleResize = _b === void 0 ? parentFlag ? 0 : 1 : _b, parentMoveable = props.parentMoveable, keepRatioFinally = props.keepRatioFinally;\r\n        var direction = datas.direction;\r\n        var sizeDirection = direction;\r\n        var distWidth = 0;\r\n        var distHeight = 0;\r\n        if (!direction[0] && !direction[1]) {\r\n            sizeDirection = [1, 1];\r\n        }\r\n        var keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\r\n        function getNextBoundingSize() {\r\n            var fixedDirection = datas.fixedDirection;\r\n            var nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\r\n            distWidth = nextSize.distWidth;\r\n            distHeight = nextSize.distHeight;\r\n            var nextWidth = (sizeDirection[0] - fixedDirection[0]) || keepRatio\r\n                ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\r\n            var nextHeight = (sizeDirection[1] - fixedDirection[1]) || keepRatio\r\n                ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\r\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\r\n                // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\r\n                if (isWidth) {\r\n                    nextHeight = nextWidth / ratio;\r\n                }\r\n                else {\r\n                    nextWidth = nextHeight * ratio;\r\n                }\r\n            }\r\n            return [nextWidth, nextHeight];\r\n        }\r\n        var _c = __read(getNextBoundingSize(), 2), boundingWidth = _c[0], boundingHeight = _c[1];\r\n        if (!parentEvent) {\r\n            datas.setFixedDirection(datas.fixedDirection);\r\n            triggerEvent(moveable, \"onBeforeResize\", fillParams(moveable, e, {\r\n                startFixedDirection: datas.startFixedDirection,\r\n                startFixedPosition: datas.startFixedPosition,\r\n                setFixedDirection: function (nextFixedDirection) {\r\n                    var _a;\r\n                    datas.setFixedDirection(nextFixedDirection);\r\n                    _a = __read(getNextBoundingSize(), 2), boundingWidth = _a[0], boundingHeight = _a[1];\r\n                    return [boundingWidth, boundingHeight];\r\n                },\r\n                setFixedPosition: function (nextFixedPosition) {\r\n                    var _a;\r\n                    datas.setFixedPosition(nextFixedPosition);\r\n                    _a = __read(getNextBoundingSize(), 2), boundingWidth = _a[0], boundingHeight = _a[1];\r\n                    return [boundingWidth, boundingHeight];\r\n                },\r\n                boundingWidth: boundingWidth,\r\n                boundingHeight: boundingHeight,\r\n                setSize: function (size) {\r\n                    var _a;\r\n                    _a = __read(size, 2), boundingWidth = _a[0], boundingHeight = _a[1];\r\n                },\r\n            }, true));\r\n        }\r\n        var fixedPosition = dragClient;\r\n        if (!dragClient) {\r\n            if (!parentFlag && isPinch) {\r\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\r\n            }\r\n            else {\r\n                fixedPosition = datas.fixedPosition;\r\n            }\r\n        }\r\n        var snapDist = [0, 0];\r\n        if (!isPinch) {\r\n            snapDist = checkSnapResize(moveable, boundingWidth, boundingHeight, direction, fixedPosition, !useSnap && isRequest, datas);\r\n        }\r\n        if (parentDist) {\r\n            !parentDist[0] && (snapDist[0] = 0);\r\n            !parentDist[1] && (snapDist[1] = 0);\r\n        }\r\n        function computeSize() {\r\n            var _a;\r\n            if (resizeFormat) {\r\n                _a = __read(resizeFormat([boundingWidth, boundingHeight]), 2), boundingWidth = _a[0], boundingHeight = _a[1];\r\n            }\r\n            boundingWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(boundingWidth, throttleResize);\r\n            boundingHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(boundingHeight, throttleResize);\r\n        }\r\n        if (keepRatio) {\r\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\r\n                if (abs(snapDist[0]) > abs(snapDist[1])) {\r\n                    snapDist[1] = 0;\r\n                }\r\n                else {\r\n                    snapDist[0] = 0;\r\n                }\r\n            }\r\n            var isNoSnap = !snapDist[0] && !snapDist[1];\r\n            if (isNoSnap) {\r\n                // pre-compute before maintaining the ratio\r\n                computeSize();\r\n            }\r\n            if ((sizeDirection[0] && !sizeDirection[1])\r\n                || (snapDist[0] && !snapDist[1])\r\n                || (isNoSnap && isWidth)) {\r\n                boundingWidth += snapDist[0];\r\n                boundingHeight = boundingWidth / ratio;\r\n            }\r\n            else if ((!sizeDirection[0] && sizeDirection[1])\r\n                || (!snapDist[0] && snapDist[1])\r\n                || (isNoSnap && !isWidth)) {\r\n                boundingHeight += snapDist[1];\r\n                boundingWidth = boundingHeight * ratio;\r\n            }\r\n        }\r\n        else {\r\n            boundingWidth += snapDist[0];\r\n            boundingHeight += snapDist[1];\r\n            boundingWidth = Math.max(0, boundingWidth);\r\n            boundingHeight = Math.max(0, boundingHeight);\r\n        }\r\n        _a = __read((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.calculateBoundSize)([boundingWidth, boundingHeight], minSize, maxSize, keepRatio ? ratio : false), 2), boundingWidth = _a[0], boundingHeight = _a[1];\r\n        computeSize();\r\n        if (keepRatio && (isGroup || keepRatioFinally)) {\r\n            if (isWidth) {\r\n                boundingHeight = boundingWidth / ratio;\r\n            }\r\n            else {\r\n                boundingWidth = boundingHeight * ratio;\r\n            }\r\n        }\r\n        distWidth = boundingWidth - startOffsetWidth;\r\n        distHeight = boundingHeight - startOffsetHeight;\r\n        var delta = [distWidth - prevWidth, distHeight - prevHeight];\r\n        datas.prevWidth = distWidth;\r\n        datas.prevHeight = distHeight;\r\n        var inverseDelta = getResizeDist(moveable, boundingWidth, boundingHeight, fixedPosition, transformOrigin, datas);\r\n        if (!parentMoveable && delta.every(function (num) { return !num; }) && inverseDelta.every(function (num) { return !num; })) {\r\n            return;\r\n        }\r\n        var drag = Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false, \"draggable\"));\r\n        var transform = drag.transform;\r\n        var nextWidth = startWidth + distWidth;\r\n        var nextHeight = startHeight + distHeight;\r\n        var params = fillParams(moveable, e, __assign({ width: nextWidth, height: nextHeight, offsetWidth: Math.round(boundingWidth), offsetHeight: Math.round(boundingHeight), startRatio: ratio, boundingWidth: boundingWidth, boundingHeight: boundingHeight, direction: direction, dist: [distWidth, distHeight], delta: delta, isPinch: !!isPinch, drag: drag }, fillAfterTransform({\r\n            style: {\r\n                width: \"\".concat(nextWidth, \"px\"),\r\n                height: \"\".concat(nextHeight, \"px\"),\r\n            },\r\n            transform: transform,\r\n        }, drag, e)));\r\n        !parentEvent && triggerEvent(moveable, \"onResize\", params);\r\n        return params;\r\n    },\r\n    dragControlAfter: function (moveable, e) {\r\n        var datas = e.datas;\r\n        var isResize = datas.isResize, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight;\r\n        if (!isResize || moveable.props.checkResizableError === false) {\r\n            return;\r\n        }\r\n        var _a = moveable.state, width = _a.width, height = _a.height;\r\n        var errorWidth = width - (startOffsetWidth + prevWidth);\r\n        var errorHeight = height - (startOffsetHeight + prevHeight);\r\n        var isErrorWidth = abs(errorWidth) > 3;\r\n        var isErrorHeight = abs(errorHeight) > 3;\r\n        if (isErrorWidth) {\r\n            datas.startWidth += errorWidth;\r\n            datas.startOffsetWidth += errorWidth;\r\n            datas.prevWidth += errorWidth;\r\n        }\r\n        if (isErrorHeight) {\r\n            datas.startHeight += errorHeight;\r\n            datas.startOffsetHeight += errorHeight;\r\n            datas.prevHeight += errorHeight;\r\n        }\r\n        if (isErrorWidth || isErrorHeight) {\r\n            return this.dragControl(moveable, e);\r\n        }\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        var datas = e.datas, parentEvent = e.parentEvent;\r\n        if (!datas.isResize) {\r\n            return;\r\n        }\r\n        datas.isResize = false;\r\n        var params = fillEndParams(moveable, e, {});\r\n        !parentEvent && triggerEvent(moveable, \"onResizeEnd\", params);\r\n        return params;\r\n    },\r\n    dragGroupControlCondition: directionCondition$2,\r\n    dragGroupControlStart: function (moveable, e) {\r\n        var datas = e.datas;\r\n        var params = this.dragControlStart(moveable, __assign(__assign({}, e), { isGroup: true }));\r\n        if (!params) {\r\n            return false;\r\n        }\r\n        var originalEvents = fillChildEvents(moveable, \"resizable\", e);\r\n        var parentStartOffsetWidth = datas.startOffsetWidth, parentStartOffsetHeight = datas.startOffsetHeight;\r\n        function updateGroupMin() {\r\n            var originalMinSize = datas.minSize;\r\n            originalEvents.forEach(function (ev) {\r\n                var _a = ev.datas, childMinSize = _a.minSize, childStartOffsetWidth = _a.startOffsetWidth, childStartOffsetHeight = _a.startOffsetHeight;\r\n                var parentMinWidth = parentStartOffsetWidth\r\n                    * (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\r\n                var parentMinHeight = parentStartOffsetHeight\r\n                    * (childStartOffsetHeight ? childMinSize[1] / childStartOffsetHeight : 0);\r\n                originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\r\n                originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\r\n            });\r\n        }\r\n        function updateGroupMax() {\r\n            var originalMaxSize = datas.maxSize;\r\n            originalEvents.forEach(function (ev) {\r\n                var _a = ev.datas, childMaxSize = _a.maxSize, childStartOffsetWidth = _a.startOffsetWidth, childStartOffsetHeight = _a.startOffsetHeight;\r\n                var parentMaxWidth = parentStartOffsetWidth\r\n                    * (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\r\n                var parentMaxHeight = parentStartOffsetHeight\r\n                    * (childStartOffsetHeight ? childMaxSize[1] / childStartOffsetHeight : 0);\r\n                originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\r\n                originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\r\n            });\r\n        }\r\n        var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function (child, ev) {\r\n            return startChildDist(moveable, child, datas, ev);\r\n        });\r\n        updateGroupMin();\r\n        updateGroupMax();\r\n        var setFixedDirection = function (fixedDirection) {\r\n            params.setFixedDirection(fixedDirection);\r\n            events.forEach(function (ev, i) {\r\n                ev.setFixedDirection(fixedDirection);\r\n                startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\r\n            });\r\n        };\r\n        datas.setFixedDirection = setFixedDirection;\r\n        var nextParams = __assign(__assign({}, params), { targets: moveable.props.targets, events: events.map(function (ev) {\r\n                return __assign(__assign({}, ev), { setMin: function (minSize) {\r\n                        ev.setMin(minSize);\r\n                        updateGroupMin();\r\n                    }, setMax: function (maxSize) {\r\n                        ev.setMax(maxSize);\r\n                        updateGroupMax();\r\n                    } });\r\n            }), setFixedDirection: setFixedDirection, setMin: function (minSize) {\r\n                params.setMin(minSize);\r\n                updateGroupMin();\r\n            }, setMax: function (maxSize) {\r\n                params.setMax(maxSize);\r\n                updateGroupMax();\r\n            } });\r\n        var result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\r\n        datas.isResize = result !== false;\r\n        return datas.isResize ? params : false;\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isResize) {\r\n            return;\r\n        }\r\n        var props = getProps(moveable.props, \"resizable\");\r\n        catchEvent(moveable, \"onBeforeResize\", function (parentEvent) {\r\n            triggerEvent(moveable, \"onBeforeResizeGroup\", fillParams(moveable, e, __assign(__assign({}, parentEvent), { targets: props.targets }), true));\r\n        });\r\n        var params = this.dragControl(moveable, __assign(__assign({}, e), { isGroup: true }));\r\n        if (!params) {\r\n            return;\r\n        }\r\n        var boundingWidth = params.boundingWidth, boundingHeight = params.boundingHeight, dist = params.dist;\r\n        var keepRatio = props.keepRatio;\r\n        var parentScale = [\r\n            boundingWidth / (boundingWidth - dist[0]),\r\n            boundingHeight / (boundingHeight - dist[1]),\r\n        ];\r\n        var fixedPosition = datas.fixedPosition;\r\n        var events = triggerChildAbles(moveable, this, \"dragControl\", e, function (_, ev) {\r\n            var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [\r\n                ev.datas.originalX * parentScale[0],\r\n                ev.datas.originalY * parentScale[1],\r\n                1,\r\n            ], 3), 2), clientX = _a[0], clientY = _a[1];\r\n            return __assign(__assign({}, ev), { parentDist: null, parentScale: parentScale, dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(fixedPosition, [clientX, clientY]), parentKeepRatio: keepRatio });\r\n        });\r\n        var nextParams = __assign({ targets: props.targets, events: events }, params);\r\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\r\n        return nextParams;\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        var isDrag = e.isDrag, datas = e.datas;\r\n        if (!datas.isResize) {\r\n            return;\r\n        }\r\n        this.dragControlEnd(moveable, e);\r\n        var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\r\n        var nextParams = fillEndParams(moveable, e, {\r\n            targets: moveable.props.targets,\r\n            events: events,\r\n        });\r\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\r\n        return isDrag;\r\n    },\r\n    /**\r\n     * @method Moveable.Resizable#request\r\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * // Use Relative Value\r\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\r\n     *\r\n     * // Use Absolute Value\r\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"resizable\");\r\n     *\r\n     * // request\r\n     * // Use Relative Value\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     *\r\n     * // Use Absolute Value\r\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\r\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\r\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */\r\n    request: function (moveable) {\r\n        var datas = {};\r\n        var distWidth = 0;\r\n        var distHeight = 0;\r\n        var useSnap = false;\r\n        var rect = moveable.getRect();\r\n        return {\r\n            isControl: true,\r\n            requestStart: function (e) {\r\n                var _a;\r\n                useSnap = e.useSnap;\r\n                return {\r\n                    datas: datas,\r\n                    parentDirection: e.direction || [1, 1],\r\n                    parentIsWidth: (_a = e === null || e === void 0 ? void 0 : e.horizontal) !== null && _a !== void 0 ? _a : true,\r\n                    useSnap: useSnap,\r\n                };\r\n            },\r\n            request: function (e) {\r\n                if (\"offsetWidth\" in e) {\r\n                    distWidth = e.offsetWidth - rect.offsetWidth;\r\n                }\r\n                else if (\"deltaWidth\" in e) {\r\n                    distWidth += e.deltaWidth;\r\n                }\r\n                if (\"offsetHeight\" in e) {\r\n                    distHeight = e.offsetHeight - rect.offsetHeight;\r\n                }\r\n                else if (\"deltaHeight\" in e) {\r\n                    distHeight += e.deltaHeight;\r\n                }\r\n                return {\r\n                    datas: datas,\r\n                    parentDist: [distWidth, distHeight],\r\n                    parentKeepRatio: e.keepRatio,\r\n                    useSnap: useSnap,\r\n                };\r\n            },\r\n            requestEnd: function () {\r\n                return { datas: datas, isDrag: true, useSnap: useSnap };\r\n            },\r\n        };\r\n    },\r\n    unset: function (moveable) {\r\n        moveable.state.gestos.resizable = null;\r\n    },\r\n};\r\n/**\r\n * Whether or not target can be resized.\r\n * @name Moveable.Resizable#resizable\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     resizable: false,\r\n * });\r\n *\r\n * moveable.resizable = true;\r\n */\r\n/**\r\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\r\n * @name Moveable.Resizable#throttleResize\r\n * @default 1\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n *   throttleResize: 1,\r\n * });\r\n *\r\n * moveable.throttleResize = 0;\r\n */\r\n/**\r\n * When resize or scale, keeps a ratio of the width, height.\r\n * @name Moveable.Resizable#keepRatio\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n * });\r\n *\r\n * moveable.keepRatio = true;\r\n */\r\n/**\r\n * Set directions to show the control box.\r\n * @name Moveable.Resizable#renderDirections\r\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\r\n * });\r\n *\r\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\r\n */\r\n/**\r\n * Function to convert size for resize\r\n * @name Moveable.Resizable#resizeFormat\r\n * @default oneself\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   resizable: true,\r\n *   resizeFormat: v => v,\r\n * });\r\n *\r\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\r\n */\r\n/**\r\n * When the resize starts, the resizeStart event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resizeStart\r\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"resizeStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\r\n * @memberof Moveable.Resizable\r\n * @event beforeResize\r\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\r\n *     if (shiftKey) {\r\n *        setFixedDirection([0, 0]);\r\n *     }\r\n * });\r\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\r\n *     target.style.width = `${width}px`;\r\n *     target.style.height = `${height}px`;\r\n *     target.style.transform = drag.transform;\r\n * });\r\n */\r\n/**\r\n * When resizing, the resize event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resize\r\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"resize\", ({ target, width, height }) => {\r\n *     target.style.width = `${e.width}px`;\r\n *     target.style.height = `${e.height}px`;\r\n * });\r\n */\r\n/**\r\n * When the resize finishes, the resizeEnd event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resizeEnd\r\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { resizable: true });\r\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */\r\n/**\r\n* When the group resize starts, the `resizeGroupStart` event is called.\r\n* @memberof Moveable.Resizable\r\n* @event resizeGroupStart\r\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     resizable: true\r\n* });\r\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\r\n*     console.log(\"onResizeGroupStart\", targets);\r\n* });\r\n*/\r\n/**\r\n* When the group resize, the `resizeGroup` event is called.\r\n* @memberof Moveable.Resizable\r\n* @event resizeGroup\r\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     resizable: true\r\n* });\r\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\r\n*     console.log(\"onResizeGroup\", targets);\r\n*     events.forEach(ev => {\r\n*         const offset = [\r\n*             direction[0] < 0 ? -ev.delta[0] : 0,\r\n*             direction[1] < 0 ? -ev.delta[1] : 0,\r\n*         ];\r\n*         // ev.drag is a drag event that occurs when the group resize.\r\n*         const left = offset[0] + ev.drag.beforeDist[0];\r\n*         const top = offset[1] + ev.drag.beforeDist[1];\r\n*         const width = ev.width;\r\n*         const top = ev.top;\r\n*     });\r\n* });\r\n*/\r\n/**\r\n * When the group resize finishes, the `resizeGroupEnd` event is called.\r\n * @memberof Moveable.Resizable\r\n * @event resizeGroupEnd\r\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     resizable: true\r\n * });\r\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\r\n * });\r\n */\n\n/**\r\n * @namespace Rotatable\r\n * @memberof Moveable\r\n * @description Rotatable indicates whether the target can be rotated.\r\n */\r\nfunction setRotateStartInfo(moveable, datas, clientX, clientY, rect) {\r\n    var groupable = moveable.props.groupable;\r\n    var state = moveable.state;\r\n    var n = state.is3d ? 4 : 3;\r\n    var origin = datas.origin;\r\n    var nextOrigin = calculatePosition(moveable.state.rootMatrix, \r\n    // TO-DO #710\r\n    (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([origin[0], origin[1]], groupable ? [0, 0] : [state.left, state.top]), n);\r\n    var startAbsoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)([rect.left, rect.top], nextOrigin);\r\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\r\n    datas.prevDeg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\r\n    datas.defaultDeg = datas.prevDeg;\r\n    datas.prevSnapDeg = 0;\r\n    datas.loop = 0;\r\n    datas.startDist = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(startAbsoluteOrigin, [clientX, clientY]);\r\n}\r\nfunction getAbsoluteDist(deg, direction, datas) {\r\n    var defaultDeg = datas.defaultDeg, prevDeg = datas.prevDeg;\r\n    var normalizedPrevDeg = prevDeg % 360;\r\n    var loop = Math.floor(prevDeg / 360);\r\n    if (normalizedPrevDeg < 0) {\r\n        normalizedPrevDeg += 360;\r\n    }\r\n    if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\r\n        // 360 => 0\r\n        ++loop;\r\n    }\r\n    else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\r\n        // 0 => 360\r\n        --loop;\r\n    }\r\n    var dist = direction * (loop * 360 + deg - defaultDeg);\r\n    datas.prevDeg = defaultDeg + dist;\r\n    return dist;\r\n}\r\nfunction getAbsoluteDistByClient(clientX, clientY, direction, datas) {\r\n    return getAbsoluteDist((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, datas);\r\n}\r\nfunction getRotateInfo(moveable, moveableRect, datas, dist, startValue, checkSnap) {\r\n    var _a = moveable.props.throttleRotate, throttleRotate = _a === void 0 ? 0 : _a;\r\n    var prevSnapDeg = datas.prevSnapDeg;\r\n    var snapRotation = 0;\r\n    var isSnap = false;\r\n    if (checkSnap) {\r\n        var result = checkSnapRotate(moveable, moveableRect, dist, startValue + dist);\r\n        isSnap = result.isSnap;\r\n        snapRotation = startValue + result.dist;\r\n    }\r\n    if (!isSnap) {\r\n        snapRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startValue + dist, throttleRotate);\r\n    }\r\n    var snapDeg = snapRotation - startValue;\r\n    datas.prevSnapDeg = snapDeg;\r\n    return [snapDeg - prevSnapDeg, snapDeg, snapRotation];\r\n}\r\nfunction getRotationPositions(rotationPosition, _a, direction) {\r\n    var _b = __read(_a, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\r\n    if (rotationPosition === \"none\") {\r\n        return [];\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(rotationPosition)) {\r\n        return rotationPosition.map(function (child) { return getRotationPositions(child, [pos1, pos2, pos3, pos4], direction)[0]; });\r\n    }\r\n    var _c = __read((rotationPosition || \"top\").split(\"-\"), 2), dir1 = _c[0], dir2 = _c[1];\r\n    var radPoses = [pos1, pos2];\r\n    if (dir1 === \"left\") {\r\n        radPoses = [pos3, pos1];\r\n    }\r\n    else if (dir1 === \"right\") {\r\n        radPoses = [pos2, pos4];\r\n    }\r\n    else if (dir1 === \"bottom\") {\r\n        radPoses = [pos4, pos3];\r\n    }\r\n    var pos = [\r\n        (radPoses[0][0] + radPoses[1][0]) / 2,\r\n        (radPoses[0][1] + radPoses[1][1]) / 2,\r\n    ];\r\n    var rad = getRotationRad(radPoses, direction);\r\n    if (dir2) {\r\n        var isStart = dir2 === \"top\" || dir2 === \"left\";\r\n        var isReverse = dir1 === \"bottom\" || dir1 === \"left\";\r\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\r\n    }\r\n    return [[pos, rad]];\r\n}\r\nfunction dragControlCondition(moveable, e) {\r\n    if (e.isRequest) {\r\n        return e.requestAble === \"rotatable\";\r\n    }\r\n    var target = e.inputEvent.target;\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"rotation-control\"))\r\n        || (moveable.props.rotateAroundControls && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"around-control\")))\r\n        || ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"control\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"rotatable\")))) {\r\n        return true;\r\n    }\r\n    var rotationTarget = moveable.props.rotationTarget;\r\n    if (rotationTarget) {\r\n        return getRefTargets(rotationTarget, true).some(function (element) {\r\n            if (!element) {\r\n                return false;\r\n            }\r\n            return target === element || target.contains(element);\r\n        });\r\n    }\r\n    return false;\r\n}\r\nvar css = \".rotation {\\nposition: absolute;\\nheight: 40px;\\nwidth: 1px;\\ntransform-origin: 50% 100%;\\nheight: calc(40px * var(--zoom));\\ntop: auto;\\nleft: 0;\\nbottom: 100%;\\nwill-change: transform;\\n}\\n.rotation .rotation-line {\\ndisplay: block;\\nwidth: 100%;\\nheight: 100%;\\ntransform-origin: 50% 50%;\\n}\\n.rotation .rotation-control {\\nborder-color: #4af;\\nborder-color: var(--moveable-color);\\nbackground:#fff;\\ncursor: alias;\\n}\\n:global .view-rotation-dragging, .rotatable.direction.control {\\ncursor: alias;\\n}\\n.rotatable.direction.control.move {\\ncursor: move;\\n}\\n\";\r\nvar Rotatable = {\r\n    name: \"rotatable\",\r\n    canPinch: true,\r\n    props: [\r\n        \"rotatable\",\r\n        \"rotationPosition\",\r\n        \"throttleRotate\",\r\n        \"renderDirections\",\r\n        \"rotationTarget\",\r\n        \"rotateAroundControls\",\r\n        \"edge\",\r\n        \"resolveAblesWithRotatable\",\r\n        \"displayAroundControls\",\r\n    ],\r\n    events: [\r\n        \"rotateStart\",\r\n        \"beforeRotate\",\r\n        \"rotate\",\r\n        \"rotateEnd\",\r\n        \"rotateGroupStart\",\r\n        \"beforeRotateGroup\",\r\n        \"rotateGroup\",\r\n        \"rotateGroupEnd\",\r\n    ],\r\n    css: [css],\r\n    viewClassName: function (moveable) {\r\n        if (!moveable.isDragging(\"rotatable\")) {\r\n            return \"\";\r\n        }\r\n        return prefix(\"view-rotation-dragging\");\r\n    },\r\n    render: function (moveable, React) {\r\n        var _a = getProps(moveable.props, \"rotatable\"), rotatable = _a.rotatable, rotationPosition = _a.rotationPosition, zoom = _a.zoom, renderDirections = _a.renderDirections, rotateAroundControls = _a.rotateAroundControls, resolveAblesWithRotatable = _a.resolveAblesWithRotatable;\r\n        var _b = moveable.getState(), renderPoses = _b.renderPoses, direction = _b.direction;\r\n        if (!rotatable) {\r\n            return null;\r\n        }\r\n        var positions = getRotationPositions(rotationPosition, renderPoses, direction);\r\n        var jsxs = [];\r\n        positions.forEach(function (_a, i) {\r\n            var _b = __read(_a, 2), pos = _b[0], rad = _b[1];\r\n            jsxs.push(React.createElement(\"div\", { key: \"rotation\".concat(i), className: prefix(\"rotation\"), style: {\r\n                    // tslint:disable-next-line: max-line-length\r\n                    transform: \"translate(-50%) translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rad, \"rad)\"),\r\n                } },\r\n                React.createElement(\"div\", { className: prefix(\"line rotation-line\"), style: {\r\n                        transform: \"scaleX(\".concat(zoom, \")\"),\r\n                    } }),\r\n                React.createElement(\"div\", { className: prefix(\"control rotation-control\"), style: {\r\n                        transform: \"translate(0.5px) scale(\".concat(zoom, \")\"),\r\n                    } })));\r\n        });\r\n        if (renderDirections) {\r\n            var ables = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(resolveAblesWithRotatable || {});\r\n            var resolveMap_1 = {};\r\n            ables.forEach(function (name) {\r\n                resolveAblesWithRotatable[name].forEach(function (direction) {\r\n                    resolveMap_1[direction] = name;\r\n                });\r\n            });\r\n            var directionControlInfos = [];\r\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(renderDirections)) {\r\n                directionControlInfos = renderDirections.map(function (dir) {\r\n                    var able = resolveMap_1[dir];\r\n                    return {\r\n                        data: able ? { resolve: able } : {},\r\n                        classNames: able ? [\"move\"] : [],\r\n                        dir: dir,\r\n                    };\r\n                });\r\n            }\r\n            jsxs.push.apply(jsxs, __spreadArray([], __read(renderDirectionControlsByInfos(moveable, \"rotatable\", directionControlInfos, React)), false));\r\n        }\r\n        if (rotateAroundControls) {\r\n            jsxs.push.apply(jsxs, __spreadArray([], __read(renderAroundControls(moveable, React)), false));\r\n        }\r\n        return jsxs;\r\n    },\r\n    dragControlCondition: dragControlCondition,\r\n    dragControlStart: function (moveable, e) {\r\n        var _a;\r\n        var _b;\r\n        var datas = e.datas, clientX = e.clientX, clientY = e.clientY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, isRequest = e.isRequest;\r\n        var state = moveable.state;\r\n        var target = state.target, left = state.left, top = state.top, direction = state.direction, beforeDirection = state.beforeDirection, targetTransform = state.targetTransform, moveableClientRect = state.moveableClientRect, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, allMatrix = state.allMatrix, width = state.width, height = state.height;\r\n        if (!isRequest && !target) {\r\n            return false;\r\n        }\r\n        var rect = moveable.getRect();\r\n        datas.rect = rect;\r\n        datas.transform = targetTransform;\r\n        datas.left = left;\r\n        datas.top = top;\r\n        var setFixedPosition = function (fixedPosition) {\r\n            var result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\r\n            datas.fixedDirection = result.fixedDirection;\r\n            datas.fixedOffset = result.fixedOffset;\r\n            datas.fixedPosition = result.fixedPosition;\r\n            if (resizeStart) {\r\n                resizeStart.setFixedPosition(fixedPosition);\r\n            }\r\n        };\r\n        var setFixedDirection = function (fixedDirection) {\r\n            var result = getOffsetFixedDirectionInfo(moveable.state, fixedDirection);\r\n            datas.fixedDirection = result.fixedDirection;\r\n            datas.fixedOffset = result.fixedOffset;\r\n            datas.fixedPosition = result.fixedPosition;\r\n            if (resizeStart) {\r\n                resizeStart.setFixedDirection(fixedDirection);\r\n            }\r\n        };\r\n        var startClientX = clientX;\r\n        var startClientY = clientY;\r\n        if (isRequest || isPinch || parentFlag) {\r\n            var externalRotate = parentRotate || 0;\r\n            datas.beforeInfo = {\r\n                origin: rect.beforeOrigin,\r\n                prevDeg: externalRotate,\r\n                defaultDeg: externalRotate,\r\n                prevSnapDeg: 0,\r\n                startDist: 0,\r\n            };\r\n            datas.afterInfo = __assign(__assign({}, datas.beforeInfo), { origin: rect.origin });\r\n            datas.absoluteInfo = __assign(__assign({}, datas.beforeInfo), { origin: rect.origin, startValue: externalRotate });\r\n        }\r\n        else {\r\n            var inputTarget = (_b = e.inputEvent) === null || _b === void 0 ? void 0 : _b.target;\r\n            if (inputTarget) {\r\n                var regionDirection = inputTarget.getAttribute(\"data-direction\") || \"\";\r\n                var controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\r\n                if (controlDirection) {\r\n                    datas.isControl = true;\r\n                    datas.isAroundControl = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(inputTarget, prefix(\"around-control\"));\r\n                    datas.controlDirection = controlDirection;\r\n                    var resolve = inputTarget.getAttribute(\"data-resolve\");\r\n                    if (resolve) {\r\n                        datas.resolveAble = resolve;\r\n                    }\r\n                    var clientPoses = calculateMoveableClientPositions(state.rootMatrix, state.renderPoses, moveableClientRect);\r\n                    _a = __read(getPosByDirection(clientPoses, controlDirection), 2), startClientX = _a[0], startClientY = _a[1];\r\n                }\r\n            }\r\n            datas.beforeInfo = { origin: rect.beforeOrigin };\r\n            datas.afterInfo = { origin: rect.origin };\r\n            datas.absoluteInfo = {\r\n                origin: rect.origin,\r\n                startValue: rect.rotation,\r\n            };\r\n            var originalFixedPosition_1 = setFixedPosition;\r\n            setFixedPosition = function (fixedPosition) {\r\n                var n = state.is3d ? 4 : 3;\r\n                var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.getOrigin)(targetMatrix, n), fixedPosition), 2), originX = _a[0], originY = _a[1];\r\n                var fixedBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([originX, originY], n));\r\n                var fixedAfterOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(allMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)([fixedPosition[0], fixedPosition[1]], n));\r\n                originalFixedPosition_1(fixedPosition);\r\n                var posDelta = state.posDelta;\r\n                datas.beforeInfo.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedBeforeOrigin, posDelta);\r\n                datas.afterInfo.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedAfterOrigin, posDelta);\r\n                datas.absoluteInfo.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedAfterOrigin, posDelta);\r\n                setRotateStartInfo(moveable, datas.beforeInfo, startClientX, startClientY, moveableClientRect);\r\n                setRotateStartInfo(moveable, datas.afterInfo, startClientX, startClientY, moveableClientRect);\r\n                setRotateStartInfo(moveable, datas.absoluteInfo, startClientX, startClientY, moveableClientRect);\r\n            };\r\n            setFixedDirection = function (fixedDirection) {\r\n                var fixedPosition = getPosByDirection([\r\n                    [0, 0],\r\n                    [width, 0],\r\n                    [0, height],\r\n                    [width, height],\r\n                ], fixedDirection);\r\n                setFixedPosition(fixedPosition);\r\n            };\r\n        }\r\n        datas.startClientX = startClientX;\r\n        datas.startClientY = startClientY;\r\n        datas.direction = direction;\r\n        datas.beforeDirection = beforeDirection;\r\n        datas.startValue = 0;\r\n        datas.datas = {};\r\n        setDefaultTransformIndex(moveable, e, \"rotate\");\r\n        var dragStart = false;\r\n        var resizeStart = false;\r\n        if (datas.isControl && datas.resolveAble) {\r\n            var resolveAble = datas.resolveAble;\r\n            if (resolveAble === \"resizable\") {\r\n                resizeStart = Resizable.dragControlStart(moveable, __assign(__assign({}, (new CustomGesto(\"resizable\").dragStart([0, 0], e))), { parentPosition: datas.controlPosition, parentFixedPosition: datas.fixedPosition }));\r\n            }\r\n        }\r\n        if (!resizeStart) {\r\n            dragStart = Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e));\r\n        }\r\n        setFixedPosition(getTotalOrigin(moveable));\r\n        var params = fillParams(moveable, e, __assign(__assign({ set: function (rotatation) {\r\n                datas.startValue = rotatation * Math.PI / 180;\r\n            }, setFixedDirection: setFixedDirection, setFixedPosition: setFixedPosition }, fillTransformStartEvent(moveable, e)), { dragStart: dragStart, resizeStart: resizeStart }));\r\n        var result = triggerEvent(moveable, \"onRotateStart\", params);\r\n        datas.isRotate = result !== false;\r\n        state.snapRenderInfo = {\r\n            request: e.isRequest,\r\n        };\r\n        return datas.isRotate ? params : false;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        var _a, _b, _c;\r\n        var datas = e.datas, clientDistX = e.clientDistX, clientDistY = e.clientDistY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, groupDelta = e.groupDelta, resolveMatrix = e.resolveMatrix;\r\n        var beforeDirection = datas.beforeDirection, beforeInfo = datas.beforeInfo, afterInfo = datas.afterInfo, absoluteInfo = datas.absoluteInfo, isRotate = datas.isRotate, startValue = datas.startValue, rect = datas.rect, startClientX = datas.startClientX, startClientY = datas.startClientY;\r\n        if (!isRotate) {\r\n            return;\r\n        }\r\n        resolveTransformEvent(moveable, e, \"rotate\");\r\n        var targetDirection = getTransformDirection(e);\r\n        var direction = beforeDirection * targetDirection;\r\n        var parentMoveable = moveable.props.parentMoveable;\r\n        var beforeDelta = 0;\r\n        var beforeDist;\r\n        var beforeRotation;\r\n        var delta = 0;\r\n        var dist;\r\n        var rotation;\r\n        var absoluteDelta = 0;\r\n        var absoluteDist;\r\n        var absoluteRotation;\r\n        var startRotation = 180 / Math.PI * startValue;\r\n        var absoluteStartRotation = absoluteInfo.startValue;\r\n        var isSnap = false;\r\n        var nextClientX = startClientX + clientDistX;\r\n        var nextClientY = startClientY + clientDistY;\r\n        if (!parentFlag && \"parentDist\" in e) {\r\n            var parentDist = e.parentDist;\r\n            beforeDist = parentDist;\r\n            dist = parentDist;\r\n            absoluteDist = parentDist;\r\n        }\r\n        else if (isPinch || parentFlag) {\r\n            beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\r\n            dist = getAbsoluteDist(parentRotate, direction, afterInfo);\r\n            absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\r\n        }\r\n        else {\r\n            beforeDist = getAbsoluteDistByClient(nextClientX, nextClientY, beforeDirection, beforeInfo);\r\n            dist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, afterInfo);\r\n            absoluteDist = getAbsoluteDistByClient(nextClientX, nextClientY, direction, absoluteInfo);\r\n            isSnap = true;\r\n        }\r\n        beforeRotation = startRotation + beforeDist;\r\n        rotation = startRotation + dist;\r\n        absoluteRotation = absoluteStartRotation + absoluteDist;\r\n        triggerEvent(moveable, \"onBeforeRotate\", fillParams(moveable, e, {\r\n            beforeRotation: beforeRotation,\r\n            rotation: rotation,\r\n            absoluteRotation: absoluteRotation,\r\n            setRotation: function (nextRotation) {\r\n                dist = nextRotation - startRotation;\r\n                beforeDist = dist;\r\n                absoluteDist = dist;\r\n            },\r\n        }, true));\r\n        _a = __read(getRotateInfo(moveable, rect, beforeInfo, beforeDist, startRotation, isSnap), 3), beforeDelta = _a[0], beforeDist = _a[1], beforeRotation = _a[2];\r\n        _b = __read(getRotateInfo(moveable, rect, afterInfo, dist, startRotation, isSnap), 3), delta = _b[0], dist = _b[1], rotation = _b[2];\r\n        _c = __read(getRotateInfo(moveable, rect, absoluteInfo, absoluteDist, absoluteStartRotation, isSnap), 3), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotation = _c[2];\r\n        if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable && !resolveMatrix) {\r\n            return;\r\n        }\r\n        var nextTransform = convertTransformFormat(datas, \"rotate(\".concat(rotation, \"deg)\"), \"rotate(\".concat(dist, \"deg)\"));\r\n        if (resolveMatrix) {\r\n            datas.fixedPosition = getTranslateFixedPosition(moveable, datas.targetAllTransform, datas.fixedDirection, datas.fixedOffset, datas);\r\n        }\r\n        var inverseDist = getRotateDist(moveable, dist, datas);\r\n        var inverseDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);\r\n        datas.prevInverseDist = inverseDist;\r\n        datas.requestValue = null;\r\n        var dragEvent = fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e);\r\n        var transformEvent = dragEvent;\r\n        var parentDistance = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)([nextClientX, nextClientY], absoluteInfo.startAbsoluteOrigin) - absoluteInfo.startDist;\r\n        var resize = undefined;\r\n        if (datas.resolveAble === \"resizable\") {\r\n            var resizeEvent = Resizable.dragControl(moveable, __assign(__assign({}, setCustomDrag(e, moveable.state, [e.deltaX, e.deltaY], !!isPinch, false, \"resizable\")), { resolveMatrix: true, parentDistance: parentDistance }));\r\n            if (resizeEvent) {\r\n                resize = resizeEvent;\r\n                transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\r\n            }\r\n        }\r\n        var params = fillParams(moveable, e, __assign(__assign({ delta: delta, dist: dist, rotate: rotation, rotation: rotation, beforeDist: beforeDist, beforeDelta: beforeDelta, beforeRotate: beforeRotation, beforeRotation: beforeRotation, absoluteDist: absoluteDist, absoluteDelta: absoluteDelta, absoluteRotate: absoluteRotation, absoluteRotation: absoluteRotation, isPinch: !!isPinch, resize: resize }, dragEvent), transformEvent));\r\n        triggerEvent(moveable, \"onRotate\", params);\r\n        return params;\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isRotate) {\r\n            return;\r\n        }\r\n        datas.isRotate = false;\r\n        var params = fillEndParams(moveable, e, {});\r\n        triggerEvent(moveable, \"onRotateEnd\", params);\r\n        return params;\r\n    },\r\n    dragGroupControlCondition: dragControlCondition,\r\n    dragGroupControlStart: function (moveable, e) {\r\n        var datas = e.datas;\r\n        var _a = moveable.state, parentLeft = _a.left, parentTop = _a.top, parentBeforeOrigin = _a.beforeOrigin;\r\n        var params = this.dragControlStart(moveable, e);\r\n        if (!params) {\r\n            return false;\r\n        }\r\n        params.set(datas.beforeDirection * moveable.rotation);\r\n        var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function (child, ev) {\r\n            var _a = child.state, left = _a.left, top = _a.top, beforeOrigin = _a.beforeOrigin;\r\n            var childClient = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)([left, top], [parentLeft, parentTop]), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(beforeOrigin, parentBeforeOrigin));\r\n            ev.datas.startGroupClient = childClient;\r\n            ev.datas.groupClient = childClient;\r\n            return __assign(__assign({}, ev), { parentRotate: 0 });\r\n        });\r\n        var nextParams = __assign(__assign({}, params), { targets: moveable.props.targets, events: events });\r\n        var result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\r\n        datas.isRotate = result !== false;\r\n        return datas.isRotate ? params : false;\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isRotate) {\r\n            return;\r\n        }\r\n        catchEvent(moveable, \"onBeforeRotate\", function (parentEvent) {\r\n            triggerEvent(moveable, \"onBeforeRotateGroup\", fillParams(moveable, e, __assign(__assign({}, parentEvent), { targets: moveable.props.targets }), true));\r\n        });\r\n        var params = this.dragControl(moveable, e);\r\n        if (!params) {\r\n            return;\r\n        }\r\n        var direction = datas.beforeDirection;\r\n        var parentRotate = params.beforeDist;\r\n        var rad = parentRotate / 180 * Math.PI;\r\n        var events = triggerChildAbles(moveable, this, \"dragControl\", e, function (_, ev) {\r\n            var startGroupClient = ev.datas.startGroupClient;\r\n            var _a = __read(ev.datas.groupClient, 2), prevClientX = _a[0], prevClientY = _a[1];\r\n            var _b = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(startGroupClient, rad * direction), 2), clientX = _b[0], clientY = _b[1];\r\n            var delta = [clientX - prevClientX, clientY - prevClientY];\r\n            ev.datas.groupClient = [clientX, clientY];\r\n            return __assign(__assign({}, ev), { parentRotate: parentRotate, groupDelta: delta });\r\n        });\r\n        moveable.rotation = direction * params.beforeRotation;\r\n        var nextParams = __assign({ targets: moveable.props.targets, events: events, set: function (rotation) {\r\n                moveable.rotation = rotation;\r\n            }, setGroupRotation: function (rotation) {\r\n                moveable.rotation = rotation;\r\n            } }, params);\r\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\r\n        return nextParams;\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        var isDrag = e.isDrag, datas = e.datas;\r\n        if (!datas.isRotate) {\r\n            return;\r\n        }\r\n        this.dragControlEnd(moveable, e);\r\n        var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\r\n        var nextParams = fillEndParams(moveable, e, {\r\n            targets: moveable.props.targets,\r\n            events: events,\r\n        });\r\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\r\n        return isDrag;\r\n    },\r\n    /**\r\n     * @method Moveable.Rotatable#request\r\n     * @param {object} [e] - the Resizable's request parameter\r\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\r\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\r\n     *\r\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"rotatable\");\r\n     *\r\n     * // request\r\n     * requester.request({ deltaRotate: 10 });\r\n     * requester.request({ deltaRotate: 10 });\r\n     * requester.request({ deltaRotate: 10 });\r\n     *\r\n     * requester.request({ rotate: 10 });\r\n     * requester.request({ rotate: 20 });\r\n     * requester.request({ rotate: 30 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */\r\n    request: function (moveable) {\r\n        var datas = {};\r\n        var distRotate = 0;\r\n        var startRotation = moveable.getRotation();\r\n        return {\r\n            isControl: true,\r\n            requestStart: function () {\r\n                return { datas: datas };\r\n            },\r\n            request: function (e) {\r\n                if (\"deltaRotate\" in e) {\r\n                    distRotate += e.deltaRotate;\r\n                }\r\n                else if (\"rotate\" in e) {\r\n                    distRotate = e.rotate - startRotation;\r\n                }\r\n                return { datas: datas, parentDist: distRotate };\r\n            },\r\n            requestEnd: function () {\r\n                return { datas: datas, isDrag: true };\r\n            },\r\n        };\r\n    },\r\n};\r\n/**\r\n * Whether or not target can be rotated. (default: false)\r\n * @name Moveable.Rotatable#rotatable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.rotatable = true;\r\n */\r\n/**\r\n * You can specify the position of the rotation. (default: \"top\")\r\n * @name Moveable.Rotatable#rotationPosition\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   rotationPosition: \"top\",\r\n * });\r\n *\r\n * moveable.rotationPosition = \"bottom\"\r\n */\r\n/**\r\n * throttle of angle(degree) when rotate.\r\n * @name Moveable.Rotatable#throttleRotate\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.throttleRotate = 1;\r\n */\r\n/**\r\n * When the rotate starts, the rotateStart event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateStart\r\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { rotatable: true });\r\n * moveable.on(\"rotateStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n* When rotating, the rotate event is called.\r\n* @memberof Moveable.Rotatable\r\n* @event rotate\r\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, { rotatable: true });\r\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\r\n*     target.style.transform = transform;\r\n* });\r\n*/\r\n/**\r\n * When the rotate finishes, the rotateEnd event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateEnd\r\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { rotatable: true });\r\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */\r\n/**\r\n * When the group rotate starts, the `rotateGroupStart` event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateGroupStart\r\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     rotatable: true\r\n * });\r\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\r\n *     console.log(\"onRotateGroupStart\", targets);\r\n * });\r\n */\r\n/**\r\n* When the group rotate, the `rotateGroup` event is called.\r\n* @memberof Moveable.Rotatable\r\n* @event rotateGroup\r\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     rotatable: true\r\n* });\r\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\r\n*     console.log(\"onRotateGroup\", targets);\r\n*     events.forEach(ev => {\r\n*         const target = ev.target;\r\n*         // ev.drag is a drag event that occurs when the group rotate.\r\n*         const left = ev.drag.beforeDist[0];\r\n*         const top = ev.drag.beforeDist[1];\r\n*         const deg = ev.beforeDist;\r\n*     });\r\n* });\r\n*/\r\n/**\r\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\r\n * @memberof Moveable.Rotatable\r\n * @event rotateGroupEnd\r\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     rotatable: true\r\n * });\r\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\r\n * });\r\n */\n\nfunction renderGuideline(info, React) {\r\n    var _a;\r\n    var direction = info.direction, classNames = info.classNames, size = info.size, pos = info.pos, zoom = info.zoom, key = info.key;\r\n    var isHorizontal = direction === \"horizontal\";\r\n    var scaleType = isHorizontal ? \"Y\" : \"X\";\r\n    // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\r\n    return React.createElement(\"div\", {\r\n        key: key,\r\n        className: classNames.join(\" \"),\r\n        style: (_a = {},\r\n            _a[isHorizontal ? \"width\" : \"height\"] = \"\".concat(size),\r\n            _a.transform = \"translate(\".concat(pos[0], \", \").concat(pos[1], \") translate\").concat(scaleType, \"(-50%) scale\").concat(scaleType, \"(\").concat(zoom, \")\"),\r\n            _a),\r\n    });\r\n}\r\nfunction renderInnerGuideline(info, React) {\r\n    return renderGuideline(__assign(__assign({}, info), { classNames: __spreadArray([\r\n            prefix(\"line\", \"guideline\", info.direction)\r\n        ], __read(info.classNames), false).filter(function (className) { return className; }), size: info.size || \"\".concat(info.sizeValue, \"px\"), pos: info.pos || info.posValue.map(function (v) { return \"\".concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(v, 0.1), \"px\"); }) }), React);\r\n}\r\nfunction renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {\r\n    var zoom = moveable.props.zoom;\r\n    return snapPoses.map(function (_a, i) {\r\n        var type = _a.type, pos = _a.pos;\r\n        var renderPos = [0, 0];\r\n        renderPos[index] = minPos;\r\n        renderPos[index ? 0 : 1] = -targetPos + pos;\r\n        return renderInnerGuideline({\r\n            key: \"\".concat(direction, \"TargetGuideline\").concat(i),\r\n            classNames: [prefix(\"target\", \"bold\", type)],\r\n            posValue: renderPos,\r\n            sizeValue: size,\r\n            zoom: zoom,\r\n            direction: direction,\r\n        }, React);\r\n    });\r\n}\r\nfunction renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {\r\n    var _a = moveable.props, zoom = _a.zoom, isDisplayInnerSnapDigit = _a.isDisplayInnerSnapDigit;\r\n    var mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\r\n    var targetStart = targetRect[mainNames.start];\r\n    var targetEnd = targetRect[mainNames.end];\r\n    return guidelines.filter(function (_a) {\r\n        var hide = _a.hide, elementRect = _a.elementRect;\r\n        if (hide) {\r\n            return false;\r\n        }\r\n        if (isDisplayInnerSnapDigit && elementRect) {\r\n            // inner\r\n            var rect = elementRect.rect;\r\n            if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }).map(function (guideline, i) {\r\n        var pos = guideline.pos, size = guideline.size, element = guideline.element, className = guideline.className;\r\n        var renderPos = [\r\n            -targetPos[0] + pos[0],\r\n            -targetPos[1] + pos[1],\r\n        ];\r\n        return renderInnerGuideline({\r\n            key: \"\".concat(type, \"-default-guideline-\").concat(i),\r\n            classNames: element ? [prefix(\"bold\"), className] : [prefix(\"normal\"), className],\r\n            direction: type,\r\n            posValue: renderPos,\r\n            sizeValue: size,\r\n            zoom: zoom,\r\n        }, React);\r\n    });\r\n}\r\nfunction renderDigitLine(moveable, type, lineType, index, gap, renderPos, className, React) {\r\n    var _a;\r\n    var _b = moveable.props, _c = _b.snapDigit, snapDigit = _c === void 0 ? 0 : _c, _d = _b.isDisplaySnapDigit, isDisplaySnapDigit = _d === void 0 ? true : _d, _e = _b.snapDistFormat, snapDistFormat = _e === void 0 ? function (v, type) {\r\n        // Type can be used render different values.\r\n        if (type === 'vertical') {\r\n            return v;\r\n        }\r\n        return v;\r\n    } : _e, zoom = _b.zoom;\r\n    var scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\r\n    var sizeName = type === \"vertical\" ? \"height\" : \"width\";\r\n    var absGap = Math.abs(gap);\r\n    var snapSize = isDisplaySnapDigit\r\n        ? parseFloat(absGap.toFixed(snapDigit))\r\n        : 0;\r\n    return React.createElement(\"div\", { key: \"\".concat(type, \"-\").concat(lineType, \"-guideline-\").concat(index), className: prefix(\"guideline-group\", type), style: (_a = {\r\n                left: \"\".concat(renderPos[0], \"px\"),\r\n                top: \"\".concat(renderPos[1], \"px\")\r\n            },\r\n            _a[sizeName] = \"\".concat(absGap, \"px\"),\r\n            _a) },\r\n        renderInnerGuideline({\r\n            direction: type,\r\n            classNames: [prefix(lineType), className],\r\n            size: \"100%\",\r\n            posValue: [0, 0],\r\n            sizeValue: absGap,\r\n            zoom: zoom,\r\n        }, React),\r\n        React.createElement(\"div\", { className: prefix(\"size-value\", \"gap\"), style: {\r\n                transform: \"translate\".concat(scaleType, \"(-50%) scale(\").concat(zoom, \")\"),\r\n            } }, snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"));\r\n}\r\nfunction groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {\r\n    var index = type === \"vertical\" ? 0 : 1;\r\n    var otherIndex = type === \"vertical\" ? 1 : 0;\r\n    var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\r\n    var targetStart = targetRect[names.start];\r\n    var targetEnd = targetRect[names.end];\r\n    return groupBy(guidelines, function (guideline) {\r\n        return guideline.pos[index];\r\n    }).map(function (nextGuidelines) {\r\n        var start = [];\r\n        var end = [];\r\n        var inner = [];\r\n        nextGuidelines.forEach(function (guideline) {\r\n            var _a, _b;\r\n            var element = guideline.element;\r\n            var rect = guideline.elementRect.rect;\r\n            if (rect[names.end] < targetStart) {\r\n                start.push(guideline);\r\n            }\r\n            else if (targetEnd < rect[names.start]) {\r\n                end.push(guideline);\r\n            }\r\n            else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {\r\n                var pos = guideline.pos;\r\n                var elementRect1 = { element: element, rect: __assign(__assign({}, rect), (_a = {}, _a[names.end] = rect[names.start], _a)) };\r\n                var elementRect2 = { element: element, rect: __assign(__assign({}, rect), (_b = {}, _b[names.start] = rect[names.end], _b)) };\r\n                var nextPos1 = [0, 0];\r\n                var nextPos2 = [0, 0];\r\n                nextPos1[index] = pos[index];\r\n                nextPos1[otherIndex] = pos[otherIndex];\r\n                nextPos2[index] = pos[index];\r\n                nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\r\n                start.push({\r\n                    type: type,\r\n                    pos: nextPos1,\r\n                    size: 0,\r\n                    elementRect: elementRect1,\r\n                    direction: \"\",\r\n                    elementDirection: \"end\",\r\n                });\r\n                end.push({\r\n                    type: type,\r\n                    pos: nextPos2,\r\n                    size: 0,\r\n                    elementRect: elementRect2,\r\n                    direction: \"\",\r\n                    elementDirection: \"start\",\r\n                });\r\n                // inner.push(guideline);\r\n            }\r\n        });\r\n        start.sort(function (a, b) {\r\n            return b.pos[otherIndex] - a.pos[otherIndex];\r\n        });\r\n        end.sort(function (a, b) {\r\n            return a.pos[otherIndex] - b.pos[otherIndex];\r\n        });\r\n        return {\r\n            total: nextGuidelines,\r\n            start: start,\r\n            end: end,\r\n            inner: inner,\r\n        };\r\n    });\r\n}\r\nfunction renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {\r\n    var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;\r\n    var rendered = [];\r\n    [\"vertical\", \"horizontal\"].forEach(function (type) {\r\n        var nextGuidelines = guidelines.filter(function (guideline) { return guideline.type === type; });\r\n        var index = type === \"vertical\" ? 1 : 0;\r\n        var otherIndex = index ? 0 : 1;\r\n        var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);\r\n        var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\r\n        var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\r\n        var targetStart = targetRect[mainNames.start];\r\n        var targetEnd = targetRect[mainNames.end];\r\n        groups.forEach(function (_a) {\r\n            var total = _a.total, start = _a.start, end = _a.end, inner = _a.inner;\r\n            var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];\r\n            var prevRect = targetRect;\r\n            start.forEach(function (guideline) {\r\n                var nextRect = guideline.elementRect.rect;\r\n                var size = prevRect[mainNames.start] - nextRect[mainNames.end];\r\n                if (size > 0) {\r\n                    var renderPos = [0, 0];\r\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;\r\n                    renderPos[otherIndex] = sidePos;\r\n                    rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size, renderPos, guideline.className, React));\r\n                }\r\n                prevRect = nextRect;\r\n            });\r\n            prevRect = targetRect;\r\n            end.forEach(function (guideline) {\r\n                var nextRect = guideline.elementRect.rect;\r\n                var size = nextRect[mainNames.start] - prevRect[mainNames.end];\r\n                if (size > 0) {\r\n                    var renderPos = [0, 0];\r\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;\r\n                    renderPos[otherIndex] = sidePos;\r\n                    rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size, renderPos, guideline.className, React));\r\n                }\r\n                prevRect = nextRect;\r\n            });\r\n            inner.forEach(function (guideline) {\r\n                var nextRect = guideline.elementRect.rect;\r\n                var size1 = targetStart - nextRect[mainNames.start];\r\n                var size2 = nextRect[mainNames.end] - targetEnd;\r\n                var renderPos1 = [0, 0];\r\n                var renderPos2 = [0, 0];\r\n                renderPos1[index] = targetPos[index] - size1;\r\n                renderPos1[otherIndex] = sidePos;\r\n                renderPos2[index] = targetPos[index] + targetEnd - targetStart;\r\n                renderPos2[otherIndex] = sidePos;\r\n                rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size1, renderPos1, guideline.className, React));\r\n                rendered.push(renderDigitLine(moveable, type, \"dashed\", rendered.length, size2, renderPos2, guideline.className, React));\r\n            });\r\n        });\r\n    });\r\n    return rendered;\r\n}\r\nfunction renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {\r\n    var rendered = [];\r\n    [\"horizontal\", \"vertical\"].forEach(function (type) {\r\n        var nextGuidelines = guidelines.filter(function (guideline) { return guideline.type === type; }).slice(0, 1);\r\n        var index = type === \"vertical\" ? 0 : 1;\r\n        var otherIndex = index ? 0 : 1;\r\n        var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\r\n        var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\r\n        var targetStart = targetRect[mainNames.start];\r\n        var targetEnd = targetRect[mainNames.end];\r\n        var targetSideStart = targetRect[sideNames.start];\r\n        var targetSideEnd = targetRect[sideNames.end];\r\n        nextGuidelines.forEach(function (_a) {\r\n            var gap = _a.gap, gapRects = _a.gapRects;\r\n            var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], __read(gapRects.map(function (_a) {\r\n                var rect = _a.rect;\r\n                return rect[sideNames.start];\r\n            })), false));\r\n            var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], __read(gapRects.map(function (_a) {\r\n                var rect = _a.rect;\r\n                return rect[sideNames.end];\r\n            })), false));\r\n            var sideCenterPos = (sideStartPos + sideEndPos) / 2;\r\n            if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {\r\n                return;\r\n            }\r\n            gapRects.forEach(function (_a) {\r\n                var rect = _a.rect, className = _a.className;\r\n                var renderPos = [targetPos[0], targetPos[1]];\r\n                if (rect[mainNames.end] < targetStart) {\r\n                    renderPos[index] += rect[mainNames.end] - targetStart;\r\n                }\r\n                else if (targetEnd < rect[mainNames.start]) {\r\n                    renderPos[index] += rect[mainNames.start] - targetStart - gap;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n                renderPos[otherIndex] += sideCenterPos - targetSideStart;\r\n                rendered.push(renderDigitLine(moveable, index ? \"vertical\" : \"horizontal\", \"gap\", rendered.length, gap, renderPos, className, React));\r\n            });\r\n        });\r\n    });\r\n    return rendered;\r\n}\n\nfunction getTotalGuidelines(moveable) {\r\n    var _a, _b;\r\n    var state = moveable.state;\r\n    var containerClientRect = state.containerClientRect, hasFixed = state.hasFixed;\r\n    var overflow = containerClientRect.overflow, containerHeight = containerClientRect.scrollHeight, containerWidth = containerClientRect.scrollWidth, containerClientHeight = containerClientRect.clientHeight, containerClientWidth = containerClientRect.clientWidth, clientLeft = containerClientRect.clientLeft, clientTop = containerClientRect.clientTop;\r\n    var _c = moveable.props, _d = _c.snapGap, snapGap = _d === void 0 ? true : _d, verticalGuidelines = _c.verticalGuidelines, horizontalGuidelines = _c.horizontalGuidelines, _e = _c.snapThreshold, snapThreshold = _e === void 0 ? 5 : _e, _f = _c.maxSnapElementGuidelineDistance, maxSnapElementGuidelineDistance = _f === void 0 ? Infinity : _f, isDisplayGridGuidelines = _c.isDisplayGridGuidelines;\r\n    var _g = getRect(getAbsolutePosesByState(moveable.state)), top = _g.top, left = _g.left, bottom = _g.bottom, right = _g.right;\r\n    var targetRect = { top: top, left: left, bottom: bottom, right: right, center: (left + right) / 2, middle: (top + bottom) / 2 };\r\n    var elementGuidelines = getElementGuidelines(moveable);\r\n    var totalGuidelines = __spreadArray([], __read(elementGuidelines), false);\r\n    var snapThresholdMultiples = ((_b = (_a = state.snapThresholdInfo) === null || _a === void 0 ? void 0 : _a.multiples) !== null && _b !== void 0 ? _b : [1, 1]).map(function (n) { return n * snapThreshold; });\r\n    if (snapGap) {\r\n        totalGuidelines.push.apply(totalGuidelines, __spreadArray([], __read(getGapGuidelines(moveable, targetRect, snapThresholdMultiples)), false));\r\n    }\r\n    var snapOffset = __assign({}, (state.snapOffset || {\r\n        left: 0,\r\n        top: 0,\r\n        bottom: 0,\r\n        right: 0,\r\n    }));\r\n    totalGuidelines.push.apply(totalGuidelines, __spreadArray([], __read(getGridGuidelines(moveable, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset, isDisplayGridGuidelines)), false));\r\n    if (hasFixed) {\r\n        var left_1 = containerClientRect.left, top_1 = containerClientRect.top;\r\n        snapOffset.left += left_1;\r\n        snapOffset.top += top_1;\r\n        snapOffset.right += left_1;\r\n        snapOffset.bottom += top_1;\r\n    }\r\n    totalGuidelines.push.apply(totalGuidelines, __spreadArray([], __read(getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset)), false));\r\n    totalGuidelines = totalGuidelines.filter(function (_a) {\r\n        var element = _a.element, elementRect = _a.elementRect, type = _a.type;\r\n        if (!element || !elementRect) {\r\n            return true;\r\n        }\r\n        var rect = elementRect.rect;\r\n        return checkBetweenRects(targetRect, rect, type, maxSnapElementGuidelineDistance);\r\n    });\r\n    return totalGuidelines;\r\n}\r\nfunction getGapGuidelines(moveable, targetRect, snapThresholds) {\r\n    var _a = moveable.props, _b = _a.maxSnapElementGuidelineDistance, maxSnapElementGuidelineDistance = _b === void 0 ? Infinity : _b, _c = _a.maxSnapElementGapDistance, maxSnapElementGapDistance = _c === void 0 ? Infinity : _c;\r\n    var elementRects = moveable.state.elementRects;\r\n    var gapGuidelines = [];\r\n    [\r\n        [\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP],\r\n        [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP],\r\n    ].forEach(function (_a) {\r\n        var _b = __read(_a, 3), type = _b[0], mainNames = _b[1], sideNames = _b[2];\r\n        var targetStart = targetRect[mainNames.start];\r\n        var targetEnd = targetRect[mainNames.end];\r\n        var targetCenter = targetRect[mainNames.center];\r\n        var targetStart2 = targetRect[sideNames.start];\r\n        var targetEnd2 = targetRect[sideNames.end];\r\n        // element : moveable\r\n        var snapThresholdMap = {\r\n            left: snapThresholds[0],\r\n            top: snapThresholds[1],\r\n        };\r\n        function getDist(elementRect) {\r\n            var rect = elementRect.rect;\r\n            var snapThreshold = snapThresholdMap[mainNames.start];\r\n            if (rect[mainNames.end] < targetStart + snapThreshold) {\r\n                return targetStart - rect[mainNames.end];\r\n            }\r\n            else if (targetEnd - snapThreshold < rect[mainNames.start]) {\r\n                return rect[mainNames.start] - targetEnd;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        var nextElementRects = elementRects.filter(function (elementRect) {\r\n            var rect = elementRect.rect;\r\n            if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {\r\n                return false;\r\n            }\r\n            return getDist(elementRect) > 0;\r\n        }).sort(function (a, b) {\r\n            return getDist(a) - getDist(b);\r\n        });\r\n        var groups = [];\r\n        nextElementRects.forEach(function (snapRect1) {\r\n            nextElementRects.forEach(function (snapRect2) {\r\n                if (snapRect1 === snapRect2) {\r\n                    return;\r\n                }\r\n                var rect1 = snapRect1.rect;\r\n                var rect2 = snapRect2.rect;\r\n                var rect1Start = rect1[sideNames.start];\r\n                var rect1End = rect1[sideNames.end];\r\n                var rect2Start = rect2[sideNames.start];\r\n                var rect2End = rect2[sideNames.end];\r\n                if (rect1Start > rect2End || rect2Start > rect1End) {\r\n                    return;\r\n                }\r\n                groups.push([snapRect1, snapRect2]);\r\n            });\r\n        });\r\n        groups.forEach(function (_a) {\r\n            var _b = __read(_a, 2), snapRect1 = _b[0], snapRect2 = _b[1];\r\n            var rect1 = snapRect1.rect;\r\n            var rect2 = snapRect2.rect;\r\n            var rect1Start = rect1[mainNames.start];\r\n            var rect1End = rect1[mainNames.end];\r\n            var rect2Start = rect2[mainNames.start];\r\n            var rect2End = rect2[mainNames.end];\r\n            var snapThreshold = snapThresholdMap[mainNames.start];\r\n            var gap = 0;\r\n            var pos = 0;\r\n            var isStart = false;\r\n            var isCenter = false;\r\n            var isEnd = false;\r\n            if (rect1End <= targetStart && targetEnd <= rect2Start) {\r\n                // (l)element1(r) : (l)target(r) : (l)element2(r)\r\n                isCenter = true;\r\n                gap = ((rect2Start - rect1End) - (targetEnd - targetStart)) / 2;\r\n                pos = rect1End + gap + (targetEnd - targetStart) / 2;\r\n                if (abs(pos - targetCenter) > snapThreshold) {\r\n                    return;\r\n                }\r\n            }\r\n            else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\r\n                // (l)element1(r) : (l)element2(r) : (l)target\r\n                isStart = true;\r\n                gap = rect2Start - rect1End;\r\n                pos = rect2End + gap;\r\n                if (abs(pos - targetStart) > snapThreshold) {\r\n                    return;\r\n                }\r\n            }\r\n            else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\r\n                // target(r) : (l)element1(r) : (l)element2(r)\r\n                isEnd = true;\r\n                gap = rect2Start - rect1End;\r\n                pos = rect1Start - gap;\r\n                if (abs(pos - targetEnd) > snapThreshold) {\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n            if (!gap) {\r\n                return;\r\n            }\r\n            if (!checkBetweenRects(targetRect, rect2, type, maxSnapElementGuidelineDistance)) {\r\n                return;\r\n            }\r\n            if (gap > maxSnapElementGapDistance) {\r\n                return;\r\n            }\r\n            gapGuidelines.push({\r\n                type: type,\r\n                pos: type === \"vertical\" ? [pos, 0] : [0, pos],\r\n                element: snapRect2.element,\r\n                size: 0,\r\n                className: snapRect2.className,\r\n                isStart: isStart,\r\n                isCenter: isCenter,\r\n                isEnd: isEnd,\r\n                gap: gap,\r\n                hide: true,\r\n                gapRects: [snapRect1, snapRect2],\r\n                direction: \"\",\r\n                elementDirection: \"\",\r\n            });\r\n        });\r\n    });\r\n    return gapGuidelines;\r\n}\r\nfunction startGridGroupGuidelines(moveable, clientLeft, clientTop, snapOffset) {\r\n    var _a, _b;\r\n    var props = moveable.props;\r\n    var state = moveable.state;\r\n    var snapGridAll = props.snapGridAll;\r\n    var _c = props.snapGridWidth, snapGridWidth = _c === void 0 ? 0 : _c, _d = props.snapGridHeight, snapGridHeight = _d === void 0 ? 0 : _d;\r\n    var snapRenderInfo = state.snapRenderInfo;\r\n    var hasDirection = snapRenderInfo && (((_a = snapRenderInfo.direction) === null || _a === void 0 ? void 0 : _a[0]) || ((_b = snapRenderInfo.direction) === null || _b === void 0 ? void 0 : _b[1]));\r\n    var moveables = moveable.moveables;\r\n    // snap group's all child to grid.\r\n    if (snapGridAll\r\n        && moveables\r\n        && hasDirection\r\n        && (snapGridWidth || snapGridHeight)) {\r\n        if (state.snapThresholdInfo) {\r\n            return;\r\n        }\r\n        state.snapThresholdInfo = {\r\n            multiples: [1, 1],\r\n            offset: [0, 0],\r\n        };\r\n        var rect_1 = moveable.getRect();\r\n        var children_1 = rect_1.children;\r\n        var direction = snapRenderInfo.direction;\r\n        if (children_1) {\r\n            var result = direction.map(function (dir, i) {\r\n                var _a = i === 0 ? {\r\n                    snapSize: snapGridWidth,\r\n                    posName: \"left\",\r\n                    sizeName: \"width\",\r\n                    clientOffset: snapOffset.left - clientLeft,\r\n                } : {\r\n                    snapSize: snapGridHeight,\r\n                    posName: \"top\",\r\n                    sizeName: \"height\",\r\n                    clientOffset: snapOffset.top - clientTop,\r\n                }, snapSize = _a.snapSize, posName = _a.posName, sizeName = _a.sizeName, clientOffset = _a.clientOffset;\r\n                if (!snapSize) {\r\n                    return {\r\n                        dir: dir,\r\n                        multiple: 1,\r\n                        snapSize: snapSize,\r\n                        snapOffset: 0,\r\n                    };\r\n                }\r\n                var rectSize = rect_1[sizeName];\r\n                var rectPos = rect_1[posName];\r\n                // 사이즈보다 만약 작다면 어떻게 해야되죠?\r\n                var childSizes = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.flat)(children_1.map(function (child) {\r\n                    return [\r\n                        (child[posName] - rectPos),\r\n                        (child[sizeName]),\r\n                        (rectSize - child[sizeName] - child[posName] + rectPos),\r\n                    ];\r\n                })).filter(function (v) { return v; }).sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n                var firstChildSize = childSizes[0];\r\n                var childSnapSizes = childSizes.map(function (size) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(size / firstChildSize, 0.1) * snapSize; });\r\n                var n = 1;\r\n                var rectRatio = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(rectSize / firstChildSize, 0.1);\r\n                for (n = 1; n <= 10; ++n) {\r\n                    if (childSnapSizes.every(function (childSize) {\r\n                        return childSize * n % 1 === 0;\r\n                    })) {\r\n                        break;\r\n                    }\r\n                }\r\n                // dir 1 (fixed -1)\r\n                // dir 0 (fixed 0)\r\n                // dir -1 (fixed 1)\r\n                var ratio = (-dir + 1) / 2;\r\n                var offsetPos = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(rectPos - clientOffset, rectPos - clientOffset + rectSize, ratio, 1 - ratio);\r\n                return {\r\n                    multiple: rectRatio * n,\r\n                    dir: dir,\r\n                    snapSize: snapSize,\r\n                    snapOffset: Math.round(offsetPos / snapSize),\r\n                };\r\n            });\r\n            var multiples = result.map(function (r) { return r.multiple || 1; });\r\n            state.snapThresholdInfo.multiples = multiples;\r\n            state.snapThresholdInfo.offset = result.map(function (r) { return r.snapOffset; });\r\n            result.forEach(function (r, i) {\r\n                if (r.snapSize) ;\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        state.snapThresholdInfo = null;\r\n    }\r\n}\r\nfunction getGridGuidelines(moveable, containerWidth, containerHeight, clientLeft, clientTop, snapOffset, isDisplayGridGuidelines) {\r\n    if (clientLeft === void 0) { clientLeft = 0; }\r\n    if (clientTop === void 0) { clientTop = 0; }\r\n    var props = moveable.props;\r\n    var state = moveable.state;\r\n    var _a = props.snapGridWidth, snapGridWidth = _a === void 0 ? 0 : _a, _b = props.snapGridHeight, snapGridHeight = _b === void 0 ? 0 : _b;\r\n    var guidelines = [];\r\n    var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top;\r\n    var startOffset = [0, 0];\r\n    startGridGroupGuidelines(moveable, clientLeft, clientTop, snapOffset);\r\n    var snapThresholdInfo = state.snapThresholdInfo;\r\n    var defaultSnapGridWidth = snapGridWidth;\r\n    var defaultSnapGridHeight = snapGridHeight;\r\n    if (snapThresholdInfo) {\r\n        snapGridWidth *= snapThresholdInfo.multiples[0] || 1;\r\n        snapGridHeight *= snapThresholdInfo.multiples[1] || 1;\r\n        startOffset = snapThresholdInfo.offset;\r\n    }\r\n    if (snapGridHeight) {\r\n        var pushGuideline = function (pos) {\r\n            guidelines.push({\r\n                type: \"horizontal\",\r\n                pos: [\r\n                    snapOffsetLeft,\r\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startOffset[1] * defaultSnapGridHeight + pos - clientTop + snapOffsetTop, 0.1),\r\n                ],\r\n                className: prefix(\"grid-guideline\"),\r\n                size: containerWidth,\r\n                hide: !isDisplayGridGuidelines,\r\n                direction: \"\",\r\n                grid: true,\r\n            });\r\n        };\r\n        for (var pos = 0; pos <= containerHeight * 2; pos += snapGridHeight) {\r\n            pushGuideline(pos);\r\n        }\r\n        for (var pos = -snapGridHeight; pos >= -containerHeight; pos -= snapGridHeight) {\r\n            pushGuideline(pos);\r\n        }\r\n    }\r\n    if (snapGridWidth) {\r\n        var pushGuideline = function (pos) {\r\n            guidelines.push({\r\n                type: \"vertical\",\r\n                pos: [\r\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(startOffset[0] * defaultSnapGridWidth + pos - clientLeft + snapOffsetLeft, 0.1),\r\n                    snapOffsetTop,\r\n                ],\r\n                className: prefix(\"grid-guideline\"),\r\n                size: containerHeight,\r\n                hide: !isDisplayGridGuidelines,\r\n                direction: \"\",\r\n                grid: true,\r\n            });\r\n        };\r\n        for (var pos = 0; pos <= containerWidth * 2; pos += snapGridWidth) {\r\n            pushGuideline(pos);\r\n        }\r\n        for (var pos = -snapGridWidth; pos >= -containerWidth; pos -= snapGridWidth) {\r\n            pushGuideline(pos);\r\n        }\r\n    }\r\n    return guidelines;\r\n}\r\nfunction checkBetweenRects(rect1, rect2, type, distance) {\r\n    if (type === \"horizontal\") {\r\n        return abs(rect1.right - rect2.left) <= distance\r\n            || abs(rect1.left - rect2.right) <= distance\r\n            || rect1.left <= rect2.right && rect2.left <= rect1.right;\r\n    }\r\n    else if (type === \"vertical\") {\r\n        return abs(rect1.bottom - rect2.top) <= distance\r\n            || abs(rect1.top - rect2.bottom) <= distance\r\n            || rect1.top <= rect2.bottom && rect2.top <= rect1.bottom;\r\n    }\r\n    return true;\r\n}\r\nfunction getElementGuidelines(moveable) {\r\n    var state = moveable.state;\r\n    var _a = moveable.props.elementGuidelines, elementGuidelines = _a === void 0 ? [] : _a;\r\n    if (!elementGuidelines.length) {\r\n        state.elementRects = [];\r\n        return [];\r\n    }\r\n    var prevValues = (state.elementRects || []).filter(function (snapRect) { return !snapRect.refresh; });\r\n    var nextElementGuidelines = elementGuidelines.map(function (el) {\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(el) && \"element\" in el) {\r\n            return __assign(__assign({}, el), { element: getRefTarget(el.element, true) });\r\n        }\r\n        return {\r\n            element: getRefTarget(el, true),\r\n        };\r\n    }).filter(function (value) {\r\n        return value.element;\r\n    });\r\n    var _b = (0,_egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__.diff)(prevValues.map(function (v) { return v.element; }), nextElementGuidelines.map(function (v) { return v.element; })), maintained = _b.maintained, added = _b.added;\r\n    var nextValues = [];\r\n    maintained.forEach(function (_a) {\r\n        var _b = __read(_a, 2), prevIndex = _b[0], nextIndex = _b[1];\r\n        nextValues[nextIndex] = prevValues[prevIndex];\r\n    });\r\n    getSnapElementRects(moveable, added.map(function (index) { return nextElementGuidelines[index]; })).map(function (rect, i) {\r\n        nextValues[added[i]] = rect;\r\n    });\r\n    state.elementRects = nextValues;\r\n    var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\r\n    var nextGuidelines = [];\r\n    nextValues.forEach(function (snapRect) {\r\n        var element = snapRect.element, _a = snapRect.top, topValue = _a === void 0 ? elementSnapDirections.top : _a, _b = snapRect.left, leftValue = _b === void 0 ? elementSnapDirections.left : _b, _c = snapRect.right, rightValue = _c === void 0 ? elementSnapDirections.right : _c, _d = snapRect.bottom, bottomValue = _d === void 0 ? elementSnapDirections.bottom : _d, _e = snapRect.center, centerValue = _e === void 0 ? elementSnapDirections.center : _e, _f = snapRect.middle, middleValue = _f === void 0 ? elementSnapDirections.middle : _f, className = snapRect.className, rect = snapRect.rect;\r\n        var _g = splitSnapDirectionPoses({\r\n            top: topValue,\r\n            right: rightValue,\r\n            left: leftValue,\r\n            bottom: bottomValue,\r\n            center: centerValue,\r\n            middle: middleValue,\r\n        }, rect), horizontal = _g.horizontal, vertical = _g.vertical, horizontalNames = _g.horizontalNames, verticalNames = _g.verticalNames;\r\n        var rectTop = rect.top;\r\n        var rectLeft = rect.left;\r\n        var width = rect.right - rectLeft;\r\n        var height = rect.bottom - rectTop;\r\n        var sizes = [width, height];\r\n        vertical.forEach(function (pos, i) {\r\n            nextGuidelines.push({\r\n                type: \"vertical\",\r\n                element: element,\r\n                pos: [\r\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(pos, 0.1),\r\n                    rectTop,\r\n                ], size: height,\r\n                sizes: sizes,\r\n                className: className,\r\n                elementRect: snapRect,\r\n                elementDirection: SNAP_SKIP_NAMES_MAP[verticalNames[i]] || verticalNames[i],\r\n                direction: \"\",\r\n            });\r\n        });\r\n        horizontal.forEach(function (pos, i) {\r\n            nextGuidelines.push({\r\n                type: \"horizontal\",\r\n                element: element,\r\n                pos: [\r\n                    rectLeft,\r\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(pos, 0.1),\r\n                ],\r\n                size: width,\r\n                sizes: sizes,\r\n                className: className,\r\n                elementRect: snapRect,\r\n                elementDirection: SNAP_SKIP_NAMES_MAP[horizontalNames[i]] || horizontalNames[i],\r\n                direction: \"\",\r\n            });\r\n        });\r\n    });\r\n    return nextGuidelines;\r\n}\r\nfunction getObjectGuidelines(guidelines, containerSize) {\r\n    return guidelines ? guidelines.map(function (info) {\r\n        var posGuideline = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(info) ? info : { pos: info };\r\n        var pos = posGuideline.pos;\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(pos)) {\r\n            return posGuideline;\r\n        }\r\n        else {\r\n            return __assign(__assign({}, posGuideline), { pos: (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, containerSize) });\r\n        }\r\n    }) : [];\r\n}\r\nfunction getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {\r\n    if (clientLeft === void 0) { clientLeft = 0; }\r\n    if (clientTop === void 0) { clientTop = 0; }\r\n    if (snapOffset === void 0) { snapOffset = { left: 0, top: 0, right: 0, bottom: 0 }; }\r\n    var guidelines = [];\r\n    var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top, snapOffsetBottom = snapOffset.bottom, snapOffsetRight = snapOffset.right;\r\n    var snapWidth = width + snapOffsetRight - snapOffsetLeft;\r\n    var snapHeight = height + snapOffsetBottom - snapOffsetTop;\r\n    getObjectGuidelines(horizontalGuidelines, snapHeight).forEach(function (posInfo) {\r\n        guidelines.push({\r\n            type: \"horizontal\",\r\n            pos: [\r\n                snapOffsetLeft,\r\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(posInfo.pos - clientTop + snapOffsetTop, 0.1),\r\n            ],\r\n            size: snapWidth,\r\n            className: posInfo.className,\r\n            direction: \"\",\r\n        });\r\n    });\r\n    getObjectGuidelines(verticalGuidelines, snapWidth).forEach(function (posInfo) {\r\n        guidelines.push({\r\n            type: \"vertical\",\r\n            pos: [\r\n                (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(posInfo.pos - clientLeft + snapOffsetLeft, 0.1),\r\n                snapOffsetTop,\r\n            ],\r\n            size: snapHeight,\r\n            className: posInfo.className,\r\n            direction: \"\",\r\n        });\r\n    });\r\n    return guidelines;\r\n}\r\nfunction getSnapElementRects(moveable, values) {\r\n    if (!values.length) {\r\n        return [];\r\n    }\r\n    var groupable = moveable.props.groupable;\r\n    var state = moveable.state;\r\n    var containerClientRect = state.containerClientRect, \r\n    // targetClientRect: {\r\n    //     top: clientTop,\r\n    //     left: clientLeft,\r\n    // },\r\n    rootMatrix = state.rootMatrix, is3d = state.is3d, offsetDelta = state.offsetDelta;\r\n    var n = is3d ? 4 : 3;\r\n    var _a = __read(calculateContainerPos(rootMatrix, containerClientRect, n), 2), containerLeft = _a[0], containerTop = _a[1];\r\n    // const poses = getAbsolutePosesByState(state);\r\n    // const {\r\n    //     minX: targetLeft,\r\n    //     minY: targetTop,\r\n    // } = getMinMaxs(poses);\r\n    // const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\r\n    //     clientLeft - containerLeft,\r\n    //     clientTop - containerTop,\r\n    // ], n)).map(pos => roundSign(pos));\r\n    var offsetLeft = groupable ? 0 : offsetDelta[0];\r\n    var offsetTop = groupable ? 0 : offsetDelta[1];\r\n    return values.map(function (value) {\r\n        var rect = value.element.getBoundingClientRect();\r\n        var left = rect.left - containerLeft - offsetLeft;\r\n        var top = rect.top - containerTop - offsetTop;\r\n        var bottom = top + rect.height;\r\n        var right = left + rect.width;\r\n        var _a = __read(calculateInversePosition(rootMatrix, [left, top], n), 2), elementLeft = _a[0], elementTop = _a[1];\r\n        var _b = __read(calculateInversePosition(rootMatrix, [right, bottom], n), 2), elementRight = _b[0], elementBottom = _b[1];\r\n        return __assign(__assign({}, value), { rect: {\r\n                left: elementLeft,\r\n                right: elementRight,\r\n                top: elementTop,\r\n                bottom: elementBottom,\r\n                center: (elementLeft + elementRight) / 2,\r\n                middle: (elementTop + elementBottom) / 2,\r\n            } });\r\n    });\r\n}\n\nfunction checkSnapInfo(moveable) {\r\n    var state = moveable.state;\r\n    var container = state.container;\r\n    var snapContainer = moveable.props.snapContainer || container;\r\n    if (state.snapContainer === snapContainer && state.guidelines && state.guidelines.length) {\r\n        return false;\r\n    }\r\n    var containerClientRect = state.containerClientRect;\r\n    var snapOffset = {\r\n        left: 0,\r\n        top: 0,\r\n        bottom: 0,\r\n        right: 0,\r\n    };\r\n    if (container !== snapContainer) {\r\n        var snapContainerTarget = getRefTarget(snapContainer, true);\r\n        if (snapContainerTarget) {\r\n            var snapContainerRect = getClientRect(snapContainerTarget);\r\n            var offset1 = getDragDistByState(state, [\r\n                snapContainerRect.left - containerClientRect.left,\r\n                snapContainerRect.top - containerClientRect.top,\r\n            ]);\r\n            var offset2 = getDragDistByState(state, [\r\n                snapContainerRect.right - containerClientRect.right,\r\n                snapContainerRect.bottom - containerClientRect.bottom,\r\n            ]);\r\n            snapOffset.left = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset1[0], 0.00001);\r\n            snapOffset.top = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset1[1], 0.00001);\r\n            snapOffset.right = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset2[0], 0.00001);\r\n            snapOffset.bottom = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(offset2[1], 0.00001);\r\n        }\r\n    }\r\n    state.snapContainer = snapContainer;\r\n    state.snapOffset = snapOffset;\r\n    state.guidelines = getTotalGuidelines(moveable);\r\n    state.enableSnap = true;\r\n    return true;\r\n}\r\nfunction getNextFixedPoses(matrix, width, height, fixedDirection, fixedPos, is3d) {\r\n    var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\r\n    var nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\r\n    return getAbsolutePoses(nextPoses, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(fixedPos, nextFixedPos));\r\n}\r\nfunction normalized(value) {\r\n    return value ? value / abs(value) : 0;\r\n}\r\nfunction getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {\r\n    var fixedDirection = datas.fixedDirection;\r\n    var directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\r\n    var innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);\r\n    var offsets = __spreadArray(__spreadArray([], __read(getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas)), false), __read(getInnerBoundInfo(moveable, innerBoundLineInfos, datas)), false);\r\n    var widthOffsetInfo = getNearOffsetInfo(offsets, 0);\r\n    var heightOffsetInfo = getNearOffsetInfo(offsets, 1);\r\n    return {\r\n        width: {\r\n            isBound: widthOffsetInfo.isBound,\r\n            offset: widthOffsetInfo.offset[0],\r\n        },\r\n        height: {\r\n            isBound: heightOffsetInfo.isBound,\r\n            offset: heightOffsetInfo.offset[1],\r\n        },\r\n    };\r\n}\r\nfunction recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {\r\n    var snapPos = getPosByDirection(poses, direction);\r\n    var _a = checkMoveableSnapBounds(moveable, isRequest, {\r\n        vertical: [snapPos[0]],\r\n        horizontal: [snapPos[1]],\r\n    }), horizontalOffset = _a.horizontal.offset, verticalOffset = _a.vertical.offset;\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(verticalOffset, FLOAT_POINT_NUM) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(horizontalOffset, FLOAT_POINT_NUM)) {\r\n        var _b = __read(getDragDist({\r\n            datas: datas,\r\n            distX: -verticalOffset,\r\n            distY: -horizontalOffset,\r\n        }), 2), nextWidthOffset = _b[0], nextHeightOffset = _b[1];\r\n        var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\r\n        var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\r\n        return [nextWidth - width, nextHeight - height];\r\n    }\r\n    return [0, 0];\r\n}\r\nfunction checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {\r\n    var poses = getAbsolutePosesByState(moveable.state);\r\n    var keepRatio = moveable.props.keepRatio;\r\n    var widthOffset = 0;\r\n    var heightOffset = 0;\r\n    for (var i = 0; i < 2; ++i) {\r\n        var nextPoses = getNextPoses(widthOffset, heightOffset);\r\n        var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas), widthOffsetInfo = _a.width, heightOffsetInfo = _a.height;\r\n        var isWidthBound = widthOffsetInfo.isBound;\r\n        var isHeightBound = heightOffsetInfo.isBound;\r\n        var nextWidthOffset = widthOffsetInfo.offset;\r\n        var nextHeightOffset = heightOffsetInfo.offset;\r\n        if (i === 1) {\r\n            if (!isWidthBound) {\r\n                nextWidthOffset = 0;\r\n            }\r\n            if (!isHeightBound) {\r\n                nextHeightOffset = 0;\r\n            }\r\n        }\r\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\r\n            return [0, 0];\r\n        }\r\n        if (keepRatio) {\r\n            var widthDist = abs(nextWidthOffset) * (width ? 1 / width : 1);\r\n            var heightDist = abs(nextHeightOffset) * (height ? 1 / height : 1);\r\n            var isGetWidthOffset = isWidthBound && isHeightBound\r\n                ? widthDist < heightDist\r\n                : isHeightBound ||\r\n                    (!isWidthBound && widthDist < heightDist);\r\n            if (isGetWidthOffset) {\r\n                // width : height = ? : heightOffset\r\n                nextWidthOffset = (width * nextHeightOffset) / height;\r\n            }\r\n            else {\r\n                // width : height = widthOffset : ?\r\n                nextHeightOffset = (height * nextWidthOffset) / width;\r\n            }\r\n        }\r\n        widthOffset += nextWidthOffset;\r\n        heightOffset += nextHeightOffset;\r\n    }\r\n    if (!keepRatio && direction[0] && direction[1]) {\r\n        var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas), maxWidth = _b.maxWidth, maxHeight = _b.maxHeight;\r\n        var _c = __read(recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function (pos) { return pos.map(function (p) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(p, FLOAT_POINT_NUM); }); }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas), 2), nextWidthOffset = _c[0], nextHeightOffset = _c[1];\r\n        widthOffset += nextWidthOffset;\r\n        heightOffset += nextHeightOffset;\r\n    }\r\n    return [widthOffset, heightOffset];\r\n}\r\nfunction absDegree(deg) {\r\n    if (deg < 0) {\r\n        deg = deg % 360 + 360;\r\n    }\r\n    deg %= 360;\r\n    return deg;\r\n}\r\nfunction bumpDegree(baseDeg, snapDeg) {\r\n    // baseDeg -80\r\n    // snapDeg 270\r\n    // return -90\r\n    snapDeg = absDegree(snapDeg);\r\n    var count = Math.floor(baseDeg / 360);\r\n    var deg1 = count * 360 + 360 - snapDeg;\r\n    var deg2 = count * 360 + snapDeg;\r\n    return abs(baseDeg - deg1) < abs(baseDeg - deg2) ? deg1 : deg2;\r\n}\r\nfunction getMinDegreeDistance(deg1, deg2) {\r\n    deg1 = absDegree(deg1);\r\n    deg2 = absDegree(deg2);\r\n    var deg3 = absDegree(deg1 - deg2);\r\n    return Math.min(deg3, 360 - deg3);\r\n}\r\nfunction checkSnapRotate(moveable, rect, dist, rotation) {\r\n    var _a;\r\n    var props = moveable.props;\r\n    var snapRotationThreshold = (_a = props[NAME_snapRotationThreshold]) !== null && _a !== void 0 ? _a : 5;\r\n    var snapRotationDegrees = props[NAME_snapRotationDegrees];\r\n    if (hasGuidelines(moveable, \"rotatable\")) {\r\n        var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4, origin2_1 = rect.origin;\r\n        var rad_1 = (dist * Math.PI) / 180;\r\n        var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos, origin2_1); });\r\n        var nextPoses = prevPoses.map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad_1); });\r\n        // console.log(moveable.state.left, moveable.state.top, moveable.state.origin);\r\n        // console.log(pos1, pos2, pos3, pos4, origin, rad, prevPoses, nextPoses);\r\n        var result = __spreadArray(__spreadArray([], __read(checkRotateBounds(moveable, prevPoses, nextPoses, origin2_1, dist)), false), __read(checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin2_1, dist)), false);\r\n        result.sort(function (a, b) { return abs(a - dist) - abs(b - dist); });\r\n        var isSnap = result.length > 0;\r\n        if (isSnap) {\r\n            return {\r\n                isSnap: isSnap,\r\n                dist: isSnap ? result[0] : dist,\r\n            };\r\n        }\r\n    }\r\n    if ((snapRotationDegrees === null || snapRotationDegrees === void 0 ? void 0 : snapRotationDegrees.length) && snapRotationThreshold) {\r\n        var sorted = snapRotationDegrees.slice().sort(function (a, b) {\r\n            return getMinDegreeDistance(a, rotation) - getMinDegreeDistance(b, rotation);\r\n        });\r\n        var firstDegree = sorted[0];\r\n        if (getMinDegreeDistance(firstDegree, rotation) <= snapRotationThreshold) {\r\n            return {\r\n                isSnap: true,\r\n                dist: dist + bumpDegree(rotation, firstDegree) - rotation,\r\n            };\r\n        }\r\n    }\r\n    return {\r\n        isSnap: false,\r\n        dist: dist,\r\n    };\r\n}\r\nfunction checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {\r\n    if (!hasGuidelines(moveable, \"resizable\")) {\r\n        return [0, 0];\r\n    }\r\n    var fixedDirection = datas.fixedDirection, nextAllMatrix = datas.nextAllMatrix;\r\n    var _a = moveable.state, allMatrix = _a.allMatrix, is3d = _a.is3d;\r\n    return checkSizeDist(moveable, function (widthOffset, heightOffset) {\r\n        return getNextFixedPoses(nextAllMatrix || allMatrix, width + widthOffset, height + heightOffset, fixedDirection, fixedPosition, is3d);\r\n    }, width, height, direction, fixedPosition, isRequest, datas);\r\n}\r\nfunction checkSnapScale(moveable, scale, direction, isRequest, datas) {\r\n    if (!hasGuidelines(moveable, \"scalable\")) {\r\n        return [0, 0];\r\n    }\r\n    var startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, fixedPosition = datas.fixedPosition, fixedDirection = datas.fixedDirection, is3d = datas.is3d;\r\n    var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {\r\n        return getNextFixedPoses(scaleMatrix(datas, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight])), startOffsetWidth, startOffsetHeight, fixedDirection, fixedPosition, is3d);\r\n    }, startOffsetWidth, startOffsetHeight, direction, fixedPosition, isRequest, datas);\r\n    return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\r\n}\r\nfunction startCheckSnapDrag(moveable, datas) {\r\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\r\n}\r\nfunction getSnapGuidelines(posInfos) {\r\n    var guidelines = [];\r\n    posInfos.forEach(function (posInfo) {\r\n        posInfo.guidelineInfos.forEach(function (_a) {\r\n            var guideline = _a.guideline;\r\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(guidelines, function (info) { return info.guideline === guideline; })) {\r\n                return;\r\n            }\r\n            guideline.direction = \"\";\r\n            guidelines.push({ guideline: guideline, posInfo: posInfo });\r\n        });\r\n    });\r\n    return guidelines.map(function (_a) {\r\n        var guideline = _a.guideline, posInfo = _a.posInfo;\r\n        return __assign(__assign({}, guideline), { direction: posInfo.direction });\r\n    });\r\n}\r\nfunction addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {\r\n    var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses), verticalBoundInfos = _a.vertical, horizontalBoundInfos = _a.horizontal;\r\n    var boundMap = getInitialBounds();\r\n    verticalBoundInfos.forEach(function (info) {\r\n        if (info.isBound) {\r\n            if (info.direction === \"start\") {\r\n                boundMap.left = true;\r\n            }\r\n            if (info.direction === \"end\") {\r\n                boundMap.right = true;\r\n            }\r\n            verticalSnapPoses.push({\r\n                type: \"bounds\",\r\n                pos: info.pos,\r\n            });\r\n        }\r\n    });\r\n    horizontalBoundInfos.forEach(function (info) {\r\n        if (info.isBound) {\r\n            if (info.direction === \"start\") {\r\n                boundMap.top = true;\r\n            }\r\n            if (info.direction === \"end\") {\r\n                boundMap.bottom = true;\r\n            }\r\n            horizontalSnapPoses.push({\r\n                type: \"bounds\",\r\n                pos: info.pos,\r\n            });\r\n        }\r\n    });\r\n    var _b = checkInnerBoundPoses(moveable), innerBoundMap = _b.boundMap, verticalInnerBoundPoses = _b.vertical, horizontalInnerBoundPoses = _b.horizontal;\r\n    verticalInnerBoundPoses.forEach(function (innerPos) {\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(verticalSnapPoses, function (_a) {\r\n            var type = _a.type, pos = _a.pos;\r\n            return type === \"bounds\" && pos === innerPos;\r\n        }) >= 0) {\r\n            return;\r\n        }\r\n        verticalSnapPoses.push({\r\n            type: \"bounds\",\r\n            pos: innerPos,\r\n        });\r\n    });\r\n    horizontalInnerBoundPoses.forEach(function (innerPos) {\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(horizontalSnapPoses, function (_a) {\r\n            var type = _a.type, pos = _a.pos;\r\n            return type === \"bounds\" && pos === innerPos;\r\n        }) >= 0) {\r\n            return;\r\n        }\r\n        horizontalSnapPoses.push({\r\n            type: \"bounds\",\r\n            pos: innerPos,\r\n        });\r\n    });\r\n    return {\r\n        boundMap: boundMap,\r\n        innerBoundMap: innerBoundMap,\r\n    };\r\n}\r\nvar directionCondition$1 = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]);\r\n/**\r\n * @namespace Moveable.Snappable\r\n * @description Whether or not target can be snapped to the guideline. (default: false)\r\n * @sort 2\r\n */\r\nvar Snappable = {\r\n    name: \"snappable\",\r\n    dragRelation: \"strong\",\r\n    props: [\r\n        \"snappable\",\r\n        \"snapContainer\",\r\n        \"snapDirections\",\r\n        \"elementSnapDirections\",\r\n        \"snapGap\",\r\n        \"snapGridWidth\",\r\n        \"snapGridHeight\",\r\n        \"isDisplaySnapDigit\",\r\n        \"isDisplayInnerSnapDigit\",\r\n        \"isDisplayGridGuidelines\",\r\n        \"snapDigit\",\r\n        \"snapThreshold\",\r\n        \"snapRenderThreshold\",\r\n        \"snapGridAll\",\r\n        NAME_snapRotationThreshold,\r\n        NAME_snapRotationDegrees,\r\n        NAME_snapHorizontalThreshold,\r\n        NAME_snapVerticalThreshold,\r\n        \"horizontalGuidelines\",\r\n        \"verticalGuidelines\",\r\n        \"elementGuidelines\",\r\n        \"bounds\",\r\n        \"innerBounds\",\r\n        \"snapDistFormat\",\r\n        \"maxSnapElementGuidelineDistance\",\r\n        \"maxSnapElementGapDistance\",\r\n    ],\r\n    events: [\"snap\", \"bound\"],\r\n    css: [\r\n        \":host {\\n--bounds-color: #d66;\\n}\\n.guideline {\\npointer-events: none;\\nz-index: 2;\\n}\\n.guideline.bounds {\\nbackground: #d66;\\nbackground: var(--bounds-color);\\n}\\n.guideline-group {\\nposition: absolute;\\ntop: 0;\\nleft: 0;\\n}\\n.guideline-group .size-value {\\nposition: absolute;\\ncolor: #f55;\\nfont-size: 12px;\\nfont-size: calc(12px * var(--zoom));\\nfont-weight: bold;\\n}\\n.guideline-group.horizontal .size-value {\\ntransform-origin: 50% 100%;\\ntransform: translateX(-50%);\\nleft: 50%;\\nbottom: 5px;\\nbottom: calc(2px + 3px * var(--zoom));\\n}\\n.guideline-group.vertical .size-value {\\ntransform-origin: 0% 50%;\\ntop: 50%;\\ntransform: translateY(-50%);\\nleft: 5px;\\nleft: calc(2px + 3px * var(--zoom));\\n}\\n.guideline.gap {\\nbackground: #f55;\\n}\\n.size-value.gap {\\ncolor: #f55;\\n}\\n\",\r\n    ],\r\n    render: function (moveable, React) {\r\n        var state = moveable.state;\r\n        var targetTop = state.top, targetLeft = state.left, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, snapRenderInfo = state.snapRenderInfo;\r\n        var _a = moveable.props.snapRenderThreshold, snapRenderThreshold = _a === void 0 ? 1 : _a;\r\n        if (!snapRenderInfo || !snapRenderInfo.render || !hasGuidelines(moveable, \"\")) {\r\n            // reset store\r\n            watchValue(moveable, \"boundMap\", getInitialBounds(), function (v) { return JSON.stringify(v); });\r\n            watchValue(moveable, \"innerBoundMap\", getInitialBounds(), function (v) { return JSON.stringify(v); });\r\n            return [];\r\n        }\r\n        state.guidelines = getTotalGuidelines(moveable);\r\n        var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\r\n        var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\r\n        var externalPoses = snapRenderInfo.externalPoses || [];\r\n        var poses = getAbsolutePosesByState(moveable.state);\r\n        var verticalSnapPoses = [];\r\n        var horizontalSnapPoses = [];\r\n        var verticalGuidelines = [];\r\n        var horizontalGuidelines = [];\r\n        var snapInfos = [];\r\n        var _b = getRect(poses), width = _b.width, height = _b.height, top = _b.top, left = _b.left, bottom = _b.bottom, right = _b.right;\r\n        var targetRect = { left: left, right: right, top: top, bottom: bottom, center: (left + right) / 2, middle: (top + bottom) / 2 };\r\n        var hasExternalPoses = externalPoses.length > 0;\r\n        var externalRect = hasExternalPoses\r\n            ? getRect(externalPoses)\r\n            : {};\r\n        if (!snapRenderInfo.request) {\r\n            if (snapRenderInfo.direction) {\r\n                snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction, snapRenderThreshold, snapRenderThreshold));\r\n            }\r\n            if (snapRenderInfo.snap) {\r\n                var rect = getRect(poses);\r\n                if (snapRenderInfo.center) {\r\n                    rect.middle = (rect.top + rect.bottom) / 2;\r\n                    rect.center = (rect.left + rect.right) / 2;\r\n                }\r\n                snapInfos.push(checkSnaps(moveable, rect, snapRenderThreshold, snapRenderThreshold));\r\n            }\r\n            if (hasExternalPoses) {\r\n                if (snapRenderInfo.center) {\r\n                    externalRect.middle =\r\n                        (externalRect.top + externalRect.bottom) / 2;\r\n                    externalRect.center =\r\n                        (externalRect.left + externalRect.right) / 2;\r\n                }\r\n                snapInfos.push(checkSnaps(moveable, externalRect, snapRenderThreshold, snapRenderThreshold));\r\n            }\r\n            snapInfos.forEach(function (snapInfo) {\r\n                var verticalPosInfos = snapInfo.vertical.posInfos, horizontalPosInfos = snapInfo.horizontal.posInfos;\r\n                verticalSnapPoses.push.apply(verticalSnapPoses, __spreadArray([], __read(verticalPosInfos.filter(function (_a) {\r\n                    var guidelineInfos = _a.guidelineInfos;\r\n                    return guidelineInfos.some(function (_a) {\r\n                        var guideline = _a.guideline;\r\n                        return !guideline.hide;\r\n                    });\r\n                }).map(function (posInfo) { return ({\r\n                    type: \"snap\",\r\n                    pos: posInfo.pos,\r\n                }); })), false));\r\n                horizontalSnapPoses.push.apply(horizontalSnapPoses, __spreadArray([], __read(horizontalPosInfos.filter(function (_a) {\r\n                    var guidelineInfos = _a.guidelineInfos;\r\n                    return guidelineInfos.some(function (_a) {\r\n                        var guideline = _a.guideline;\r\n                        return !guideline.hide;\r\n                    });\r\n                }).map(function (posInfo) { return ({\r\n                    type: \"snap\",\r\n                    pos: posInfo.pos,\r\n                }); })), false));\r\n                verticalGuidelines.push.apply(verticalGuidelines, __spreadArray([], __read(getSnapGuidelines(verticalPosInfos)), false));\r\n                horizontalGuidelines.push.apply(horizontalGuidelines, __spreadArray([], __read(getSnapGuidelines(horizontalPosInfos)), false));\r\n            });\r\n        }\r\n        var _c = addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses), boundMap = _c.boundMap, innerBoundMap = _c.innerBoundMap;\r\n        if (hasExternalPoses) {\r\n            addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);\r\n        }\r\n        var allGuidelines = __spreadArray(__spreadArray([], __read(verticalGuidelines), false), __read(horizontalGuidelines), false);\r\n        var elementGuidelines = allGuidelines.filter(function (guideline) { return guideline.element && !guideline.gapRects; });\r\n        var gapGuidelines = allGuidelines.filter(function (guideline) { return guideline.gapRects; }).sort(function (a, b) {\r\n            return a.gap - b.gap;\r\n        });\r\n        triggerEvent(moveable, \"onSnap\", {\r\n            guidelines: allGuidelines.filter(function (_a) {\r\n                var element = _a.element;\r\n                return !element;\r\n            }),\r\n            elements: elementGuidelines,\r\n            gaps: gapGuidelines,\r\n        }, true);\r\n        var nextBoundMap = watchValue(moveable, \"boundMap\", boundMap, function (v) { return JSON.stringify(v); }, getInitialBounds());\r\n        var nextInnerBoundMap = watchValue(moveable, \"innerBoundMap\", innerBoundMap, function (v) { return JSON.stringify(v); }, getInitialBounds());\r\n        if (boundMap === nextBoundMap || innerBoundMap === nextInnerBoundMap) {\r\n            triggerEvent(moveable, \"onBound\", {\r\n                bounds: boundMap,\r\n                innerBounds: innerBoundMap,\r\n            }, true);\r\n        }\r\n        // verticalSnapPoses.\r\n        return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React)), false), __read(renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React)), false), __read(renderGuidelines(moveable, \"horizontal\", horizontalGuidelines, [targetLeft, targetTop], targetRect, React)), false), __read(renderGuidelines(moveable, \"vertical\", verticalGuidelines, [targetLeft, targetTop], targetRect, React)), false), __read(renderSnapPoses(moveable, \"horizontal\", horizontalSnapPoses, minLeft, targetTop, width, 0, React)), false), __read(renderSnapPoses(moveable, \"vertical\", verticalSnapPoses, minTop, targetLeft, height, 1, React)), false);\r\n    },\r\n    dragStart: function (moveable, e) {\r\n        moveable.state.snapRenderInfo = {\r\n            request: e.isRequest,\r\n            snap: true,\r\n            center: true,\r\n        };\r\n        checkSnapInfo(moveable);\r\n    },\r\n    drag: function (moveable) {\r\n        var state = moveable.state;\r\n        if (!checkSnapInfo(moveable)) {\r\n            state.guidelines = getTotalGuidelines(moveable);\r\n        }\r\n        if (state.snapRenderInfo) {\r\n            state.snapRenderInfo.render = true;\r\n        }\r\n    },\r\n    pinchStart: function (moveable) {\r\n        this.unset(moveable);\r\n    },\r\n    dragEnd: function (moveable) {\r\n        this.unset(moveable);\r\n    },\r\n    dragControlCondition: function (moveable, e) {\r\n        if (directionCondition$1(moveable, e) || dragControlCondition(moveable, e)) {\r\n            return true;\r\n        }\r\n        if (!e.isRequest && e.inputEvent) {\r\n            return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(e.inputEvent.target, prefix(\"snap-control\"));\r\n        }\r\n    },\r\n    dragControlStart: function (moveable) {\r\n        moveable.state.snapRenderInfo = null;\r\n        checkSnapInfo(moveable);\r\n    },\r\n    dragControl: function (moveable) {\r\n        this.drag(moveable);\r\n    },\r\n    dragControlEnd: function (moveable) {\r\n        this.unset(moveable);\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        this.dragStart(moveable, e);\r\n    },\r\n    dragGroup: function (moveable) {\r\n        this.drag(moveable);\r\n    },\r\n    dragGroupEnd: function (moveable) {\r\n        this.unset(moveable);\r\n    },\r\n    dragGroupControlStart: function (moveable) {\r\n        moveable.state.snapRenderInfo = null;\r\n        checkSnapInfo(moveable);\r\n    },\r\n    dragGroupControl: function (moveable) {\r\n        this.drag(moveable);\r\n    },\r\n    dragGroupControlEnd: function (moveable) {\r\n        this.unset(moveable);\r\n    },\r\n    unset: function (moveable) {\r\n        var state = moveable.state;\r\n        state.enableSnap = false;\r\n        state.guidelines = [];\r\n        state.snapRenderInfo = null;\r\n        state.elementRects = [];\r\n    },\r\n};\r\n/**\r\n * Whether or not target can be snapped to the guideline. (default: false)\r\n * @name Moveable.Snappable#snappable\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snappable = true;\r\n */\r\n/**\r\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\r\n * @name Moveable.Snappable#snapContainer\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.querySelector(\".container\"));\r\n *\r\n * moveable.snapContainer = document.body;\r\n */\r\n/**\r\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\r\n * @name Moveable.Snappable#snapDirections\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   snappable: true,\r\n *   snapDirections: true,\r\n * });\r\n * // snap center\r\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\r\n */\r\n/**\r\n * You can specify the snap directions of elements. (default: { left: true, ftrue, right: true, bottom: true })\r\n * @name Moveable.Snappable#elementSnapDirections\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   snappable: true,\r\n *   elementSnapDirections: true,\r\n * });\r\n * // snap center\r\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\r\n */\r\n/**\r\n * When you drag, make the gap snap in the element guidelines. (default: true)\r\n * @name Moveable.Snappable#snapGap\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   snappable: true,\r\n *   snapElement: true,\r\n *   snapGap: true,\r\n * });\r\n *\r\n * moveable.snapGap = false;\r\n */\r\n/**\r\n * Distance value that can snap to guidelines. (default: 5)\r\n * @name Moveable.Snappable#snapThreshold\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapThreshold = 5;\r\n */\r\n/**\r\n * Add guidelines in the horizontal direction. (default: [])\r\n * @name Moveable.Snappable#horizontalGuidelines\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.horizontalGuidelines = [100, 200, 500];\r\n */\r\n/**\r\n * Add guidelines in the vertical direction. (default: [])\r\n * @name Moveable.Snappable#verticalGuidelines\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.verticalGuidelines = [100, 200, 500];\r\n */\r\n/**\r\n * Add guidelines for the element. (default: [])\r\n * @name Moveable.Snappable#elementGuidelines\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.elementGuidelines = [\r\n *   document.querySelector(\".element\"),\r\n * ];\r\n */\r\n/**\r\n * You can set up boundaries.\r\n * @name Moveable.Snappable#bounds\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @default null\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\r\n */\r\n/**\r\n * You can set up inner boundaries.\r\n * @name Moveable.Snappable#innerBounds\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @default null\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\r\n */\r\n/**\r\n * snap distance digits (default: 0)\r\n * @name Moveable.Snappable#snapDigit\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapDigit = 0\r\n */\r\n/**\r\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\r\n * @name Moveable.Snappable#snapGridWidth\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapGridWidth = 5;\r\n */\r\n/**\r\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\r\n * @name Moveable.Snappable#snapGridHeight\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.snapGridHeight = 5;\r\n */\r\n/**\r\n * Whether to show snap distance (default: true)\r\n * @name Moveable.Snappable#isDisplaySnapDigit\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.isDisplaySnapDigit = true;\r\n */\r\n/**\r\n * Whether to show element inner snap distance (default: false)\r\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.isDisplayInnerSnapDigit = true;\r\n */\r\n/**\r\n * You can set the text format of the distance shown in the guidelines. (default: self)\r\n * @name Moveable.Snappable#snapDistFormat\r\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  snappable: true,\r\n *  snapDistFormat: (v, type) => v,\r\n * });\r\n * moveable.snapDistFormat = (v, type) => `${v}px`;\r\n */\r\n/**\r\n * When you drag or dragControl, the `snap` event is called.\r\n * @memberof Moveable.Snappable\r\n * @event snap\r\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     snappable: true\r\n * });\r\n * moveable.on(\"snap\", e => {\r\n *     console.log(\"onSnap\", e);\r\n * });\r\n */\n\nfunction multiply2(pos1, pos2) {\r\n    return [\r\n        pos1[0] * pos2[0],\r\n        pos1[1] * pos2[1],\r\n    ];\r\n}\r\nfunction prefix() {\r\n    var classNames = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        classNames[_i] = arguments[_i];\r\n    }\r\n    return framework_utils__WEBPACK_IMPORTED_MODULE_6__.prefixNames.apply(void 0, __spreadArray([PREFIX], __read(classNames), false));\r\n}\r\nfunction defaultSync(fn) {\r\n    fn();\r\n}\r\nfunction getTransformMatrix(transform) {\r\n    if (!transform || transform === \"none\") {\r\n        return [1, 0, 0, 1, 0, 0];\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(transform)) {\r\n        return transform;\r\n    }\r\n    return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parseMat)(transform);\r\n}\r\nfunction getAbsoluteMatrix(matrix, n, origin) {\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(origin, n), matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(origin.map(function (a) { return -a; }), n));\r\n}\r\nfunction measureSVGSize(el, unit, isHorizontal) {\r\n    if (unit === \"%\") {\r\n        var viewBox = getSVGViewBox(el.ownerSVGElement);\r\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\r\n    }\r\n    return 1;\r\n}\r\nfunction getBeforeTransformOrigin(el) {\r\n    var relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\r\n    return relativeOrigin.map(function (o, i) {\r\n        var _a = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitUnit)(o), value = _a.value, unit = _a.unit;\r\n        return value * measureSVGSize(el, unit, i === 0);\r\n    });\r\n}\r\nfunction getTransformOriginArray(transformOrigin) {\r\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\r\n}\r\nfunction getTransformOrigin(style) {\r\n    return getTransformOriginArray(style.transformOrigin);\r\n}\r\nfunction getElementTransform(target) {\r\n    var getStyle = getCachedStyle(target);\r\n    var computedTransform = getStyle(\"transform\");\r\n    if (computedTransform && computedTransform !== \"none\") {\r\n        return computedTransform;\r\n    }\r\n    if (\"transform\" in target) {\r\n        var list = target.transform;\r\n        var baseVal = list.baseVal;\r\n        if (!baseVal) {\r\n            return \"\";\r\n        }\r\n        var length_1 = baseVal.length;\r\n        if (!length_1) {\r\n            return \"\";\r\n        }\r\n        var matrixes = [];\r\n        var _loop_1 = function (i) {\r\n            var matrix = baseVal[i].matrix;\r\n            matrixes.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function (chr) { return matrix[chr]; }).join(\", \"), \")\"));\r\n        };\r\n        for (var i = 0; i < length_1; ++i) {\r\n            _loop_1(i);\r\n        }\r\n        return matrixes.join(\" \");\r\n    }\r\n    return \"\";\r\n}\r\nfunction getOffsetInfo(el, lastParent, isParent, checkZoom, getTargetStyle) {\r\n    var _a, _b;\r\n    var documentElement = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentElement)(el) || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el);\r\n    var hasSlot = false;\r\n    var target;\r\n    var parentSlotElement;\r\n    if (!el || isParent) {\r\n        target = el;\r\n    }\r\n    else {\r\n        var assignedSlotParentElement = (_a = el === null || el === void 0 ? void 0 : el.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentElement;\r\n        var parentElement = el.parentElement;\r\n        if (assignedSlotParentElement) {\r\n            hasSlot = true;\r\n            parentSlotElement = parentElement;\r\n            target = assignedSlotParentElement;\r\n        }\r\n        else {\r\n            target = parentElement;\r\n        }\r\n    }\r\n    var isCustomElement = false;\r\n    var isEnd = el === lastParent || target === lastParent;\r\n    var position = \"relative\";\r\n    var offsetZoom = 1;\r\n    var targetZoom = parseFloat(getTargetStyle === null || getTargetStyle === void 0 ? void 0 : getTargetStyle(\"zoom\")) || 1;\r\n    var targetPosition = getTargetStyle === null || getTargetStyle === void 0 ? void 0 : getTargetStyle(\"position\");\r\n    while (target && target !== documentElement) {\r\n        if (lastParent === target) {\r\n            isEnd = true;\r\n        }\r\n        var getStyle = getCachedStyle(target);\r\n        var tagName = target.tagName.toLowerCase();\r\n        var transform = getElementTransform(target);\r\n        var willChange = getStyle(\"willChange\");\r\n        var zoom = parseFloat(getStyle(\"zoom\")) || 1;\r\n        position = getStyle(\"position\");\r\n        if (checkZoom && zoom !== 1) {\r\n            offsetZoom = zoom;\r\n            break;\r\n        }\r\n        if (\r\n        // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\r\n        !isParent && checkZoom && targetZoom !== 1 && targetPosition && targetPosition !== \"absolute\"\r\n            || tagName === \"svg\"\r\n            || tagName === \"foreignobject\"\r\n            || position !== \"static\"\r\n            || (transform && transform !== \"none\")\r\n            || willChange === \"transform\") {\r\n            break;\r\n        }\r\n        var slotParentNode = (_b = el === null || el === void 0 ? void 0 : el.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;\r\n        var targetParentNode = target.parentNode;\r\n        if (slotParentNode) {\r\n            hasSlot = true;\r\n            parentSlotElement = targetParentNode;\r\n        }\r\n        var parentNode = targetParentNode;\r\n        if (parentNode && parentNode.nodeType === 11) {\r\n            // Shadow Root\r\n            target = parentNode.host;\r\n            isCustomElement = true;\r\n            position = getCachedStyle(target)(\"position\");\r\n            break;\r\n        }\r\n        target = parentNode;\r\n        position = \"relative\";\r\n    }\r\n    return {\r\n        offsetZoom: offsetZoom,\r\n        hasSlot: hasSlot,\r\n        parentSlotElement: parentSlotElement,\r\n        isCustomElement: isCustomElement,\r\n        isStatic: position === \"static\",\r\n        isEnd: isEnd || !target || target === documentElement,\r\n        offsetParent: target || documentElement,\r\n    };\r\n}\r\nfunction getOffsetPosInfo(el, target) {\r\n    var _a;\r\n    var tagName = el.tagName.toLowerCase();\r\n    var offsetLeft = el.offsetLeft;\r\n    var offsetTop = el.offsetTop;\r\n    var getStyle = getCachedStyle(el);\r\n    // svg\r\n    var isSVG = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(offsetLeft);\r\n    var hasOffset = !isSVG;\r\n    var origin;\r\n    var targetOrigin;\r\n    // inner svg element\r\n    if (!hasOffset && (tagName !== \"svg\" || el.ownerSVGElement)) {\r\n        origin = IS_WEBKIT605\r\n            ? getBeforeTransformOrigin(el)\r\n            : getTransformOriginArray(getStyle(\"transformOrigin\")).map(function (pos) { return parseFloat(pos); });\r\n        targetOrigin = origin.slice();\r\n        hasOffset = true;\r\n        if (tagName === \"svg\") {\r\n            offsetLeft = 0;\r\n            offsetTop = 0;\r\n        }\r\n        else {\r\n            _a = __read(getSVGGraphicsOffset(el, origin, el === target && target.tagName.toLowerCase() === \"g\"), 4), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];\r\n        }\r\n    }\r\n    else {\r\n        origin = getTransformOriginArray(getStyle(\"transformOrigin\")).map(function (pos) { return parseFloat(pos); });\r\n        targetOrigin = origin.slice();\r\n        // console.log(getStyle(\"transformOrigin\"), targetOrigin);\r\n    }\r\n    return {\r\n        tagName: tagName,\r\n        isSVG: isSVG,\r\n        hasOffset: hasOffset,\r\n        offset: [offsetLeft || 0, offsetTop || 0],\r\n        origin: origin,\r\n        targetOrigin: targetOrigin,\r\n    };\r\n}\r\nfunction getBodyOffset(el, isSVG) {\r\n    var getStyle = getCachedStyle(el);\r\n    var getBodyStyle = getCachedStyle((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el));\r\n    var bodyPosition = getBodyStyle(\"position\");\r\n    if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\r\n        return [0, 0];\r\n    }\r\n    var marginLeft = parseInt(getBodyStyle(\"marginLeft\"), 10);\r\n    var marginTop = parseInt(getBodyStyle(\"marginTop\"), 10);\r\n    if (getStyle(\"position\") === \"absolute\") {\r\n        if (getStyle(\"top\") !== \"auto\" || getStyle(\"bottom\") !== \"auto\") {\r\n            marginTop = 0;\r\n        }\r\n        if (getStyle(\"left\") !== \"auto\" || getStyle(\"right\") !== \"auto\") {\r\n            marginLeft = 0;\r\n        }\r\n    }\r\n    return [marginLeft, marginTop];\r\n}\r\nfunction convert3DMatrixes(matrixes) {\r\n    matrixes.forEach(function (info) {\r\n        var matrix = info.matrix;\r\n        if (matrix) {\r\n            info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(matrix, 3, 4);\r\n        }\r\n    });\r\n}\r\nfunction getPositionFixedInfo(el) {\r\n    var fixedContainer = el.parentElement;\r\n    var hasTransform = false;\r\n    var body = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el);\r\n    while (fixedContainer) {\r\n        var transform = getComputedStyle(fixedContainer).transform;\r\n        if (transform && transform !== \"none\") {\r\n            hasTransform = true;\r\n            break;\r\n        }\r\n        if (fixedContainer === body) {\r\n            break;\r\n        }\r\n        fixedContainer = fixedContainer.parentElement;\r\n    }\r\n    return {\r\n        fixedContainer: fixedContainer || body,\r\n        hasTransform: hasTransform,\r\n    };\r\n}\r\nfunction makeMatrixCSS(matrix, is3d) {\r\n    if (is3d === void 0) { is3d = matrix.length > 9; }\r\n    return \"\".concat(is3d ? \"matrix3d\" : \"matrix\", \"(\").concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertMatrixtoCSS)(matrix, !is3d).join(\",\"), \")\");\r\n}\r\nfunction getSVGViewBox(el) {\r\n    var clientWidth = el.clientWidth;\r\n    var clientHeight = el.clientHeight;\r\n    if (!el) {\r\n        return { x: 0, y: 0, width: 0, height: 0, clientWidth: clientWidth, clientHeight: clientHeight };\r\n    }\r\n    var viewBox = el.viewBox;\r\n    var baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\r\n    return {\r\n        x: baseVal.x,\r\n        y: baseVal.y,\r\n        width: baseVal.width || clientWidth,\r\n        height: baseVal.height || clientHeight,\r\n        clientWidth: clientWidth,\r\n        clientHeight: clientHeight,\r\n    };\r\n}\r\nfunction getSVGMatrix(el, n) {\r\n    var _a;\r\n    var _b = getSVGViewBox(el), viewBoxWidth = _b.width, viewBoxHeight = _b.height, clientWidth = _b.clientWidth, clientHeight = _b.clientHeight;\r\n    var scaleX = clientWidth / viewBoxWidth;\r\n    var scaleY = clientHeight / viewBoxHeight;\r\n    var preserveAspectRatio = el.preserveAspectRatio.baseVal;\r\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\r\n    var align = preserveAspectRatio.align;\r\n    // 1 : meet 2: slice\r\n    var meetOrSlice = preserveAspectRatio.meetOrSlice;\r\n    var svgOrigin = [0, 0];\r\n    var scale = [scaleX, scaleY];\r\n    var translate = [0, 0];\r\n    if (align !== 1) {\r\n        var xAlign = (align - 2) % 3;\r\n        var yAlign = Math.floor((align - 2) / 3);\r\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\r\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\r\n        var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\r\n        scale[0] = scaleDimension;\r\n        scale[1] = scaleDimension;\r\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\r\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\r\n    }\r\n    var scaleMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createScaleMatrix)(scale, n);\r\n    _a = __read(translate, 2), scaleMatrix[n * (n - 1)] = _a[0], scaleMatrix[n * (n - 1) + 1] = _a[1];\r\n    return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\r\n}\r\nfunction getSVGGraphicsOffset(el, origin, isGTarget) {\r\n    var tagName = el.tagName.toLowerCase();\r\n    if (!el.getBBox || !isGTarget && tagName === \"g\") {\r\n        return [0, 0, 0, 0];\r\n    }\r\n    var getStyle = getCachedStyle(el);\r\n    var isFillBox = getStyle(\"transform-box\") === \"fill-box\";\r\n    var bbox = el.getBBox();\r\n    var viewBox = getSVGViewBox(el.ownerSVGElement);\r\n    var x = bbox.x;\r\n    var y = bbox.y;\r\n    // x, y가 0으로 나타나는 버그\r\n    if (tagName === \"foreignobject\" && (!x && !y)) {\r\n        x = parseFloat(el.getAttribute(\"x\")) || 0;\r\n        y = parseFloat(el.getAttribute(\"y\")) || 0;\r\n    }\r\n    var left = x - viewBox.x;\r\n    var top = y - viewBox.y;\r\n    var originX = isFillBox ? origin[0] : origin[0] - left;\r\n    var originY = isFillBox ? origin[1] : origin[1] - top;\r\n    // if (isFillBox) {\r\n    //     const bbox = (el as SVGGraphicsElement).getBBox();\r\n    //     const x = parseFloat(getStyle(\"x\")) || bbox.x;\r\n    //     const y = parseFloat(getStyle(\"y\")) || bbox.y;\r\n    //     const xScale = bbox.x / x;\r\n    //     const yScale = bbox.y / y;\r\n    //     console.log(x, y);\r\n    //     originX *= xScale;\r\n    //     originY *= yScale;\r\n    // }\r\n    return [left, top, originX, originY];\r\n}\r\nfunction calculatePosition(matrix, pos, n) {\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(matrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)(pos, n), n);\r\n}\r\nfunction calculatePoses(matrix, width, height, n) {\r\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) { return calculatePosition(matrix, pos, n); });\r\n}\r\nfunction getRect(poses) {\r\n    var posesX = poses.map(function (pos) { return pos[0]; });\r\n    var posesY = poses.map(function (pos) { return pos[1]; });\r\n    var left = Math.min.apply(Math, __spreadArray([], __read(posesX), false));\r\n    var top = Math.min.apply(Math, __spreadArray([], __read(posesY), false));\r\n    var right = Math.max.apply(Math, __spreadArray([], __read(posesX), false));\r\n    var bottom = Math.max.apply(Math, __spreadArray([], __read(posesY), false));\r\n    var rectWidth = right - left;\r\n    var rectHeight = bottom - top;\r\n    return {\r\n        left: left,\r\n        top: top,\r\n        right: right,\r\n        bottom: bottom,\r\n        width: rectWidth,\r\n        height: rectHeight,\r\n    };\r\n}\r\nfunction calculateRect(matrix, width, height, n) {\r\n    var poses = calculatePoses(matrix, width, height, n);\r\n    return getRect(poses);\r\n}\r\nfunction getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {\r\n    var _a;\r\n    var target = offsetInfo.target;\r\n    var origin = offsetInfo.origin;\r\n    var targetMatrix = targetInfo.matrix;\r\n    var _b = getSize(target), width = _b.offsetWidth, height = _b.offsetHeight;\r\n    var containerClientRect = container.getBoundingClientRect();\r\n    var margin = [0, 0];\r\n    if (container === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(container)) {\r\n        margin = getBodyOffset(target, true);\r\n    }\r\n    var rect = target.getBoundingClientRect();\r\n    var rectLeft = rect.left - containerClientRect.left + container.scrollLeft\r\n        - (container.clientLeft || 0) + margin[0];\r\n    var rectTop = rect.top - containerClientRect.top + container.scrollTop\r\n        - (container.clientTop || 0) + margin[1];\r\n    var rectWidth = rect.width;\r\n    var rectHeight = rect.height;\r\n    var mat = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, beforeMatrix, targetMatrix);\r\n    var _c = calculateRect(mat, width, height, n), prevLeft = _c.left, prevTop = _c.top, prevWidth = _c.width, prevHeight = _c.height;\r\n    var posOrigin = calculatePosition(mat, origin, n);\r\n    var prevOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(posOrigin, [prevLeft, prevTop]);\r\n    var rectOrigin = [\r\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\r\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\r\n    ];\r\n    var offset = [0, 0];\r\n    var count = 0;\r\n    while (++count < 10) {\r\n        var inverseBeforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(beforeMatrix, n);\r\n        _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), 2), offset[0] = _a[0], offset[1] = _a[1];\r\n        var mat2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, beforeMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(offset, n), targetMatrix);\r\n        var _d = calculateRect(mat2, width, height, n), nextLeft = _d.left, nextTop = _d.top;\r\n        var distLeft = nextLeft - rectLeft;\r\n        var distTop = nextTop - rectTop;\r\n        if (abs(distLeft) < 2 && abs(distTop) < 2) {\r\n            break;\r\n        }\r\n        rectOrigin[0] -= distLeft;\r\n        rectOrigin[1] -= distTop;\r\n    }\r\n    return offset.map(function (p) { return Math.round(p); });\r\n}\r\nfunction calculateMoveableClientPositions(rootMatrix, poses, rootClientRect) {\r\n    var is3d = rootMatrix.length === 16;\r\n    var n = is3d ? 4 : 3;\r\n    var rootPoses = poses.map(function (pos) { return calculatePosition(rootMatrix, pos, n); });\r\n    var left = rootClientRect.left, top = rootClientRect.top;\r\n    return rootPoses.map(function (pos) {\r\n        return [pos[0] + left, pos[1] + top];\r\n    });\r\n}\r\nfunction getDistSize(vec) {\r\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\r\n}\r\nfunction getDiagonalSize(pos1, pos2) {\r\n    return getDistSize([\r\n        pos2[0] - pos1[0],\r\n        pos2[1] - pos1[1],\r\n    ]);\r\n}\r\nfunction getLineStyle(pos1, pos2, zoom, rad) {\r\n    if (zoom === void 0) { zoom = 1; }\r\n    if (rad === void 0) { rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2); }\r\n    var width = getDiagonalSize(pos1, pos2);\r\n    return {\r\n        transform: \"translateY(-50%) translate(\".concat(pos1[0], \"px, \").concat(pos1[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\"),\r\n        width: \"\".concat(width, \"px\"),\r\n    };\r\n}\r\nfunction getControlTransform(rotation, zoom) {\r\n    var poses = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        poses[_i - 2] = arguments[_i];\r\n    }\r\n    var length = poses.length;\r\n    var x = poses.reduce(function (prev, pos) { return prev + pos[0]; }, 0) / length;\r\n    var y = poses.reduce(function (prev, pos) { return prev + pos[1]; }, 0) / length;\r\n    return {\r\n        transform: \"translateZ(0px) translate(\".concat(x, \"px, \").concat(y, \"px) rotate(\").concat(rotation, \"rad) scale(\").concat(zoom, \")\"),\r\n    };\r\n}\r\nfunction getProps(props, ableName) {\r\n    var self = props[ableName];\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(self)) {\r\n        return __assign(__assign({}, props), self);\r\n    }\r\n    return props;\r\n}\r\nfunction getSize(target) {\r\n    var hasOffset = target && !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(target.offsetWidth);\r\n    var offsetWidth = 0;\r\n    var offsetHeight = 0;\r\n    var clientWidth = 0;\r\n    var clientHeight = 0;\r\n    var cssWidth = 0;\r\n    var cssHeight = 0;\r\n    var contentWidth = 0;\r\n    var contentHeight = 0;\r\n    var minWidth = 0;\r\n    var minHeight = 0;\r\n    var minOffsetWidth = 0;\r\n    var minOffsetHeight = 0;\r\n    var maxWidth = Infinity;\r\n    var maxHeight = Infinity;\r\n    var maxOffsetWidth = Infinity;\r\n    var maxOffsetHeight = Infinity;\r\n    var inlineCSSWidth = 0;\r\n    var inlineCSSHeight = 0;\r\n    var svg = false;\r\n    if (target) {\r\n        if (!hasOffset && target.ownerSVGElement) {\r\n            // check svg elements\r\n            var bbox = target.getBBox();\r\n            svg = true;\r\n            offsetWidth = bbox.width;\r\n            offsetHeight = bbox.height;\r\n            cssWidth = offsetWidth;\r\n            cssHeight = offsetHeight;\r\n            contentWidth = offsetWidth;\r\n            contentHeight = offsetHeight;\r\n            clientWidth = offsetWidth;\r\n            clientHeight = offsetHeight;\r\n        }\r\n        else {\r\n            // check html elements\r\n            var getStyle = getCachedStyle(target);\r\n            var targetStyle = target.style;\r\n            var boxSizing = getStyle(\"boxSizing\") === \"border-box\";\r\n            var borderLeft = parseFloat(getStyle(\"borderLeftWidth\")) || 0;\r\n            var borderRight = parseFloat(getStyle(\"borderRightWidth\")) || 0;\r\n            var borderTop = parseFloat(getStyle(\"borderTopWidth\")) || 0;\r\n            var borderBottom = parseFloat(getStyle(\"borderBottomWidth\")) || 0;\r\n            var paddingLeft = parseFloat(getStyle(\"paddingLeft\")) || 0;\r\n            var paddingRight = parseFloat(getStyle(\"paddingRight\")) || 0;\r\n            var paddingTop = parseFloat(getStyle(\"paddingTop\")) || 0;\r\n            var paddingBottom = parseFloat(getStyle(\"paddingBottom\")) || 0;\r\n            var horizontalPadding = paddingLeft + paddingRight;\r\n            var verticalPadding = paddingTop + paddingBottom;\r\n            var horizontalBorder = borderLeft + borderRight;\r\n            var verticalBorder = borderTop + borderBottom;\r\n            var horizontalOffset = horizontalPadding + horizontalBorder;\r\n            var verticalOffset = verticalPadding + verticalBorder;\r\n            var position = getStyle(\"position\");\r\n            var containerWidth = 0;\r\n            var containerHeight = 0;\r\n            // SVGSVGElement, HTMLElement\r\n            if (\"clientLeft\" in target) {\r\n                var parentElement = null;\r\n                if (position === \"absolute\") {\r\n                    var offsetInfo = getOffsetInfo(target, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(target));\r\n                    parentElement = offsetInfo.offsetParent;\r\n                }\r\n                else {\r\n                    parentElement = target.parentElement;\r\n                }\r\n                if (parentElement) {\r\n                    var getParentStyle = getCachedStyle(parentElement);\r\n                    containerWidth = parseFloat(getParentStyle(\"width\"));\r\n                    containerHeight = parseFloat(getParentStyle(\"height\"));\r\n                }\r\n            }\r\n            minWidth = Math.max(horizontalPadding, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"minWidth\"), containerWidth) || 0);\r\n            minHeight = Math.max(verticalPadding, (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"minHeight\"), containerHeight) || 0);\r\n            maxWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"maxWidth\"), containerWidth);\r\n            maxHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(getStyle(\"maxHeight\"), containerHeight);\r\n            if (isNaN(maxWidth)) {\r\n                maxWidth = Infinity;\r\n            }\r\n            if (isNaN(maxHeight)) {\r\n                maxHeight = Infinity;\r\n            }\r\n            inlineCSSWidth = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(targetStyle.width, 0) || 0;\r\n            inlineCSSHeight = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(targetStyle.height, 0) || 0;\r\n            cssWidth = parseFloat(getStyle(\"width\")) || 0;\r\n            cssHeight = parseFloat(getStyle(\"height\")) || 0;\r\n            contentWidth = abs(cssWidth - inlineCSSWidth) < 1\r\n                ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.between)(minWidth, inlineCSSWidth || cssWidth, maxWidth)\r\n                : cssWidth;\r\n            contentHeight = abs(cssHeight - inlineCSSHeight) < 1\r\n                ? (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.between)(minHeight, inlineCSSHeight || cssHeight, maxHeight)\r\n                : cssHeight;\r\n            offsetWidth = contentWidth;\r\n            offsetHeight = contentHeight;\r\n            clientWidth = contentWidth;\r\n            clientHeight = contentHeight;\r\n            if (boxSizing) {\r\n                maxOffsetWidth = maxWidth;\r\n                maxOffsetHeight = maxHeight;\r\n                minOffsetWidth = minWidth;\r\n                minOffsetHeight = minHeight;\r\n                contentWidth = offsetWidth - horizontalOffset;\r\n                contentHeight = offsetHeight - verticalOffset;\r\n            }\r\n            else {\r\n                maxOffsetWidth = maxWidth + horizontalOffset;\r\n                maxOffsetHeight = maxHeight + verticalOffset;\r\n                minOffsetWidth = minWidth + horizontalOffset;\r\n                minOffsetHeight = minHeight + verticalOffset;\r\n                offsetWidth = contentWidth + horizontalOffset;\r\n                offsetHeight = contentHeight + verticalOffset;\r\n            }\r\n            clientWidth = contentWidth + horizontalPadding;\r\n            clientHeight = contentHeight + verticalPadding;\r\n        }\r\n    }\r\n    return {\r\n        svg: svg,\r\n        offsetWidth: offsetWidth,\r\n        offsetHeight: offsetHeight,\r\n        clientWidth: clientWidth,\r\n        clientHeight: clientHeight,\r\n        contentWidth: contentWidth,\r\n        contentHeight: contentHeight,\r\n        inlineCSSWidth: inlineCSSWidth,\r\n        inlineCSSHeight: inlineCSSHeight,\r\n        cssWidth: cssWidth,\r\n        cssHeight: cssHeight,\r\n        minWidth: minWidth,\r\n        minHeight: minHeight,\r\n        maxWidth: maxWidth,\r\n        maxHeight: maxHeight,\r\n        minOffsetWidth: minOffsetWidth,\r\n        minOffsetHeight: minOffsetHeight,\r\n        maxOffsetWidth: maxOffsetWidth,\r\n        maxOffsetHeight: maxOffsetHeight,\r\n    };\r\n}\r\nfunction getRotationRad(poses, direction) {\r\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\r\n}\r\nfunction resetClientRect() {\r\n    return {\r\n        left: 0, top: 0,\r\n        width: 0, height: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        clientLeft: 0, clientTop: 0,\r\n        clientWidth: 0, clientHeight: 0,\r\n        scrollWidth: 0, scrollHeight: 0,\r\n    };\r\n}\r\nfunction getExtendsRect(el, rect) {\r\n    var isRoot = el === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(el) || el === (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentElement)(el);\r\n    var extendsRect = {\r\n        clientLeft: el.clientLeft,\r\n        clientTop: el.clientTop,\r\n        clientWidth: el.clientWidth,\r\n        clientHeight: el.clientHeight,\r\n        scrollWidth: el.scrollWidth,\r\n        scrollHeight: el.scrollHeight,\r\n        overflow: false,\r\n    };\r\n    if (isRoot) {\r\n        extendsRect.clientHeight = Math.max(rect.height, extendsRect.clientHeight);\r\n        extendsRect.scrollHeight = Math.max(rect.height, extendsRect.scrollHeight);\r\n    }\r\n    extendsRect.overflow = getCachedStyle(el)(\"overflow\") !== \"visible\";\r\n    return __assign(__assign({}, rect), extendsRect);\r\n}\r\nfunction getClientRectByPosition(position, base, el, isExtends) {\r\n    var left = position.left, right = position.right, top = position.top, bottom = position.bottom;\r\n    var baseTop = base.top;\r\n    var baseLeft = base.left;\r\n    var rect = {\r\n        left: baseLeft + left,\r\n        top: baseTop + top,\r\n        right: baseLeft + right,\r\n        bottom: baseTop + bottom,\r\n        width: right - left,\r\n        height: bottom - top,\r\n    };\r\n    if (el && isExtends) {\r\n        return getExtendsRect(el, rect);\r\n    }\r\n    return rect;\r\n}\r\nfunction getClientRect(el, isExtends) {\r\n    var left = 0;\r\n    var top = 0;\r\n    var width = 0;\r\n    var height = 0;\r\n    // let isRoot = false;\r\n    if (el) {\r\n        var clientRect = el.getBoundingClientRect();\r\n        left = clientRect.left;\r\n        top = clientRect.top;\r\n        width = clientRect.width;\r\n        height = clientRect.height;\r\n    }\r\n    var rect = {\r\n        left: left,\r\n        top: top,\r\n        width: width,\r\n        height: height,\r\n        right: left + width,\r\n        bottom: top + height,\r\n    };\r\n    if (el && isExtends) {\r\n        return getExtendsRect(el, rect);\r\n    }\r\n    return rect;\r\n}\r\nfunction getTotalOrigin(moveable) {\r\n    var _a = moveable.props, groupable = _a.groupable, svgOrigin = _a.svgOrigin;\r\n    var _b = moveable.getState(), offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight, svg = _b.svg, transformOrigin = _b.transformOrigin;\r\n    if (!groupable && svg && svgOrigin) {\r\n        return convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight);\r\n    }\r\n    return transformOrigin;\r\n}\r\nfunction getTotalDirection(parentDirection, isPinch, inputEvent, datas) {\r\n    var direction;\r\n    if (parentDirection) {\r\n        direction = parentDirection;\r\n    }\r\n    else if (isPinch) {\r\n        direction = [0, 0];\r\n    }\r\n    else {\r\n        var target = inputEvent.target;\r\n        direction = getDirection(target, datas);\r\n    }\r\n    return direction;\r\n}\r\nfunction getDirection(target, datas) {\r\n    if (!target) {\r\n        return;\r\n    }\r\n    var deg = target.getAttribute(\"data-rotation\") || \"\";\r\n    var direciton = target.getAttribute(\"data-direction\");\r\n    datas.deg = deg;\r\n    if (!direciton) {\r\n        return;\r\n    }\r\n    var dir = [0, 0];\r\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\r\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\r\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\r\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\r\n    return dir;\r\n}\r\nfunction getAbsolutePoses(poses, dist) {\r\n    return [\r\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[0]),\r\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[1]),\r\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[2]),\r\n        (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(dist, poses[3]),\r\n    ];\r\n}\r\nfunction getAbsolutePosesByState(_a) {\r\n    var left = _a.left, top = _a.top, pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4;\r\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\r\n}\r\nfunction unsetAbles(self, isControl) {\r\n    self[isControl ? \"controlAbles\" : \"targetAbles\"].forEach(function (able) {\r\n        able.unset && able.unset(self);\r\n    });\r\n}\r\nfunction unsetGesto(self, isControl) {\r\n    var gestoName = isControl ? \"controlGesto\" : \"targetGesto\";\r\n    var gesto = self[gestoName];\r\n    if ((gesto === null || gesto === void 0 ? void 0 : gesto.isIdle()) === false) {\r\n        unsetAbles(self, isControl);\r\n    }\r\n    gesto === null || gesto === void 0 ? void 0 : gesto.unset();\r\n    self[gestoName] = null;\r\n}\r\nfunction fillCSSObject(style, resolvedEvent) {\r\n    if (resolvedEvent) {\r\n        var originalDatas = getBeforeRenderableDatas(resolvedEvent);\r\n        originalDatas.nextStyle = __assign(__assign({}, originalDatas.nextStyle), style);\r\n    }\r\n    return {\r\n        style: style,\r\n        cssText: (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(style).map(function (name) { return \"\".concat((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.decamelize)(name, \"-\"), \": \").concat(style[name], \";\"); }).join(\"\"),\r\n    };\r\n}\r\nfunction fillAfterTransform(prevEvent, nextEvent, resolvedEvent) {\r\n    var afterTransform = nextEvent.afterTransform || nextEvent.transform;\r\n    return __assign(__assign({}, fillCSSObject(__assign(__assign(__assign({}, prevEvent.style), nextEvent.style), { transform: afterTransform }), resolvedEvent)), { afterTransform: afterTransform, transform: prevEvent.transform });\r\n}\r\nfunction fillParams(moveable, e, params, isBeforeEvent) {\r\n    var datas = e.datas;\r\n    if (!datas.datas) {\r\n        datas.datas = {};\r\n    }\r\n    var nextParams = __assign(__assign({}, params), { target: moveable.state.target, clientX: e.clientX, clientY: e.clientY, inputEvent: e.inputEvent, currentTarget: moveable, moveable: moveable, datas: datas.datas, isRequest: e.isRequest, isRequestChild: e.isRequestChild, isFirstDrag: !!e.isFirstDrag, isTrusted: e.isTrusted !== false, stopAble: function () {\r\n            datas.isEventStart = false;\r\n        }, stopDrag: function () {\r\n            var _a;\r\n            (_a = e.stop) === null || _a === void 0 ? void 0 : _a.call(e);\r\n        } });\r\n    if (!datas.isStartEvent) {\r\n        datas.isStartEvent = true;\r\n    }\r\n    else if (!isBeforeEvent) {\r\n        datas.lastEvent = nextParams;\r\n    }\r\n    return nextParams;\r\n}\r\nfunction fillEndParams(moveable, e, params) {\r\n    var datas = e.datas;\r\n    var isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\r\n    if (!datas.datas) {\r\n        datas.datas = {};\r\n    }\r\n    return __assign(__assign({ isDrag: isDrag }, params), { moveable: moveable, target: moveable.state.target, clientX: e.clientX, clientY: e.clientY, inputEvent: e.inputEvent, currentTarget: moveable, lastEvent: datas.lastEvent, isDouble: e.isDouble, datas: datas.datas, isFirstDrag: !!e.isFirstDrag });\r\n}\r\nfunction catchEvent(moveable, name, callback) {\r\n    moveable._emitter.on(name, callback);\r\n}\r\nfunction triggerEvent(moveable, name, params, isManager, isRequest) {\r\n    return moveable.triggerEvent(name, params, isManager, isRequest);\r\n}\r\nfunction getComputedStyle(el, pseudoElt) {\r\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(el).getComputedStyle(el, pseudoElt);\r\n}\r\nfunction filterAbles(ables, methods, triggerAblesSimultaneously) {\r\n    var enabledAbles = {};\r\n    var ableGroups = {};\r\n    return ables.filter(function (able) {\r\n        var name = able.name;\r\n        if (enabledAbles[name] || !methods.some(function (method) { return able[method]; })) {\r\n            return false;\r\n        }\r\n        if (!triggerAblesSimultaneously && able.ableGroup) {\r\n            if (ableGroups[able.ableGroup]) {\r\n                return false;\r\n            }\r\n            ableGroups[able.ableGroup] = true;\r\n        }\r\n        enabledAbles[name] = true;\r\n        return true;\r\n    });\r\n}\r\nfunction equals(a1, a2) {\r\n    return a1 === a2 || (a1 == null && a2 == null);\r\n}\r\nfunction selectValue() {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    var length = values.length - 1;\r\n    for (var i = 0; i < length; ++i) {\r\n        var value = values[i];\r\n        if (!(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(value)) {\r\n            return value;\r\n        }\r\n    }\r\n    return values[length];\r\n}\r\nfunction groupBy(arr, func) {\r\n    var groups = [];\r\n    var groupKeys = [];\r\n    arr.forEach(function (el, index) {\r\n        var groupKey = func(el, index, arr);\r\n        var keyIndex = groupKeys.indexOf(groupKey);\r\n        var group = groups[keyIndex] || [];\r\n        if (keyIndex === -1) {\r\n            groupKeys.push(groupKey);\r\n            groups.push(group);\r\n        }\r\n        group.push(el);\r\n    });\r\n    return groups;\r\n}\r\nfunction groupByMap(arr, func) {\r\n    var groups = [];\r\n    var groupKeys = {};\r\n    arr.forEach(function (el, index) {\r\n        var groupKey = func(el, index, arr);\r\n        var group = groupKeys[groupKey];\r\n        if (!group) {\r\n            group = [];\r\n            groupKeys[groupKey] = group;\r\n            groups.push(group);\r\n        }\r\n        group.push(el);\r\n    });\r\n    return groups;\r\n}\r\nfunction flat(arr) {\r\n    return arr.reduce(function (prev, cur) {\r\n        return prev.concat(cur);\r\n    }, []);\r\n}\r\nfunction maxOffset() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    args.sort(function (a, b) { return abs(b) - abs(a); });\r\n    return args[0];\r\n}\r\nfunction calculateInversePosition(matrix, pos, n) {\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(matrix, n), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertPositionMatrix)(pos, n), n);\r\n}\r\nfunction convertDragDist(state, e) {\r\n    var _a;\r\n    var is3d = state.is3d, rootMatrix = state.rootMatrix;\r\n    var n = is3d ? 4 : 3;\r\n    _a = __read(calculateInversePosition(rootMatrix, [e.distX, e.distY], n), 2), e.distX = _a[0], e.distY = _a[1];\r\n    return e;\r\n}\r\nfunction calculatePadding(matrix, pos, added, n) {\r\n    if (!added[0] && !added[1]) {\r\n        return pos;\r\n    }\r\n    var xAdded = calculatePosition(matrix, [normalized(added[0] || 1), 0], n);\r\n    var yAdded = calculatePosition(matrix, [0, normalized(added[1] || 1)], n);\r\n    var nextAdded = calculatePosition(matrix, [\r\n        added[0] / getDistSize(xAdded),\r\n        added[1] / getDistSize(yAdded),\r\n    ], n);\r\n    return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, nextAdded);\r\n}\r\nfunction convertCSSSize(value, size, isRelative) {\r\n    return isRelative ? \"\".concat(value / size * 100, \"%\") : \"\".concat(value, \"px\");\r\n}\r\nfunction getTinyDist(v) {\r\n    return abs(v) <= TINY_NUM ? 0 : v;\r\n}\r\nfunction getDirectionViewClassName(ableName) {\r\n    return function (moveable) {\r\n        if (!moveable.isDragging(ableName)) {\r\n            return \"\";\r\n        }\r\n        var data = getGestoData(moveable, ableName);\r\n        var deg = data.deg;\r\n        if (!deg) {\r\n            return \"\";\r\n        }\r\n        return prefix(\"view-control-rotation\".concat(deg));\r\n    };\r\n}\r\nfunction getDirectionCondition(ableName, checkAbles) {\r\n    if (checkAbles === void 0) { checkAbles = [ableName]; }\r\n    return function (moveable, e) {\r\n        if (e.isRequest) {\r\n            if (checkAbles.some(function (name) { return e.requestAble === name; })) {\r\n                return e.parentDirection;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        var target = e.inputEvent.target;\r\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (!ableName || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(ableName)));\r\n    };\r\n}\r\nfunction convertTransformInfo(transforms, state, index) {\r\n    var _a;\r\n    var matrixInfos = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(transforms, {\r\n        \"x%\": function (v) { return v / 100 * state.offsetWidth; },\r\n        \"y%\": function (v) { return v / 100 * state.offsetHeight; },\r\n    });\r\n    var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\r\n    var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\r\n    var targetFunctionText = transforms[index] || \"\";\r\n    var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\r\n    var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\r\n    var beforeFunctions = matrixInfos.slice(0, index < 0 ? undefined : index);\r\n    var beforeFunctions2 = matrixInfos.slice(0, index < 0 ? undefined : index + 1);\r\n    var targetFunction = (_a = matrixInfos[index]) !== null && _a !== void 0 ? _a : (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)([\"\"])[0];\r\n    var afterFunctions = index < 0 ? [] : matrixInfos.slice(index);\r\n    var afterFunctions2 = index < 0 ? [] : matrixInfos.slice(index + 1);\r\n    var targetFunctions = targetFunction ? [targetFunction] : [];\r\n    var beforeFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions);\r\n    var beforeFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(beforeFunctions2);\r\n    var afterFunctionMatrix = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions);\r\n    var afterFunctionMatrix2 = (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(afterFunctions2);\r\n    var allFunctionMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(beforeFunctionMatrix, afterFunctionMatrix, 4);\r\n    return {\r\n        transforms: transforms,\r\n        beforeFunctionMatrix: beforeFunctionMatrix,\r\n        beforeFunctionMatrix2: beforeFunctionMatrix2,\r\n        targetFunctionMatrix: (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.toMat)(targetFunctions),\r\n        afterFunctionMatrix: afterFunctionMatrix,\r\n        afterFunctionMatrix2: afterFunctionMatrix2,\r\n        allFunctionMatrix: allFunctionMatrix,\r\n        beforeFunctions: beforeFunctions,\r\n        beforeFunctions2: beforeFunctions2,\r\n        targetFunction: targetFunctions[0],\r\n        afterFunctions: afterFunctions,\r\n        afterFunctions2: afterFunctions2,\r\n        beforeFunctionTexts: beforeFunctionTexts,\r\n        beforeFunctionTexts2: beforeFunctionTexts2,\r\n        targetFunctionText: targetFunctionText,\r\n        afterFunctionTexts: afterFunctionTexts,\r\n        afterFunctionTexts2: afterFunctionTexts2,\r\n    };\r\n}\r\nfunction isArrayFormat(arr) {\r\n    if (!arr || !(0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isObject)(arr)) {\r\n        return false;\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNode)(arr)) {\r\n        return false;\r\n    }\r\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(arr) || \"length\" in arr;\r\n}\r\nfunction getRefTarget(target, isSelector) {\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNode)(target)) {\r\n        return target;\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\r\n        if (isSelector) {\r\n            return document.querySelector(target);\r\n        }\r\n        return target;\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(target)) {\r\n        return target();\r\n    }\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isWindow)(target)) {\r\n        return target;\r\n    }\r\n    if (\"current\" in target) {\r\n        return target.current;\r\n    }\r\n    return target;\r\n}\r\nfunction getRefTargets(targets, isSelector) {\r\n    if (!targets) {\r\n        return [];\r\n    }\r\n    var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\r\n    return userTargets.reduce(function (prev, target) {\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target) && isSelector) {\r\n            return __spreadArray(__spreadArray([], __read(prev), false), __read([].slice.call(document.querySelectorAll(target))), false);\r\n        }\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\r\n            prev.push(getRefTargets(target, isSelector));\r\n        }\r\n        else {\r\n            prev.push(getRefTarget(target, isSelector));\r\n        }\r\n        return prev;\r\n    }, []);\r\n}\r\nfunction getAbsoluteRotation(pos1, pos2, direction) {\r\n    var deg = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2) / Math.PI * 180;\r\n    deg = direction >= 0 ? deg : 180 - deg;\r\n    deg = deg >= 0 ? deg : 360 + deg;\r\n    return deg;\r\n}\r\nfunction getDragDistByState(state, dist) {\r\n    var rootMatrix = state.rootMatrix, is3d = state.is3d;\r\n    var n = is3d ? 4 : 3;\r\n    var inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(rootMatrix, n);\r\n    if (!is3d) {\r\n        inverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(inverseMatrix, 3, 4);\r\n    }\r\n    inverseMatrix[12] = 0;\r\n    inverseMatrix[13] = 0;\r\n    inverseMatrix[14] = 0;\r\n    return (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.calculateMatrixDist)(inverseMatrix, dist);\r\n}\r\nfunction getSizeDistByDist(startSize, dist, ratio, direction, keepRatio) {\r\n    var _a = __read(startSize, 2), startOffsetWidth = _a[0], startOffsetHeight = _a[1];\r\n    var distWidth = 0;\r\n    var distHeight = 0;\r\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\r\n        var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], dist);\r\n        var standardRad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)([0, 0], direction);\r\n        var size = getDistSize(dist);\r\n        var signSize = Math.cos(rad - standardRad) * size;\r\n        if (!direction[0]) {\r\n            // top, bottom\r\n            distHeight = signSize;\r\n            distWidth = distHeight * ratio;\r\n        }\r\n        else if (!direction[1]) {\r\n            // left, right\r\n            distWidth = signSize;\r\n            distHeight = distWidth / ratio;\r\n        }\r\n        else {\r\n            // two-way\r\n            var startWidthSize = direction[0] * startOffsetWidth;\r\n            var startHeightSize = direction[1] * startOffsetHeight;\r\n            var secondRad = Math.atan2(startWidthSize + dist[0], startHeightSize + dist[1]);\r\n            var firstRad = Math.atan2(startWidthSize, startHeightSize);\r\n            if (secondRad < 0) {\r\n                secondRad += Math.PI * 2;\r\n            }\r\n            if (firstRad < 0) {\r\n                firstRad += Math.PI * 2;\r\n            }\r\n            var rad_1 = 0;\r\n            if (abs(secondRad - firstRad) < Math.PI / 2 || abs(secondRad - firstRad) > Math.PI / 2 * 3) {\r\n                rad_1 = secondRad - firstRad;\r\n            }\r\n            else {\r\n                firstRad += Math.PI;\r\n                rad_1 = secondRad - firstRad;\r\n            }\r\n            if (rad_1 > Math.PI * 2) {\r\n                rad_1 -= Math.PI * 2;\r\n            }\r\n            else if (rad_1 > Math.PI) {\r\n                rad_1 = 2 * Math.PI - rad_1;\r\n            }\r\n            else if (rad_1 < -Math.PI) {\r\n                rad_1 = -2 * Math.PI - rad_1;\r\n            }\r\n            //       180\r\n            // -1, -1,  // 1, -1\r\n            // 270            90\r\n            // -1, 1    // 1, 1\r\n            //       0\r\n            var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) * Math.cos(rad_1);\r\n            distWidth = distSize * Math.sin(firstRad) - startWidthSize;\r\n            distHeight = distSize * Math.cos(firstRad) - startHeightSize;\r\n            if (direction[0] < 0) {\r\n                distWidth *= -1;\r\n            }\r\n            if (direction[1] < 0) {\r\n                distHeight *= -1;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        distWidth = direction[0] * dist[0];\r\n        distHeight = direction[1] * dist[1];\r\n    }\r\n    return [distWidth, distHeight];\r\n}\r\nfunction getOffsetSizeDist(sizeDirection, keepRatio, datas, e) {\r\n    var _a;\r\n    var ratio = datas.ratio, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight;\r\n    var distWidth = 0;\r\n    var distHeight = 0;\r\n    var distX = e.distX, distY = e.distY, pinchScale = e.pinchScale, parentDistance = e.parentDistance, parentDist = e.parentDist, parentScale = e.parentScale;\r\n    var startFixedDirection = datas.fixedDirection;\r\n    var directionsDists = [0, 1].map(function (index) {\r\n        return abs(sizeDirection[index] - startFixedDirection[index]);\r\n    });\r\n    var directionRatios = [0, 1].map(function (index) {\r\n        var dist = directionsDists[index];\r\n        if (dist !== 0) {\r\n            dist = 2 / dist;\r\n        }\r\n        return dist;\r\n    });\r\n    if (parentDist) {\r\n        distWidth = parentDist[0];\r\n        distHeight = parentDist[1];\r\n        if (keepRatio) {\r\n            if (!distWidth) {\r\n                distWidth = distHeight * ratio;\r\n            }\r\n            else if (!distHeight) {\r\n                distHeight = distWidth / ratio;\r\n            }\r\n        }\r\n    }\r\n    else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(pinchScale)) {\r\n        distWidth = (pinchScale - 1) * startOffsetWidth;\r\n        distHeight = (pinchScale - 1) * startOffsetHeight;\r\n    }\r\n    else if (parentScale) {\r\n        distWidth = (parentScale[0] - 1) * startOffsetWidth;\r\n        distHeight = (parentScale[1] - 1) * startOffsetHeight;\r\n    }\r\n    else if (parentDistance) {\r\n        var scaleX = startOffsetWidth * directionsDists[0];\r\n        var scaleY = startOffsetHeight * directionsDists[1];\r\n        var ratioDistance = getDistSize([scaleX, scaleY]);\r\n        distWidth = parentDistance / ratioDistance * scaleX * directionRatios[0];\r\n        distHeight = parentDistance / ratioDistance * scaleY * directionRatios[1];\r\n    }\r\n    else {\r\n        var dist_1 = getDragDist({ datas: datas, distX: distX, distY: distY });\r\n        dist_1 = directionRatios.map(function (ratio, i) {\r\n            return dist_1[i] * ratio;\r\n        });\r\n        _a = __read(getSizeDistByDist([startOffsetWidth, startOffsetHeight], dist_1, ratio, sizeDirection, keepRatio), 2), distWidth = _a[0], distHeight = _a[1];\r\n    }\r\n    return {\r\n        // direction,\r\n        // sizeDirection,\r\n        distWidth: distWidth,\r\n        distHeight: distHeight,\r\n    };\r\n}\r\nfunction convertTransformUnit(origin, xy) {\r\n    if (xy) {\r\n        if (origin === \"left\") {\r\n            return { x: \"0%\", y: \"50%\" };\r\n        }\r\n        else if (origin === \"top\") {\r\n            return { x: \"50%\", y: \"50%\" };\r\n        }\r\n        else if (origin === \"center\") {\r\n            return { x: \"50%\", y: \"50%\" };\r\n        }\r\n        else if (origin === \"right\") {\r\n            return { x: \"100%\", y: \"50%\" };\r\n        }\r\n        else if (origin === \"bottom\") {\r\n            return { x: \"50%\", y: \"100%\" };\r\n        }\r\n        var _a = __read(origin.split(\" \"), 2), left = _a[0], right = _a[1];\r\n        var leftOrigin = convertTransformUnit(left || \"\");\r\n        var rightOrigin = convertTransformUnit(right || \"\");\r\n        var originObject = __assign(__assign({}, leftOrigin), rightOrigin);\r\n        var nextOriginObject = {\r\n            x: \"50%\",\r\n            y: \"50%\",\r\n        };\r\n        if (originObject.x) {\r\n            nextOriginObject.x = originObject.x;\r\n        }\r\n        if (originObject.y) {\r\n            nextOriginObject.y = originObject.y;\r\n        }\r\n        if (originObject.value) {\r\n            if (originObject.x && !originObject.y) {\r\n                nextOriginObject.y = originObject.value;\r\n            }\r\n            if (!originObject.x && originObject.y) {\r\n                nextOriginObject.x = originObject.value;\r\n            }\r\n        }\r\n        return nextOriginObject;\r\n    }\r\n    if (origin === \"left\") {\r\n        return { x: \"0%\" };\r\n    }\r\n    if (origin === \"right\") {\r\n        return { x: \"100%\" };\r\n    }\r\n    if (origin === \"top\") {\r\n        return { y: \"0%\" };\r\n    }\r\n    if (origin === \"bottom\") {\r\n        return { y: \"100%\" };\r\n    }\r\n    if (!origin) {\r\n        return {};\r\n    }\r\n    if (origin === \"center\") {\r\n        return { value: \"50%\" };\r\n    }\r\n    return { value: origin };\r\n}\r\nfunction convertTransformOriginArray(transformOrigin, width, height) {\r\n    var _a = convertTransformUnit(transformOrigin, true), x = _a.x, y = _a.y;\r\n    return [\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(x, width) || 0,\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(y, height) || 0,\r\n    ];\r\n}\r\nfunction rotatePosesInfo(poses, origin, rad) {\r\n    var prevPoses = poses.map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos, origin); });\r\n    var nextPoses = prevPoses.map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.rotate)(pos, rad); });\r\n    return {\r\n        prev: prevPoses,\r\n        next: nextPoses,\r\n        result: nextPoses.map(function (pos) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, origin); }),\r\n    };\r\n}\r\nfunction isDeepArrayEquals(arr1, arr2) {\r\n    return arr1.length === arr2.length && arr1.every(function (value1, i) {\r\n        var value2 = arr2[i];\r\n        var isArray1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(value1);\r\n        var isArray2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(value2);\r\n        if (isArray1 && isArray2) {\r\n            return isDeepArrayEquals(value1, value2);\r\n        }\r\n        else if (!isArray1 && !isArray2) {\r\n            return value1 === value2;\r\n        }\r\n        return false;\r\n    });\r\n}\r\nfunction watchValue(moveable, property, nextValue, valueKey, defaultValue) {\r\n    var store = moveable._store;\r\n    var prevValue = store[property];\r\n    if (!(property in store)) {\r\n        if (defaultValue != null) {\r\n            store[property] = defaultValue;\r\n            prevValue = defaultValue;\r\n        }\r\n        else {\r\n            store[property] = nextValue;\r\n            return nextValue;\r\n        }\r\n    }\r\n    if (prevValue === nextValue || valueKey(prevValue) === valueKey(nextValue)) {\r\n        return prevValue;\r\n    }\r\n    store[property] = nextValue;\r\n    return nextValue;\r\n}\r\nfunction sign(value) {\r\n    return value >= 0 ? 1 : -1;\r\n}\r\nfunction abs(value) {\r\n    return Math.abs(value);\r\n}\r\nfunction countEach(count, callback) {\r\n    return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.counter)(count).map(function (index) { return callback(index); });\r\n}\r\nfunction getPaddingBox(padding) {\r\n    if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNumber)(padding)) {\r\n        return {\r\n            top: padding,\r\n            left: padding,\r\n            right: padding,\r\n            bottom: padding,\r\n        };\r\n    }\r\n    return {\r\n        left: padding.left || 0,\r\n        top: padding.top || 0,\r\n        right: padding.right || 0,\r\n        bottom: padding.bottom || 0,\r\n    };\r\n}\n\n/**\r\n * @namespace Moveable.Pinchable\r\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\r\n */\r\nvar Pinchable = makeAble(\"pinchable\", {\r\n    props: [\r\n        \"pinchable\",\r\n    ],\r\n    events: [\r\n        \"pinchStart\",\r\n        \"pinch\",\r\n        \"pinchEnd\",\r\n        \"pinchGroupStart\",\r\n        \"pinchGroup\",\r\n        \"pinchGroupEnd\",\r\n    ],\r\n    dragStart: function () {\r\n        return true;\r\n    },\r\n    pinchStart: function (moveable, e) {\r\n        var datas = e.datas, targets = e.targets, angle = e.angle, originalDatas = e.originalDatas;\r\n        var _a = moveable.props, pinchable = _a.pinchable, ables = _a.ables;\r\n        if (!pinchable) {\r\n            return false;\r\n        }\r\n        var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\", \"Start\");\r\n        var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"ControlStart\");\r\n        var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {\r\n            return pinchable.indexOf(able.name) > -1;\r\n        })).filter(function (able) { return able.canPinch && able[controlEventName]; });\r\n        var params = fillParams(moveable, e, {});\r\n        if (targets) {\r\n            params.targets = targets;\r\n        }\r\n        var result = triggerEvent(moveable, eventName, params);\r\n        datas.isPinch = result !== false;\r\n        datas.ables = pinchAbles;\r\n        var isPinch = datas.isPinch;\r\n        if (!isPinch) {\r\n            return false;\r\n        }\r\n        pinchAbles.forEach(function (able) {\r\n            originalDatas[able.name] = originalDatas[able.name] || {};\r\n            if (!able[controlEventName]) {\r\n                return;\r\n            }\r\n            var ableEvent = __assign(__assign({}, e), { datas: originalDatas[able.name], parentRotate: angle, isPinch: true });\r\n            able[controlEventName](moveable, ableEvent);\r\n        });\r\n        moveable.state.snapRenderInfo = {\r\n            request: e.isRequest,\r\n            direction: [0, 0],\r\n        };\r\n        return isPinch;\r\n    },\r\n    pinch: function (moveable, e) {\r\n        var datas = e.datas, pinchScale = e.scale, distance = e.distance, originalDatas = e.originalDatas, inputEvent = e.inputEvent, targets = e.targets, angle = e.angle;\r\n        if (!datas.isPinch) {\r\n            return;\r\n        }\r\n        var parentDistance = distance * (1 - 1 / pinchScale);\r\n        var params = fillParams(moveable, e, {});\r\n        if (targets) {\r\n            params.targets = targets;\r\n        }\r\n        var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\");\r\n        triggerEvent(moveable, eventName, params);\r\n        var ables = datas.ables;\r\n        var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"Control\");\r\n        ables.forEach(function (able) {\r\n            if (!able[controlEventName]) {\r\n                return;\r\n            }\r\n            able[controlEventName](moveable, __assign(__assign({}, e), { datas: originalDatas[able.name], inputEvent: inputEvent, resolveMatrix: true, pinchScale: pinchScale, parentDistance: parentDistance, parentRotate: angle, isPinch: true }));\r\n        });\r\n        return params;\r\n    },\r\n    pinchEnd: function (moveable, e) {\r\n        var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, targets = e.targets, originalDatas = e.originalDatas;\r\n        if (!datas.isPinch) {\r\n            return;\r\n        }\r\n        var eventName = \"onPinch\".concat(targets ? \"Group\" : \"\", \"End\");\r\n        var params = fillEndParams(moveable, e, { isDrag: isPinch });\r\n        if (targets) {\r\n            params.targets = targets;\r\n        }\r\n        triggerEvent(moveable, eventName, params);\r\n        var ables = datas.ables;\r\n        var controlEventName = \"drag\".concat(targets ? \"Group\" : \"\", \"ControlEnd\");\r\n        ables.forEach(function (able) {\r\n            if (!able[controlEventName]) {\r\n                return;\r\n            }\r\n            able[controlEventName](moveable, __assign(__assign({}, e), { isDrag: isPinch, datas: originalDatas[able.name], inputEvent: inputEvent, isPinch: true }));\r\n        });\r\n        return isPinch;\r\n    },\r\n    pinchGroupStart: function (moveable, e) {\r\n        return this.pinchStart(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    pinchGroup: function (moveable, e) {\r\n        return this.pinch(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    pinchGroupEnd: function (moveable, e) {\r\n        return this.pinchEnd(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n});\r\n/**\r\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\r\n * @name Moveable.Pinchable#pinchable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.pinchable = true;\r\n */\r\n/**\r\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\r\n * @memberof Moveable.Pinchable\r\n * @event pinchStart\r\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     rotatable: true,\r\n *     scalable: true,\r\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\r\n * });\r\n * moveable.on(\"pinchStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"rotateStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"scaleStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n * When pinching, the pinch event is called with part of scale, rotate, resize\r\n * @memberof Moveable.Pinchable\r\n * @event pinch\r\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     rotatable: true,\r\n *     scalable: true,\r\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\r\n * });\r\n * moveable.on(\"pinch\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"rotate\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"scale\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n * When the pinch finishes, the pinchEnd event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchEnd\r\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     rotatable: true,\r\n *     scalable: true,\r\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\r\n * });\r\n * moveable.on(\"pinchEnd\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"rotateEnd\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n * moveable.on(\"scaleEnd\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n * When the group pinch starts, the `pinchGroupStart` event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchGroupStart\r\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     pinchable: true\r\n * });\r\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\r\n *     console.log(\"onPinchGroupStart\", targets);\r\n * });\r\n */\r\n/**\r\n * When the group pinch, the `pinchGroup` event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchGroup\r\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     pinchable: true\r\n * });\r\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\r\n *     console.log(\"onPinchGroup\", targets);\r\n * });\r\n */\r\n/**\r\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\r\n * @memberof Moveable.Pinchable\r\n * @event pinchGroupEnd\r\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     pinchable: true\r\n * });\r\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\r\n * });\r\n */\n\nvar directionCondition = getDirectionCondition(\"scalable\");\r\n/**\r\n * @namespace Scalable\r\n * @memberof Moveable\r\n * @description Scalable indicates whether the target's x and y can be scale of transform.\r\n */\r\nvar Scalable = {\r\n    name: \"scalable\",\r\n    ableGroup: \"size\",\r\n    canPinch: true,\r\n    props: [\r\n        \"scalable\",\r\n        \"throttleScale\",\r\n        \"renderDirections\",\r\n        \"keepRatio\",\r\n        \"edge\",\r\n        \"displayAroundControls\",\r\n    ],\r\n    events: [\r\n        \"scaleStart\",\r\n        \"beforeScale\",\r\n        \"scale\",\r\n        \"scaleEnd\",\r\n        \"scaleGroupStart\",\r\n        \"beforeScaleGroup\",\r\n        \"scaleGroup\",\r\n        \"scaleGroupEnd\",\r\n    ],\r\n    render: getRenderDirections(\"scalable\"),\r\n    dragControlCondition: directionCondition,\r\n    viewClassName: getDirectionViewClassName(\"scalable\"),\r\n    dragControlStart: function (moveable, e) {\r\n        var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, parentDirection = e.parentDirection;\r\n        var direction = getTotalDirection(parentDirection, isPinch, inputEvent, datas);\r\n        var _a = moveable.state, width = _a.width, height = _a.height, targetTransform = _a.targetTransform, target = _a.target, pos1 = _a.pos1, pos2 = _a.pos2, pos4 = _a.pos4;\r\n        if (!direction || !target) {\r\n            return false;\r\n        }\r\n        if (!isPinch) {\r\n            setDragStart(moveable, e);\r\n        }\r\n        datas.datas = {};\r\n        datas.transform = targetTransform;\r\n        datas.prevDist = [1, 1];\r\n        datas.direction = direction;\r\n        datas.startOffsetWidth = width;\r\n        datas.startOffsetHeight = height;\r\n        datas.startValue = [1, 1];\r\n        // const scaleWidth = getDist(pos1, pos2);\r\n        // const scaleHeight = getDist(pos2, pos4);\r\n        var isWidth = (!direction[0] && !direction[1]) || direction[0] || !direction[1];\r\n        // datas.scaleWidth = scaleWidth;\r\n        // datas.scaleHeight = scaleHeight;\r\n        // datas.scaleXRatio = scaleWidth / width;\r\n        // datas.scaleYRatio = scaleHeight / height;\r\n        setDefaultTransformIndex(moveable, e, \"scale\");\r\n        datas.isWidth = isWidth;\r\n        function setRatio(ratio) {\r\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\r\n        }\r\n        datas.startPositions = getAbsolutePosesByState(moveable.state);\r\n        function setFixedDirection(fixedDirection) {\r\n            var result = getFixedDirectionInfo(datas.startPositions, fixedDirection);\r\n            datas.fixedDirection = result.fixedDirection;\r\n            datas.fixedPosition = result.fixedPosition;\r\n            datas.fixedOffset = result.fixedOffset;\r\n        }\r\n        datas.setFixedDirection = setFixedDirection;\r\n        setRatio((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(pos1, pos2) / (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDist)(pos2, pos4));\r\n        setFixedDirection([-direction[0], -direction[1]]);\r\n        var setMinScaleSize = function (min) {\r\n            datas.minScaleSize = min;\r\n        };\r\n        var setMaxScaleSize = function (max) {\r\n            datas.maxScaleSize = max;\r\n        };\r\n        // const setMinScale = (min: number[]) => {\r\n        // };\r\n        // const setMaxScale = (max: number[]) => {\r\n        // };\r\n        setMinScaleSize([-Infinity, -Infinity]);\r\n        setMaxScaleSize([Infinity, Infinity]);\r\n        var params = fillParams(moveable, e, __assign(__assign({ direction: direction, set: function (scale) {\r\n                datas.startValue = scale;\r\n            }, setRatio: setRatio, setFixedDirection: setFixedDirection, setMinScaleSize: setMinScaleSize, setMaxScaleSize: setMaxScaleSize }, fillTransformStartEvent(moveable, e)), { dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e)) }));\r\n        var result = triggerEvent(moveable, \"onScaleStart\", params);\r\n        datas.startFixedDirection = datas.fixedDirection;\r\n        if (result !== false) {\r\n            datas.isScale = true;\r\n            moveable.state.snapRenderInfo = {\r\n                request: e.isRequest,\r\n                direction: direction,\r\n            };\r\n        }\r\n        return datas.isScale ? params : false;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        resolveTransformEvent(moveable, e, \"scale\");\r\n        var datas = e.datas, parentKeepRatio = e.parentKeepRatio, parentFlag = e.parentFlag, isPinch = e.isPinch, dragClient = e.dragClient, isRequest = e.isRequest, useSnap = e.useSnap, resolveMatrix = e.resolveMatrix;\r\n        var prevDist = datas.prevDist, direction = datas.direction, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, isScale = datas.isScale, startValue = datas.startValue, isWidth = datas.isWidth, ratio = datas.ratio;\r\n        if (!isScale) {\r\n            return false;\r\n        }\r\n        var props = moveable.props;\r\n        var throttleScale = props.throttleScale, parentMoveable = props.parentMoveable;\r\n        var sizeDirection = direction;\r\n        if (!direction[0] && !direction[1]) {\r\n            sizeDirection = [1, 1];\r\n        }\r\n        var keepRatio = (ratio && (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) || false;\r\n        var state = moveable.state;\r\n        var tempScaleValue = [\r\n            startValue[0],\r\n            startValue[1],\r\n        ];\r\n        function getNextScale() {\r\n            var _a = getOffsetSizeDist(sizeDirection, keepRatio, datas, e), distWidth = _a.distWidth, distHeight = _a.distHeight;\r\n            var distX = startOffsetWidth ? (startOffsetWidth + distWidth) / startOffsetWidth : 1;\r\n            var distY = startOffsetHeight ? (startOffsetHeight + distHeight) / startOffsetHeight : 1;\r\n            if (!startValue[0]) {\r\n                tempScaleValue[0] = distWidth / startOffsetWidth;\r\n            }\r\n            if (!startValue[1]) {\r\n                tempScaleValue[1] = distHeight / startOffsetHeight;\r\n            }\r\n            var scaleX = (sizeDirection[0] || keepRatio ? distX : 1) * tempScaleValue[0];\r\n            var scaleY = (sizeDirection[1] || keepRatio ? distY : 1) * tempScaleValue[1];\r\n            if (scaleX === 0) {\r\n                scaleX = sign(prevDist[0]) * MIN_SCALE;\r\n            }\r\n            if (scaleY === 0) {\r\n                scaleY = sign(prevDist[1]) * MIN_SCALE;\r\n            }\r\n            return [scaleX, scaleY];\r\n        }\r\n        var scale = getNextScale();\r\n        if (!isPinch && moveable.props.groupable) {\r\n            var snapRenderInfo = state.snapRenderInfo || {};\r\n            var stateDirection = snapRenderInfo.direction;\r\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(stateDirection) && (stateDirection[0] || stateDirection[1])) {\r\n                state.snapRenderInfo = { direction: direction, request: e.isRequest };\r\n            }\r\n        }\r\n        triggerEvent(moveable, \"onBeforeScale\", fillParams(moveable, e, {\r\n            scale: scale,\r\n            setFixedDirection: function (nextFixedDirection) {\r\n                datas.setFixedDirection(nextFixedDirection);\r\n                scale = getNextScale();\r\n                return scale;\r\n            },\r\n            startFixedDirection: datas.startFixedDirection,\r\n            setScale: function (nextScale) {\r\n                scale = nextScale;\r\n            },\r\n        }, true));\r\n        var dist = [\r\n            scale[0] / tempScaleValue[0],\r\n            scale[1] / tempScaleValue[1],\r\n        ];\r\n        var fixedPosition = dragClient;\r\n        var snapDist = [0, 0];\r\n        var distSign = sign(dist[0] * dist[1]);\r\n        var isSelfPinch = !dragClient && !parentFlag && isPinch;\r\n        if (isSelfPinch || resolveMatrix) {\r\n            fixedPosition = getTranslateFixedPosition(moveable, datas.targetAllTransform, [0, 0], [0, 0], datas);\r\n        }\r\n        else if (!dragClient) {\r\n            fixedPosition = datas.fixedPosition;\r\n        }\r\n        if (!isPinch) {\r\n            snapDist = checkSnapScale(moveable, dist, direction, !useSnap && isRequest, datas);\r\n        }\r\n        if (keepRatio) {\r\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\r\n                if (Math.abs(snapDist[0] * startOffsetWidth) > Math.abs(snapDist[1] * startOffsetHeight)) {\r\n                    snapDist[1] = 0;\r\n                }\r\n                else {\r\n                    snapDist[0] = 0;\r\n                }\r\n            }\r\n            var isNoSnap = !snapDist[0] && !snapDist[1];\r\n            if (isNoSnap) {\r\n                // throttle scale value (not absolute scale size)\r\n                if (isWidth) {\r\n                    dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[0] * tempScaleValue[0], throttleScale) / tempScaleValue[0];\r\n                }\r\n                else {\r\n                    dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[1] * tempScaleValue[1], throttleScale) / tempScaleValue[1];\r\n                }\r\n            }\r\n            if ((sizeDirection[0] && !sizeDirection[1])\r\n                || (snapDist[0] && !snapDist[1])\r\n                || (isNoSnap && isWidth)) {\r\n                dist[0] += snapDist[0];\r\n                var snapHeight = startOffsetWidth * dist[0] * tempScaleValue[0] / ratio;\r\n                dist[1] = sign(distSign * dist[0]) * abs(snapHeight / startOffsetHeight / tempScaleValue[1]);\r\n            }\r\n            else if ((!sizeDirection[0] && sizeDirection[1])\r\n                || (!snapDist[0] && snapDist[1])\r\n                || (isNoSnap && !isWidth)) {\r\n                dist[1] += snapDist[1];\r\n                var snapWidth = startOffsetHeight * dist[1] * tempScaleValue[1] * ratio;\r\n                dist[0] = sign(distSign * dist[1]) * abs(snapWidth / startOffsetWidth / tempScaleValue[0]);\r\n            }\r\n        }\r\n        else {\r\n            dist[0] += snapDist[0];\r\n            dist[1] += snapDist[1];\r\n            if (!snapDist[0]) {\r\n                dist[0] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[0] * tempScaleValue[0], throttleScale) / tempScaleValue[0];\r\n            }\r\n            if (!snapDist[1]) {\r\n                dist[1] = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(dist[1] * tempScaleValue[1], throttleScale) / tempScaleValue[1];\r\n            }\r\n        }\r\n        if (dist[0] === 0) {\r\n            dist[0] = sign(prevDist[0]) * MIN_SCALE;\r\n        }\r\n        if (dist[1] === 0) {\r\n            dist[1] = sign(prevDist[1]) * MIN_SCALE;\r\n        }\r\n        scale = multiply2(dist, [tempScaleValue[0], tempScaleValue[1]]);\r\n        var startOffsetSize = [\r\n            startOffsetWidth,\r\n            startOffsetHeight,\r\n        ];\r\n        var scaleSize = [\r\n            startOffsetWidth * scale[0],\r\n            startOffsetHeight * scale[1],\r\n        ];\r\n        scaleSize = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.calculateBoundSize)(scaleSize, datas.minScaleSize, datas.maxScaleSize, keepRatio ? ratio : false);\r\n        // if (keepRatio && (isGroup || keepRatioFinally)) {\r\n        //     if (isWidth) {\r\n        //         boundingHeight = boundingWidth / ratio;\r\n        //     } else {\r\n        //         boundingWidth = boundingHeight * ratio;\r\n        //     }\r\n        // }\r\n        scale = countEach(2, function (i) {\r\n            return startOffsetSize[i] ? scaleSize[i] / startOffsetSize[i] : scaleSize[i];\r\n        });\r\n        dist = countEach(2, function (i) {\r\n            return scale[i] / tempScaleValue[i];\r\n        });\r\n        var delta = countEach(2, function (i) { return prevDist[i] ? dist[i] / prevDist[i] : dist[i]; });\r\n        var distText = \"scale(\".concat(dist.join(\", \"), \")\");\r\n        var scaleText = \"scale(\".concat(scale.join(\", \"), \")\");\r\n        var nextTransform = convertTransformFormat(datas, scaleText, distText);\r\n        var isZeroScale = !startValue[0] || !startValue[1];\r\n        var inverseDist = getScaleDist(moveable, isZeroScale ? scaleText : distText, datas.fixedDirection, fixedPosition, datas.fixedOffset, datas, isZeroScale);\r\n        var inverseDelta = isSelfPinch ? inverseDist : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(inverseDist, datas.prevInverseDist || [0, 0]);\r\n        datas.prevDist = dist;\r\n        datas.prevInverseDist = inverseDist;\r\n        if (scale[0] === prevDist[0] && scale[1] === prevDist[1]\r\n            && inverseDelta.every(function (num) { return !num; })\r\n            && !parentMoveable\r\n            && !isSelfPinch) {\r\n            return false;\r\n        }\r\n        var params = fillParams(moveable, e, __assign({ offsetWidth: startOffsetWidth, offsetHeight: startOffsetHeight, direction: direction, scale: scale, dist: dist, delta: delta, isPinch: !!isPinch }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));\r\n        triggerEvent(moveable, \"onScale\", params);\r\n        return params;\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isScale) {\r\n            return false;\r\n        }\r\n        datas.isScale = false;\r\n        var scaleEndParam = fillEndParams(moveable, e, {});\r\n        triggerEvent(moveable, \"onScaleEnd\", scaleEndParam);\r\n        return scaleEndParam;\r\n    },\r\n    dragGroupControlCondition: directionCondition,\r\n    dragGroupControlStart: function (moveable, e) {\r\n        var datas = e.datas;\r\n        var params = this.dragControlStart(moveable, e);\r\n        if (!params) {\r\n            return false;\r\n        }\r\n        var originalEvents = fillChildEvents(moveable, \"resizable\", e);\r\n        datas.moveableScale = moveable.scale;\r\n        var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function (child, ev) {\r\n            return startChildDist(moveable, child, datas, ev);\r\n        });\r\n        var setFixedDirection = function (fixedDirection) {\r\n            params.setFixedDirection(fixedDirection);\r\n            events.forEach(function (ev, i) {\r\n                ev.setFixedDirection(fixedDirection);\r\n                startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\r\n            });\r\n        };\r\n        datas.setFixedDirection = setFixedDirection;\r\n        var nextParams = __assign(__assign({}, params), { targets: moveable.props.targets, events: events, setFixedDirection: setFixedDirection });\r\n        var result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\r\n        datas.isScale = result !== false;\r\n        return datas.isScale ? nextParams : false;\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isScale) {\r\n            return;\r\n        }\r\n        catchEvent(moveable, \"onBeforeScale\", function (parentEvent) {\r\n            triggerEvent(moveable, \"onBeforeScaleGroup\", fillParams(moveable, e, __assign(__assign({}, parentEvent), { targets: moveable.props.targets }), true));\r\n        });\r\n        var params = this.dragControl(moveable, e);\r\n        if (!params) {\r\n            return;\r\n        }\r\n        var dist = params.dist;\r\n        var moveableScale = datas.moveableScale;\r\n        moveable.scale = [\r\n            dist[0] * moveableScale[0],\r\n            dist[1] * moveableScale[1],\r\n        ];\r\n        var keepRatio = moveable.props.keepRatio;\r\n        var fixedPosition = datas.fixedPosition;\r\n        var events = triggerChildAbles(moveable, this, \"dragControl\", e, function (_, ev) {\r\n            var _a = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createRotateMatrix)(moveable.rotation / 180 * Math.PI, 3), [\r\n                ev.datas.originalX * dist[0],\r\n                ev.datas.originalY * dist[1],\r\n                1,\r\n            ], 3), 2), clientX = _a[0], clientY = _a[1];\r\n            return __assign(__assign({}, ev), { parentDist: null, parentScale: dist, parentKeepRatio: keepRatio, \r\n                // recalculate child fixed position for parent group's dragging.\r\n                dragClient: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(fixedPosition, [clientX, clientY]) });\r\n        });\r\n        var nextParams = __assign({ targets: moveable.props.targets, events: events }, params);\r\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\r\n        return nextParams;\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        var isDrag = e.isDrag, datas = e.datas;\r\n        if (!datas.isScale) {\r\n            return;\r\n        }\r\n        this.dragControlEnd(moveable, e);\r\n        var events = triggerChildAbles(moveable, this, \"dragControlEnd\", e);\r\n        var nextParams = fillEndParams(moveable, e, {\r\n            targets: moveable.props.targets,\r\n            events: events,\r\n        });\r\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\r\n        return isDrag;\r\n    },\r\n    /**\r\n     * @method Moveable.Scalable#request\r\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\r\n     * @return {Moveable.Requester} Moveable Requester\r\n     * @example\r\n\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\r\n     *\r\n     * // requestStart\r\n     * const requester = moveable.request(\"scalable\");\r\n     *\r\n     * // request\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\r\n     *\r\n     * // requestEnd\r\n     * requester.requestEnd();\r\n     */\r\n    request: function () {\r\n        var datas = {};\r\n        var distWidth = 0;\r\n        var distHeight = 0;\r\n        var useSnap = false;\r\n        return {\r\n            isControl: true,\r\n            requestStart: function (e) {\r\n                useSnap = e.useSnap;\r\n                return {\r\n                    datas: datas,\r\n                    parentDirection: e.direction || [1, 1],\r\n                    useSnap: useSnap,\r\n                };\r\n            },\r\n            request: function (e) {\r\n                distWidth += e.deltaWidth;\r\n                distHeight += e.deltaHeight;\r\n                return {\r\n                    datas: datas,\r\n                    parentDist: [distWidth, distHeight],\r\n                    parentKeepRatio: e.keepRatio,\r\n                    useSnap: useSnap,\r\n                };\r\n            },\r\n            requestEnd: function () {\r\n                return { datas: datas, isDrag: true, useSnap: useSnap };\r\n            },\r\n        };\r\n    },\r\n};\r\n/**\r\n * Whether or not target can scaled.\r\n *\r\n * @name Moveable.Scalable#scalable\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.scalable = true;\r\n */\r\n/**\r\n * throttle of scaleX, scaleY when scale.\r\n * @name Moveable.Scalable#throttleScale\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.throttleScale = 0.1;\r\n */\r\n/**\r\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\r\n * @name Moveable.Scalable#renderDirections\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     scalable: true,\r\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\r\n * });\r\n *\r\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\r\n */\r\n/**\r\n * When resize or scale, keeps a ratio of the width, height. (default: false)\r\n * @name Moveable.Scalable#keepRatio\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     scalable: true,\r\n * });\r\n *\r\n * moveable.keepRatio = true;\r\n */\r\n/**\r\n * When the scale starts, the scaleStart event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scaleStart\r\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"scaleStart\", ({ target }) => {\r\n *     console.log(target);\r\n * });\r\n */\r\n/**\r\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\r\n * @memberof Moveable.Scalable\r\n * @event beforeScale\r\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\r\n *     if (shiftKey) {\r\n *        setFixedDirection([0, 0]);\r\n *     }\r\n * });\r\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\r\n *     target.style.transform = transform;\r\n * });\r\n */\r\n/**\r\n * When scaling, the `scale` event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scale\r\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\r\n *     target.style.transform = transform;\r\n * });\r\n */\r\n/**\r\n * When the scale finishes, the `scaleEnd` event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scaleEnd\r\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { scalable: true });\r\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */\r\n/**\r\n* When the group scale starts, the `scaleGroupStart` event is called.\r\n* @memberof Moveable.Scalable\r\n* @event scaleGroupStart\r\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     scalable: true\r\n* });\r\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\r\n*     console.log(\"onScaleGroupStart\", targets);\r\n* });\r\n*/\r\n/**\r\n* When the group scale, the `scaleGroup` event is called.\r\n* @memberof Moveable.Scalable\r\n* @event scaleGroup\r\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n*     scalable: true\r\n* });\r\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\r\n*     console.log(\"onScaleGroup\", targets);\r\n*     events.forEach(ev => {\r\n*         const target = ev.target;\r\n*         // ev.drag is a drag event that occurs when the group scale.\r\n*         const left = ev.drag.beforeDist[0];\r\n*         const top = ev.drag.beforeDist[1];\r\n*         const scaleX = ev.scale[0];\r\n*         const scaleY = ev.scale[1];\r\n*     });\r\n* });\r\n*/\r\n/**\r\n * When the group scale finishes, the `scaleGroupEnd` event is called.\r\n * @memberof Moveable.Scalable\r\n * @event scaleGroupEnd\r\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n *     scalable: true\r\n * });\r\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\r\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\r\n * });\r\n */\n\nfunction getMiddleLinePos(pos1, pos2) {\r\n    return pos1.map(function (pos, i) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.dot)(pos, pos2[i], 1, 2); });\r\n}\r\nfunction getTriangleRad(pos1, pos2, pos3) {\r\n    // pos1 Rad\r\n    var rad1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos2);\r\n    var rad2 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(pos1, pos3);\r\n    var rad = rad2 - rad1;\r\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\r\n}\r\nfunction isValidPos(poses1, poses2) {\r\n    var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\r\n    var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\r\n    var pi = Math.PI;\r\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @namespace Moveable.Warpable\r\n * @description Warpable indicates whether the target can be warped(distorted, bented).\r\n */\r\nvar Warpable = {\r\n    name: \"warpable\",\r\n    ableGroup: \"size\",\r\n    props: [\r\n        \"warpable\",\r\n        \"renderDirections\",\r\n        \"edge\",\r\n        \"displayAroundControls\",\r\n    ],\r\n    events: [\r\n        \"warpStart\",\r\n        \"warp\",\r\n        \"warpEnd\",\r\n    ],\r\n    viewClassName: getDirectionViewClassName(\"warpable\"),\r\n    render: function (moveable, React) {\r\n        var _a = moveable.props, resizable = _a.resizable, scalable = _a.scalable, warpable = _a.warpable, zoom = _a.zoom;\r\n        if (resizable || scalable || !warpable) {\r\n            return [];\r\n        }\r\n        var _b = moveable.state, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4;\r\n        var linePosFrom1 = getMiddleLinePos(pos1, pos2);\r\n        var linePosFrom2 = getMiddleLinePos(pos2, pos1);\r\n        var linePosFrom3 = getMiddleLinePos(pos1, pos3);\r\n        var linePosFrom4 = getMiddleLinePos(pos3, pos1);\r\n        var linePosTo1 = getMiddleLinePos(pos3, pos4);\r\n        var linePosTo2 = getMiddleLinePos(pos4, pos3);\r\n        var linePosTo3 = getMiddleLinePos(pos2, pos4);\r\n        var linePosTo4 = getMiddleLinePos(pos4, pos2);\r\n        return __spreadArray([\r\n            React.createElement(\"div\", { className: prefix(\"line\"), key: \"middeLine1\", style: getLineStyle(linePosFrom1, linePosTo1, zoom) }),\r\n            React.createElement(\"div\", { className: prefix(\"line\"), key: \"middeLine2\", style: getLineStyle(linePosFrom2, linePosTo2, zoom) }),\r\n            React.createElement(\"div\", { className: prefix(\"line\"), key: \"middeLine3\", style: getLineStyle(linePosFrom3, linePosTo3, zoom) }),\r\n            React.createElement(\"div\", { className: prefix(\"line\"), key: \"middeLine4\", style: getLineStyle(linePosFrom4, linePosTo4, zoom) })\r\n        ], __read(renderAllDirections(moveable, \"warpable\", React)), false);\r\n    },\r\n    dragControlCondition: function (moveable, e) {\r\n        if (e.isRequest) {\r\n            return false;\r\n        }\r\n        var target = e.inputEvent.target;\r\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"warpable\"));\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        var datas = e.datas, inputEvent = e.inputEvent;\r\n        var target = moveable.props.target;\r\n        var inputTarget = inputEvent.target;\r\n        var direction = getDirection(inputTarget, datas);\r\n        if (!direction || !target) {\r\n            return false;\r\n        }\r\n        var state = moveable.state;\r\n        var transformOrigin = state.transformOrigin, is3d = state.is3d, targetTransform = state.targetTransform, targetMatrix = state.targetMatrix, width = state.width, height = state.height, left = state.left, top = state.top;\r\n        datas.datas = {};\r\n        datas.targetTransform = targetTransform;\r\n        datas.warpTargetMatrix = is3d ? targetMatrix : (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);\r\n        datas.targetInverseMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.ignoreDimension)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(datas.warpTargetMatrix, 4), 3, 4);\r\n        datas.direction = direction;\r\n        datas.left = left;\r\n        datas.top = top;\r\n        datas.poses = [\r\n            [0, 0],\r\n            [width, 0],\r\n            [0, height],\r\n            [width, height],\r\n        ].map(function (p) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(p, transformOrigin); });\r\n        datas.nextPoses = datas.poses.map(function (_a) {\r\n            var _b = __read(_a, 2), x = _b[0], y = _b[1];\r\n            return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.calculate)(datas.warpTargetMatrix, [x, y, 0, 1], 4);\r\n        });\r\n        datas.startValue = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4);\r\n        datas.prevMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(4);\r\n        datas.absolutePoses = getAbsolutePosesByState(state);\r\n        datas.posIndexes = getPosIndexesByDirection(direction);\r\n        setDragStart(moveable, e);\r\n        setDefaultTransformIndex(moveable, e, \"matrix3d\");\r\n        state.snapRenderInfo = {\r\n            request: e.isRequest,\r\n            direction: direction,\r\n        };\r\n        var params = fillParams(moveable, e, __assign({ set: function (matrix) {\r\n                datas.startValue = matrix;\r\n            } }, fillTransformStartEvent(moveable, e)));\r\n        var result = triggerEvent(moveable, \"onWarpStart\", params);\r\n        if (result !== false) {\r\n            datas.isWarp = true;\r\n        }\r\n        return datas.isWarp;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        var datas = e.datas, isRequest = e.isRequest;\r\n        var distX = e.distX, distY = e.distY;\r\n        var targetInverseMatrix = datas.targetInverseMatrix, prevMatrix = datas.prevMatrix, isWarp = datas.isWarp, startValue = datas.startValue, poses = datas.poses, posIndexes = datas.posIndexes, absolutePoses = datas.absolutePoses;\r\n        if (!isWarp) {\r\n            return false;\r\n        }\r\n        resolveTransformEvent(moveable, e, \"matrix3d\");\r\n        if (hasGuidelines(moveable, \"warpable\")) {\r\n            var selectedPoses = posIndexes.map(function (index) { return absolutePoses[index]; });\r\n            if (selectedPoses.length > 1) {\r\n                selectedPoses.push([\r\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\r\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\r\n                ]);\r\n            }\r\n            var _a = checkMoveableSnapBounds(moveable, isRequest, {\r\n                horizontal: selectedPoses.map(function (pos) { return pos[1] + distY; }),\r\n                vertical: selectedPoses.map(function (pos) { return pos[0] + distX; }),\r\n            }), horizontalSnapInfo = _a.horizontal, verticalSnapInfo = _a.vertical;\r\n            distY -= horizontalSnapInfo.offset;\r\n            distX -= verticalSnapInfo.offset;\r\n        }\r\n        var dist = getDragDist({ datas: datas, distX: distX, distY: distY }, true);\r\n        var nextPoses = datas.nextPoses.slice();\r\n        posIndexes.forEach(function (index) {\r\n            nextPoses[index] = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(nextPoses[index], dist);\r\n        });\r\n        if (!NEARBY_POS.every(function (nearByPoses) { return isValidPos(nearByPoses.map(function (i) { return poses[i]; }), nearByPoses.map(function (i) { return nextPoses[i]; })); })) {\r\n            return false;\r\n        }\r\n        var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);\r\n        if (!h.length) {\r\n            return false;\r\n        }\r\n        // B * A * M\r\n        var afterMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(targetInverseMatrix, h, 4);\r\n        // B * M * A\r\n        var matrix = getTransfromMatrix(datas, afterMatrix, true);\r\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.invert)(prevMatrix, 4), matrix, 4);\r\n        datas.prevMatrix = matrix;\r\n        var totalMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(startValue, matrix, 4);\r\n        var nextTransform = convertTransformFormat(datas, \"matrix3d(\".concat(totalMatrix.join(\", \"), \")\"), \"matrix3d(\".concat(matrix.join(\", \"), \")\"));\r\n        fillOriginalTransform(e, nextTransform);\r\n        triggerEvent(moveable, \"onWarp\", fillParams(moveable, e, __assign({ delta: delta, matrix: totalMatrix, dist: matrix, multiply: _scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply, transform: nextTransform }, fillCSSObject({\r\n            transform: nextTransform,\r\n        }, e))));\r\n        return true;\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        var datas = e.datas, isDrag = e.isDrag;\r\n        if (!datas.isWarp) {\r\n            return false;\r\n        }\r\n        datas.isWarp = false;\r\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams(moveable, e, {}));\r\n        return isDrag;\r\n    },\r\n};\r\n/**\r\n * Whether or not target can be warped. (default: false)\r\n * @name Moveable.Warpable#warpable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.warpable = true;\r\n */\r\n/**\r\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\r\n* @name Moveable.Warpable#renderDirections\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     warpable: true,\r\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\r\n* });\r\n*\r\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\r\n*/\r\n/**\r\n* When the warp starts, the warpStart event is called.\r\n* @memberof Moveable.Warpable\r\n* @event warpStart\r\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, { warpable: true });\r\n* moveable.on(\"warpStart\", ({ target }) => {\r\n*     console.log(target);\r\n* });\r\n*/\r\n/**\r\n * When warping, the warp event is called.\r\n * @memberof Moveable.Warpable\r\n * @event warp\r\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n * let matrix = [\r\n *  1, 0, 0, 0,\r\n *  0, 1, 0, 0,\r\n *  0, 0, 1, 0,\r\n *  0, 0, 0, 1,\r\n * ];\r\n * const moveable = new Moveable(document.body, { warpable: true });\r\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\r\n *    // target.style.transform = transform;\r\n *    matrix = multiply(matrix, delta);\r\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\r\n * });\r\n */\r\n/**\r\n * When the warp finishes, the warpEnd event is called.\r\n * @memberof Moveable.Warpable\r\n * @event warpEnd\r\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, { warpable: true });\r\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\r\n *     console.log(target, isDrag);\r\n * });\r\n */\n\nvar AREA_PIECES = /*#__PURE__*/ prefix(\"area-pieces\");\r\nvar AREA_PIECE = /*#__PURE__*/ prefix(\"area-piece\");\r\nvar AVOID = /*#__PURE__*/ prefix(\"avoid\");\r\nvar VIEW_DRAGGING = prefix(\"view-dragging\");\n\nfunction restoreStyle(moveable) {\r\n    var el = moveable.areaElement;\r\n    if (!el) {\r\n        return;\r\n    }\r\n    var _a = moveable.state, width = _a.width, height = _a.height;\r\n    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.removeClass)(el, AVOID);\r\n    el.style.cssText += \"left: 0px; top: 0px; width: \".concat(width, \"px; height: \").concat(height, \"px\");\r\n}\r\nfunction renderPieces(React) {\r\n    return (React.createElement(\"div\", { key: \"area_pieces\", className: AREA_PIECES },\r\n        React.createElement(\"div\", { className: AREA_PIECE }),\r\n        React.createElement(\"div\", { className: AREA_PIECE }),\r\n        React.createElement(\"div\", { className: AREA_PIECE }),\r\n        React.createElement(\"div\", { className: AREA_PIECE })));\r\n}\r\nvar DragArea = {\r\n    name: \"dragArea\",\r\n    props: [\r\n        \"dragArea\",\r\n        \"passDragArea\",\r\n    ],\r\n    events: [\r\n        \"click\",\r\n        \"clickGroup\",\r\n    ],\r\n    render: function (moveable, React) {\r\n        var _a = moveable.props, target = _a.target, dragArea = _a.dragArea, groupable = _a.groupable, passDragArea = _a.passDragArea;\r\n        var _b = moveable.getState(), width = _b.width, height = _b.height, renderPoses = _b.renderPoses;\r\n        var className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\r\n        if (groupable) {\r\n            return [\r\n                React.createElement(\"div\", { key: \"area\", ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(moveable, \"areaElement\"), className: className }),\r\n                renderPieces(React),\r\n            ];\r\n        }\r\n        if (!target || !dragArea) {\r\n            return [];\r\n        }\r\n        var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);\r\n        var transform = h.length ? makeMatrixCSS(h, true) : \"none\";\r\n        return [\r\n            React.createElement(\"div\", { key: \"area\", ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(moveable, \"areaElement\"), className: className, style: {\r\n                    top: \"0px\",\r\n                    left: \"0px\",\r\n                    width: \"\".concat(width, \"px\"),\r\n                    height: \"\".concat(height, \"px\"),\r\n                    transformOrigin: \"0 0\",\r\n                    transform: transform,\r\n                } }),\r\n            renderPieces(React),\r\n        ];\r\n    },\r\n    dragStart: function (moveable, _a) {\r\n        var datas = _a.datas, clientX = _a.clientX, clientY = _a.clientY, inputEvent = _a.inputEvent;\r\n        if (!inputEvent) {\r\n            return false;\r\n        }\r\n        datas.isDragArea = false;\r\n        var areaElement = moveable.areaElement;\r\n        var state = moveable.state;\r\n        var moveableClientRect = state.moveableClientRect, renderPoses = state.renderPoses, rootMatrix = state.rootMatrix, is3d = state.is3d;\r\n        var left = moveableClientRect.left, top = moveableClientRect.top;\r\n        var _b = getRect(renderPoses), relativeLeft = _b.left, relativeTop = _b.top, width = _b.width, height = _b.height;\r\n        var n = is3d ? 4 : 3;\r\n        var _c = __read(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), 2), posX = _c[0], posY = _c[1];\r\n        posX -= relativeLeft;\r\n        posY -= relativeTop;\r\n        var rects = [\r\n            { left: relativeLeft, top: relativeTop, width: width, height: posY - 10 },\r\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height: height },\r\n            { left: relativeLeft, top: relativeTop + posY + 10, width: width, height: height - posY - 10 },\r\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height: height },\r\n        ];\r\n        var children = [].slice.call(areaElement.nextElementSibling.children);\r\n        rects.forEach(function (rect, i) {\r\n            children[i].style.cssText\r\n                = \"left: \".concat(rect.left, \"px;top: \").concat(rect.top, \"px; width: \").concat(rect.width, \"px; height: \").concat(rect.height, \"px;\");\r\n        });\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.addClass)(areaElement, AVOID);\r\n        state.disableNativeEvent = true;\r\n        return;\r\n    },\r\n    drag: function (moveable, _a) {\r\n        var datas = _a.datas, inputEvent = _a.inputEvent;\r\n        this.enableNativeEvent(moveable);\r\n        if (!inputEvent) {\r\n            return false;\r\n        }\r\n        if (!datas.isDragArea) {\r\n            datas.isDragArea = true;\r\n            restoreStyle(moveable);\r\n        }\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        this.enableNativeEvent(moveable);\r\n        var inputEvent = e.inputEvent, datas = e.datas;\r\n        if (!inputEvent) {\r\n            return false;\r\n        }\r\n        if (!datas.isDragArea) {\r\n            restoreStyle(moveable);\r\n        }\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        return this.dragStart(moveable, e);\r\n    },\r\n    dragGroup: function (moveable, e) {\r\n        return this.drag(moveable, e);\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        return this.dragEnd(moveable, e);\r\n    },\r\n    unset: function (moveable) {\r\n        restoreStyle(moveable);\r\n        moveable.state.disableNativeEvent = false;\r\n    },\r\n    enableNativeEvent: function (moveable) {\r\n        var state = moveable.state;\r\n        if (state.disableNativeEvent) {\r\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.requestAnimationFrame)(function () {\r\n                state.disableNativeEvent = false;\r\n            });\r\n        }\r\n    },\r\n};\r\n/**\r\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\r\n * @name Moveable#dragArea\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  dragArea: false,\r\n * });\r\n */\r\n/**\r\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\r\n * @name Moveable#passDragArea\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  dragArea: false,\r\n * });\r\n */\n\nvar Origin = makeAble(\"origin\", {\r\n    props: [\"origin\", \"svgOrigin\"],\r\n    render: function (moveable, React) {\r\n        var _a = moveable.props, zoom = _a.zoom, svgOrigin = _a.svgOrigin, groupable = _a.groupable;\r\n        var _b = moveable.getState(), beforeOrigin = _b.beforeOrigin, rotation = _b.rotation, svg = _b.svg, allMatrix = _b.allMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\r\n        var originStyle;\r\n        if (!groupable && svg && svgOrigin) {\r\n            var _c = __read(convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight), 2), originX = _c[0], originY = _c[1];\r\n            var n = is3d ? 4 : 3;\r\n            var result = calculatePosition(allMatrix, [originX, originY], n);\r\n            originStyle = getControlTransform(rotation, zoom, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(result, [left, top]));\r\n        }\r\n        else {\r\n            originStyle = getControlTransform(rotation, zoom, beforeOrigin);\r\n        }\r\n        return [\r\n            React.createElement(\"div\", { className: prefix(\"control\", \"origin\"), style: originStyle, key: \"beforeOrigin\" }),\r\n        ];\r\n    },\r\n});\r\n/**\r\n * Whether or not the origin controlbox will be visible or not (default: true)\r\n * @name Moveable#origin\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n *\r\n * moveable.origin = true;\r\n */\n\nfunction getDefaultScrollPosition(e) {\r\n    var scrollContainer = e.scrollContainer;\r\n    return [\r\n        scrollContainer.scrollLeft,\r\n        scrollContainer.scrollTop,\r\n    ];\r\n}\r\n/**\r\n * @namespace Moveable.Scrollable\r\n * @description Whether or not target can be scrolled to the scroll container (default: false)\r\n */\r\nvar Scrollable = {\r\n    name: \"scrollable\",\r\n    canPinch: true,\r\n    props: [\r\n        \"scrollable\",\r\n        \"scrollContainer\",\r\n        \"scrollThreshold\",\r\n        \"scrollThrottleTime\",\r\n        \"getScrollPosition\",\r\n        \"scrollOptions\",\r\n    ],\r\n    events: [\r\n        \"scroll\",\r\n        \"scrollGroup\",\r\n    ],\r\n    dragRelation: \"strong\",\r\n    dragStart: function (moveable, e) {\r\n        var props = moveable.props;\r\n        var _a = props.scrollContainer, scrollContainer = _a === void 0 ? moveable.getContainer() : _a, scrollOptions = props.scrollOptions;\r\n        var dragScroll = new _scena_dragscroll__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\r\n        var scrollContainerElement = getRefTarget(scrollContainer, true);\r\n        e.datas.dragScroll = dragScroll;\r\n        moveable.state.dragScroll = dragScroll;\r\n        var gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\r\n        var targets = e.targets;\r\n        dragScroll.on(\"scroll\", function (_a) {\r\n            var container = _a.container, direction = _a.direction;\r\n            var params = fillParams(moveable, e, {\r\n                scrollContainer: container,\r\n                direction: direction,\r\n            });\r\n            var eventName = targets ? \"onScrollGroup\" : \"onScroll\";\r\n            if (targets) {\r\n                params.targets = targets;\r\n            }\r\n            triggerEvent(moveable, eventName, params);\r\n        }).on(\"move\", function (_a) {\r\n            var offsetX = _a.offsetX, offsetY = _a.offsetY, inputEvent = _a.inputEvent;\r\n            moveable[gestoName].scrollBy(offsetX, offsetY, inputEvent.inputEvent, false);\r\n        }).on(\"scrollDrag\", function (_a) {\r\n            var next = _a.next;\r\n            next(moveable[gestoName].getCurrentEvent());\r\n        });\r\n        dragScroll.dragStart(e, __assign({ container: scrollContainerElement }, scrollOptions));\r\n    },\r\n    checkScroll: function (moveable, e) {\r\n        var dragScroll = e.datas.dragScroll;\r\n        if (!dragScroll) {\r\n            return;\r\n        }\r\n        var _a = moveable.props, _b = _a.scrollContainer, scrollContainer = _b === void 0 ? moveable.getContainer() : _b, _c = _a.scrollThreshold, scrollThreshold = _c === void 0 ? 0 : _c, _d = _a.scrollThrottleTime, scrollThrottleTime = _d === void 0 ? 0 : _d, _e = _a.getScrollPosition, getScrollPosition = _e === void 0 ? getDefaultScrollPosition : _e, scrollOptions = _a.scrollOptions;\r\n        dragScroll.drag(e, __assign({ container: scrollContainer, threshold: scrollThreshold, throttleTime: scrollThrottleTime, getScrollPosition: function (ev) {\r\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\r\n            } }, scrollOptions));\r\n        return true;\r\n    },\r\n    drag: function (moveable, e) {\r\n        return this.checkScroll(moveable, e);\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        e.datas.dragScroll.dragEnd();\r\n        e.datas.dragScroll = null;\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        return this.dragStart(moveable, __assign(__assign({}, e), { isControl: true }));\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        return this.drag(moveable, e);\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        return this.dragEnd(moveable, e);\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        return this.dragStart(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    dragGroup: function (moveable, e) {\r\n        return this.drag(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        return this.dragEnd(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    dragGroupControlStart: function (moveable, e) {\r\n        return this.dragStart(moveable, __assign(__assign({}, e), { targets: moveable.props.targets, isControl: true }));\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        return this.drag(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    dragGroupControEnd: function (moveable, e) {\r\n        return this.dragEnd(moveable, __assign(__assign({}, e), { targets: moveable.props.targets }));\r\n    },\r\n    unset: function (moveable) {\r\n        var _a;\r\n        var state = moveable.state;\r\n        (_a = state.dragScroll) === null || _a === void 0 ? void 0 : _a.dragEnd();\r\n        state.dragScroll = null;\r\n    },\r\n};\r\n/**\r\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\r\n * @memberof Moveable.Scrollable\r\n * @event scroll\r\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\r\n *   scrollContainer.scrollLeft += direction[0] * 10;\r\n *   scrollContainer.scrollTop += direction[1] * 10;\r\n * });\r\n */\r\n/**\r\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\r\n * @memberof Moveable.Scrollable\r\n * @event scrollGroup\r\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\r\n *   scrollContainer.scrollLeft += direction[0] * 10;\r\n *   scrollContainer.scrollTop += direction[1] * 10;\r\n * });\r\n */\n\nvar Default = {\r\n    name: \"\",\r\n    props: [\r\n        \"target\",\r\n        \"dragTargetSelf\",\r\n        \"dragTarget\",\r\n        \"dragContainer\",\r\n        \"container\",\r\n        \"warpSelf\",\r\n        \"rootContainer\",\r\n        \"useResizeObserver\",\r\n        \"useMutationObserver\",\r\n        \"zoom\",\r\n        \"dragFocusedInput\",\r\n        \"transformOrigin\",\r\n        \"ables\",\r\n        \"className\",\r\n        \"pinchThreshold\",\r\n        \"pinchOutside\",\r\n        \"triggerAblesSimultaneously\",\r\n        \"checkInput\",\r\n        \"cspNonce\",\r\n        \"translateZ\",\r\n        \"hideDefaultLines\",\r\n        \"props\",\r\n        \"flushSync\",\r\n        \"stopPropagation\",\r\n        \"preventClickEventOnDrag\",\r\n        \"preventClickDefault\",\r\n        \"viewContainer\",\r\n        \"persistData\",\r\n        \"useAccuratePosition\",\r\n        \"firstRenderState\",\r\n        \"linePadding\",\r\n        \"controlPadding\",\r\n        \"preventDefault\",\r\n        \"preventRightClick\",\r\n        \"preventWheelClick\",\r\n        \"requestStyles\",\r\n    ],\r\n    events: [\r\n        \"changeTargets\",\r\n    ],\r\n};\n\nvar Padding = makeAble(\"padding\", {\r\n    props: [\"padding\"],\r\n    render: function (moveable, React) {\r\n        var props = moveable.props;\r\n        if (props.dragArea) {\r\n            return [];\r\n        }\r\n        var _a = getPaddingBox(props.padding || {}), left = _a.left, top = _a.top, right = _a.right, bottom = _a.bottom;\r\n        var _b = moveable.getState(), renderPoses = _b.renderPoses, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4;\r\n        var poses = [pos1, pos2, pos3, pos4];\r\n        var paddingDirections = [];\r\n        if (left > 0) {\r\n            paddingDirections.push([0, 2]);\r\n        }\r\n        if (top > 0) {\r\n            paddingDirections.push([0, 1]);\r\n        }\r\n        if (right > 0) {\r\n            paddingDirections.push([1, 3]);\r\n        }\r\n        if (bottom > 0) {\r\n            paddingDirections.push([2, 3]);\r\n        }\r\n        return paddingDirections.map(function (_a, i) {\r\n            var _b = __read(_a, 2), dir1 = _b[0], dir2 = _b[1];\r\n            var paddingPos1 = poses[dir1];\r\n            var paddingPos2 = poses[dir2];\r\n            var paddingPos3 = renderPoses[dir1];\r\n            var paddingPos4 = renderPoses[dir2];\r\n            var h = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createWarpMatrix)([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);\r\n            if (!h.length) {\r\n                return undefined;\r\n            }\r\n            return (React.createElement(\"div\", { key: \"padding\".concat(i), className: prefix(\"padding\"), style: {\r\n                    transform: makeMatrixCSS(h, true),\r\n                } }));\r\n        });\r\n    },\r\n});\r\n/**\r\n * Add padding around the target to increase the drag area.\r\n * @name Moveable#padding\r\n * @default null\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  target: document.querySelector(\".target\"),\r\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\r\n * });\r\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\r\n * moveable.updateRect();\r\n */\n\nvar RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\r\nfunction calculateRatio(values, size) {\r\n    var sumSize = values[0] + values[1];\r\n    var sumRatio = sumSize > size ? size / sumSize : 1;\r\n    values[0] *= sumRatio;\r\n    values[1] = size - values[1] * sumRatio;\r\n    return values;\r\n}\r\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\r\nvar VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\r\nvar HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];\r\nvar VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\r\nfunction getRadiusStyles(nextPoses, isRelative, width, height, left, top, right, bottom) {\r\n    if (left === void 0) { left = 0; }\r\n    if (top === void 0) { top = 0; }\r\n    if (right === void 0) { right = width; }\r\n    if (bottom === void 0) { bottom = height; }\r\n    var clipStyles = [];\r\n    var isVertical = false;\r\n    var radiusPoses = nextPoses.filter(function (pos) { return !pos.virtual; });\r\n    var raws = radiusPoses.map(function (posInfo) {\r\n        var horizontal = posInfo.horizontal, vertical = posInfo.vertical, pos = posInfo.pos;\r\n        if (vertical && !isVertical) {\r\n            isVertical = true;\r\n            clipStyles.push(\"/\");\r\n        }\r\n        if (isVertical) {\r\n            var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\r\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\r\n            return rawPos;\r\n        }\r\n        else {\r\n            var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\r\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\r\n            return rawPos;\r\n        }\r\n    });\r\n    return {\r\n        radiusPoses: radiusPoses,\r\n        styles: clipStyles,\r\n        raws: raws,\r\n    };\r\n}\r\nfunction getRadiusRange(controlPoses) {\r\n    // [start, length]\r\n    var horizontalRange = [0, 0];\r\n    var verticalRange = [0, 0];\r\n    var length = controlPoses.length;\r\n    for (var i = 0; i < length; ++i) {\r\n        var clipPose = controlPoses[i];\r\n        if (!clipPose.sub) {\r\n            continue;\r\n        }\r\n        if (clipPose.horizontal) {\r\n            if (horizontalRange[1] === 0) {\r\n                horizontalRange[0] = i;\r\n            }\r\n            horizontalRange[1] = i - horizontalRange[0] + 1;\r\n            verticalRange[0] = i + 1;\r\n        }\r\n        if (clipPose.vertical) {\r\n            if (verticalRange[1] === 0) {\r\n                verticalRange[0] = i;\r\n            }\r\n            verticalRange[1] = i - verticalRange[0] + 1;\r\n        }\r\n    }\r\n    return {\r\n        horizontalRange: horizontalRange,\r\n        verticalRange: verticalRange,\r\n    };\r\n}\r\nfunction getRadiusValues(values, width, height, left, top, minCounts, full) {\r\n    var _a, _b, _c, _d;\r\n    if (minCounts === void 0) { minCounts = [0, 0]; }\r\n    if (full === void 0) { full = false; }\r\n    var splitIndex = values.indexOf(\"/\");\r\n    var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\r\n    var horizontalValues = values.slice(0, splitLength);\r\n    var verticalValues = values.slice(splitLength + 1);\r\n    var horizontalValuesLength = horizontalValues.length;\r\n    var verticalValuesLength = verticalValues.length;\r\n    var hasVerticalValues = verticalValuesLength > 0;\r\n    var _e = __read(horizontalValues, 4), _f = _e[0], nwValue = _f === void 0 ? \"0px\" : _f, _g = _e[1], neValue = _g === void 0 ? nwValue : _g, _h = _e[2], seValue = _h === void 0 ? nwValue : _h, _j = _e[3], swValue = _j === void 0 ? neValue : _j;\r\n    var _k = __read(verticalValues, 4), _l = _k[0], wnValue = _l === void 0 ? nwValue : _l, _m = _k[1], enValue = _m === void 0 ? hasVerticalValues ? wnValue : neValue : _m, _o = _k[2], esValue = _o === void 0 ? hasVerticalValues ? wnValue : seValue : _o, _p = _k[3], wsValue = _p === void 0 ? hasVerticalValues ? enValue : swValue : _p;\r\n    var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, width); });\r\n    var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, height); });\r\n    var horizontalPoses = horizontalRawPoses.slice();\r\n    var verticalPoses = verticalRawPoses.slice();\r\n    _a = __read(calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), 2), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];\r\n    _b = __read(calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), 2), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];\r\n    _c = __read(calculateRatio([verticalPoses[0], verticalPoses[3]], height), 2), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];\r\n    _d = __read(calculateRatio([verticalPoses[1], verticalPoses[2]], height), 2), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];\r\n    var nextHorizontalPoses = full\r\n        ? horizontalPoses\r\n        : horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValuesLength));\r\n    var nextVerticalPoses = full\r\n        ? verticalPoses\r\n        : verticalPoses.slice(0, Math.max(minCounts[1], verticalValuesLength));\r\n    return __spreadArray(__spreadArray([], __read(nextHorizontalPoses.map(function (pos, i) {\r\n        var direction = RADIUS_DIRECTIONS[i];\r\n        return {\r\n            virtual: i >= horizontalValuesLength,\r\n            horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\r\n            vertical: 0,\r\n            pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\r\n            sub: true,\r\n            raw: horizontalRawPoses[i],\r\n            direction: direction,\r\n        };\r\n    })), false), __read(nextVerticalPoses.map(function (pos, i) {\r\n        var direction = RADIUS_DIRECTIONS[i];\r\n        return {\r\n            virtual: i >= verticalValuesLength,\r\n            horizontal: 0,\r\n            vertical: VERTICAL_RADIUS_DIRECTIONS[i],\r\n            pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\r\n            sub: true,\r\n            raw: verticalRawPoses[i],\r\n            direction: direction,\r\n        };\r\n    })), false);\r\n}\r\nfunction removeRadiusPos(controlPoses, poses, index, startIndex, length) {\r\n    if (length === void 0) { length = poses.length; }\r\n    var _a = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a.horizontalRange, verticalRange = _a.verticalRange;\r\n    var radiuslIndex = index - startIndex;\r\n    var deleteCount = 0;\r\n    if (radiuslIndex === 0) {\r\n        deleteCount = length;\r\n    }\r\n    else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\r\n        deleteCount = horizontalRange[1] - radiuslIndex;\r\n    }\r\n    else if (radiuslIndex >= verticalRange[0]) {\r\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\r\n    }\r\n    else {\r\n        return;\r\n    }\r\n    controlPoses.splice(index, deleteCount);\r\n    poses.splice(index, deleteCount);\r\n}\r\nfunction addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {\r\n    if (left === void 0) { left = 0; }\r\n    if (top === void 0) { top = 0; }\r\n    var _a = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a.horizontalRange, verticalRange = _a.verticalRange;\r\n    if (horizontalIndex > -1) {\r\n        var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\r\n            ? distX - left\r\n            : right - distX;\r\n        for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {\r\n            var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\r\n            var x = 0;\r\n            if (horizontalIndex === i) {\r\n                x = distX;\r\n            }\r\n            else if (i === 0) {\r\n                x = left + radiusX;\r\n            }\r\n            else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\r\n                x = right - (poses[startIndex][0] - left);\r\n            }\r\n            controlPoses.splice(startIndex + i, 0, {\r\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\r\n                vertical: 0,\r\n                pos: [x, y],\r\n            });\r\n            poses.splice(startIndex + i, 0, [x, y]);\r\n            if (i === 0) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else if (verticalIndex > -1) {\r\n        var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\r\n            ? distY - top\r\n            : bottom - distY;\r\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\r\n            var pos = [\r\n                left + radiusY,\r\n                top,\r\n            ];\r\n            controlPoses.push({\r\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\r\n                vertical: 0,\r\n                pos: pos,\r\n            });\r\n            poses.push(pos);\r\n        }\r\n        var startVerticalIndex = verticalRange[0];\r\n        for (var i = verticalRange[1]; i <= verticalIndex; ++i) {\r\n            var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\r\n            var y = 0;\r\n            if (verticalIndex === i) {\r\n                y = distY;\r\n            }\r\n            else if (i === 0) {\r\n                y = top + radiusY;\r\n            }\r\n            else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\r\n                y = poses[startIndex + startVerticalIndex][1];\r\n            }\r\n            else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\r\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\r\n            }\r\n            controlPoses.push({\r\n                horizontal: 0,\r\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\r\n                pos: [x, y],\r\n            });\r\n            poses.push([x, y]);\r\n            if (i === 0) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction splitRadiusPoses(controlPoses, raws) {\r\n    if (raws === void 0) { raws = controlPoses.map(function (pos) { return pos.raw; }); }\r\n    var horizontals = controlPoses\r\n        .map(function (pos, i) { return pos.horizontal ? raws[i] : null; }).filter(function (pos) { return pos != null; });\r\n    var verticals = controlPoses\r\n        .map(function (pos, i) { return pos.vertical ? raws[i] : null; }).filter(function (pos) { return pos != null; });\r\n    return {\r\n        horizontals: horizontals,\r\n        verticals: verticals,\r\n    };\r\n}\n\nvar CLIP_DIRECTIONS = [\r\n    [0, -1, \"n\"],\r\n    [1, 0, \"e\"],\r\n];\r\nvar CLIP_RECT_DIRECTIONS = [\r\n    [-1, -1, \"nw\"],\r\n    [0, -1, \"n\"],\r\n    [1, -1, \"ne\"],\r\n    [1, 0, \"e\"],\r\n    [1, 1, \"se\"],\r\n    [0, 1, \"s\"],\r\n    [-1, 1, \"sw\"],\r\n    [-1, 0, \"w\"],\r\n];\r\n// 1 2 5 6 0 3 4 7\r\n// 0 1 2 3 4 5 6 7\r\nfunction getClipStyles(moveable, clipPath, poses) {\r\n    var clipRelative = moveable.props.clipRelative;\r\n    var _a = moveable.state, width = _a.width, height = _a.height;\r\n    var _b = clipPath, clipType = _b.type, clipPoses = _b.poses;\r\n    var isRect = clipType === \"rect\";\r\n    var isCircle = clipType === \"circle\";\r\n    if (clipType === \"polygon\") {\r\n        return poses.map(function (pos) { return \"\".concat(convertCSSSize(pos[0], width, clipRelative), \" \").concat(convertCSSSize(pos[1], height, clipRelative)); });\r\n    }\r\n    else if (isRect || clipType === \"inset\") {\r\n        var top_1 = poses[1][1];\r\n        var right = poses[3][0];\r\n        var left = poses[7][0];\r\n        var bottom = poses[5][1];\r\n        if (isRect) {\r\n            return [\r\n                top_1,\r\n                right,\r\n                bottom,\r\n                left,\r\n            ].map(function (pos) { return \"\".concat(pos, \"px\"); });\r\n        }\r\n        var clipStyles = [top_1, width - right, height - bottom, left]\r\n            .map(function (pos, i) { return convertCSSSize(pos, i % 2 ? width : height, clipRelative); });\r\n        if (poses.length > 8) {\r\n            var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[4], poses[0]), 2), subWidth = _c[0], subHeight = _c[1];\r\n            clipStyles.push.apply(clipStyles, __spreadArray([\"round\"], __read(getRadiusStyles(clipPoses.slice(8).map(function (info, i) {\r\n                return __assign(__assign({}, info), { pos: poses[i] });\r\n            }), clipRelative, subWidth, subHeight, left, top_1, right, bottom).styles), false));\r\n        }\r\n        return clipStyles;\r\n    }\r\n    else if (isCircle || clipType === \"ellipse\") {\r\n        var center = poses[0];\r\n        var ry = convertCSSSize(abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);\r\n        var clipStyles = isCircle ? [ry]\r\n            : [convertCSSSize(abs(poses[2][0] - center[0]), width, clipRelative), ry];\r\n        clipStyles.push(\"at\", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));\r\n        return clipStyles;\r\n    }\r\n}\r\nfunction getRectPoses(top, right, bottom, left) {\r\n    var xs = [left, (left + right) / 2, right];\r\n    var ys = [top, (top + bottom) / 2, bottom];\r\n    return CLIP_RECT_DIRECTIONS.map(function (_a) {\r\n        var _b = __read(_a, 3), dirx = _b[0], diry = _b[1], dir = _b[2];\r\n        var x = xs[dirx + 1];\r\n        var y = ys[diry + 1];\r\n        return {\r\n            vertical: abs(diry),\r\n            horizontal: abs(dirx),\r\n            direction: dir,\r\n            pos: [x, y],\r\n        };\r\n    });\r\n}\r\nfunction getControlSize(controlPoses) {\r\n    var xRange = [Infinity, -Infinity];\r\n    var yRange = [Infinity, -Infinity];\r\n    controlPoses.forEach(function (_a) {\r\n        var pos = _a.pos;\r\n        xRange[0] = Math.min(xRange[0], pos[0]);\r\n        xRange[1] = Math.max(xRange[1], pos[0]);\r\n        yRange[0] = Math.min(yRange[0], pos[1]);\r\n        yRange[1] = Math.max(yRange[1], pos[1]);\r\n    });\r\n    return [\r\n        abs(xRange[1] - xRange[0]),\r\n        abs(yRange[1] - yRange[0]),\r\n    ];\r\n}\r\nfunction getClipPath(target, width, height, defaultClip, customClip) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n    if (!target) {\r\n        return;\r\n    }\r\n    var clipText = customClip;\r\n    if (!clipText) {\r\n        var getStyle = getCachedStyle(target);\r\n        var clipPath = getStyle(\"clipPath\");\r\n        clipText = clipPath !== \"none\" ? clipPath : getStyle(\"clip\");\r\n    }\r\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\r\n        clipText = defaultClip;\r\n        if (!clipText) {\r\n            return;\r\n        }\r\n    }\r\n    var _k = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitBracket)(clipText), _l = _k.prefix, clipPrefix = _l === void 0 ? clipText : _l, _m = _k.value, value = _m === void 0 ? \"\" : _m;\r\n    var isCircle = clipPrefix === \"circle\";\r\n    var splitter = \" \";\r\n    if (clipPrefix === \"polygon\") {\r\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitComma)(value || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\r\n        splitter = \",\";\r\n        var poses = values.map(function (pos) {\r\n            var _a = __read(pos.split(\" \"), 2), xPos = _a[0], yPos = _a[1];\r\n            return {\r\n                vertical: 1,\r\n                horizontal: 1,\r\n                pos: [\r\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(xPos, width),\r\n                    (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(yPos, height),\r\n                ],\r\n            };\r\n        });\r\n        var minMaxs = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)(poses.map(function (pos) { return pos.pos; }));\r\n        return {\r\n            type: clipPrefix,\r\n            clipText: clipText,\r\n            poses: poses,\r\n            splitter: splitter,\r\n            left: minMaxs.minX,\r\n            right: minMaxs.maxX,\r\n            top: minMaxs.minY,\r\n            bottom: minMaxs.maxY,\r\n        };\r\n    }\r\n    else if (isCircle || clipPrefix === \"ellipse\") {\r\n        var xPos = \"\";\r\n        var yPos = \"\";\r\n        var radiusX_1 = 0;\r\n        var radiusY_1 = 0;\r\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(value);\r\n        if (isCircle) {\r\n            var radius = \"\";\r\n            _a = __read(values, 4), _b = _a[0], radius = _b === void 0 ? \"50%\" : _b, _c = _a[2], xPos = _c === void 0 ? \"50%\" : _c, _d = _a[3], yPos = _d === void 0 ? \"50%\" : _d;\r\n            radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(radius, Math.sqrt((width * width + height * height) / 2));\r\n            radiusY_1 = radiusX_1;\r\n        }\r\n        else {\r\n            var xRadius = \"\";\r\n            var yRadius = \"\";\r\n            _e = __read(values, 5), _f = _e[0], xRadius = _f === void 0 ? \"50%\" : _f, _g = _e[1], yRadius = _g === void 0 ? \"50%\" : _g, _h = _e[3], xPos = _h === void 0 ? \"50%\" : _h, _j = _e[4], yPos = _j === void 0 ? \"50%\" : _j;\r\n            radiusX_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(xRadius, width);\r\n            radiusY_1 = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(yRadius, height);\r\n        }\r\n        var centerPos_1 = [\r\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(xPos, width),\r\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(yPos, height),\r\n        ];\r\n        var poses = __spreadArray([\r\n            {\r\n                vertical: 1,\r\n                horizontal: 1,\r\n                pos: centerPos_1,\r\n                direction: \"nesw\",\r\n            }\r\n        ], __read(CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) { return ({\r\n            vertical: abs(dir[1]),\r\n            horizontal: dir[0],\r\n            direction: dir[2],\r\n            sub: true,\r\n            pos: [\r\n                centerPos_1[0] + dir[0] * radiusX_1,\r\n                centerPos_1[1] + dir[1] * radiusY_1,\r\n            ],\r\n        }); })), false);\r\n        return {\r\n            type: clipPrefix,\r\n            clipText: clipText,\r\n            radiusX: radiusX_1,\r\n            radiusY: radiusY_1,\r\n            left: centerPos_1[0] - radiusX_1,\r\n            top: centerPos_1[1] - radiusY_1,\r\n            right: centerPos_1[0] + radiusX_1,\r\n            bottom: centerPos_1[1] + radiusY_1,\r\n            poses: poses,\r\n            splitter: splitter,\r\n        };\r\n    }\r\n    else if (clipPrefix === \"inset\") {\r\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(value || \"0 0 0 0\");\r\n        var roundIndex = values.indexOf(\"round\");\r\n        var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\r\n        var radiusValues = values.slice(rectLength + 1);\r\n        var _o = __read(values.slice(0, rectLength), 4), topValue = _o[0], _p = _o[1], rightValue = _p === void 0 ? topValue : _p, _q = _o[2], bottomValue = _q === void 0 ? topValue : _q, _r = _o[3], leftValue = _r === void 0 ? rightValue : _r;\r\n        var _s = __read([topValue, bottomValue].map(function (pos) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, height); }), 2), top_2 = _s[0], bottom = _s[1];\r\n        var _t = __read([leftValue, rightValue].map(function (pos) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(pos, width); }), 2), left = _t[0], right = _t[1];\r\n        var nextRight = width - right;\r\n        var nextBottom = height - bottom;\r\n        var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top_2, left, top_2);\r\n        var poses = __spreadArray(__spreadArray([], __read(getRectPoses(top_2, nextRight, nextBottom, left)), false), __read(radiusPoses), false);\r\n        return {\r\n            type: \"inset\",\r\n            clipText: clipText,\r\n            poses: poses,\r\n            top: top_2,\r\n            left: left,\r\n            right: nextRight,\r\n            bottom: nextBottom,\r\n            radius: radiusValues,\r\n            splitter: splitter,\r\n        };\r\n    }\r\n    else if (clipPrefix === \"rect\") {\r\n        // top right bottom left\r\n        var values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitComma)(value || \"0px, \".concat(width, \"px, \").concat(height, \"px, 0px\"));\r\n        splitter = \",\";\r\n        var _u = __read(values.map(function (pos) {\r\n            var posValue = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitUnit)(pos).value;\r\n            return posValue;\r\n        }), 4), top_3 = _u[0], right = _u[1], bottom = _u[2], left = _u[3];\r\n        var poses = getRectPoses(top_3, right, bottom, left);\r\n        return {\r\n            type: \"rect\",\r\n            clipText: clipText,\r\n            poses: poses,\r\n            top: top_3,\r\n            right: right,\r\n            bottom: bottom,\r\n            left: left,\r\n            values: values,\r\n            splitter: splitter,\r\n        };\r\n    }\r\n    return;\r\n}\n\nfunction moveControlPos(controlPoses, index, dist, isRect, keepRatio) {\r\n    var _a = controlPoses[index], direction = _a.direction, sub = _a.sub;\r\n    var dists = controlPoses.map(function () { return [0, 0]; });\r\n    var directions = direction ? direction.split(\"\") : [];\r\n    if (isRect && index < 8) {\r\n        var verticalDirections = directions.filter(function (dir) { return dir === \"w\" || dir === \"e\"; });\r\n        var horizontalDirections = directions.filter(function (dir) { return dir === \"n\" || dir === \"s\"; });\r\n        var verticalDirection_1 = verticalDirections[0];\r\n        var horizontalDirection_1 = horizontalDirections[0];\r\n        dists[index] = dist;\r\n        var _b = __read(getControlSize(controlPoses), 2), width = _b[0], height = _b[1];\r\n        var ratio = width && height ? width / height : 0;\r\n        if (ratio && keepRatio) {\r\n            // 0 1 2\r\n            // 7   3\r\n            // 6 5 4\r\n            var fixedIndex = (index + 4) % 8;\r\n            var fixedPosition = controlPoses[fixedIndex].pos;\r\n            var sizeDirection = [0, 0];\r\n            if (direction.indexOf(\"w\") > -1) {\r\n                sizeDirection[0] = -1;\r\n            }\r\n            else if (direction.indexOf(\"e\") > -1) {\r\n                sizeDirection[0] = 1;\r\n            }\r\n            if (direction.indexOf(\"n\") > -1) {\r\n                sizeDirection[1] = -1;\r\n            }\r\n            else if (direction.indexOf(\"s\") > -1) {\r\n                sizeDirection[1] = 1;\r\n            }\r\n            var nextDist = getSizeDistByDist([width, height], dist, ratio, sizeDirection, true);\r\n            var nextWidth = width + nextDist[0];\r\n            var nextHeight = height + nextDist[1];\r\n            var top_1 = fixedPosition[1];\r\n            var bottom = fixedPosition[1];\r\n            var left = fixedPosition[0];\r\n            var right = fixedPosition[0];\r\n            if (sizeDirection[0] === -1) {\r\n                left = right - nextWidth;\r\n            }\r\n            else if (sizeDirection[0] === 1) {\r\n                right = left + nextWidth;\r\n            }\r\n            else {\r\n                left = left - nextWidth / 2;\r\n                right = right + nextWidth / 2;\r\n            }\r\n            if (sizeDirection[1] === -1) {\r\n                top_1 = bottom - nextHeight;\r\n            }\r\n            else if (sizeDirection[1] === 1) {\r\n                bottom = top_1 + nextHeight;\r\n            }\r\n            else {\r\n                top_1 = bottom - nextHeight / 2;\r\n                bottom = top_1 + nextHeight;\r\n            }\r\n            var nextControlPoses_1 = getRectPoses(top_1, right, bottom, left);\r\n            controlPoses.forEach(function (controlPose, i) {\r\n                dists[i][0] = nextControlPoses_1[i].pos[0] - controlPose.pos[0];\r\n                dists[i][1] = nextControlPoses_1[i].pos[1] - controlPose.pos[1];\r\n            });\r\n        }\r\n        else {\r\n            controlPoses.forEach(function (controlPose, i) {\r\n                var controlDir = controlPose.direction;\r\n                if (!controlDir) {\r\n                    return;\r\n                }\r\n                if (controlDir.indexOf(verticalDirection_1) > -1) {\r\n                    dists[i][0] = dist[0];\r\n                }\r\n                if (controlDir.indexOf(horizontalDirection_1) > -1) {\r\n                    dists[i][1] = dist[1];\r\n                }\r\n            });\r\n            if (verticalDirection_1) {\r\n                dists[1][0] = dist[0] / 2;\r\n                dists[5][0] = dist[0] / 2;\r\n            }\r\n            if (horizontalDirection_1) {\r\n                dists[3][1] = dist[1] / 2;\r\n                dists[7][1] = dist[1] / 2;\r\n            }\r\n        }\r\n    }\r\n    else if (direction && !sub) {\r\n        directions.forEach(function (dir) {\r\n            var isVertical = dir === \"n\" || dir === \"s\";\r\n            controlPoses.forEach(function (controlPose, i) {\r\n                var dirDir = controlPose.direction, dirHorizontal = controlPose.horizontal, dirVertical = controlPose.vertical;\r\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\r\n                    return;\r\n                }\r\n                dists[i] = [\r\n                    isVertical || !dirHorizontal ? 0 : dist[0],\r\n                    !isVertical || !dirVertical ? 0 : dist[1],\r\n                ];\r\n            });\r\n        });\r\n    }\r\n    else {\r\n        dists[index] = dist;\r\n    }\r\n    return dists;\r\n}\r\nfunction addClipPath(moveable, e) {\r\n    var _a = __read(calculatePointerDist(moveable, e), 2), distX = _a[0], distY = _a[1];\r\n    var _b = e.datas, clipPath = _b.clipPath, clipIndex = _b.clipIndex;\r\n    var _c = clipPath, clipType = _c.type, clipPoses = _c.poses, splitter = _c.splitter;\r\n    var poses = clipPoses.map(function (pos) { return pos.pos; });\r\n    if (clipType === \"polygon\") {\r\n        poses.splice(clipIndex, 0, [distX, distY]);\r\n    }\r\n    else if (clipType === \"inset\") {\r\n        var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\r\n        var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\r\n        var length_1 = clipPoses.length;\r\n        addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);\r\n        if (length_1 === clipPoses.length) {\r\n            return;\r\n        }\r\n    }\r\n    else {\r\n        return;\r\n    }\r\n    var clipStyles = getClipStyles(moveable, clipPath, poses);\r\n    var clipStyle = \"\".concat(clipType, \"(\").concat(clipStyles.join(splitter), \")\");\r\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, __assign({ clipEventType: \"added\", clipType: clipType, poses: poses, clipStyles: clipStyles, clipStyle: clipStyle, distX: 0, distY: 0 }, fillCSSObject({\r\n        clipPath: clipStyle,\r\n    }, e))));\r\n}\r\nfunction removeClipPath(moveable, e) {\r\n    var _a = e.datas, clipPath = _a.clipPath, clipIndex = _a.clipIndex;\r\n    var _b = clipPath, clipType = _b.type, clipPoses = _b.poses, splitter = _b.splitter;\r\n    var poses = clipPoses.map(function (pos) { return pos.pos; });\r\n    var length = poses.length;\r\n    if (clipType === \"polygon\") {\r\n        clipPoses.splice(clipIndex, 1);\r\n        poses.splice(clipIndex, 1);\r\n    }\r\n    else if (clipType === \"inset\") {\r\n        if (clipIndex < 8) {\r\n            return;\r\n        }\r\n        removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\r\n        if (length === clipPoses.length) {\r\n            return;\r\n        }\r\n    }\r\n    else {\r\n        return;\r\n    }\r\n    var clipStyles = getClipStyles(moveable, clipPath, poses);\r\n    var clipStyle = \"\".concat(clipType, \"(\").concat(clipStyles.join(splitter), \")\");\r\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, __assign({ clipEventType: \"removed\", clipType: clipType, poses: poses, clipStyles: clipStyles, clipStyle: clipStyle, distX: 0, distY: 0 }, fillCSSObject({\r\n        clipPath: clipStyle,\r\n    }, e))));\r\n}\r\n/**\r\n * @namespace Moveable.Clippable\r\n * @description Whether to clip the target.\r\n */\r\nvar Clippable = {\r\n    name: \"clippable\",\r\n    props: [\r\n        \"clippable\",\r\n        \"defaultClipPath\",\r\n        \"customClipPath\",\r\n        \"keepRatio\",\r\n        \"clipRelative\",\r\n        \"clipArea\",\r\n        \"dragWithClip\",\r\n        \"clipTargetBounds\",\r\n        \"clipVerticalGuidelines\",\r\n        \"clipHorizontalGuidelines\",\r\n        \"clipSnapThreshold\",\r\n    ],\r\n    events: [\r\n        \"clipStart\",\r\n        \"clip\",\r\n        \"clipEnd\",\r\n    ],\r\n    css: [\r\n        \".control.clip-control {\\nbackground: #6d6;\\ncursor: pointer;\\n}\\n.control.clip-control.clip-radius {\\nbackground: #d66;\\n}\\n.line.clip-line {\\nbackground: #6e6;\\ncursor: move;\\nz-index: 1;\\n}\\n.clip-area {\\nposition: absolute;\\ntop: 0;\\nleft: 0;\\n}\\n.clip-ellipse {\\nposition: absolute;\\ncursor: move;\\nborder: 1px solid #6d6;\\nborder: var(--zoompx) solid #6d6;\\nborder-radius: 50%;\\ntransform-origin: 0px 0px;\\n}\",\r\n        \":host {\\n--bounds-color: #d66;\\n}\",\r\n        \".guideline {\\npointer-events: none;\\nz-index: 2;\\n}\",\r\n        \".line.guideline.bounds {\\nbackground: #d66;\\nbackground: var(--bounds-color);\\n}\",\r\n    ],\r\n    render: function (moveable, React) {\r\n        var _a = moveable.props, customClipPath = _a.customClipPath, defaultClipPath = _a.defaultClipPath, clipArea = _a.clipArea, zoom = _a.zoom, groupable = _a.groupable;\r\n        var _b = moveable.getState(), target = _b.target, width = _b.width, height = _b.height, allMatrix = _b.allMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4, clipPathState = _b.clipPathState, snapBoundInfos = _b.snapBoundInfos, rotationRad = _b.rotation;\r\n        if (!target || groupable) {\r\n            return [];\r\n        }\r\n        var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\r\n        if (!clipPath) {\r\n            return [];\r\n        }\r\n        var n = is3d ? 4 : 3;\r\n        var type = clipPath.type;\r\n        var clipPoses = clipPath.poses;\r\n        var poses = clipPoses.map(function (pos) {\r\n            // return [x, y];\r\n            var calculatedPos = calculatePosition(allMatrix, pos.pos, n);\r\n            return [\r\n                calculatedPos[0] - left,\r\n                calculatedPos[1] - top,\r\n            ];\r\n        });\r\n        var controls = [];\r\n        var lines = [];\r\n        var isRect = type === \"rect\";\r\n        var isInset = type === \"inset\";\r\n        var isPolygon = type === \"polygon\";\r\n        if (isRect || isInset || isPolygon) {\r\n            var linePoses_1 = isInset ? poses.slice(0, 8) : poses;\r\n            lines = linePoses_1.map(function (to, i) {\r\n                var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];\r\n                var rad = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getRad)(from, to);\r\n                var dist = getDiagonalSize(from, to);\r\n                return React.createElement(\"div\", { key: \"clipLine\".concat(i), className: prefix(\"line\", \"clip-line\", \"snap-control\"), \"data-clip-index\": i, style: {\r\n                        width: \"\".concat(dist, \"px\"),\r\n                        transform: \"translate(\".concat(from[0], \"px, \").concat(from[1], \"px) rotate(\").concat(rad, \"rad) scaleY(\").concat(zoom, \")\"),\r\n                    } });\r\n            });\r\n        }\r\n        controls = poses.map(function (pos, i) {\r\n            return React.createElement(\"div\", { key: \"clipControl\".concat(i), className: prefix(\"control\", \"clip-control\", \"snap-control\"), \"data-clip-index\": i, style: {\r\n                    transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rotationRad, \"rad) scale(\").concat(zoom, \")\"),\r\n                } });\r\n        });\r\n        if (isInset) {\r\n            controls.push.apply(controls, __spreadArray([], __read(poses.slice(8).map(function (pos, i) {\r\n                return React.createElement(\"div\", { key: \"clipRadiusControl\".concat(i), className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"), \"data-clip-index\": 8 + i, style: {\r\n                        transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) rotate(\").concat(rotationRad, \"rad) scale(\").concat(zoom, \")\"),\r\n                    } });\r\n            })), false));\r\n        }\r\n        if (type === \"circle\" || type === \"ellipse\") {\r\n            var clipLeft = clipPath.left, clipTop = clipPath.top, radiusX = clipPath.radiusX, radiusY = clipPath.radiusY;\r\n            var _c = __read((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)), 2), distLeft = _c[0], distTop = _c[1];\r\n            var ellipseClipPath = \"none\";\r\n            if (!clipArea) {\r\n                var piece = Math.max(10, radiusX / 5, radiusY / 5);\r\n                var areaPoses = [];\r\n                for (var i = 0; i <= piece; ++i) {\r\n                    var rad = Math.PI * 2 / piece * i;\r\n                    areaPoses.push([\r\n                        radiusX + (radiusX - zoom) * Math.cos(rad),\r\n                        radiusY + (radiusY - zoom) * Math.sin(rad),\r\n                    ]);\r\n                }\r\n                areaPoses.push([radiusX, -2]);\r\n                areaPoses.push([-2, -2]);\r\n                areaPoses.push([-2, radiusY * 2 + 2]);\r\n                areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);\r\n                areaPoses.push([radiusX * 2 + 2, -2]);\r\n                areaPoses.push([radiusX, -2]);\r\n                ellipseClipPath = \"polygon(\".concat(areaPoses.map(function (pos) { return \"\".concat(pos[0], \"px \").concat(pos[1], \"px\"); }).join(\", \"), \")\");\r\n            }\r\n            controls.push(React.createElement(\"div\", { key: \"clipEllipse\", className: prefix(\"clip-ellipse\", \"snap-control\"), style: {\r\n                    width: \"\".concat(radiusX * 2, \"px\"),\r\n                    height: \"\".concat(radiusY * 2, \"px\"),\r\n                    clipPath: ellipseClipPath,\r\n                    transform: \"translate(\".concat(-left + distLeft, \"px, \").concat(-top + distTop, \"px) \").concat(makeMatrixCSS(allMatrix)),\r\n                } }));\r\n        }\r\n        if (clipArea) {\r\n            var _d = getRect(__spreadArray([pos1, pos2, pos3, pos4], __read(poses), false)), allWidth = _d.width, allHeight = _d.height, allLeft_1 = _d.left, allTop_1 = _d.top;\r\n            if (isPolygon || isRect || isInset) {\r\n                var areaPoses = isInset ? poses.slice(0, 8) : poses;\r\n                controls.push(React.createElement(\"div\", { key: \"clipArea\", className: prefix(\"clip-area\", \"snap-control\"), style: {\r\n                        width: \"\".concat(allWidth, \"px\"),\r\n                        height: \"\".concat(allHeight, \"px\"),\r\n                        transform: \"translate(\".concat(allLeft_1, \"px, \").concat(allTop_1, \"px)\"),\r\n                        clipPath: \"polygon(\".concat(areaPoses.map(function (pos) { return \"\".concat(pos[0] - allLeft_1, \"px \").concat(pos[1] - allTop_1, \"px\"); }).join(\", \"), \")\"),\r\n                    } }));\r\n            }\r\n        }\r\n        if (snapBoundInfos) {\r\n            [\"vertical\", \"horizontal\"].forEach(function (directionType) {\r\n                var info = snapBoundInfos[directionType];\r\n                var isHorizontal = directionType === \"horizontal\";\r\n                if (info.isSnap) {\r\n                    lines.push.apply(lines, __spreadArray([], __read(info.snap.posInfos.map(function (_a, i) {\r\n                        var pos = _a.pos;\r\n                        var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\r\n                        var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\r\n                        return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\".concat(directionType, \"snap\").concat(i), \"guideline\");\r\n                    })), false));\r\n                }\r\n                if (info.isBound) {\r\n                    lines.push.apply(lines, __spreadArray([], __read(info.bounds.map(function (_a, i) {\r\n                        var pos = _a.pos;\r\n                        var snapPos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\r\n                        var snapPos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\r\n                        return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\".concat(directionType, \"bounds\").concat(i), \"guideline\", \"bounds\", \"bold\");\r\n                    })), false));\r\n                }\r\n            });\r\n        }\r\n        return __spreadArray(__spreadArray([], __read(controls), false), __read(lines), false);\r\n    },\r\n    dragControlCondition: function (moveable, e) {\r\n        return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\r\n    },\r\n    dragStart: function (moveable, e) {\r\n        var props = moveable.props;\r\n        var _a = props.dragWithClip, dragWithClip = _a === void 0 ? true : _a;\r\n        if (dragWithClip) {\r\n            return false;\r\n        }\r\n        return this.dragControlStart(moveable, e);\r\n    },\r\n    drag: function (moveable, e) {\r\n        return this.dragControl(moveable, __assign(__assign({}, e), { isDragTarget: true }));\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        return this.dragControlEnd(moveable, e);\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        var state = moveable.state;\r\n        var _a = moveable.props, defaultClipPath = _a.defaultClipPath, customClipPath = _a.customClipPath;\r\n        var target = state.target, width = state.width, height = state.height;\r\n        var inputTarget = e.inputEvent ? e.inputEvent.target : null;\r\n        var className = (inputTarget && inputTarget.getAttribute(\"class\")) || \"\";\r\n        var datas = e.datas;\r\n        var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", customClipPath);\r\n        if (!clipPath) {\r\n            return false;\r\n        }\r\n        var clipText = clipPath.clipText, type = clipPath.type, poses = clipPath.poses;\r\n        var result = triggerEvent(moveable, \"onClipStart\", fillParams(moveable, e, {\r\n            clipType: type,\r\n            clipStyle: clipText,\r\n            poses: poses.map(function (pos) { return pos.pos; }),\r\n        }));\r\n        if (result === false) {\r\n            datas.isClipStart = false;\r\n            return false;\r\n        }\r\n        datas.isControl = className && className.indexOf(\"clip-control\") > -1;\r\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\r\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\r\n        datas.clipIndex = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\r\n        datas.clipPath = clipPath;\r\n        datas.isClipStart = true;\r\n        state.clipPathState = clipText;\r\n        setDragStart(moveable, e);\r\n        return true;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        var _a, _b, _c;\r\n        var datas = e.datas, originalDatas = e.originalDatas, isDragTarget = e.isDragTarget;\r\n        if (!datas.isClipStart) {\r\n            return false;\r\n        }\r\n        var _d = datas, isControl = _d.isControl, isLine = _d.isLine, isArea = _d.isArea, clipIndex = _d.clipIndex, clipPath = _d.clipPath;\r\n        if (!clipPath) {\r\n            return false;\r\n        }\r\n        var props = getProps(moveable.props, \"clippable\");\r\n        var keepRatio = props.keepRatio;\r\n        var distX = 0;\r\n        var distY = 0;\r\n        var originalDraggable = originalDatas.draggable;\r\n        var originalDist = getDragDist(e);\r\n        if (isDragTarget && originalDraggable) {\r\n            _a = __read(originalDraggable.prevBeforeDist, 2), distX = _a[0], distY = _a[1];\r\n        }\r\n        else {\r\n            _b = __read(originalDist, 2), distX = _b[0], distY = _b[1];\r\n        }\r\n        var firstDist = [distX, distY];\r\n        var state = moveable.state;\r\n        var width = state.width, height = state.height;\r\n        var isDragWithTarget = !isArea && !isControl && !isLine;\r\n        var clipType = clipPath.type, clipPoses = clipPath.poses, splitter = clipPath.splitter;\r\n        var poses = clipPoses.map(function (pos) { return pos.pos; });\r\n        if (isDragWithTarget) {\r\n            distX = -distX;\r\n            distY = -distY;\r\n        }\r\n        var isAll = !isControl || clipPoses[clipIndex].direction === \"nesw\";\r\n        var isRect = clipType === \"inset\" || clipType === \"rect\";\r\n        var dists = clipPoses.map(function () { return [0, 0]; });\r\n        if (isControl && !isAll) {\r\n            var _e = clipPoses[clipIndex], horizontal = _e.horizontal, vertical = _e.vertical;\r\n            var dist = [\r\n                distX * abs(horizontal),\r\n                distY * abs(vertical),\r\n            ];\r\n            dists = moveControlPos(clipPoses, clipIndex, dist, isRect, keepRatio);\r\n        }\r\n        else if (isAll) {\r\n            dists = poses.map(function () { return [distX, distY]; });\r\n        }\r\n        var nextPoses = poses.map(function (pos, i) { return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, dists[i]); });\r\n        var guidePoses = __spreadArray([], __read(nextPoses), false);\r\n        state.snapBoundInfos = null;\r\n        var isCircle = clipPath.type === \"circle\";\r\n        var isEllipse = clipPath.type === \"ellipse\";\r\n        if (isCircle || isEllipse) {\r\n            var guideRect = getRect(nextPoses);\r\n            var ry = abs(guideRect.bottom - guideRect.top);\r\n            var rx = abs(isEllipse ? guideRect.right - guideRect.left : ry);\r\n            var bottom = nextPoses[0][1] + ry;\r\n            var left = nextPoses[0][0] - rx;\r\n            var right = nextPoses[0][0] + rx;\r\n            // right\r\n            if (isCircle) {\r\n                guidePoses.push([right, guideRect.bottom]);\r\n                dists.push([1, 0]);\r\n            }\r\n            // bottom\r\n            guidePoses.push([guideRect.left, bottom]);\r\n            dists.push([0, 1]);\r\n            // left\r\n            guidePoses.push([left, guideRect.bottom]);\r\n            dists.push([1, 0]);\r\n        }\r\n        var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function (v) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(v), height); }), (props.clipVerticalGuidelines || []).map(function (v) { return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.convertUnitSize)(\"\".concat(v), width); }), width, height);\r\n        var guideXPoses = [];\r\n        var guideYPoses = [];\r\n        if (isCircle || isEllipse) {\r\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\r\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\r\n        }\r\n        else if (isRect) {\r\n            var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\r\n            var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];\r\n            guideXPoses = rectPoses.filter(function (_, i) { return rectDists_1[i][0]; }).map(function (pos) { return pos[0]; });\r\n            guideYPoses = rectPoses.filter(function (_, i) { return rectDists_1[i][1]; }).map(function (pos) { return pos[1]; });\r\n        }\r\n        else {\r\n            guideXPoses = guidePoses.filter(function (_, i) { return dists[i][0]; }).map(function (pos) { return pos[0]; });\r\n            guideYPoses = guidePoses.filter(function (_, i) { return dists[i][1]; }).map(function (pos) { return pos[1]; });\r\n        }\r\n        var boundDelta = [0, 0];\r\n        var _f = checkSnapBounds(guidelines, props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height }, guideXPoses, guideYPoses, 5, 5), horizontalSnapInfo = _f.horizontal, verticalSnapInfo = _f.vertical;\r\n        var snapOffsetY = horizontalSnapInfo.offset;\r\n        var snapOffsetX = verticalSnapInfo.offset;\r\n        if (horizontalSnapInfo.isBound) {\r\n            boundDelta[1] += snapOffsetY;\r\n        }\r\n        if (verticalSnapInfo.isBound) {\r\n            boundDelta[0] += snapOffsetX;\r\n        }\r\n        if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\r\n            var guideRect = getRect(nextPoses);\r\n            var cy = guideRect.bottom - guideRect.top;\r\n            var cx = isEllipse ? guideRect.right - guideRect.left : cy;\r\n            var distSnapX = verticalSnapInfo.isBound\r\n                ? abs(snapOffsetX)\r\n                : (verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX);\r\n            var distSnapY = horizontalSnapInfo.isBound\r\n                ? abs(snapOffsetY)\r\n                : (horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY);\r\n            cx -= distSnapX;\r\n            cy -= distSnapY;\r\n            if (isCircle) {\r\n                cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\r\n                cx = cy;\r\n            }\r\n            var center = guidePoses[0];\r\n            guidePoses[1][1] = center[1] - cy;\r\n            guidePoses[2][0] = center[0] + cx;\r\n            guidePoses[3][1] = center[1] + cy;\r\n            guidePoses[4][0] = center[0] - cx;\r\n        }\r\n        else if (isRect && keepRatio && isControl) {\r\n            var _g = __read(getControlSize(clipPoses), 2), width_1 = _g[0], height_1 = _g[1];\r\n            var ratio = width_1 && height_1 ? width_1 / height_1 : 0;\r\n            var clipPose = clipPoses[clipIndex];\r\n            var direction = clipPose.direction || \"\";\r\n            var top_2 = guidePoses[1][1];\r\n            var bottom = guidePoses[5][1];\r\n            var left = guidePoses[7][0];\r\n            var right = guidePoses[3][0];\r\n            if (abs(snapOffsetY) <= abs(snapOffsetX)) {\r\n                snapOffsetY = sign(snapOffsetY) * abs(snapOffsetX) / ratio;\r\n            }\r\n            else {\r\n                snapOffsetX = sign(snapOffsetX) * abs(snapOffsetY) * ratio;\r\n            }\r\n            if (direction.indexOf(\"w\") > -1) {\r\n                left -= snapOffsetX;\r\n            }\r\n            else if (direction.indexOf(\"e\") > -1) {\r\n                right -= snapOffsetX;\r\n            }\r\n            else {\r\n                left += snapOffsetX / 2;\r\n                right -= snapOffsetX / 2;\r\n            }\r\n            if (direction.indexOf(\"n\") > -1) {\r\n                top_2 -= snapOffsetY;\r\n            }\r\n            else if (direction.indexOf(\"s\") > -1) {\r\n                bottom -= snapOffsetY;\r\n            }\r\n            else {\r\n                top_2 += snapOffsetY / 2;\r\n                bottom -= snapOffsetY / 2;\r\n            }\r\n            var nextControlPoses_2 = getRectPoses(top_2, right, bottom, left);\r\n            guidePoses.forEach(function (pos, i) {\r\n                var _a;\r\n                _a = __read(nextControlPoses_2[i].pos, 2), pos[0] = _a[0], pos[1] = _a[1];\r\n            });\r\n        }\r\n        else {\r\n            guidePoses.forEach(function (pos, j) {\r\n                var dist = dists[j];\r\n                if (dist[0]) {\r\n                    pos[0] -= snapOffsetX;\r\n                }\r\n                if (dist[1]) {\r\n                    pos[1] -= snapOffsetY;\r\n                }\r\n            });\r\n        }\r\n        var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);\r\n        var clipStyle = \"\".concat(clipType, \"(\").concat(nextClipStyles.join(splitter), \")\");\r\n        state.clipPathState = clipStyle;\r\n        if (isCircle || isEllipse) {\r\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\r\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\r\n        }\r\n        else if (isRect) {\r\n            var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\r\n            guideXPoses = rectPoses.map(function (pos) { return pos[0]; });\r\n            guideYPoses = rectPoses.map(function (pos) { return pos[1]; });\r\n        }\r\n        else {\r\n            guideXPoses = guidePoses.map(function (pos) { return pos[0]; });\r\n            guideYPoses = guidePoses.map(function (pos) { return pos[1]; });\r\n        }\r\n        state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height }, guideXPoses, guideYPoses, 1, 1);\r\n        if (originalDraggable) {\r\n            var is3d = state.is3d, allMatrix = state.allMatrix;\r\n            var n = is3d ? 4 : 3;\r\n            var dragDist = boundDelta;\r\n            if (isDragTarget) {\r\n                dragDist = [\r\n                    firstDist[0] + boundDelta[0] - originalDist[0],\r\n                    firstDist[1] + boundDelta[1] - originalDist[1],\r\n                ];\r\n            }\r\n            originalDraggable.deltaOffset = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(allMatrix, [dragDist[0], dragDist[1], 0, 0], n);\r\n        }\r\n        triggerEvent(moveable, \"onClip\", fillParams(moveable, e, __assign({ clipEventType: \"changed\", clipType: clipType, poses: nextPoses, clipStyle: clipStyle, clipStyles: nextClipStyles, distX: distX, distY: distY }, fillCSSObject((_c = {},\r\n            _c[clipType === \"rect\" ? \"clip\" : \"clipPath\"] = clipStyle,\r\n            _c), e))));\r\n        return true;\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        this.unset(moveable);\r\n        var isDrag = e.isDrag, datas = e.datas, isDouble = e.isDouble;\r\n        var isLine = datas.isLine, isClipStart = datas.isClipStart, isControl = datas.isControl;\r\n        if (!isClipStart) {\r\n            return false;\r\n        }\r\n        triggerEvent(moveable, \"onClipEnd\", fillEndParams(moveable, e, {}));\r\n        if (isDouble) {\r\n            if (isControl) {\r\n                removeClipPath(moveable, e);\r\n            }\r\n            else if (isLine) {\r\n                // add\r\n                addClipPath(moveable, e);\r\n            }\r\n        }\r\n        return isDouble || isDrag;\r\n    },\r\n    unset: function (moveable) {\r\n        moveable.state.clipPathState = \"\";\r\n        moveable.state.snapBoundInfos = null;\r\n    },\r\n};\r\n/**\r\n * Whether to clip the target. (default: false)\r\n * @name Moveable.Clippable#clippable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\r\n * @name Moveable.Clippable#defaultClipPath\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\r\n * @name Moveable.Clippable#clipRelative\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\r\n * @name Moveable.Clippable#customClipPath\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When dragging the target, the clip also moves. (default: true)\r\n * @name Moveable.Clippable#dragWithClip\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * You can drag the clip by setting clipArea.\r\n * @name Moveable.Clippable#clipArea\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n* Whether the clip is bound to the target.\r\n* @name Moveable.Clippable#clipTargetBounds\r\n* @default false\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipTargetBounds: true,\r\n* });\r\n* moveable.on(\"clipStart\", e => {\r\n*     console.log(e);\r\n* }).on(\"clip\", e => {\r\n*     if (e.clipType === \"rect\") {\r\n*         e.target.style.clip = e.clipStyle;\r\n*     } else {\r\n*         e.target.style.clipPath = e.clipStyle;\r\n*     }\r\n* }).on(\"clipEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/\r\n/**\r\n * Add clip guidelines in the vertical direction.\r\n * @name Moveable.Clippable#clipVerticalGuidelines\r\n * @default 0\r\n * @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipVerticalGuidelines: [0, 100, 200],\r\n*     clipHorizontalGuidelines: [0, 100, 200],\r\n*     clipSnapThreshold: 5,\r\n* });\r\n*/\r\n/**\r\n* Add clip guidelines in the horizontal direction.\r\n* @name Moveable.Clippable#clipHorizontalGuidelines\r\n* @default []\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipVerticalGuidelines: [0, 100, 200],\r\n*     clipHorizontalGuidelines: [0, 100, 200],\r\n*     clipSnapThreshold: 5,\r\n* });\r\n*/\r\n/**\r\n* istance value that can snap to clip guidelines.\r\n* @name Moveable.Clippable#clipSnapThreshold\r\n* @default 5\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     clippable: true,\r\n*     defaultClipPath: \"inset\",\r\n*     customClipPath: \"\",\r\n*     clipRelative: false,\r\n*     clipArea: false,\r\n*     dragWithClip: true,\r\n*     clipVerticalGuidelines: [0, 100, 200],\r\n*     clipHorizontalGuidelines: [0, 100, 200],\r\n*     clipSnapThreshold: 5,\r\n* });\r\n*/\r\n/**\r\n * When drag start the clip area or controls, the `clipStart` event is called.\r\n * @memberof Moveable.Clippable\r\n * @event clipStart\r\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag the clip area or controls, the `clip` event is called.\r\n * @memberof Moveable.Clippable\r\n * @event clip\r\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag end the clip area or controls, the `clipEnd` event is called.\r\n * @memberof Moveable.Clippable\r\n * @event clipEnd\r\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     clippable: true,\r\n *     defaultClipPath: \"inset\",\r\n *     customClipPath: \"\",\r\n *     clipRelative: false,\r\n *     clipArea: false,\r\n *     dragWithClip: true,\r\n * });\r\n * moveable.on(\"clipStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"clip\", e => {\r\n *     if (e.clipType === \"rect\") {\r\n *         e.target.style.clip = e.clipStyle;\r\n *     } else {\r\n *         e.target.style.clipPath = e.clipStyle;\r\n *     }\r\n * }).on(\"clipEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\n\n/**\r\n * @namespace OriginDraggable\r\n * @memberof Moveable\r\n * @description Whether to drag origin (default: false)\r\n */\r\nvar OriginDraggable = {\r\n    name: \"originDraggable\",\r\n    props: [\r\n        \"originDraggable\",\r\n        \"originRelative\",\r\n    ],\r\n    events: [\r\n        \"dragOriginStart\",\r\n        \"dragOrigin\",\r\n        \"dragOriginEnd\",\r\n    ],\r\n    css: [\r\n        \":host[data-able-origindraggable] .control.origin {\\npointer-events: auto;\\n}\",\r\n    ],\r\n    dragControlCondition: function (_, e) {\r\n        if (e.isRequest) {\r\n            return e.requestAble === \"originDraggable\";\r\n        }\r\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(e.inputEvent.target, prefix(\"origin\"));\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        var datas = e.datas;\r\n        setDragStart(moveable, e);\r\n        var params = fillParams(moveable, e, {\r\n            dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e)),\r\n        });\r\n        var result = triggerEvent(moveable, \"onDragOriginStart\", params);\r\n        datas.startOrigin = moveable.state.transformOrigin;\r\n        datas.startTargetOrigin = moveable.state.targetOrigin;\r\n        datas.prevOrigin = [0, 0];\r\n        datas.isDragOrigin = true;\r\n        if (result === false) {\r\n            datas.isDragOrigin = false;\r\n            return false;\r\n        }\r\n        return params;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        var datas = e.datas, isPinch = e.isPinch, isRequest = e.isRequest;\r\n        if (!datas.isDragOrigin) {\r\n            return false;\r\n        }\r\n        var _a = __read(getDragDist(e), 2), distX = _a[0], distY = _a[1];\r\n        var state = moveable.state;\r\n        var width = state.width, height = state.height, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, is3d = state.is3d;\r\n        var _b = moveable.props.originRelative, originRelative = _b === void 0 ? true : _b;\r\n        var n = is3d ? 4 : 3;\r\n        var dist = [distX, distY];\r\n        if (isRequest) {\r\n            var distOrigin = e.distOrigin;\r\n            if (distOrigin[0] || distOrigin[1]) {\r\n                dist = distOrigin;\r\n            }\r\n        }\r\n        var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(datas.startOrigin, dist);\r\n        var targetOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(datas.startTargetOrigin, dist);\r\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, datas.prevOrigin);\r\n        var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);\r\n        var rect = moveable.getRect();\r\n        var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\r\n        var dragDelta = [\r\n            rect.left - nextRect.left,\r\n            rect.top - nextRect.top,\r\n        ];\r\n        datas.prevOrigin = dist;\r\n        var transformOrigin = [\r\n            convertCSSSize(targetOrigin[0], width, originRelative),\r\n            convertCSSSize(targetOrigin[1], height, originRelative),\r\n        ].join(\" \");\r\n        var result = Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false));\r\n        var params = fillParams(moveable, e, __assign(__assign({ width: width, height: height, origin: origin, dist: dist, delta: delta, transformOrigin: transformOrigin, drag: result }, fillCSSObject({\r\n            transformOrigin: transformOrigin,\r\n            transform: result.transform,\r\n        }, e)), { afterTransform: result.transform }));\r\n        triggerEvent(moveable, \"onDragOrigin\", params);\r\n        return params;\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        var datas = e.datas;\r\n        if (!datas.isDragOrigin) {\r\n            return false;\r\n        }\r\n        triggerEvent(moveable, \"onDragOriginEnd\", fillEndParams(moveable, e, {}));\r\n        return true;\r\n    },\r\n    dragGroupControlCondition: function (moveable, e) {\r\n        return this.dragControlCondition(moveable, e);\r\n    },\r\n    dragGroupControlStart: function (moveable, e) {\r\n        var params = this.dragControlStart(moveable, e);\r\n        if (!params) {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        var params = this.dragControl(moveable, e);\r\n        if (!params) {\r\n            return false;\r\n        }\r\n        moveable.transformOrigin = params.transformOrigin;\r\n        return true;\r\n    },\r\n    /**\r\n    * @method Moveable.OriginDraggable#request\r\n    * @param {object} e - the OriginDraggable's request parameter\r\n    * @param {number} [e.x] - x position\r\n    * @param {number} [e.y] - y position\r\n    * @param {number} [e.deltaX] - x number to move\r\n    * @param {number} [e.deltaY] - y number to move\r\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\r\n    * @param {array} [e.origin] - transform-origin position\r\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\r\n    * @return {Moveable.Requester} Moveable Requester\r\n    * @example\r\n\n    * // Instantly Request (requestStart - request - requestEnd)\r\n    * // Use Relative Value\r\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\r\n    * // Use Absolute Value\r\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\r\n    * // Use Transform Value\r\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\r\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\r\n    * // requestStart\r\n    * const requester = moveable.request(\"originDraggable\");\r\n    *\r\n    * // request\r\n    * // Use Relative Value\r\n    * requester.request({ deltaX: 10, deltaY: 10 });\r\n    * requester.request({ deltaX: 10, deltaY: 10 });\r\n    * requester.request({ deltaX: 10, deltaY: 10 });\r\n    * // Use Absolute Value\r\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\r\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\r\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\r\n    *\r\n    * // requestEnd\r\n    * requester.requestEnd();\r\n    */\r\n    request: function (moveable) {\r\n        var datas = {};\r\n        var rect = moveable.getRect();\r\n        var distX = 0;\r\n        var distY = 0;\r\n        var transformOrigin = rect.transformOrigin;\r\n        var distOrigin = [0, 0];\r\n        return {\r\n            isControl: true,\r\n            requestStart: function () {\r\n                return { datas: datas };\r\n            },\r\n            request: function (e) {\r\n                if (\"deltaOrigin\" in e) {\r\n                    distOrigin[0] += e.deltaOrigin[0];\r\n                    distOrigin[1] += e.deltaOrigin[1];\r\n                }\r\n                else if (\"origin\" in e) {\r\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\r\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\r\n                }\r\n                else {\r\n                    if (\"x\" in e) {\r\n                        distX = e.x - rect.left;\r\n                    }\r\n                    else if (\"deltaX\" in e) {\r\n                        distX += e.deltaX;\r\n                    }\r\n                    if (\"y\" in e) {\r\n                        distY = e.y - rect.top;\r\n                    }\r\n                    else if (\"deltaY\" in e) {\r\n                        distY += e.deltaY;\r\n                    }\r\n                }\r\n                return { datas: datas, distX: distX, distY: distY, distOrigin: distOrigin };\r\n            },\r\n            requestEnd: function () {\r\n                return { datas: datas, isDrag: true };\r\n            },\r\n        };\r\n    },\r\n};\r\n/**\r\n * Whether to drag origin (default: false)\r\n * @name Moveable.OriginDraggable#originDraggable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     originDraggable: true,\r\n * });\r\n * let translate = [0, 0];\r\n * moveable.on(\"dragOriginStart\", e => {\r\n *     e.dragStart && e.dragStart.set(translate);\r\n * }).on(\"dragOrigin\", e => {\r\n *     translate = e.drag.beforeTranslate;\r\n *     e.target.style.cssText\r\n *         = `transform-origin: ${e.transformOrigin};`\r\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n * }).on(\"dragOriginEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * % Can be used instead of the absolute px (default: true)\r\n * @name Moveable.OriginDraggable#originRelative\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     originDraggable: true,\r\n *     originRelative: false,\r\n * });\r\n * moveable.originRelative = true;\r\n */\r\n/**\r\n* When drag start the origin, the `dragOriginStart` event is called.\r\n* @memberof Moveable.OriginDraggable\r\n* @event dragOriginStart\r\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     originDraggable: true,\r\n* });\r\n* let translate = [0, 0];\r\n* moveable.on(\"dragOriginStart\", e => {\r\n*     e.dragStart && e.dragStart.set(translate);\r\n* }).on(\"dragOrigin\", e => {\r\n*     translate = e.drag.beforeTranslate;\r\n*     e.target.style.cssText\r\n*         = `transform-origin: ${e.transformOrigin};`\r\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n* }).on(\"dragOriginEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/\r\n/**\r\n* When drag the origin, the `dragOrigin` event is called.\r\n* @memberof Moveable.OriginDraggable\r\n* @event dragOrigin\r\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     originDraggable: true,\r\n* });\r\n* let translate = [0, 0];\r\n* moveable.on(\"dragOriginStart\", e => {\r\n*     e.dragStart && e.dragStart.set(translate);\r\n* }).on(\"dragOrigin\", e => {\r\n*     translate = e.drag.beforeTranslate;\r\n*     e.target.style.cssText\r\n*         = `transform-origin: ${e.transformOrigin};`\r\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n* }).on(\"dragOriginEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/\r\n/**\r\n* When drag end the origin, the `dragOriginEnd` event is called.\r\n* @memberof Moveable.OriginDraggable\r\n* @event dragOriginEnd\r\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\r\n* @example\r\n* import Moveable from \"moveable\";\r\n*\r\n* const moveable = new Moveable(document.body, {\r\n*     originDraggable: true,\r\n* });\r\n* let translate = [0, 0];\r\n* moveable.on(\"dragOriginStart\", e => {\r\n*     e.dragStart && e.dragStart.set(translate);\r\n* }).on(\"dragOrigin\", e => {\r\n*     translate = e.drag.beforeTranslate;\r\n*     e.target.style.cssText\r\n*         = `transform-origin: ${e.transformOrigin};`\r\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\r\n* }).on(\"dragOriginEnd\", e => {\r\n*     console.log(e);\r\n* });\r\n*/\n\nfunction addBorderRadiusByLine(controlPoses, lineIndex, distX, distY) {\r\n    // lineIndex\r\n    // 0 top\r\n    // 1 right\r\n    // 2 bottom\r\n    // 3 left\r\n    var horizontalsLength = controlPoses.filter(function (_a) {\r\n        var virtual = _a.virtual, horizontal = _a.horizontal;\r\n        return horizontal && !virtual;\r\n    }).length;\r\n    var verticalsLength = controlPoses.filter(function (_a) {\r\n        var virtual = _a.virtual, vertical = _a.vertical;\r\n        return vertical && !virtual;\r\n    }).length;\r\n    var controlIndex = -1;\r\n    //top\r\n    if (lineIndex === 0) {\r\n        if (horizontalsLength === 0) {\r\n            controlIndex = 0;\r\n        }\r\n        else if (horizontalsLength === 1) {\r\n            controlIndex = 1;\r\n        }\r\n    }\r\n    // bottom\r\n    if (lineIndex === 2) {\r\n        if (horizontalsLength <= 2) {\r\n            controlIndex = 2;\r\n        }\r\n        else if (horizontalsLength <= 3) {\r\n            controlIndex = 3;\r\n        }\r\n    }\r\n    // left\r\n    if (lineIndex === 3) {\r\n        if (verticalsLength === 0) {\r\n            controlIndex = 4;\r\n        }\r\n        else if (verticalsLength < 4) {\r\n            controlIndex = 7;\r\n        }\r\n    }\r\n    // right\r\n    if (lineIndex === 1) {\r\n        if (verticalsLength <= 1) {\r\n            controlIndex = 5;\r\n        }\r\n        else if (verticalsLength <= 2) {\r\n            controlIndex = 6;\r\n        }\r\n    }\r\n    if (controlIndex === -1 || !controlPoses[controlIndex].virtual) {\r\n        return;\r\n    }\r\n    var controlPoseInfo = controlPoses[controlIndex];\r\n    addBorderRadius(controlPoses, controlIndex);\r\n    if (controlIndex < 4) {\r\n        controlPoseInfo.pos[0] = distX;\r\n    }\r\n    else {\r\n        controlPoseInfo.pos[1] = distY;\r\n    }\r\n}\r\nfunction addBorderRadius(controlPoses, index) {\r\n    if (index < 4) {\r\n        controlPoses.slice(0, index + 1).forEach(function (info) {\r\n            info.virtual = false;\r\n        });\r\n    }\r\n    else {\r\n        if (controlPoses[0].virtual) {\r\n            controlPoses[0].virtual = false;\r\n        }\r\n        controlPoses.slice(4, index + 1).forEach(function (info) {\r\n            info.virtual = false;\r\n        });\r\n    }\r\n}\r\nfunction removeBorderRadius(controlPoses, index) {\r\n    if (index < 4) {\r\n        controlPoses.slice(index, 4).forEach(function (info) {\r\n            info.virtual = true;\r\n        });\r\n    }\r\n    else {\r\n        controlPoses.slice(index).forEach(function (info) {\r\n            info.virtual = true;\r\n        });\r\n    }\r\n}\r\nfunction getBorderRadius(borderRadius, width, height, minCounts, full) {\r\n    if (minCounts === void 0) { minCounts = [0, 0]; }\r\n    var values = [];\r\n    if (!borderRadius || borderRadius === \"0px\") {\r\n        values = [];\r\n    }\r\n    else {\r\n        values = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(borderRadius);\r\n    }\r\n    return getRadiusValues(values, width, height, 0, 0, minCounts, full);\r\n}\r\nfunction triggerRoundEvent(moveable, e, dist, delta, nextPoses) {\r\n    var state = moveable.state;\r\n    var width = state.width, height = state.height;\r\n    var _a = getRadiusStyles(nextPoses, moveable.props.roundRelative, width, height), raws = _a.raws, styles = _a.styles, radiusPoses = _a.radiusPoses;\r\n    var _b = splitRadiusPoses(radiusPoses, raws), horizontals = _b.horizontals, verticals = _b.verticals;\r\n    var borderRadius = styles.join(\" \");\r\n    state.borderRadiusState = borderRadius;\r\n    var params = fillParams(moveable, e, __assign({ horizontals: horizontals, verticals: verticals, borderRadius: borderRadius, width: width, height: height, delta: delta, dist: dist }, fillCSSObject({\r\n        borderRadius: borderRadius,\r\n    }, e)));\r\n    triggerEvent(moveable, \"onRound\", params);\r\n    return params;\r\n}\r\nfunction getStyleBorderRadius(moveable) {\r\n    var _a, _b;\r\n    var style = moveable.getState().style;\r\n    var borderRadius = style.borderRadius || \"\";\r\n    if (!borderRadius && moveable.props.groupable) {\r\n        var firstMoveable = moveable.moveables[0];\r\n        var firstTarget = moveable.getTargets()[0];\r\n        if (firstTarget) {\r\n            if ((firstMoveable === null || firstMoveable === void 0 ? void 0 : firstMoveable.props.target) === firstTarget) {\r\n                borderRadius = (_b = (_a = moveable.moveables[0]) === null || _a === void 0 ? void 0 : _a.state.style.borderRadius) !== null && _b !== void 0 ? _b : \"\";\r\n                style.borderRadius = borderRadius;\r\n            }\r\n            else {\r\n                borderRadius = getComputedStyle(firstTarget).borderRadius;\r\n                style.borderRadius = borderRadius;\r\n            }\r\n        }\r\n    }\r\n    return borderRadius;\r\n}\r\n/**\r\n * @namespace Moveable.Roundable\r\n * @description Whether to show and drag or double click border-radius\r\n */\r\nvar Roundable = {\r\n    name: \"roundable\",\r\n    props: [\r\n        \"roundable\",\r\n        \"roundRelative\",\r\n        \"minRoundControls\",\r\n        \"maxRoundControls\",\r\n        \"roundClickable\",\r\n        \"roundPadding\",\r\n        \"isDisplayShadowRoundControls\",\r\n    ],\r\n    events: [\r\n        \"roundStart\",\r\n        \"round\",\r\n        \"roundEnd\",\r\n        \"roundGroupStart\",\r\n        \"roundGroup\",\r\n        \"roundGroupEnd\",\r\n    ],\r\n    css: [\r\n        \".control.border-radius {\\nbackground: #d66;\\ncursor: pointer;\\nz-index: 3;\\n}\",\r\n        \".control.border-radius.vertical {\\nbackground: #d6d;\\nz-index: 2;\\n}\",\r\n        \".control.border-radius.virtual {\\nopacity: 0.5;\\nz-index: 1;\\n}\",\r\n        \":host.round-line-clickable .line.direction {\\ncursor: pointer;\\n}\",\r\n    ],\r\n    className: function (moveable) {\r\n        var roundClickable = moveable.props.roundClickable;\r\n        return roundClickable === true || roundClickable === \"line\" ? prefix(\"round-line-clickable\") : \"\";\r\n    },\r\n    requestStyle: function () {\r\n        return [\"borderRadius\"];\r\n    },\r\n    requestChildStyle: function () {\r\n        return [\"borderRadius\"];\r\n    },\r\n    render: function (moveable, React) {\r\n        var _a = moveable.getState(), target = _a.target, width = _a.width, height = _a.height, allMatrix = _a.allMatrix, is3d = _a.is3d, left = _a.left, top = _a.top, borderRadiusState = _a.borderRadiusState;\r\n        var _b = moveable.props, _c = _b.minRoundControls, minRoundControls = _c === void 0 ? [0, 0] : _c, _d = _b.maxRoundControls, maxRoundControls = _d === void 0 ? [4, 4] : _d, zoom = _b.zoom, _e = _b.roundPadding, roundPadding = _e === void 0 ? 0 : _e, isDisplayShadowRoundControls = _b.isDisplayShadowRoundControls, groupable = _b.groupable;\r\n        if (!target) {\r\n            return null;\r\n        }\r\n        var borderRadius = borderRadiusState || getStyleBorderRadius(moveable);\r\n        var n = is3d ? 4 : 3;\r\n        var radiusValues = getBorderRadius(borderRadius, width, height, minRoundControls, true);\r\n        if (!radiusValues) {\r\n            return null;\r\n        }\r\n        var verticalCount = 0;\r\n        var horizontalCount = 0;\r\n        var basePos = groupable ? [0, 0] : [left, top];\r\n        return radiusValues.map(function (v, i) {\r\n            var horizontal = v.horizontal;\r\n            var vertical = v.vertical;\r\n            var direction = v.direction || \"\";\r\n            var originalPos = __spreadArray([], __read(v.pos), false);\r\n            horizontalCount += Math.abs(horizontal);\r\n            verticalCount += Math.abs(vertical);\r\n            if (horizontal && direction.indexOf(\"n\") > -1) {\r\n                originalPos[1] -= roundPadding;\r\n            }\r\n            if (vertical && direction.indexOf(\"w\") > -1) {\r\n                originalPos[0] -= roundPadding;\r\n            }\r\n            if (horizontal && direction.indexOf(\"s\") > -1) {\r\n                originalPos[1] += roundPadding;\r\n            }\r\n            if (vertical && direction.indexOf(\"e\") > -1) {\r\n                originalPos[0] += roundPadding;\r\n            }\r\n            var pos = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculatePosition(allMatrix, originalPos, n), basePos);\r\n            var isDisplayVerticalShadow = isDisplayShadowRoundControls\r\n                && isDisplayShadowRoundControls !== \"horizontal\";\r\n            var isDisplay = v.vertical\r\n                ? verticalCount <= maxRoundControls[1] && (isDisplayVerticalShadow || !v.virtual)\r\n                : horizontalCount <= maxRoundControls[0] && (isDisplayShadowRoundControls || !v.virtual);\r\n            return React.createElement(\"div\", { key: \"borderRadiusControl\".concat(i), className: prefix(\"control\", \"border-radius\", v.vertical ? \"vertical\" : \"\", v.virtual ? \"virtual\" : \"\"), \"data-radius-index\": i, style: {\r\n                    display: isDisplay ? \"block\" : \"none\",\r\n                    transform: \"translate(\".concat(pos[0], \"px, \").concat(pos[1], \"px) scale(\").concat(zoom, \")\"),\r\n                } });\r\n        });\r\n    },\r\n    dragControlCondition: function (moveable, e) {\r\n        if (!e.inputEvent || e.isRequest) {\r\n            return false;\r\n        }\r\n        var className = (e.inputEvent.target.getAttribute(\"class\") || \"\");\r\n        return className.indexOf(\"border-radius\") > -1\r\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\r\n    },\r\n    dragGroupControlCondition: function (moveable, e) {\r\n        return this.dragControlCondition(moveable, e);\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        var inputEvent = e.inputEvent, datas = e.datas;\r\n        var inputTarget = inputEvent.target;\r\n        var className = (inputTarget.getAttribute(\"class\") || \"\");\r\n        var isControl = className.indexOf(\"border-radius\") > -1;\r\n        var isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\r\n        var controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\r\n        var lineIndex = -1;\r\n        if (isLine) {\r\n            var indexAttr = inputTarget.getAttribute(\"data-line-key\") || \"\";\r\n            if (indexAttr) {\r\n                lineIndex = parseInt(indexAttr.replace(/render-line-/g, \"\"), 10);\r\n                if (isNaN(lineIndex)) {\r\n                    lineIndex = -1;\r\n                }\r\n            }\r\n        }\r\n        if (!isControl && !isLine) {\r\n            return false;\r\n        }\r\n        var params = fillParams(moveable, e, {});\r\n        var result = triggerEvent(moveable, \"onRoundStart\", params);\r\n        if (result === false) {\r\n            return false;\r\n        }\r\n        datas.lineIndex = lineIndex;\r\n        datas.controlIndex = controlIndex;\r\n        datas.isControl = isControl;\r\n        datas.isLine = isLine;\r\n        setDragStart(moveable, e);\r\n        var _a = moveable.props, roundRelative = _a.roundRelative, _b = _a.minRoundControls, minRoundControls = _b === void 0 ? [0, 0] : _b;\r\n        var state = moveable.state;\r\n        var width = state.width, height = state.height;\r\n        datas.isRound = true;\r\n        datas.prevDist = [0, 0];\r\n        var borderRadius = getStyleBorderRadius(moveable);\r\n        var controlPoses = getBorderRadius(borderRadius || \"\", width, height, minRoundControls, true) || [];\r\n        datas.controlPoses = controlPoses;\r\n        state.borderRadiusState = getRadiusStyles(controlPoses, roundRelative, width, height).styles.join(\" \");\r\n        return params;\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        var datas = e.datas;\r\n        var controlPoses = datas.controlPoses;\r\n        if (!datas.isRound || !datas.isControl || !controlPoses.length) {\r\n            return false;\r\n        }\r\n        var index = datas.controlIndex;\r\n        var _a = __read(getDragDist(e), 2), distX = _a[0], distY = _a[1];\r\n        var dist = [distX, distY];\r\n        var delta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(dist, datas.prevDist);\r\n        var _b = moveable.props.maxRoundControls, maxRoundControls = _b === void 0 ? [4, 4] : _b;\r\n        var _c = moveable.state, width = _c.width, height = _c.height;\r\n        var selectedControlPose = controlPoses[index];\r\n        var selectedVertical = selectedControlPose.vertical;\r\n        var selectedHorizontal = selectedControlPose.horizontal;\r\n        // 0: [0, 1, 2, 3] maxCount === 1\r\n        // 0: [0, 2] maxCount === 2\r\n        // 1: [1, 3] maxCount === 2\r\n        // 0: [0] maxCount === 3\r\n        // 1: [1, 3] maxCount === 3\r\n        var dists = controlPoses.map(function (pose) {\r\n            var horizontal = pose.horizontal, vertical = pose.vertical;\r\n            var poseDist = [\r\n                horizontal * selectedHorizontal * dist[0],\r\n                vertical * selectedVertical * dist[1],\r\n            ];\r\n            if (horizontal) {\r\n                if (maxRoundControls[0] === 1) {\r\n                    return poseDist;\r\n                }\r\n                else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\r\n                    return poseDist;\r\n                }\r\n            }\r\n            else if (maxRoundControls[1] === 0) {\r\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\r\n                return poseDist;\r\n            }\r\n            else if (selectedVertical) {\r\n                if (maxRoundControls[1] === 1) {\r\n                    return poseDist;\r\n                }\r\n                else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\r\n                    return poseDist;\r\n                }\r\n            }\r\n            return [0, 0];\r\n        });\r\n        dists[index] = dist;\r\n        var nextPoses = controlPoses.map(function (info, i) {\r\n            return __assign(__assign({}, info), { pos: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(info.pos, dists[i]) });\r\n        });\r\n        if (index < 4) {\r\n            nextPoses.slice(0, index + 1).forEach(function (info) {\r\n                info.virtual = false;\r\n            });\r\n        }\r\n        else {\r\n            nextPoses.slice(4, index + 1).forEach(function (info) {\r\n                info.virtual = false;\r\n            });\r\n        }\r\n        datas.prevDist = [distX, distY];\r\n        return triggerRoundEvent(moveable, e, dist, delta, nextPoses);\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        var state = moveable.state;\r\n        state.borderRadiusState = \"\";\r\n        var datas = e.datas, isDouble = e.isDouble;\r\n        if (!datas.isRound) {\r\n            return false;\r\n        }\r\n        var isControl = datas.isControl, controlIndex = datas.controlIndex, isLine = datas.isLine, lineIndex = datas.lineIndex;\r\n        var controlPoses = datas.controlPoses;\r\n        var length = controlPoses.filter(function (_a) {\r\n            var virtual = _a.virtual;\r\n            return virtual;\r\n        }).length;\r\n        var _a = moveable.props.roundClickable, roundClickable = _a === void 0 ? true : _a;\r\n        if (isDouble && roundClickable) {\r\n            if (isControl && (roundClickable === true || roundClickable === \"control\")) {\r\n                removeBorderRadius(controlPoses, controlIndex);\r\n            }\r\n            else if (isLine && (roundClickable === true || roundClickable === \"line\")) {\r\n                var _b = __read(calculatePointerDist(moveable, e), 2), distX = _b[0], distY = _b[1];\r\n                addBorderRadiusByLine(controlPoses, lineIndex, distX, distY);\r\n            }\r\n            if (length !== controlPoses.filter(function (_a) {\r\n                var virtual = _a.virtual;\r\n                return virtual;\r\n            }).length) {\r\n                triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses);\r\n            }\r\n        }\r\n        var params = fillEndParams(moveable, e, {});\r\n        triggerEvent(moveable, \"onRoundEnd\", params);\r\n        state.borderRadiusState = \"\";\r\n        return params;\r\n    },\r\n    dragGroupControlStart: function (moveable, e) {\r\n        var result = this.dragControlStart(moveable, e);\r\n        if (!result) {\r\n            return false;\r\n        }\r\n        var moveables = moveable.moveables;\r\n        var targets = moveable.props.targets;\r\n        var events = fillChildEvents(moveable, \"roundable\", e);\r\n        var nextParams = __assign({ targets: moveable.props.targets, events: events.map(function (ev, i) {\r\n                return __assign(__assign({}, ev), { target: targets[i], moveable: moveables[i], currentTarget: moveables[i] });\r\n            }) }, result);\r\n        triggerEvent(moveable, \"onRoundGroupStart\", nextParams);\r\n        return result;\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        var result = this.dragControl(moveable, e);\r\n        if (!result) {\r\n            return false;\r\n        }\r\n        var moveables = moveable.moveables;\r\n        var targets = moveable.props.targets;\r\n        var events = fillChildEvents(moveable, \"roundable\", e);\r\n        var nextParams = __assign({ targets: moveable.props.targets, events: events.map(function (ev, i) {\r\n                return __assign(__assign(__assign({}, ev), { target: targets[i], moveable: moveables[i], currentTarget: moveables[i] }), fillCSSObject({\r\n                    borderRadius: result.borderRadius,\r\n                }, ev));\r\n            }) }, result);\r\n        triggerEvent(moveable, \"onRoundGroup\", nextParams);\r\n        return nextParams;\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        var moveables = moveable.moveables;\r\n        var targets = moveable.props.targets;\r\n        var events = fillChildEvents(moveable, \"roundable\", e);\r\n        catchEvent(moveable, \"onRound\", function (parentEvent) {\r\n            var nextParams = __assign({ targets: moveable.props.targets, events: events.map(function (ev, i) {\r\n                    return __assign(__assign(__assign({}, ev), { target: targets[i], moveable: moveables[i], currentTarget: moveables[i] }), fillCSSObject({\r\n                        borderRadius: parentEvent.borderRadius,\r\n                    }, ev));\r\n                }) }, parentEvent);\r\n            triggerEvent(moveable, \"onRoundGroup\", nextParams);\r\n        });\r\n        var result = this.dragControlEnd(moveable, e);\r\n        if (!result) {\r\n            return false;\r\n        }\r\n        var nextParams = __assign({ targets: moveable.props.targets, events: events.map(function (ev, i) {\r\n                var _a;\r\n                return __assign(__assign({}, ev), { target: targets[i], moveable: moveables[i], currentTarget: moveables[i], lastEvent: (_a = ev.datas) === null || _a === void 0 ? void 0 : _a.lastEvent });\r\n            }) }, result);\r\n        triggerEvent(moveable, \"onRoundGroupEnd\", nextParams);\r\n        return nextParams;\r\n    },\r\n    unset: function (moveable) {\r\n        moveable.state.borderRadiusState = \"\";\r\n    },\r\n};\r\n/**\r\n * Whether to show and drag or double click border-radius, (default: false)\r\n * @name Moveable.Roundable#roundable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * % Can be used instead of the absolute px\r\n * @name Moveable.Roundable#roundRelative\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\r\n * @name Moveable.Roundable#minRoundControls\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n *     minRoundControls: [0, 0],\r\n * });\r\n * moveable.minRoundControls = [1, 0];\r\n */\r\n/**\r\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\r\n * @name Moveable.Roundable#maxRoundControls\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n *     maxRoundControls: [4, 4],\r\n * });\r\n * moveable.maxRoundControls = [1, 0];\r\n */\r\n/**\r\n * Whether you can add/delete round controls by double-clicking a line or control.\r\n * @name Moveable.Roundable#roundClickable\r\n * @default true\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n *     roundClickable: true,\r\n * });\r\n * moveable.roundClickable = false;\r\n */\r\n/**\r\n * Whether to show a round control that does not actually exist as a shadow\r\n * @name Moveable.Roundable#isDisplayShadowRoundControls\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     isDisplayShadowRoundControls: false,\r\n * });\r\n * moveable.isDisplayShadowRoundControls = true;\r\n */\r\n/**\r\n * The padding value of the position of the round control\r\n * @name Moveable.Roundable#roundPadding\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundPadding: 0,\r\n * });\r\n * moveable.roundPadding = 15;\r\n */\r\n/**\r\n * When drag start the clip area or controls, the `roundStart` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundStart\r\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag or double click the border area or controls, the `round` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event round\r\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\r\n * @example\r\n  * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag end the border area or controls, the `roundEnd` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundEnd\r\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\r\n * @example\r\n  * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     roundable: true,\r\n *     roundRelative: false,\r\n * });\r\n * moveable.on(\"roundStart\", e => {\r\n *     console.log(e);\r\n * }).on(\"round\", e => {\r\n *     e.target.style.borderRadius = e.borderRadius;\r\n * }).on(\"roundEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag start the clip area or controls, the `roundGroupStart` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundGroupStart\r\n * @param {Moveable.Roundable.OnRoundGroupStart} - Parameters for the `roundGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     targets: [target1, target2, target3],\r\n *     roundable: true,\r\n * });\r\n * moveable.on(\"roundGroupStart\", e => {\r\n *     console.log(e.targets);\r\n * }).on(\"roundGroup\", e => {\r\n *   e.events.forEach(ev => {\r\n *       ev.target.style.cssText += ev.cssText;\r\n *   });\r\n * }).on(\"roundGroupEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag or double click the border area or controls, the `roundGroup` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundGroup\r\n * @param {Moveable.Roundable.OnRoundGroup} - Parameters for the `roundGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     targets: [target1, target2, target3],\r\n *     roundable: true,\r\n * });\r\n * moveable.on(\"roundGroupStart\", e => {\r\n *     console.log(e.targets);\r\n * }).on(\"roundGroup\", e => {\r\n *   e.events.forEach(ev => {\r\n *       ev.target.style.cssText += ev.cssText;\r\n *   });\r\n * }).on(\"roundGroupEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\r\n/**\r\n * When drag end the border area or controls, the `roundGroupEnd` event is called.\r\n * @memberof Moveable.Roundable\r\n * @event roundGroupEnd\r\n * @param {Moveable.Roundable.onRoundGroupEnd} - Parameters for the `roundGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     targets: [target1, target2, target3],\r\n *     roundable: true,\r\n * });\r\n * moveable.on(\"roundGroupStart\", e => {\r\n *     console.log(e.targets);\r\n * }).on(\"roundGroup\", e => {\r\n *     e.events.forEach(ev => {\r\n *         ev.target.style.cssText += ev.cssText;\r\n *     });\r\n * }).on(\"roundGroupEnd\", e => {\r\n *     console.log(e);\r\n * });\r\n */\n\nfunction isIdentityMatrix(matrix, is3d) {\r\n    var n = is3d ? 4 : 3;\r\n    var identityMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\r\n    var value = \"matrix\".concat(is3d ? \"3d\" : \"\", \"(\").concat(identityMatrix.join(\",\"), \")\");\r\n    return matrix === value || matrix === \"matrix(1,0,0,1,0,0)\";\r\n}\r\nvar BeforeRenderable = {\r\n    isPinch: true,\r\n    name: \"beforeRenderable\",\r\n    props: [],\r\n    events: [\r\n        \"beforeRenderStart\",\r\n        \"beforeRender\",\r\n        \"beforeRenderEnd\",\r\n        \"beforeRenderGroupStart\",\r\n        \"beforeRenderGroup\",\r\n        \"beforeRenderGroupEnd\",\r\n    ],\r\n    dragRelation: \"weak\",\r\n    setTransform: function (moveable, e) {\r\n        var _a = moveable.state, is3d = _a.is3d, targetMatrix = _a.targetMatrix, inlineTransform = _a.inlineTransform;\r\n        var cssMatrix = is3d\r\n            ? \"matrix3d(\".concat(targetMatrix.join(\",\"), \")\")\r\n            : \"matrix(\".concat((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertMatrixtoCSS)(targetMatrix, true), \")\");\r\n        var startTransform = !inlineTransform || inlineTransform === \"none\" ? cssMatrix : inlineTransform;\r\n        e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(startTransform);\r\n    },\r\n    resetStyle: function (e) {\r\n        var datas = e.datas;\r\n        datas.nextStyle = {};\r\n        datas.nextTransforms = e.datas.startTransforms;\r\n        datas.nextTransformAppendedIndexes = [];\r\n    },\r\n    fillDragStartParams: function (moveable, e) {\r\n        return fillParams(moveable, e, {\r\n            setTransform: function (transform) {\r\n                e.datas.startTransforms = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(transform) ? transform : (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.splitSpace)(transform);\r\n            },\r\n            isPinch: !!e.isPinch,\r\n        });\r\n    },\r\n    fillDragParams: function (moveable, e) {\r\n        return fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n        });\r\n    },\r\n    dragStart: function (moveable, e) {\r\n        this.setTransform(moveable, e);\r\n        this.resetStyle(e);\r\n        triggerEvent(moveable, \"onBeforeRenderStart\", this.fillDragStartParams(moveable, e));\r\n    },\r\n    drag: function (moveable, e) {\r\n        if (!e.datas.startTransforms) {\r\n            this.setTransform(moveable, e);\r\n        }\r\n        this.resetStyle(e);\r\n        triggerEvent(moveable, \"onBeforeRender\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n        }));\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        if (!e.datas.startTransforms) {\r\n            this.setTransform(moveable, e);\r\n            this.resetStyle(e);\r\n        }\r\n        triggerEvent(moveable, \"onBeforeRenderEnd\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n            isDrag: e.isDrag,\r\n        }));\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        var _this = this;\r\n        this.dragStart(moveable, e);\r\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\r\n        var moveables = moveable.moveables;\r\n        var params = events.map(function (childEvent, i) {\r\n            var childMoveable = moveables[i];\r\n            _this.setTransform(childMoveable, childEvent);\r\n            _this.resetStyle(childEvent);\r\n            return _this.fillDragStartParams(childMoveable, childEvent);\r\n        });\r\n        triggerEvent(moveable, \"onBeforeRenderGroupStart\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n            targets: moveable.props.targets,\r\n            setTransform: function () { },\r\n            events: params,\r\n        }));\r\n    },\r\n    dragGroup: function (moveable, e) {\r\n        var _this = this;\r\n        this.drag(moveable, e);\r\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\r\n        var moveables = moveable.moveables;\r\n        var params = events.map(function (childEvent, i) {\r\n            var childMoveable = moveables[i];\r\n            _this.resetStyle(childEvent);\r\n            return _this.fillDragParams(childMoveable, childEvent);\r\n        });\r\n        triggerEvent(moveable, \"onBeforeRenderGroup\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n            targets: moveable.props.targets,\r\n            events: params,\r\n        }));\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        this.dragEnd(moveable, e);\r\n        triggerEvent(moveable, \"onBeforeRenderGroupEnd\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n            isDrag: e.isDrag,\r\n            targets: moveable.props.targets,\r\n        }));\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        return this.dragStart(moveable, e);\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        return this.drag(moveable, e);\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        return this.dragEnd(moveable, e);\r\n    },\r\n    dragGroupControlStart: function (moveable, e) {\r\n        return this.dragGroupStart(moveable, e);\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        return this.dragGroup(moveable, e);\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        return this.dragGroupEnd(moveable, e);\r\n    },\r\n};\n\nvar Renderable = {\r\n    name: \"renderable\",\r\n    props: [],\r\n    events: [\r\n        \"renderStart\",\r\n        \"render\",\r\n        \"renderEnd\",\r\n        \"renderGroupStart\",\r\n        \"renderGroup\",\r\n        \"renderGroupEnd\",\r\n    ],\r\n    dragRelation: \"weak\",\r\n    dragStart: function (moveable, e) {\r\n        triggerEvent(moveable, \"onRenderStart\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n        }));\r\n    },\r\n    drag: function (moveable, e) {\r\n        triggerEvent(moveable, \"onRender\", this.fillDragParams(moveable, e));\r\n    },\r\n    dragAfter: function (moveable, e) {\r\n        return this.drag(moveable, e);\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        triggerEvent(moveable, \"onRenderEnd\", this.fillDragEndParams(moveable, e));\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        triggerEvent(moveable, \"onRenderGroupStart\", fillParams(moveable, e, {\r\n            isPinch: !!e.isPinch,\r\n            targets: moveable.props.targets,\r\n        }));\r\n    },\r\n    dragGroup: function (moveable, e) {\r\n        var _this = this;\r\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\r\n        var moveables = moveable.moveables;\r\n        var params = events.map(function (childEvent, i) {\r\n            var childMoveable = moveables[i];\r\n            return _this.fillDragParams(childMoveable, childEvent);\r\n        });\r\n        triggerEvent(moveable, \"onRenderGroup\", fillParams(moveable, e, __assign(__assign({ isPinch: !!e.isPinch, targets: moveable.props.targets, transform: getNextTransformText(e), transformObject: {} }, fillCSSObject(getNextStyle(e))), { events: params })));\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        var _this = this;\r\n        var events = fillChildEvents(moveable, \"beforeRenderable\", e);\r\n        var moveables = moveable.moveables;\r\n        var params = events.map(function (childEvent, i) {\r\n            var childMoveable = moveables[i];\r\n            return _this.fillDragEndParams(childMoveable, childEvent);\r\n        });\r\n        triggerEvent(moveable, \"onRenderGroupEnd\", fillParams(moveable, e, __assign({ isPinch: !!e.isPinch, isDrag: e.isDrag, targets: moveable.props.targets, events: params, transformObject: {}, transform: getNextTransformText(e) }, fillCSSObject(getNextStyle(e)))));\r\n    },\r\n    dragControlStart: function (moveable, e) {\r\n        return this.dragStart(moveable, e);\r\n    },\r\n    dragControl: function (moveable, e) {\r\n        return this.drag(moveable, e);\r\n    },\r\n    dragControlAfter: function (moveable, e) {\r\n        return this.dragAfter(moveable, e);\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        return this.dragEnd(moveable, e);\r\n    },\r\n    dragGroupControlStart: function (moveable, e) {\r\n        return this.dragGroupStart(moveable, e);\r\n    },\r\n    dragGroupControl: function (moveable, e) {\r\n        return this.dragGroup(moveable, e);\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        return this.dragGroupEnd(moveable, e);\r\n    },\r\n    fillDragParams: function (moveable, e) {\r\n        var transformObject = {};\r\n        (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(getNextTransforms(e) || []).forEach(function (matrixInfo) {\r\n            transformObject[matrixInfo.name] = matrixInfo.functionValue;\r\n        });\r\n        return fillParams(moveable, e, __assign({ isPinch: !!e.isPinch, transformObject: transformObject, transform: getNextTransformText(e) }, fillCSSObject(getNextStyle(e))));\r\n    },\r\n    fillDragEndParams: function (moveable, e) {\r\n        var transformObject = {};\r\n        (0,css_to_mat__WEBPACK_IMPORTED_MODULE_4__.parse)(getNextTransforms(e) || []).forEach(function (matrixInfo) {\r\n            transformObject[matrixInfo.name] = matrixInfo.functionValue;\r\n        });\r\n        return fillParams(moveable, e, __assign({ isPinch: !!e.isPinch, isDrag: e.isDrag, transformObject: transformObject, transform: getNextTransformText(e) }, fillCSSObject(getNextStyle(e))));\r\n    },\r\n};\n\nfunction triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType, e, requestInstant) {\r\n    // pre setting\r\n    e.clientDistX = e.distX;\r\n    e.clientDistY = e.distY;\r\n    var isStart = eventType === \"Start\";\r\n    var isEnd = eventType === \"End\";\r\n    var isAfter = eventType === \"After\";\r\n    var target = moveable.state.target;\r\n    var isRequest = e.isRequest;\r\n    var isControl = eventAffix.indexOf(\"Control\") > -1;\r\n    if (!target\r\n        || (isStart && isControl && !isRequest && moveable.areaElement === e.inputEvent.target)) {\r\n        return false;\r\n    }\r\n    var ables = __spreadArray([], __read(moveableAbles), false);\r\n    if (isRequest) {\r\n        var requestAble_1 = e.requestAble;\r\n        if (!ables.some(function (able) { return able.name === requestAble_1; })) {\r\n            ables.push.apply(ables, __spreadArray([], __read(moveable.props.ables.filter(function (able) { return able.name === requestAble_1; })), false));\r\n        }\r\n    }\r\n    if (!ables.length || ables.every(function (able) { return able.dragRelation; })) {\r\n        return false;\r\n    }\r\n    // \"drag\" \"Control\" \"After\"\r\n    var inputEvent = e.inputEvent;\r\n    var inputTarget;\r\n    if (isEnd && inputEvent) {\r\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\r\n    }\r\n    var isDragStop = false;\r\n    var stop = function () {\r\n        var _a;\r\n        isDragStop = true;\r\n        (_a = e.stop) === null || _a === void 0 ? void 0 : _a.call(e);\r\n    };\r\n    var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto\r\n        || (!moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag()));\r\n    if (isFirstStart) {\r\n        moveable.updateRect(eventType, true, false);\r\n    }\r\n    // trigger ables\r\n    var datas = e.datas;\r\n    var gestoType = isControl ? \"controlGesto\" : \"targetGesto\";\r\n    var prevGesto = moveable[gestoType];\r\n    var trigger = function (able, eventName, conditionName) {\r\n        if (!(eventName in able) || prevGesto !== moveable[gestoType]) {\r\n            return false;\r\n        }\r\n        var ableName = able.name;\r\n        var nextDatas = datas[ableName] || (datas[ableName] = {});\r\n        if (isStart) {\r\n            nextDatas.isEventStart = !conditionName\r\n                || !able[conditionName] || able[conditionName](moveable, e);\r\n        }\r\n        if (!nextDatas.isEventStart) {\r\n            return false;\r\n        }\r\n        var result = able[eventName](moveable, __assign(__assign({}, e), { stop: stop, datas: nextDatas, originalDatas: datas, inputTarget: inputTarget }));\r\n        moveable._emitter.off();\r\n        if (isStart && result === false) {\r\n            nextDatas.isEventStart = false;\r\n        }\r\n        return result;\r\n    };\r\n    // unset ables for first drag start\r\n    if (isFirstStart) {\r\n        ables.forEach(function (able) {\r\n            able.unset && able.unset(moveable);\r\n        });\r\n    }\r\n    // BeforeRenderable\r\n    trigger(BeforeRenderable, \"drag\".concat(eventAffix).concat(eventType));\r\n    var forceEndedCount = 0;\r\n    var updatedCount = 0;\r\n    eventOperations.forEach(function (eventOperation) {\r\n        if (isDragStop) {\r\n            return false;\r\n        }\r\n        var eventName = \"\".concat(eventOperation).concat(eventAffix).concat(eventType);\r\n        var conditionName = \"\".concat(eventOperation).concat(eventAffix, \"Condition\");\r\n        if (eventType === \"\" && !isRequest) {\r\n            // Convert distX, distY\r\n            convertDragDist(moveable.state, e);\r\n        }\r\n        // const isGroup = eventAffix.indexOf(\"Group\") > -1;\r\n        var eventAbles = ables.filter(function (able) { return able[eventName]; });\r\n        eventAbles = eventAbles.filter(function (able, i) {\r\n            return able.name && eventAbles.indexOf(able) === i;\r\n        });\r\n        var results = eventAbles.filter(function (able) { return trigger(able, eventName, conditionName); });\r\n        var isUpdate = results.length;\r\n        // end ables\r\n        if (isDragStop) {\r\n            ++forceEndedCount;\r\n        }\r\n        if (isUpdate) {\r\n            ++updatedCount;\r\n        }\r\n        if (!isDragStop && isStart && eventAbles.length && !isUpdate) {\r\n            forceEndedCount += eventAbles.filter(function (able) {\r\n                var ableName = able.name;\r\n                var nextDatas = datas[ableName];\r\n                if (nextDatas.isEventStart) {\r\n                    if (able.dragRelation === \"strong\") {\r\n                        return false;\r\n                    }\r\n                    // stop drag\r\n                    return true;\r\n                }\r\n                // pre stop drag\r\n                return false;\r\n            }).length ? 1 : 0;\r\n        }\r\n    });\r\n    if (!isAfter || updatedCount) {\r\n        trigger(Renderable, \"drag\".concat(eventAffix).concat(eventType));\r\n    }\r\n    // stop gesto condition\r\n    var isForceEnd = prevGesto !== moveable[gestoType] || forceEndedCount === eventOperations.length;\r\n    if (isEnd || isDragStop || isForceEnd) {\r\n        moveable.state.gestos = {};\r\n        if (moveable.moveables) {\r\n            moveable.moveables.forEach(function (childMoveable) {\r\n                childMoveable.state.gestos = {};\r\n            });\r\n        }\r\n        ables.forEach(function (able) {\r\n            able.unset && able.unset(moveable);\r\n        });\r\n    }\r\n    if (isStart && !isForceEnd && !isRequest && updatedCount && moveable.props.preventDefault) {\r\n        e === null || e === void 0 ? void 0 : e.preventDefault();\r\n    }\r\n    if (moveable.isUnmounted || isForceEnd) {\r\n        return false;\r\n    }\r\n    if ((!isStart && updatedCount && !requestInstant) || isEnd) {\r\n        var flushSync = moveable.props.flushSync || defaultSync;\r\n        flushSync(function () {\r\n            moveable.updateRect(isEnd ? eventType : \"\", true, false);\r\n            moveable.forceUpdate();\r\n        });\r\n    }\r\n    if (!isStart && !isEnd && !isAfter && updatedCount && !requestInstant) {\r\n        triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType + \"After\", e);\r\n    }\r\n    return true;\r\n}\r\nfunction checkMoveableTarget(moveable, isControl) {\r\n    return function (e, target) {\r\n        var _a;\r\n        if (target === void 0) { target = e.inputEvent.target; }\r\n        var eventTarget = target;\r\n        var areaElement = moveable.areaElement;\r\n        var dragTargetElement = moveable._dragTarget;\r\n        if (!dragTargetElement || (!isControl && ((_a = moveable.controlGesto) === null || _a === void 0 ? void 0 : _a.isFlag()))) {\r\n            return false;\r\n        }\r\n        return eventTarget === dragTargetElement\r\n            || dragTargetElement.contains(eventTarget)\r\n            || eventTarget === areaElement\r\n            || (!moveable.isMoveableElement(eventTarget) && !moveable.controlBox.contains(eventTarget))\r\n            || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(eventTarget, \"moveable-area\")\r\n            || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(eventTarget, \"moveable-padding\")\r\n            || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(eventTarget, \"moveable-edgeDraggable\");\r\n    };\r\n}\r\nfunction getTargetAbleGesto(moveable, moveableTarget, eventAffix) {\r\n    var controlBox = moveable.controlBox;\r\n    var targets = [];\r\n    var props = moveable.props;\r\n    var dragArea = props.dragArea;\r\n    var target = moveable.state.target;\r\n    var dragTarget = props.dragTarget;\r\n    targets.push(controlBox);\r\n    if (!dragArea || dragTarget) {\r\n        targets.push(moveableTarget);\r\n    }\r\n    if (!dragArea && dragTarget && target && moveableTarget !== target && props.dragTargetSelf) {\r\n        targets.push(target);\r\n    }\r\n    var checkTarget = checkMoveableTarget(moveable);\r\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\r\n        dragStart: checkTarget,\r\n        pinchStart: checkTarget,\r\n    });\r\n}\r\nfunction getControlAbleGesto(moveable, eventAffix) {\r\n    var controlBox = moveable.controlBox;\r\n    var targets = [];\r\n    targets.push(controlBox);\r\n    var checkTarget = checkMoveableTarget(moveable, true);\r\n    var checkControlTarget = function (e, target) {\r\n        if (target === void 0) { target = e.inputEvent.target; }\r\n        if (target === controlBox) {\r\n            return true;\r\n        }\r\n        var result = checkTarget(e, target);\r\n        return !result;\r\n    };\r\n    return getAbleGesto(moveable, targets, \"controlAbles\", eventAffix, {\r\n        dragStart: checkControlTarget,\r\n        pinchStart: checkControlTarget,\r\n    });\r\n}\r\nfunction getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {\r\n    if (conditionFunctions === void 0) { conditionFunctions = {}; }\r\n    var isTargetAbles = ableType === \"targetAbles\";\r\n    var _a = moveable.props, pinchOutside = _a.pinchOutside, pinchThreshold = _a.pinchThreshold, preventClickEventOnDrag = _a.preventClickEventOnDrag, preventClickDefault = _a.preventClickDefault, checkInput = _a.checkInput, dragFocusedInput = _a.dragFocusedInput, _b = _a.preventDefault, preventDefault = _b === void 0 ? true : _b, _c = _a.preventRightClick, preventRightClick = _c === void 0 ? true : _c, _d = _a.preventWheelClick, preventWheelClick = _d === void 0 ? true : _d, dragContaienrOption = _a.dragContainer;\r\n    var dragContainer = getRefTarget(dragContaienrOption, true);\r\n    var options = {\r\n        preventDefault: preventDefault,\r\n        preventRightClick: preventRightClick,\r\n        preventWheelClick: preventWheelClick,\r\n        container: dragContainer || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(moveable.getControlBoxElement()),\r\n        pinchThreshold: pinchThreshold,\r\n        pinchOutside: pinchOutside,\r\n        preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\r\n        preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\r\n        preventClickEventByCondition: isTargetAbles ? null : function (e) {\r\n            return moveable.controlBox.contains(e.target);\r\n        },\r\n        checkInput: isTargetAbles ? checkInput : false,\r\n        dragFocusedInput: dragFocusedInput,\r\n    };\r\n    var gesto = new gesto__WEBPACK_IMPORTED_MODULE_9__[\"default\"](target, options);\r\n    var isControl = eventAffix === \"Control\";\r\n    [\"drag\", \"pinch\"].forEach(function (eventOperation) {\r\n        [\"Start\", \"\", \"End\"].forEach(function (eventType) {\r\n            gesto.on(\"\".concat(eventOperation).concat(eventType), function (e) {\r\n                var _a;\r\n                var eventName = e.eventType;\r\n                var isPinchScheduled = eventOperation === \"drag\" && e.isPinch;\r\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\r\n                    e.stop();\r\n                    return;\r\n                }\r\n                if (isPinchScheduled) {\r\n                    return;\r\n                }\r\n                var eventOperations = eventOperation === \"drag\" ? [eventOperation] : [\"drag\", eventOperation];\r\n                var moveableAbles = __spreadArray([], __read(moveable[ableType]), false);\r\n                var result = triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType, e);\r\n                if (!result) {\r\n                    e.stop();\r\n                }\r\n                else if (moveable.props.stopPropagation || (eventType === \"Start\" && isControl)) {\r\n                    (_a = e === null || e === void 0 ? void 0 : e.inputEvent) === null || _a === void 0 ? void 0 : _a.stopPropagation();\r\n                }\r\n            });\r\n        });\r\n    });\r\n    return gesto;\r\n}\n\nvar EventManager = /*#__PURE__*/ (function () {\r\n    function EventManager(target, moveable, eventName) {\r\n        var _this = this;\r\n        this.target = target;\r\n        this.moveable = moveable;\r\n        this.eventName = eventName;\r\n        this.ables = [];\r\n        this._onEvent = function (e) {\r\n            var eventName = _this.eventName;\r\n            var moveable = _this.moveable;\r\n            if (moveable.state.disableNativeEvent) {\r\n                return;\r\n            }\r\n            _this.ables.forEach(function (able) {\r\n                able[eventName](moveable, {\r\n                    inputEvent: e,\r\n                });\r\n            });\r\n        };\r\n        target.addEventListener(eventName.toLowerCase(), this._onEvent);\r\n    }\r\n    EventManager.prototype.setAbles = function (ables) {\r\n        this.ables = ables;\r\n    };\r\n    EventManager.prototype.destroy = function () {\r\n        this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent);\r\n        this.target = null;\r\n        this.moveable = null;\r\n    };\r\n    return EventManager;\r\n}());\n\nfunction calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {\r\n    var _a;\r\n    if (rootContainer === void 0) { rootContainer = container; }\r\n    var _b = getMatrixStackInfo(target, container), matrixes = _b.matrixes, is3d = _b.is3d, prevTargetMatrix = _b.targetMatrix, transformOrigin = _b.transformOrigin, targetOrigin = _b.targetOrigin, offsetContainer = _b.offsetContainer, hasFixed = _b.hasFixed, containerZoom = _b.zoom; // prevMatrix\r\n    var _c = getCachedMatrixContainerInfo(offsetContainer, rootContainer), rootMatrixes = _c.matrixes, isRoot3d = _c.is3d, offsetRootContainer = _c.offsetContainer, rootZoom = _c.zoom; // prevRootMatrix\r\n    // if (rootContainer === document.body) {\r\n    //     console.log(offsetContainer, rootContainer, rootMatrixes);\r\n    // }\r\n    var isNext3d = isAbsolute3d || isRoot3d || is3d;\r\n    var n = isNext3d ? 4 : 3;\r\n    var isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\r\n    var targetMatrix = prevTargetMatrix;\r\n    // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\r\n    // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\r\n    // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\r\n    var allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\r\n    var rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\r\n    var beforeMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\r\n    var offsetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n);\r\n    var length = matrixes.length;\r\n    var nextRootMatrixes = rootMatrixes.map(function (info) {\r\n        return __assign(__assign({}, info), { matrix: info.matrix ? __spreadArray([], __read(info.matrix), false) : undefined });\r\n    }).reverse();\r\n    matrixes.reverse();\r\n    if (!is3d && isNext3d) {\r\n        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 3, 4);\r\n        convert3DMatrixes(matrixes);\r\n    }\r\n    if (!isRoot3d && isNext3d) {\r\n        convert3DMatrixes(nextRootMatrixes);\r\n    }\r\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\r\n    // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\r\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\r\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\r\n    nextRootMatrixes.forEach(function (info) {\r\n        rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(rootMatrix, info.matrix, n);\r\n    });\r\n    var originalRootContainer = rootContainer || (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getDocumentBody)(target);\r\n    var endContainer = ((_a = nextRootMatrixes[0]) === null || _a === void 0 ? void 0 : _a.target)\r\n        || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\r\n    var rootMatrixBeforeOffset = nextRootMatrixes.slice(1).reduce(function (matrix, info) {\r\n        return (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(matrix, info.matrix, n);\r\n    }, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n));\r\n    matrixes.forEach(function (info, i) {\r\n        if (length - 2 === i) {\r\n            // length - 3\r\n            beforeMatrix = allMatrix.slice();\r\n        }\r\n        if (length - 1 === i) {\r\n            // length - 2\r\n            offsetMatrix = allMatrix.slice();\r\n        }\r\n        // calculate for SVGElement\r\n        if (!info.matrix) {\r\n            var nextInfo = matrixes[i + 1];\r\n            var offset = getSVGOffset(info, nextInfo, endContainer, n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(rootMatrixBeforeOffset, allMatrix, n));\r\n            info.matrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(offset, n);\r\n        }\r\n        allMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(allMatrix, info.matrix, n);\r\n    });\r\n    var isMatrix3d = !isSVGGraphicElement && is3d;\r\n    if (!targetMatrix) {\r\n        targetMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(isMatrix3d ? 4 : 3);\r\n    }\r\n    var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16\r\n        ? (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.convertDimension)(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);\r\n    var originalRootMatrix = rootMatrix;\r\n    rootMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.ignoreDimension)(rootMatrix, n, n);\r\n    return {\r\n        hasZoom: containerZoom !== 1 || rootZoom !== 1,\r\n        hasFixed: hasFixed,\r\n        matrixes: matrixes,\r\n        rootMatrix: rootMatrix,\r\n        originalRootMatrix: originalRootMatrix,\r\n        beforeMatrix: beforeMatrix,\r\n        offsetMatrix: offsetMatrix,\r\n        allMatrix: allMatrix,\r\n        targetMatrix: targetMatrix,\r\n        targetTransform: targetTransform,\r\n        inlineTransform: target.style.transform,\r\n        transformOrigin: transformOrigin,\r\n        targetOrigin: targetOrigin,\r\n        is3d: isNext3d,\r\n        offsetContainer: offsetContainer,\r\n        offsetRootContainer: offsetRootContainer,\r\n    };\r\n}\n\nfunction calculateElementInfo(target, container, rootContainer, isAbsolute3d) {\r\n    if (rootContainer === void 0) { rootContainer = container; }\r\n    var width = 0;\r\n    var height = 0;\r\n    var rotation = 0;\r\n    var allResult = {};\r\n    var sizes = getSize(target);\r\n    if (target) {\r\n        width = sizes.offsetWidth;\r\n        height = sizes.offsetHeight;\r\n    }\r\n    if (target) {\r\n        var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);\r\n        var position = calculateElementPosition(result.allMatrix, result.transformOrigin, width, height);\r\n        allResult = __assign(__assign({}, result), position);\r\n        var rotationPosition = calculateElementPosition(result.allMatrix, [50, 50], 100, 100);\r\n        rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\r\n    }\r\n    var n = isAbsolute3d ? 4 : 3;\r\n    return __assign(__assign(__assign({ hasZoom: false, width: width, height: height, rotation: rotation }, sizes), { originalRootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n), rootMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n), beforeMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n), offsetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n), allMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n), targetMatrix: (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createIdentityMatrix)(n), targetTransform: \"\", inlineTransform: \"\", transformOrigin: [0, 0], targetOrigin: [0, 0], is3d: !!isAbsolute3d, left: 0, top: 0, right: 0, bottom: 0, origin: [0, 0], pos1: [0, 0], pos2: [0, 0], pos3: [0, 0], pos4: [0, 0], direction: 1, hasFixed: false, offsetContainer: null, offsetRootContainer: null, matrixes: [] }), allResult);\r\n}\r\nfunction getElementInfo(target, container, rootContainer) {\r\n    if (rootContainer === void 0) { rootContainer = container; }\r\n    return calculateElementInfo(target, container, rootContainer, true);\r\n}\n\nfunction getMoveableTargetInfo(moveableElement, target, container, parentContainer, rootContainer, requestStyles) {\r\n    if (requestStyles === void 0) { requestStyles = []; }\r\n    var beforeDirection = 1;\r\n    var beforeOrigin = [0, 0];\r\n    var targetClientRect = resetClientRect();\r\n    var moveableClientRect = resetClientRect();\r\n    var containerClientRect = resetClientRect();\r\n    var rootContainerClientRect = resetClientRect();\r\n    var offsetDelta = [0, 0];\r\n    var style = {};\r\n    var result = calculateElementInfo(target, container, rootContainer, true);\r\n    if (target) {\r\n        var getStyle_1 = getCachedStyle(target);\r\n        requestStyles.forEach(function (name) {\r\n            style[name] = getStyle_1(name);\r\n        });\r\n        var n = result.is3d ? 4 : 3;\r\n        var beforePosition = calculateElementPosition(result.offsetMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(result.transformOrigin, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.getOrigin)(result.targetMatrix, n)), result.width, result.height);\r\n        beforeDirection = beforePosition.direction;\r\n        beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);\r\n        rootContainerClientRect = getClientRect(result.offsetRootContainer);\r\n        var offsetContainer = getOffsetInfo(parentContainer, parentContainer, true).offsetParent\r\n            || result.offsetRootContainer;\r\n        if (result.hasZoom) {\r\n            var absoluteTargetPosition = calculateElementPosition((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiply)(result.originalRootMatrix, result.allMatrix), result.transformOrigin, result.width, result.height);\r\n            var absoluteContainerPosition = calculateElementPosition(result.originalRootMatrix, getTransformOriginArray(getCachedStyle(offsetContainer)(\"transformOrigin\")).map(function (pos) { return parseFloat(pos); }), offsetContainer.offsetWidth, offsetContainer.offsetHeight);\r\n            targetClientRect = getClientRectByPosition(absoluteTargetPosition, rootContainerClientRect);\r\n            containerClientRect = getClientRectByPosition(absoluteContainerPosition, rootContainerClientRect, offsetContainer, true);\r\n            if (moveableElement) {\r\n                var left = absoluteTargetPosition.left;\r\n                var top_1 = absoluteTargetPosition.top;\r\n                moveableClientRect = getClientRectByPosition({\r\n                    left: left,\r\n                    top: top_1,\r\n                    bottom: top_1,\r\n                    right: top_1,\r\n                }, rootContainerClientRect);\r\n            }\r\n        }\r\n        else {\r\n            targetClientRect = getClientRect(target);\r\n            containerClientRect = getCachedClientRect(offsetContainer);\r\n            if (moveableElement) {\r\n                moveableClientRect = getClientRect(moveableElement);\r\n            }\r\n            var containerClientRectLeft = containerClientRect.left, containerClientRectTop = containerClientRect.top, containterClientLeft = containerClientRect.clientLeft, containerClientTop = containerClientRect.clientTop;\r\n            var clientDelta = [\r\n                targetClientRect.left - containerClientRectLeft,\r\n                targetClientRect.top - containerClientRectTop,\r\n            ];\r\n            offsetDelta = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(calculateInversePosition(result.rootMatrix, clientDelta, 4), [containterClientLeft + result.left, containerClientTop + result.top]);\r\n        }\r\n    }\r\n    return __assign({ targetClientRect: targetClientRect, containerClientRect: containerClientRect, moveableClientRect: moveableClientRect, rootContainerClientRect: rootContainerClientRect, beforeDirection: beforeDirection, beforeOrigin: beforeOrigin, originalBeforeOrigin: beforeOrigin, target: target, style: style, offsetDelta: offsetDelta }, result);\r\n}\n\nfunction getPersistState(rect) {\r\n    var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4;\r\n    if (!pos1 || !pos2 || !pos3 || !pos4) {\r\n        return null;\r\n    }\r\n    var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)([pos1, pos2, pos3, pos4]);\r\n    var posDelta = [minPos.minX, minPos.minY];\r\n    var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(rect.origin, posDelta);\r\n    pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos1, posDelta);\r\n    pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos2, posDelta);\r\n    pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos3, posDelta);\r\n    pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos4, posDelta);\r\n    return __assign(__assign({}, rect), { left: rect.left, top: rect.top, posDelta: posDelta, pos1: pos1, pos2: pos2, pos3: pos3, pos4: pos4, origin: origin, beforeOrigin: origin, \r\n        // originalBeforeOrigin: origin,\r\n        isPersisted: true });\r\n}\n\nvar MoveableManager = /*#__PURE__*/ (function (_super) {\r\n    __extends(MoveableManager, _super);\r\n    function MoveableManager() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.state = __assign({ container: null, gestos: {}, renderLines: [\r\n                [[0, 0], [0, 0]],\r\n                [[0, 0], [0, 0]],\r\n                [[0, 0], [0, 0]],\r\n                [[0, 0], [0, 0]],\r\n            ], renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]], disableNativeEvent: false, posDelta: [0, 0] }, getMoveableTargetInfo(null));\r\n        _this.renderState = {};\r\n        _this.enabledAbles = [];\r\n        _this.targetAbles = [];\r\n        _this.controlAbles = [];\r\n        _this.rotation = 0;\r\n        _this.scale = [1, 1];\r\n        _this.isMoveableMounted = false;\r\n        _this.isUnmounted = false;\r\n        _this.events = {\r\n            \"mouseEnter\": null,\r\n            \"mouseLeave\": null,\r\n        };\r\n        _this._emitter = new _scena_event_emitter__WEBPACK_IMPORTED_MODULE_10__[\"default\"]();\r\n        _this._prevOriginalDragTarget = null;\r\n        _this._originalDragTarget = null;\r\n        _this._prevDragTarget = null;\r\n        _this._dragTarget = null;\r\n        _this._prevPropTarget = null;\r\n        _this._propTarget = null;\r\n        _this._prevDragArea = false;\r\n        _this._isPropTargetChanged = false;\r\n        _this._hasFirstTarget = false;\r\n        _this._reiszeObserver = null;\r\n        _this._observerId = 0;\r\n        _this._mutationObserver = null;\r\n        _this._rootContainer = null;\r\n        _this._viewContainer = null;\r\n        _this._viewClassNames = [];\r\n        _this._store = {};\r\n        _this.checkUpdateRect = function () {\r\n            if (_this.isDragging()) {\r\n                return;\r\n            }\r\n            var parentMoveable = _this.props.parentMoveable;\r\n            if (parentMoveable) {\r\n                parentMoveable.checkUpdateRect();\r\n                return;\r\n            }\r\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.cancelAnimationFrame)(_this._observerId);\r\n            _this._observerId = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.requestAnimationFrame)(function () {\r\n                if (_this.isDragging()) {\r\n                    return;\r\n                }\r\n                _this.updateRect();\r\n            });\r\n        };\r\n        _this._onPreventClick = function (e) {\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n            // removeEvent(window, \"click\", this._onPreventClick, true);\r\n        };\r\n        return _this;\r\n    }\r\n    MoveableManager.prototype.render = function () {\r\n        var props = this.props;\r\n        var state = this.getState();\r\n        var parentPosition = props.parentPosition, className = props.className, propsTarget = props.target, zoom = props.zoom, cspNonce = props.cspNonce, translateZ = props.translateZ, ControlBoxElement = props.cssStyled, groupable = props.groupable, linePadding = props.linePadding, controlPadding = props.controlPadding;\r\n        this._checkUpdateRootContainer();\r\n        this.checkUpdate();\r\n        this.updateRenderPoses();\r\n        var _a = __read(parentPosition || [0, 0], 2), parentLeft = _a[0], parentTop = _a[1];\r\n        var left = state.left, top = state.top, stateTarget = state.target, direction = state.direction, hasFixed = state.hasFixed, offsetDelta = state.offsetDelta;\r\n        var groupTargets = props.targets;\r\n        var isDragging = this.isDragging();\r\n        var ableAttributes = {};\r\n        this.getEnabledAbles().forEach(function (able) {\r\n            ableAttributes[\"data-able-\".concat(able.name.toLowerCase())] = true;\r\n        });\r\n        var ableClassName = this._getAbleClassName();\r\n        var isDisplay = (groupTargets && groupTargets.length && (stateTarget || groupable))\r\n            || propsTarget\r\n            || (!this._hasFirstTarget && this.state.isPersisted);\r\n        var isVisible = this.controlBox || this.props.firstRenderState || this.props.persistData;\r\n        var translate = [left - parentLeft, top - parentTop];\r\n        if (!groupable && props.useAccuratePosition) {\r\n            translate[0] += offsetDelta[0];\r\n            translate[1] += offsetDelta[1];\r\n        }\r\n        var style = {\r\n            \"position\": hasFixed ? \"fixed\" : \"absolute\",\r\n            \"display\": isDisplay ? \"block\" : \"none\",\r\n            \"visibility\": isVisible ? \"visible\" : \"hidden\",\r\n            \"transform\": \"translate3d(\".concat(translate[0], \"px, \").concat(translate[1], \"px, \").concat(translateZ, \")\"),\r\n            \"--zoom\": zoom,\r\n            \"--zoompx\": \"\".concat(zoom, \"px\"),\r\n        };\r\n        if (linePadding) {\r\n            style[\"--moveable-line-padding\"] = linePadding;\r\n        }\r\n        if (controlPadding) {\r\n            style[\"--moveable-control-padding\"] = controlPadding;\r\n        }\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlBoxElement, __assign({ cspNonce: cspNonce, ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"controlBox\"), className: \"\".concat(prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\"), \" \").concat(ableClassName, \" \").concat(className) }, ableAttributes, { onClick: this._onPreventClick, style: style }),\r\n            this.renderAbles(),\r\n            this._renderLines()));\r\n    };\r\n    MoveableManager.prototype.componentDidMount = function () {\r\n        this.isMoveableMounted = true;\r\n        this.isUnmounted = false;\r\n        var props = this.props;\r\n        var parentMoveable = props.parentMoveable, container = props.container;\r\n        this._checkUpdateRootContainer();\r\n        this._checkUpdateViewContainer();\r\n        this._updateTargets();\r\n        this._updateNativeEvents();\r\n        this._updateEvents();\r\n        this.updateCheckInput();\r\n        this._updateObserver(this.props);\r\n        if (!container && !parentMoveable && !this.state.isPersisted) {\r\n            this.updateRect(\"\", false, false);\r\n            this.forceUpdate();\r\n        }\r\n    };\r\n    MoveableManager.prototype.componentDidUpdate = function (prevProps) {\r\n        this._checkUpdateRootContainer();\r\n        this._checkUpdateViewContainer();\r\n        this._updateNativeEvents();\r\n        this._updateTargets();\r\n        this._updateEvents();\r\n        this.updateCheckInput();\r\n        this._updateObserver(prevProps);\r\n    };\r\n    MoveableManager.prototype.componentWillUnmount = function () {\r\n        var _a, _b;\r\n        this.isMoveableMounted = false;\r\n        this.isUnmounted = true;\r\n        this._emitter.off();\r\n        (_a = this._reiszeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n        (_b = this._mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\r\n        var viewContainer = this._viewContainer;\r\n        if (viewContainer) {\r\n            this._changeAbleViewClassNames([]);\r\n        }\r\n        unsetGesto(this, false);\r\n        unsetGesto(this, true);\r\n        var events = this.events;\r\n        for (var name_1 in events) {\r\n            var manager = events[name_1];\r\n            manager && manager.destroy();\r\n        }\r\n    };\r\n    MoveableManager.prototype.getTargets = function () {\r\n        var target = this.props.target;\r\n        return target ? [target] : [];\r\n    };\r\n    /**\r\n     * Get the able used in MoveableManager.\r\n     * @method Moveable#getAble\r\n     * @param - able name\r\n     */\r\n    MoveableManager.prototype.getAble = function (ableName) {\r\n        var ables = this.props.ables || [];\r\n        return (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(ables, function (able) { return able.name === ableName; });\r\n    };\r\n    MoveableManager.prototype.getContainer = function () {\r\n        var _a = this.props, parentMoveable = _a.parentMoveable, wrapperMoveable = _a.wrapperMoveable, container = _a.container;\r\n        return container\r\n            || (wrapperMoveable && wrapperMoveable.getContainer())\r\n            || (parentMoveable && parentMoveable.getContainer())\r\n            || this.controlBox.parentElement;\r\n    };\r\n    /**\r\n     * Returns the element of the control box.\r\n     * @method Moveable#getControlBoxElement\r\n     */\r\n    MoveableManager.prototype.getControlBoxElement = function () {\r\n        return this.controlBox;\r\n    };\r\n    /**\r\n     * Target element to be dragged in moveable\r\n     * @method Moveable#getDragElement\r\n     */\r\n    MoveableManager.prototype.getDragElement = function () {\r\n        return this._dragTarget;\r\n    };\r\n    /**\r\n     * Check if the target is an element included in the moveable.\r\n     * @method Moveable#isMoveableElement\r\n     * @param - the target\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * window.addEventListener(\"click\", e => {\r\n     *     if (!moveable.isMoveableElement(e.target)) {\r\n     *         moveable.target = e.target;\r\n     *     }\r\n     * });\r\n     */\r\n    MoveableManager.prototype.isMoveableElement = function (target) {\r\n        var _a;\r\n        return target && (((_a = target.getAttribute) === null || _a === void 0 ? void 0 : _a.call(target, \"class\")) || \"\").indexOf(PREFIX) > -1;\r\n    };\r\n    /**\r\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\r\n     * @method Moveable#dragStart\r\n     * @param - external `MouseEvent`or `TouchEvent`\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * document.body.addEventListener(\"mousedown\", e => {\r\n     *     if (!moveable.isMoveableElement(e.target)) {\r\n     *          moveable.dragStart(e);\r\n     *     }\r\n     * });\r\n     */\r\n    MoveableManager.prototype.dragStart = function (e, target) {\r\n        if (target === void 0) { target = e.target; }\r\n        var targetGesto = this.targetGesto;\r\n        var controlGesto = this.controlGesto;\r\n        if (targetGesto && checkMoveableTarget(this)({ inputEvent: e }, target)) {\r\n            if (!targetGesto.isFlag()) {\r\n                targetGesto.triggerDragStart(e);\r\n            }\r\n        }\r\n        else if (controlGesto && this.isMoveableElement(target)) {\r\n            if (!controlGesto.isFlag()) {\r\n                controlGesto.triggerDragStart(e);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Hit test an element or rect on a moveable target.\r\n     * (100% = 100)\r\n     * @method Moveable#hitTest\r\n     * @param - element or rect to test\r\n     * @return - Get hit test rate (rate > 0 is hitted)\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * document.body.addEventListener(\"mousedown\", e => {\r\n     *     if (moveable.hitTest(e.target) > 0) {\r\n     *          console.log(\"hiited\");\r\n     *     }\r\n     * });\r\n     */\r\n    MoveableManager.prototype.hitTest = function (el) {\r\n        var _a = this.state, target = _a.target, pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4, targetClientRect = _a.targetClientRect;\r\n        if (!target) {\r\n            return 0;\r\n        }\r\n        var rect;\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isNode)(el)) {\r\n            var clientRect = el.getBoundingClientRect();\r\n            rect = {\r\n                left: clientRect.left,\r\n                top: clientRect.top,\r\n                width: clientRect.width,\r\n                height: clientRect.height,\r\n            };\r\n        }\r\n        else {\r\n            rect = __assign({ width: 0, height: 0 }, el);\r\n        }\r\n        var rectLeft = rect.left, rectTop = rect.top, rectWidth = rect.width, rectHeight = rect.height;\r\n        var points = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect);\r\n        var size = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getOverlapSize)(points, [\r\n            [rectLeft, rectTop],\r\n            [rectLeft + rectWidth, rectTop],\r\n            [rectLeft + rectWidth, rectTop + rectHeight],\r\n            [rectLeft, rectTop + rectHeight],\r\n        ]);\r\n        var totalSize = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getAreaSize)(points);\r\n        if (!size || !totalSize) {\r\n            return 0;\r\n        }\r\n        return Math.min(100, size / totalSize * 100);\r\n    };\r\n    /**\r\n     * Whether the coordinates are inside Moveable\r\n     * @method Moveable#isInside\r\n     * @param - x coordinate\r\n     * @param - y coordinate\r\n     * @return - True if the coordinate is in moveable or false\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * document.body.addEventListener(\"mousedown\", e => {\r\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\r\n     *          console.log(\"inside\");\r\n     *     }\r\n     * });\r\n     */\r\n    MoveableManager.prototype.isInside = function (clientX, clientY) {\r\n        var _a = this.state, target = _a.target, pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4, targetClientRect = _a.targetClientRect;\r\n        if (!target) {\r\n            return false;\r\n        }\r\n        return (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.isInside)([clientX, clientY], (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.fitPoints)([pos1, pos2, pos4, pos3], targetClientRect));\r\n    };\r\n    /**\r\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\r\n     * @method Moveable#updateRect\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * window.addEventListener(\"resize\", e => {\r\n     *     moveable.updateRect();\r\n     * });\r\n     */\r\n    MoveableManager.prototype.updateRect = function (type, isTarget, isSetState) {\r\n        if (isSetState === void 0) { isSetState = true; }\r\n        var props = this.props;\r\n        var isSingle = !props.parentPosition && !props.wrapperMoveable;\r\n        if (isSingle) {\r\n            setStoreCache(true);\r\n        }\r\n        var parentMoveable = props.parentMoveable;\r\n        var state = this.state;\r\n        var target = (state.target || props.target);\r\n        var container = this.getContainer();\r\n        var rootContainer = parentMoveable\r\n            ? parentMoveable._rootContainer\r\n            : this._rootContainer;\r\n        var nextState = getMoveableTargetInfo(this.controlBox, target, container, container, rootContainer || container, this._getRequestStyles());\r\n        if (!target && this._hasFirstTarget && props.persistData) {\r\n            var persistState = getPersistState(props.persistData);\r\n            for (var name_2 in persistState) {\r\n                nextState[name_2] = persistState[name_2];\r\n            }\r\n        }\r\n        if (isSingle) {\r\n            setStoreCache();\r\n        }\r\n        this.updateState(nextState, parentMoveable ? false : isSetState);\r\n    };\r\n    /**\r\n     * Check if the moveable state is being dragged.\r\n     * @method Moveable#isDragging\r\n     * @param - If you want to check if able is dragging, specify ableName.\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * // false\r\n     * console.log(moveable.isDragging());\r\n     *\r\n     * moveable.on(\"drag\", () => {\r\n     *   // true\r\n     *   console.log(moveable.isDragging());\r\n     * });\r\n     */\r\n    MoveableManager.prototype.isDragging = function (ableName) {\r\n        var _a, _b;\r\n        var targetGesto = this.targetGesto;\r\n        var controlGesto = this.controlGesto;\r\n        if (targetGesto === null || targetGesto === void 0 ? void 0 : targetGesto.isFlag()) {\r\n            if (!ableName) {\r\n                return true;\r\n            }\r\n            var data = targetGesto.getEventData();\r\n            return !!((_a = data[ableName]) === null || _a === void 0 ? void 0 : _a.isEventStart);\r\n        }\r\n        if (controlGesto === null || controlGesto === void 0 ? void 0 : controlGesto.isFlag()) {\r\n            if (!ableName) {\r\n                return true;\r\n            }\r\n            var data = controlGesto.getEventData();\r\n            return !!((_b = data[ableName]) === null || _b === void 0 ? void 0 : _b.isEventStart);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\r\n     * Use `.updateRect()` method\r\n     * @method Moveable#updateTarget\r\n     * @deprecated\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * moveable.updateTarget();\r\n     */\r\n    MoveableManager.prototype.updateTarget = function (type) {\r\n        this.updateRect(type, true);\r\n    };\r\n    /**\r\n     * You can get the vertex information, position and offset size information of the target based on the container.\r\n     * @method Moveable#getRect\r\n     * @return - The Rect Info\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * const rectInfo = moveable.getRect();\r\n     */\r\n    MoveableManager.prototype.getRect = function () {\r\n        var state = this.state;\r\n        var poses = getAbsolutePosesByState(this.state);\r\n        var _a = __read(poses, 4), pos1 = _a[0], pos2 = _a[1], pos3 = _a[2], pos4 = _a[3];\r\n        var rect = getRect(poses);\r\n        var offsetWidth = state.width, offsetHeight = state.height;\r\n        var width = rect.width, height = rect.height, left = rect.left, top = rect.top;\r\n        var statePos = [state.left, state.top];\r\n        var origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(statePos, state.origin);\r\n        var beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(statePos, state.beforeOrigin);\r\n        var transformOrigin = state.transformOrigin;\r\n        return {\r\n            width: width,\r\n            height: height,\r\n            left: left,\r\n            top: top,\r\n            pos1: pos1,\r\n            pos2: pos2,\r\n            pos3: pos3,\r\n            pos4: pos4,\r\n            offsetWidth: offsetWidth,\r\n            offsetHeight: offsetHeight,\r\n            beforeOrigin: beforeOrigin,\r\n            origin: origin,\r\n            transformOrigin: transformOrigin,\r\n            rotation: this.getRotation(),\r\n        };\r\n    };\r\n    /**\r\n     * Get a manager that manages the moveable's state and props.\r\n     * @method Moveable#getManager\r\n     * @return - The Rect Info\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * const manager = moveable.getManager(); // real moveable class instance\r\n     */\r\n    MoveableManager.prototype.getManager = function () {\r\n        return this;\r\n    };\r\n    /**\r\n     * You can stop the dragging currently in progress through a method from outside.\r\n     * @method Moveable#stopDrag\r\n     * @return - The Rect Info\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * moveable.stopDrag();\r\n     */\r\n    MoveableManager.prototype.stopDrag = function (type) {\r\n        if (!type || type === \"target\") {\r\n            var gesto = this.targetGesto;\r\n            if ((gesto === null || gesto === void 0 ? void 0 : gesto.isIdle()) === false) {\r\n                unsetAbles(this, false);\r\n            }\r\n            gesto === null || gesto === void 0 ? void 0 : gesto.stop();\r\n        }\r\n        if (!type || type === \"control\") {\r\n            var gesto = this.controlGesto;\r\n            if ((gesto === null || gesto === void 0 ? void 0 : gesto.isIdle()) === false) {\r\n                unsetAbles(this, true);\r\n            }\r\n            gesto === null || gesto === void 0 ? void 0 : gesto.stop();\r\n        }\r\n    };\r\n    MoveableManager.prototype.getRotation = function () {\r\n        var _a = this.state, pos1 = _a.pos1, pos2 = _a.pos2, direction = _a.direction;\r\n        return getAbsoluteRotation(pos1, pos2, direction);\r\n    };\r\n    /**\r\n     * Request able through a method rather than an event.\r\n     * At the moment of execution, requestStart is executed,\r\n     * and then request and requestEnd can be executed through Requester.\r\n     * @method Moveable#request\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\r\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\r\n     * @param - ableName\r\n     * @param - request to be able params.\r\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\r\n     * @return - Able Requester. If there is no request in able, nothing will work.\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * // Instantly Request (requestStart - request - requestEnd)\r\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\r\n     *\r\n     * // Start move\r\n     * const requester = moveable.request(\"draggable\");\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.request({ deltaX: 10, deltaY: 10 });\r\n     * requester.requestEnd();\r\n     */\r\n    MoveableManager.prototype.request = function (ableName, param, isInstant) {\r\n        if (param === void 0) { param = {}; }\r\n        var self = this;\r\n        var props = self.props;\r\n        var manager = props.parentMoveable || props.wrapperMoveable || self;\r\n        var allAbles = manager.props.ables;\r\n        var groupable = props.groupable;\r\n        var requsetAble = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(allAbles, function (able) { return able.name === ableName; });\r\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\r\n            return {\r\n                request: function () {\r\n                    return this;\r\n                },\r\n                requestEnd: function () {\r\n                    return this;\r\n                },\r\n            };\r\n        }\r\n        var ableRequester = requsetAble.request(self);\r\n        var requestInstant = isInstant || param.isInstant;\r\n        var ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\r\n        var eventAffix = \"\".concat((groupable ? \"Group\" : \"\")).concat(ableRequester.isControl ? \"Control\" : \"\");\r\n        var moveableAbles = __spreadArray([], __read(manager[ableType]), false);\r\n        var requester = {\r\n            request: function (ableParam) {\r\n                triggerAble(self, moveableAbles, [\"drag\"], eventAffix, \"\", __assign(__assign({}, ableRequester.request(ableParam)), { requestAble: ableName, isRequest: true }), requestInstant);\r\n                return requester;\r\n            },\r\n            requestEnd: function () {\r\n                triggerAble(self, moveableAbles, [\"drag\"], eventAffix, \"End\", __assign(__assign({}, ableRequester.requestEnd()), { requestAble: ableName, isRequest: true }), requestInstant);\r\n                return requester;\r\n            },\r\n        };\r\n        triggerAble(self, moveableAbles, [\"drag\"], eventAffix, \"Start\", __assign(__assign({}, ableRequester.requestStart(param)), { requestAble: ableName, isRequest: true }), requestInstant);\r\n        return requestInstant ? requester.request(param).requestEnd() : requester;\r\n    };\r\n    /**\r\n     * moveable is the top level that manages targets\r\n     * `Single`: MoveableManager instance\r\n     * `Group`: MoveableGroup instance\r\n     * `IndividualGroup`: MoveableIndividaulGroup instance\r\n     * Returns leaf target MoveableManagers.\r\n     */\r\n    MoveableManager.prototype.getMoveables = function () {\r\n        return [this];\r\n    };\r\n    /**\r\n     * Remove the Moveable object and the events.\r\n     * @method Moveable#destroy\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body);\r\n     *\r\n     * moveable.destroy();\r\n     */\r\n    MoveableManager.prototype.destroy = function () {\r\n        this.componentWillUnmount();\r\n    };\r\n    MoveableManager.prototype.updateRenderPoses = function () {\r\n        var state = this.getState();\r\n        var props = this.props;\r\n        var padding = props.padding;\r\n        var originalBeforeOrigin = state.originalBeforeOrigin, transformOrigin = state.transformOrigin, allMatrix = state.allMatrix, is3d = state.is3d, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, stateLeft = state.left, stateTop = state.top, isPersisted = state.isPersisted;\r\n        var zoom = props.zoom || 1;\r\n        if (!padding && zoom <= 1) {\r\n            state.renderPoses = [\r\n                pos1,\r\n                pos2,\r\n                pos3,\r\n                pos4,\r\n            ];\r\n            state.renderLines = [\r\n                [pos1, pos2],\r\n                [pos2, pos4],\r\n                [pos4, pos3],\r\n                [pos3, pos1],\r\n            ];\r\n            return;\r\n        }\r\n        var _a = getPaddingBox(padding || {}), left = _a.left, top = _a.top, bottom = _a.bottom, right = _a.right;\r\n        var n = is3d ? 4 : 3;\r\n        // const clipPathInfo = getClipPath(\r\n        //     props.target,\r\n        //     offsetWidth,\r\n        //     offsetHeight,\r\n        // );\r\n        // if (clipPathInfo) {\r\n        //     left -= Math.max(0, clipPathInfo.left);\r\n        //     top -= Math.max(0, clipPathInfo.top);\r\n        //     bottom -= Math.max(0, offsetHeight - clipPathInfo.bottom);\r\n        //     right -= Math.max(0, offsetWidth - clipPathInfo.right);\r\n        // }\r\n        var absoluteOrigin = [];\r\n        if (isPersisted) {\r\n            absoluteOrigin = transformOrigin;\r\n        }\r\n        else if (this.controlBox && props.groupable) {\r\n            absoluteOrigin = originalBeforeOrigin;\r\n        }\r\n        else {\r\n            absoluteOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(originalBeforeOrigin, [stateLeft, stateTop]);\r\n        }\r\n        var nextMatrix = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.multiplies)(n, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(absoluteOrigin.map(function (v) { return -v; }), n), allMatrix, (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.createOriginMatrix)(transformOrigin, n));\r\n        var renderPos1 = calculatePadding(nextMatrix, pos1, [-left, -top], n);\r\n        var renderPos2 = calculatePadding(nextMatrix, pos2, [right, -top], n);\r\n        var renderPos3 = calculatePadding(nextMatrix, pos3, [-left, bottom], n);\r\n        var renderPos4 = calculatePadding(nextMatrix, pos4, [right, bottom], n);\r\n        state.renderPoses = [\r\n            renderPos1,\r\n            renderPos2,\r\n            renderPos3,\r\n            renderPos4,\r\n        ];\r\n        state.renderLines = [\r\n            [renderPos1, renderPos2],\r\n            [renderPos2, renderPos4],\r\n            [renderPos4, renderPos3],\r\n            [renderPos3, renderPos1],\r\n        ];\r\n        if (zoom) {\r\n            var zoomOffset = zoom / 2;\r\n            state.renderLines = [\r\n                [\r\n                    calculatePadding(nextMatrix, pos1, [-left - zoomOffset, -top], n),\r\n                    calculatePadding(nextMatrix, pos2, [right + zoomOffset, -top], n),\r\n                ],\r\n                [\r\n                    calculatePadding(nextMatrix, pos2, [right, -top - zoomOffset], n),\r\n                    calculatePadding(nextMatrix, pos4, [right, bottom + zoomOffset], n),\r\n                ],\r\n                [\r\n                    calculatePadding(nextMatrix, pos4, [right + zoomOffset, bottom], n),\r\n                    calculatePadding(nextMatrix, pos3, [-left - zoomOffset, bottom], n),\r\n                ],\r\n                [\r\n                    calculatePadding(nextMatrix, pos3, [-left, bottom + zoomOffset], n),\r\n                    calculatePadding(nextMatrix, pos1, [-left, -top - zoomOffset], n),\r\n                ],\r\n            ];\r\n        }\r\n    };\r\n    MoveableManager.prototype.checkUpdate = function () {\r\n        this._isPropTargetChanged = false;\r\n        var _a = this.props, target = _a.target, container = _a.container, parentMoveable = _a.parentMoveable;\r\n        var _b = this.state, stateTarget = _b.target, stateContainer = _b.container;\r\n        if (!stateTarget && !target) {\r\n            return;\r\n        }\r\n        this.updateAbles();\r\n        var isTargetChanged = !equals(stateTarget, target);\r\n        var isChanged = isTargetChanged || !equals(stateContainer, container);\r\n        if (!isChanged) {\r\n            return;\r\n        }\r\n        var moveableContainer = container || this.controlBox;\r\n        if (moveableContainer) {\r\n            this.unsetAbles();\r\n        }\r\n        this.updateState({ target: target, container: container });\r\n        if (!parentMoveable && moveableContainer) {\r\n            this.updateRect(\"End\", false, false);\r\n        }\r\n        this._isPropTargetChanged = isTargetChanged;\r\n    };\r\n    MoveableManager.prototype.waitToChangeTarget = function () {\r\n        return new Promise(function () { });\r\n    };\r\n    MoveableManager.prototype.triggerEvent = function (name, e) {\r\n        var props = this.props;\r\n        this._emitter.trigger(name, e);\r\n        if (props.parentMoveable && e.isRequest && !e.isRequestChild) {\r\n            return props.parentMoveable.triggerEvent(name, e, true);\r\n        }\r\n        var callback = props[name];\r\n        return callback && callback(e);\r\n    };\r\n    MoveableManager.prototype.useCSS = function (tag, css) {\r\n        var customStyleMap = this.props.customStyledMap;\r\n        var key = tag + css;\r\n        if (!customStyleMap[key]) {\r\n            customStyleMap[key] = (0,react_css_styled__WEBPACK_IMPORTED_MODULE_11__.styled)(tag, css);\r\n        }\r\n        return customStyleMap[key];\r\n    };\r\n    MoveableManager.prototype.getState = function () {\r\n        var _a;\r\n        var props = this.props;\r\n        if (props.target || ((_a = props.targets) === null || _a === void 0 ? void 0 : _a.length)) {\r\n            this._hasFirstTarget = true;\r\n        }\r\n        var hasControlBox = this.controlBox;\r\n        var persistData = props.persistData;\r\n        var firstRenderState = props.firstRenderState;\r\n        if (firstRenderState && !hasControlBox) {\r\n            return firstRenderState;\r\n        }\r\n        if (!this._hasFirstTarget && persistData) {\r\n            var persistState = getPersistState(persistData);\r\n            if (persistState) {\r\n                this.updateState(persistState, false);\r\n                return this.state;\r\n            }\r\n        }\r\n        this.state.isPersisted = false;\r\n        return this.state;\r\n    };\r\n    MoveableManager.prototype.updateSelectors = function () { };\r\n    MoveableManager.prototype.unsetAbles = function () {\r\n        var _this = this;\r\n        this.targetAbles.forEach(function (able) {\r\n            if (able.unset) {\r\n                able.unset(_this);\r\n            }\r\n        });\r\n    };\r\n    MoveableManager.prototype.updateAbles = function (ables, eventAffix) {\r\n        if (ables === void 0) { ables = this.props.ables; }\r\n        if (eventAffix === void 0) { eventAffix = \"\"; }\r\n        var props = this.props;\r\n        var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\r\n        var enabledAbles = this.getEnabledAbles(ables);\r\n        var dragStart = \"drag\".concat(eventAffix, \"Start\");\r\n        var pinchStart = \"pinch\".concat(eventAffix, \"Start\");\r\n        var dragControlStart = \"drag\".concat(eventAffix, \"ControlStart\");\r\n        var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\r\n        var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\r\n        this.enabledAbles = enabledAbles;\r\n        this.targetAbles = targetAbles;\r\n        this.controlAbles = controlAbles;\r\n    };\r\n    MoveableManager.prototype.updateState = function (nextState, isSetState) {\r\n        if (isSetState) {\r\n            if (this.isUnmounted) {\r\n                return;\r\n            }\r\n            this.setState(nextState);\r\n        }\r\n        else {\r\n            var state = this.state;\r\n            for (var name_3 in nextState) {\r\n                state[name_3] = nextState[name_3];\r\n            }\r\n        }\r\n    };\r\n    MoveableManager.prototype.getEnabledAbles = function (ables) {\r\n        if (ables === void 0) { ables = this.props.ables; }\r\n        var props = this.props;\r\n        return ables.filter(function (able) { return able && ((able.always && props[able.name] !== false)\r\n            || props[able.name]); });\r\n    };\r\n    MoveableManager.prototype.renderAbles = function () {\r\n        var _this = this;\r\n        var props = this.props;\r\n        var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\r\n        var Renderer = {\r\n            createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement,\r\n        };\r\n        this.renderState = {};\r\n        return groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(function (_a) {\r\n            var render = _a.render;\r\n            return render(_this, Renderer) || [];\r\n        })).filter(function (el) { return el; }), function (_a) {\r\n            var key = _a.key;\r\n            return key;\r\n        }).map(function (group) { return group[0]; });\r\n    };\r\n    MoveableManager.prototype.updateCheckInput = function () {\r\n        this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\r\n    };\r\n    MoveableManager.prototype._getRequestStyles = function () {\r\n        var styleNames = this.getEnabledAbles().reduce(function (names, able) {\r\n            var _a, _b;\r\n            var ableStyleNames = ((_b = (_a = able.requestStyle) === null || _a === void 0 ? void 0 : _a.call(able)) !== null && _b !== void 0 ? _b : []);\r\n            return __spreadArray(__spreadArray([], __read(names), false), __read(ableStyleNames), false);\r\n        }, __spreadArray([], __read((this.props.requestStyles || [])), false));\r\n        return styleNames;\r\n    };\r\n    MoveableManager.prototype._updateObserver = function (prevProps) {\r\n        this._updateResizeObserver(prevProps);\r\n        this._updateMutationObserver(prevProps);\r\n    };\r\n    MoveableManager.prototype._updateEvents = function () {\r\n        var hasTargetAble = this.targetAbles.length;\r\n        var hasControlAble = this.controlAbles.length;\r\n        var target = this._dragTarget;\r\n        var isUnset = (!hasTargetAble && this.targetGesto)\r\n            || this._isTargetChanged(true);\r\n        if (isUnset) {\r\n            unsetGesto(this, false);\r\n            this.updateState({ gestos: {} });\r\n        }\r\n        if (!hasControlAble) {\r\n            unsetGesto(this, true);\r\n        }\r\n        if (target && hasTargetAble && !this.targetGesto) {\r\n            this.targetGesto = getTargetAbleGesto(this, target, \"\");\r\n        }\r\n        if (!this.controlGesto && hasControlAble) {\r\n            this.controlGesto = getControlAbleGesto(this, \"Control\");\r\n        }\r\n    };\r\n    MoveableManager.prototype._updateTargets = function () {\r\n        var props = this.props;\r\n        this._prevPropTarget = this._propTarget;\r\n        this._prevDragTarget = this._dragTarget;\r\n        this._prevOriginalDragTarget = this._originalDragTarget;\r\n        this._prevDragArea = props.dragArea;\r\n        this._propTarget = props.target;\r\n        this._originalDragTarget = props.dragTarget || props.target;\r\n        this._dragTarget = getRefTarget(this._originalDragTarget, true);\r\n    };\r\n    MoveableManager.prototype._renderLines = function () {\r\n        var props = this.props;\r\n        var _a = props, zoom = _a.zoom, hideDefaultLines = _a.hideDefaultLines, hideChildMoveableDefaultLines = _a.hideChildMoveableDefaultLines, parentMoveable = _a.parentMoveable;\r\n        if (hideDefaultLines || (parentMoveable && hideChildMoveableDefaultLines)) {\r\n            return [];\r\n        }\r\n        var state = this.getState();\r\n        var Renderer = {\r\n            createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement,\r\n        };\r\n        return state.renderLines.map(function (line, i) {\r\n            return renderLine(Renderer, \"\", line[0], line[1], zoom, \"render-line-\".concat(i));\r\n        });\r\n    };\r\n    MoveableManager.prototype._isTargetChanged = function (useDragArea) {\r\n        var props = this.props;\r\n        var nextTarget = props.dragTarget || props.target;\r\n        var prevTarget = this._prevOriginalDragTarget;\r\n        var prevDragArea = this._prevDragArea;\r\n        var dragArea = props.dragArea;\r\n        // check target without dragArea\r\n        var isDragTargetChanged = !dragArea && prevTarget !== nextTarget;\r\n        var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;\r\n        return isDragTargetChanged || isDragAreaChanged || this._prevPropTarget != this._propTarget;\r\n    };\r\n    MoveableManager.prototype._updateNativeEvents = function () {\r\n        var _this = this;\r\n        var props = this.props;\r\n        var target = props.dragArea ? this.areaElement : this.state.target;\r\n        var events = this.events;\r\n        var eventKeys = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(events);\r\n        if (this._isTargetChanged()) {\r\n            for (var eventName in events) {\r\n                var manager = events[eventName];\r\n                manager && manager.destroy();\r\n                events[eventName] = null;\r\n            }\r\n        }\r\n        if (!target) {\r\n            return;\r\n        }\r\n        var enabledAbles = this.enabledAbles;\r\n        eventKeys.forEach(function (eventName) {\r\n            var ables = filterAbles(enabledAbles, [eventName]);\r\n            var hasAbles = ables.length > 0;\r\n            var manager = events[eventName];\r\n            if (!hasAbles) {\r\n                if (manager) {\r\n                    manager.destroy();\r\n                    events[eventName] = null;\r\n                }\r\n                return;\r\n            }\r\n            if (!manager) {\r\n                manager = new EventManager(target, _this, eventName);\r\n                events[eventName] = manager;\r\n            }\r\n            manager.setAbles(ables);\r\n        });\r\n    };\r\n    MoveableManager.prototype._checkUpdateRootContainer = function () {\r\n        var rootContainer = this.props.rootContainer;\r\n        if (!this._rootContainer && rootContainer) {\r\n            this._rootContainer = getRefTarget(rootContainer, true);\r\n        }\r\n    };\r\n    MoveableManager.prototype._checkUpdateViewContainer = function () {\r\n        var viewContainerOption = this.props.viewContainer;\r\n        if (!this._viewContainer && viewContainerOption) {\r\n            this._viewContainer = getRefTarget(viewContainerOption, true);\r\n        }\r\n        var viewContainer = this._viewContainer;\r\n        if (viewContainer) {\r\n            this._changeAbleViewClassNames(__spreadArray(__spreadArray([], __read(this._getAbleViewClassNames()), false), [\r\n                this.isDragging() ? VIEW_DRAGGING : \"\",\r\n            ], false));\r\n        }\r\n    };\r\n    MoveableManager.prototype._changeAbleViewClassNames = function (classNames) {\r\n        var viewContainer = this._viewContainer;\r\n        var nextClassNames = groupBy(classNames.filter(Boolean), function (el) { return el; }).map(function (_a) {\r\n            var _b = __read(_a, 1), className = _b[0];\r\n            return className;\r\n        });\r\n        var prevClassNames = this._viewClassNames;\r\n        var _a = (0,_egjs_list_differ__WEBPACK_IMPORTED_MODULE_12__.diff)(prevClassNames, nextClassNames), removed = _a.removed, added = _a.added;\r\n        removed.forEach(function (index) {\r\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.removeClass)(viewContainer, prevClassNames[index]);\r\n        });\r\n        added.forEach(function (index) {\r\n            (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.addClass)(viewContainer, nextClassNames[index]);\r\n        });\r\n        this._viewClassNames = nextClassNames;\r\n    };\r\n    MoveableManager.prototype._getAbleViewClassNames = function () {\r\n        var _this = this;\r\n        return (this.getEnabledAbles().map(function (able) {\r\n            var _a;\r\n            return (((_a = able.viewClassName) === null || _a === void 0 ? void 0 : _a.call(able, _this)) || \"\");\r\n        }).join(\" \") + \" \".concat(this._getAbleClassName(\"-view\"))).split(/\\s+/g);\r\n    };\r\n    MoveableManager.prototype._getAbleClassName = function (classPrefix) {\r\n        var _this = this;\r\n        if (classPrefix === void 0) { classPrefix = \"\"; }\r\n        var ables = this.getEnabledAbles();\r\n        var targetGesto = this.targetGesto;\r\n        var controlGesto = this.controlGesto;\r\n        var targetGestoData = (targetGesto === null || targetGesto === void 0 ? void 0 : targetGesto.isFlag())\r\n            ? targetGesto.getEventData() : {};\r\n        var controlGestoData = (controlGesto === null || controlGesto === void 0 ? void 0 : controlGesto.isFlag())\r\n            ? controlGesto.getEventData() : {};\r\n        return ables.map(function (able) {\r\n            var _a, _b, _c;\r\n            var name = able.name;\r\n            var className = ((_a = able.className) === null || _a === void 0 ? void 0 : _a.call(able, _this)) || \"\";\r\n            if (((_b = targetGestoData[name]) === null || _b === void 0 ? void 0 : _b.isEventStart)\r\n                || ((_c = controlGestoData[name]) === null || _c === void 0 ? void 0 : _c.isEventStart)) {\r\n                className += \" \".concat(prefix(\"\".concat(name).concat(classPrefix, \"-dragging\")));\r\n            }\r\n            return className.trim();\r\n        }).filter(Boolean).join(\" \");\r\n    };\r\n    MoveableManager.prototype._updateResizeObserver = function (prevProps) {\r\n        var _a;\r\n        var props = this.props;\r\n        var target = props.target;\r\n        var win = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(this.getControlBoxElement());\r\n        if (!win.ResizeObserver || !target || !props.useResizeObserver) {\r\n            (_a = this._reiszeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n            return;\r\n        }\r\n        if (prevProps.target === target && this._reiszeObserver) {\r\n            return;\r\n        }\r\n        var observer = new win.ResizeObserver(this.checkUpdateRect);\r\n        observer.observe(target, {\r\n            box: \"border-box\",\r\n        });\r\n        this._reiszeObserver = observer;\r\n    };\r\n    MoveableManager.prototype._updateMutationObserver = function (prevProps) {\r\n        var _this = this;\r\n        var _a;\r\n        var props = this.props;\r\n        var target = props.target;\r\n        var win = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getWindow)(this.getControlBoxElement());\r\n        if (!win.MutationObserver || !target || !props.useMutationObserver) {\r\n            (_a = this._mutationObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n            return;\r\n        }\r\n        if (prevProps.target === target && this._mutationObserver) {\r\n            return;\r\n        }\r\n        var observer = new win.MutationObserver(function (records) {\r\n            var e_1, _a;\r\n            try {\r\n                for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {\r\n                    var mutation = records_1_1.value;\r\n                    if (mutation.type === \"attributes\" && mutation.attributeName === \"style\") {\r\n                        _this.checkUpdateRect();\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        });\r\n        observer.observe(target, {\r\n            attributes: true,\r\n        });\r\n        this._mutationObserver = observer;\r\n    };\r\n    MoveableManager.defaultProps = {\r\n        dragTargetSelf: false,\r\n        target: null,\r\n        dragTarget: null,\r\n        container: null,\r\n        rootContainer: null,\r\n        origin: true,\r\n        parentMoveable: null,\r\n        wrapperMoveable: null,\r\n        isWrapperMounted: false,\r\n        parentPosition: null,\r\n        warpSelf: false,\r\n        svgOrigin: \"\",\r\n        dragContainer: null,\r\n        useResizeObserver: false,\r\n        useMutationObserver: false,\r\n        preventDefault: true,\r\n        preventRightClick: true,\r\n        preventWheelClick: true,\r\n        linePadding: 0,\r\n        controlPadding: 0,\r\n        ables: [],\r\n        pinchThreshold: 20,\r\n        dragArea: false,\r\n        passDragArea: false,\r\n        transformOrigin: \"\",\r\n        className: \"\",\r\n        zoom: 1,\r\n        triggerAblesSimultaneously: false,\r\n        padding: {},\r\n        pinchOutside: true,\r\n        checkInput: false,\r\n        dragFocusedInput: false,\r\n        groupable: false,\r\n        hideDefaultLines: false,\r\n        cspNonce: \"\",\r\n        translateZ: 0,\r\n        cssStyled: null,\r\n        customStyledMap: {},\r\n        props: {},\r\n        stopPropagation: false,\r\n        preventClickDefault: false,\r\n        preventClickEventOnDrag: true,\r\n        flushSync: defaultSync,\r\n        firstRenderState: null,\r\n        persistData: null,\r\n        viewContainer: null,\r\n        requestStyles: [],\r\n        useAccuratePosition: false,\r\n    };\r\n    return MoveableManager;\r\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\r\n/**\r\n * The target to indicate Moveable Control Box.\r\n * @name Moveable#target\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.target = document.querySelector(\".target\");\r\n */\r\n/**\r\n * Zooms in the elements of a moveable.\r\n * @name Moveable#zoom\r\n * @default 1\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.zoom = 2;\r\n */\r\n/**\r\n * Whether the target size is detected and updated whenever it changes.\r\n * @name Moveable#useResizeObserver\r\n * @default false\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.useResizeObserver = true;\r\n */\r\n/**\r\n * Resize, Scale Events at edges\r\n * @name Moveable#edge\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.edge = true;\r\n */\r\n/**\r\n * You can specify the className of the moveable controlbox.\r\n * @name Moveable#className\r\n * @default \"\"\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *   className: \"\",\r\n * });\r\n *\r\n * moveable.className = \"moveable1\";\r\n */\r\n/**\r\n * The target(s) to drag Moveable target(s)\r\n * @name Moveable#dragTarget\r\n * @default target\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body);\r\n * moveable.target = document.querySelector(\".target\");\r\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\r\n */\r\n/**\r\n * `renderStart` event occurs at the first start of all events.\r\n * @memberof Moveable\r\n * @event renderStart\r\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"renderStart\", ({ target }) => {\r\n *     console.log(\"onRenderStart\", target);\r\n * });\r\n */\r\n/**\r\n * `render` event occurs before the target is drawn on the screen.\r\n * @memberof Moveable\r\n * @event render\r\n * @param {Moveable.OnRender} - Parameters for the `render` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"render\", ({ target }) => {\r\n *     console.log(\"onRender\", target);\r\n * });\r\n */\r\n/**\r\n * `renderEnd` event occurs at the end of all events.\r\n * @memberof Moveable\r\n * @event renderEnd\r\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"renderEnd\", ({ target }) => {\r\n *     console.log(\"onRenderEnd\", target);\r\n * });\r\n */\r\n/**\r\n * `renderGroupStart` event occurs at the first start of all events in group.\r\n * @memberof Moveable\r\n * @event renderGroupStart\r\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\r\n *     console.log(\"onRenderGroupStart\", targets);\r\n * });\r\n */\r\n/**\r\n * `renderGroup` event occurs before the target is drawn on the screen in group.\r\n * @memberof Moveable\r\n * @event renderGroup\r\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"renderGroup\", ({ targets }) => {\r\n *     console.log(\"onRenderGroup\", targets);\r\n * });\r\n */\r\n/**\r\n * `renderGroupEnd` event occurs at the end of all events in group.\r\n * @memberof Moveable\r\n * @event renderGroupEnd\r\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\r\n *     console.log(\"onRenderGroupEnd\", targets);\r\n * });\r\n */\n\nvar Groupable = {\r\n    name: \"groupable\",\r\n    props: [\r\n        \"defaultGroupRotate\",\r\n        \"useDefaultGroupRotate\",\r\n        \"defaultGroupOrigin\",\r\n        \"groupable\",\r\n        \"groupableProps\",\r\n        \"targetGroups\",\r\n        \"hideChildMoveableDefaultLines\",\r\n    ],\r\n    events: [],\r\n    render: function (moveable, React) {\r\n        var _a;\r\n        var props = moveable.props;\r\n        var targets = props.targets || [];\r\n        var _b = moveable.getState(), left = _b.left, top = _b.top, isPersisted = _b.isPersisted;\r\n        var zoom = props.zoom || 1;\r\n        var renderGroupRects = moveable.renderGroupRects;\r\n        var persistDatChildren = ((_a = props.persistData) === null || _a === void 0 ? void 0 : _a.children) || [];\r\n        if (isPersisted) {\r\n            targets = persistDatChildren.map(function () { return null; });\r\n        }\r\n        else {\r\n            persistDatChildren = [];\r\n        }\r\n        var parentPosition = watchValue(moveable, \"parentPosition\", [left, top], function (styles) { return styles.join(\",\"); });\r\n        var requestStyles = watchValue(moveable, \"requestStyles\", moveable.getRequestChildStyles(), function (styles) { return styles.join(\",\"); });\r\n        moveable.moveables = moveable.moveables.slice(0, targets.length);\r\n        return __spreadArray(__spreadArray([], __read(targets.map(function (target, i) {\r\n            return React.createElement(MoveableManager, { key: \"moveable\" + i, ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.refs)(moveable, \"moveables\", i), target: target, origin: false, requestStyles: requestStyles, cssStyled: props.cssStyled, customStyledMap: props.customStyledMap, useResizeObserver: props.useResizeObserver, useMutationObserver: props.useMutationObserver, hideChildMoveableDefaultLines: props.hideChildMoveableDefaultLines, parentMoveable: moveable, parentPosition: [left, top], persistData: persistDatChildren[i], zoom: zoom });\r\n        })), false), __read(flat(renderGroupRects.map(function (_a, i) {\r\n            var pos1 = _a.pos1, pos2 = _a.pos2, pos3 = _a.pos3, pos4 = _a.pos4;\r\n            var poses = [pos1, pos2, pos3, pos4];\r\n            return [\r\n                [0, 1],\r\n                [1, 3],\r\n                [3, 2],\r\n                [2, 0],\r\n            ].map(function (_a, j) {\r\n                var _b = __read(_a, 2), from = _b[0], to = _b[1];\r\n                return renderLine(React, \"\", (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[from], parentPosition), (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(poses[to], parentPosition), zoom, \"group-rect-\".concat(i, \"-\").concat(j));\r\n            });\r\n        }))), false);\r\n    },\r\n};\n\nvar Clickable = makeAble(\"clickable\", {\r\n    props: [\r\n        \"clickable\",\r\n    ],\r\n    events: [\r\n        \"click\",\r\n        \"clickGroup\",\r\n    ],\r\n    always: true,\r\n    dragRelation: \"weak\",\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    dragStart: function () {\r\n        return;\r\n    },\r\n    dragControlStart: function () {\r\n        return;\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        var target = moveable.props.target;\r\n        var inputEvent = e.inputEvent;\r\n        var inputTarget = e.inputTarget;\r\n        var isMoveableElement = moveable.isMoveableElement(inputTarget);\r\n        var containsElement = !isMoveableElement && moveable.controlBox.contains(inputTarget);\r\n        if (!inputEvent || !inputTarget || e.isDrag\r\n            || moveable.isMoveableElement(inputTarget)\r\n            || containsElement\r\n        // External event duplicate target or dragAreaElement\r\n        ) {\r\n            return;\r\n        }\r\n        var containsTarget = target.contains(inputTarget);\r\n        triggerEvent(moveable, \"onClick\", fillParams(moveable, e, {\r\n            isDouble: e.isDouble,\r\n            inputTarget: inputTarget,\r\n            isTarget: target === inputTarget,\r\n            moveableTarget: moveable.props.target,\r\n            containsTarget: containsTarget,\r\n        }));\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        var inputEvent = e.inputEvent;\r\n        var inputTarget = e.inputTarget;\r\n        if (!inputEvent || !inputTarget || e.isDrag\r\n            || moveable.isMoveableElement(inputTarget)\r\n            // External event duplicate target or dragAreaElement\r\n            || e.datas.inputTarget === inputTarget) {\r\n            return;\r\n        }\r\n        var targets = moveable.props.targets;\r\n        var targetIndex = targets.indexOf(inputTarget);\r\n        var isTarget = targetIndex > -1;\r\n        var containsTarget = false;\r\n        if (targetIndex === -1) {\r\n            targetIndex = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.findIndex)(targets, function (parentTarget) { return parentTarget.contains(inputTarget); });\r\n            containsTarget = targetIndex > -1;\r\n        }\r\n        triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\r\n            isDouble: e.isDouble,\r\n            targets: targets,\r\n            inputTarget: inputTarget,\r\n            targetIndex: targetIndex,\r\n            isTarget: isTarget,\r\n            containsTarget: containsTarget,\r\n            moveableTarget: targets[targetIndex],\r\n        }));\r\n    },\r\n    dragControlEnd: function (moveable, e) {\r\n        this.dragEnd(moveable, e);\r\n    },\r\n    dragGroupControlEnd: function (moveable, e) {\r\n        this.dragEnd(moveable, e);\r\n    },\r\n});\r\n/**\r\n * When you click on the element, the `click` event is called.\r\n * @memberof Moveable\r\n * @event click\r\n * @param {Moveable.OnClick} - Parameters for the `click` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: document.querySelector(\".target\"),\r\n * });\r\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\r\n *     // If you click on an element other than the target and not included in the target, index is -1.\r\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\r\n * });\r\n */\r\n/**\r\n * When you click on the element inside the group, the `clickGroup` event is called.\r\n * @memberof Moveable\r\n * @event clickGroup\r\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\r\n * });\r\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\r\n *     // If you click on an element other than the target and not included in the target, index is -1.\r\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\r\n * });\r\n */\n\nfunction getDraggableEvent(e) {\r\n    var datas = e.originalDatas.draggable;\r\n    if (!datas) {\r\n        e.originalDatas.draggable = {};\r\n        datas = e.originalDatas.draggable;\r\n    }\r\n    return __assign(__assign({}, e), { datas: datas });\r\n}\r\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\r\n    css: [\r\n        \".edge.edgeDraggable.line {\\ncursor: move;\\n}\",\r\n    ],\r\n    render: function (moveable, React) {\r\n        var props = moveable.props;\r\n        var edge = props.edgeDraggable;\r\n        if (!edge) {\r\n            return [];\r\n        }\r\n        return renderEdgeLines(React, \"edgeDraggable\", edge, moveable.getState().renderPoses, props.zoom);\r\n    },\r\n    dragCondition: function (moveable, e) {\r\n        var _a;\r\n        var props = moveable.props;\r\n        var target = (_a = e.inputEvent) === null || _a === void 0 ? void 0 : _a.target;\r\n        if (!props.edgeDraggable || !target) {\r\n            return false;\r\n        }\r\n        return !props.draggable\r\n            && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\"))\r\n            && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"edge\"))\r\n            && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"edgeDraggable\"));\r\n    },\r\n    dragStart: function (moveable, e) {\r\n        return Draggable.dragStart(moveable, getDraggableEvent(e));\r\n    },\r\n    drag: function (moveable, e) {\r\n        return Draggable.drag(moveable, getDraggableEvent(e));\r\n    },\r\n    dragEnd: function (moveable, e) {\r\n        return Draggable.dragEnd(moveable, getDraggableEvent(e));\r\n    },\r\n    dragGroupCondition: function (moveable, e) {\r\n        var _a;\r\n        var props = moveable.props;\r\n        var target = (_a = e.inputEvent) === null || _a === void 0 ? void 0 : _a.target;\r\n        if (!props.edgeDraggable || !target) {\r\n            return false;\r\n        }\r\n        return !props.draggable && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"direction\")) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.hasClass)(target, prefix(\"line\"));\r\n    },\r\n    dragGroupStart: function (moveable, e) {\r\n        return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\r\n    },\r\n    dragGroup: function (moveable, e) {\r\n        return Draggable.dragGroup(moveable, getDraggableEvent(e));\r\n    },\r\n    dragGroupEnd: function (moveable, e) {\r\n        return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\r\n    },\r\n    unset: function (moveable) {\r\n        return Draggable.unset(moveable);\r\n    },\r\n});\r\n/**\r\n * Whether to move by dragging the edge line (default: false)\r\n * @name Moveable.Draggable#edgeDraggable\r\n * @example\r\n * import Moveable from \"moveable\";\r\n *\r\n * const moveable = new Moveable(document.body, {\r\n *  draggable: true,\r\n *  edgeDraggable: false,\r\n * });\r\n *\r\n * moveable.edgeDraggable = true;\r\n */\n\nvar IndividualGroupable = {\r\n    name: \"individualGroupable\",\r\n    props: [\r\n        \"individualGroupable\",\r\n        \"individualGroupableProps\",\r\n    ],\r\n    events: [],\r\n};\n\nvar MOVEABLE_ABLES =  [\r\n    BeforeRenderable,\r\n    Default, Snappable, Pinchable,\r\n    Draggable, edgeDraggable,\r\n    Resizable, Scalable, Warpable, Rotatable,\r\n    Scrollable, Padding, Origin,\r\n    OriginDraggable,\r\n    Clippable, Roundable, Groupable, IndividualGroupable,\r\n    Clickable,\r\n    DragArea,\r\n    Renderable,\r\n];\r\nvar MOVEABLE_EVENTS = /*#__PURE__*/ MOVEABLE_ABLES.reduce(function (current, able) {\r\n    (able.events || []).forEach(function (name) {\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.pushSet)(current, name);\r\n    });\r\n    return current;\r\n}, []);\r\nvar MOVEABLE_PROPS = /*#__PURE__*/ MOVEABLE_ABLES.reduce(function (current, able) {\r\n    (able.props || []).forEach(function (name) {\r\n        (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.pushSet)(current, name);\r\n    });\r\n    return current;\r\n}, []);\n\nfunction solveConstantsDistance(_a, pos) {\r\n    var _b = __read(_a, 3), a = _b[0], b = _b[1], c = _b[2];\r\n    return (a * pos[0] + b * pos[1] + c) / Math.sqrt(a * a + b * b);\r\n}\r\nfunction solveC(_a, pos) {\r\n    var _b = __read(_a, 2), a = _b[0], b = _b[1];\r\n    // ax + by + c = 0\r\n    // -ax -by;\r\n    return -a * pos[0] - b * pos[1];\r\n}\n\nfunction getMaxPos(poses, index) {\r\n    return Math.max.apply(Math, __spreadArray([], __read(poses.map(function (_a) {\r\n        var _b = __read(_a, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\r\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\r\n    })), false));\r\n}\r\nfunction getMinPos(poses, index) {\r\n    return Math.min.apply(Math, __spreadArray([], __read(poses.map(function (_a) {\r\n        var _b = __read(_a, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\r\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\r\n    })), false));\r\n}\r\nfunction getGroupRect(parentPoses, rotation) {\r\n    var _a, _b, _c;\r\n    var pos1 = [0, 0];\r\n    var pos2 = [0, 0];\r\n    var pos3 = [0, 0];\r\n    var pos4 = [0, 0];\r\n    var width = 0;\r\n    var height = 0;\r\n    if (!parentPoses.length) {\r\n        return {\r\n            pos1: pos1,\r\n            pos2: pos2,\r\n            pos3: pos3,\r\n            pos4: pos4,\r\n            minX: 0,\r\n            minY: 0,\r\n            maxX: 0,\r\n            maxY: 0,\r\n            width: width,\r\n            height: height,\r\n            rotation: rotation,\r\n        };\r\n    }\r\n    var fixedRotation = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.throttle)(rotation, TINY_NUM);\r\n    if (fixedRotation % 90) {\r\n        var rad = fixedRotation / 180 * Math.PI;\r\n        var a1_1 = Math.tan(rad);\r\n        var a2_1 = -1 / a1_1;\r\n        // ax = y  // -ax + y = 0 // 0 => 1\r\n        // -ax = y // ax + y = 0  // 0 => 3\r\n        var a1MinMax_1 = [MAX_NUM, MIN_NUM];\r\n        var a1MinMaxPos_1 = [[0, 0], [0, 0]];\r\n        var a2MinMax_1 = [MAX_NUM, MIN_NUM];\r\n        var a2MinMaxPos_1 = [[0, 0], [0, 0]];\r\n        parentPoses.forEach(function (poses) {\r\n            poses.forEach(function (pos) {\r\n                // const b1 = pos[1] - a1 * pos[0];\r\n                // const b2 = pos[1] - a2 * pos[0];\r\n                var a1Dist = solveConstantsDistance([-a1_1, 1, 0], pos);\r\n                var a2Dist = solveConstantsDistance([-a2_1, 1, 0], pos);\r\n                if (a1MinMax_1[0] > a1Dist) {\r\n                    a1MinMaxPos_1[0] = pos;\r\n                    a1MinMax_1[0] = a1Dist;\r\n                }\r\n                if (a1MinMax_1[1] < a1Dist) {\r\n                    a1MinMaxPos_1[1] = pos;\r\n                    a1MinMax_1[1] = a1Dist;\r\n                }\r\n                if (a2MinMax_1[0] > a2Dist) {\r\n                    a2MinMaxPos_1[0] = pos;\r\n                    a2MinMax_1[0] = a2Dist;\r\n                }\r\n                if (a2MinMax_1[1] < a2Dist) {\r\n                    a2MinMaxPos_1[1] = pos;\r\n                    a2MinMax_1[1] = a2Dist;\r\n                }\r\n            });\r\n        });\r\n        var _d = __read(a1MinMaxPos_1, 2), a1MinPos = _d[0], a1MaxPos = _d[1];\r\n        var _e = __read(a2MinMaxPos_1, 2), a2MinPos = _e[0], a2MaxPos = _e[1];\r\n        var minHorizontalLine = [-a1_1, 1, solveC([-a1_1, 1], a1MinPos)];\r\n        var maxHorizontalLine = [-a1_1, 1, solveC([-a1_1, 1], a1MaxPos)];\r\n        var minVerticalLine = [-a2_1, 1, solveC([-a2_1, 1], a2MinPos)];\r\n        var maxVerticalLine = [-a2_1, 1, solveC([-a2_1, 1], a2MaxPos)];\r\n        _a = __read([\r\n            [minHorizontalLine, minVerticalLine],\r\n            [minHorizontalLine, maxVerticalLine],\r\n            [maxHorizontalLine, minVerticalLine],\r\n            [maxHorizontalLine, maxVerticalLine],\r\n        ].map(function (_a) {\r\n            var _b = __read(_a, 2), line1 = _b[0], line2 = _b[1];\r\n            return (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getIntersectionPointsByConstants)(line1, line2)[0];\r\n        }), 4), pos1 = _a[0], pos2 = _a[1], pos3 = _a[2], pos4 = _a[3];\r\n        width = a2MinMax_1[1] - a2MinMax_1[0];\r\n        height = a1MinMax_1[1] - a1MinMax_1[0];\r\n    }\r\n    else {\r\n        var minX_1 = getMinPos(parentPoses, 0);\r\n        var minY_1 = getMinPos(parentPoses, 1);\r\n        var maxX_1 = getMaxPos(parentPoses, 0);\r\n        var maxY_1 = getMaxPos(parentPoses, 1);\r\n        pos1 = [minX_1, minY_1];\r\n        pos2 = [maxX_1, minY_1];\r\n        pos3 = [minX_1, maxY_1];\r\n        pos4 = [maxX_1, maxY_1];\r\n        width = maxX_1 - minX_1;\r\n        height = maxY_1 - minY_1;\r\n        if (fixedRotation % 180) {\r\n            // 0\r\n            // 1 2\r\n            // 3 4\r\n            // 90\r\n            // 3 1\r\n            // 4 2\r\n            // 180\r\n            // 4 3\r\n            // 2 1\r\n            // 270\r\n            // 2 4\r\n            // 1 3\r\n            // 1, 2, 3,4 = 3 1 4 2\r\n            var changedX = [pos3, pos1, pos4, pos2];\r\n            _b = __read(changedX, 4), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];\r\n            width = maxY_1 - minY_1;\r\n            height = maxX_1 - minX_1;\r\n        }\r\n    }\r\n    if (fixedRotation % 360 > 180) {\r\n        // 1 2   4 3\r\n        // 3 4   2 1\r\n        var changedX = [pos4, pos3, pos2, pos1];\r\n        _c = __read(changedX, 4), pos1 = _c[0], pos2 = _c[1], pos3 = _c[2], pos4 = _c[3];\r\n    }\r\n    var _f = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)([pos1, pos2, pos3, pos4]), minX = _f.minX, minY = _f.minY, maxX = _f.maxX, maxY = _f.maxY;\r\n    return {\r\n        pos1: pos1,\r\n        pos2: pos2,\r\n        pos3: pos3,\r\n        pos4: pos4,\r\n        width: width,\r\n        height: height,\r\n        minX: minX,\r\n        minY: minY,\r\n        maxX: maxX,\r\n        maxY: maxY,\r\n        rotation: rotation,\r\n    };\r\n}\r\nfunction findMoveableGroups(moveables, childTargetGroups) {\r\n    var groups = childTargetGroups.map(function (targetGroup) {\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(targetGroup)) {\r\n            var childMoveableGroups = findMoveableGroups(moveables, targetGroup);\r\n            var length_1 = childMoveableGroups.length;\r\n            if (length_1 > 1) {\r\n                return childMoveableGroups;\r\n            }\r\n            else if (length_1 === 1) {\r\n                return childMoveableGroups[0];\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            var checked = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(moveables, function (_a) {\r\n                var manager = _a.manager;\r\n                return manager.props.target === targetGroup;\r\n            });\r\n            if (checked) {\r\n                checked.finded = true;\r\n                return checked.manager;\r\n            }\r\n            return null;\r\n        }\r\n    }).filter(Boolean);\r\n    if (groups.length === 1 && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(groups[0])) {\r\n        return groups[0];\r\n    }\r\n    return groups;\r\n}\r\n/**\r\n * @namespace Moveable.Group\r\n * @description You can make targets moveable.\r\n */\r\nvar MoveableGroup = /*#__PURE__*/ (function (_super) {\r\n    __extends(MoveableGroup, _super);\r\n    function MoveableGroup() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\r\n        _this.moveables = [];\r\n        _this.transformOrigin = \"50% 50%\";\r\n        _this.renderGroupRects = [];\r\n        _this._targetGroups = [];\r\n        _this._hasFirstTargets = false;\r\n        return _this;\r\n    }\r\n    MoveableGroup.prototype.componentDidMount = function () {\r\n        _super.prototype.componentDidMount.call(this);\r\n    };\r\n    MoveableGroup.prototype.checkUpdate = function () {\r\n        this._isPropTargetChanged = false;\r\n        this.updateAbles();\r\n    };\r\n    MoveableGroup.prototype.getTargets = function () {\r\n        return this.props.targets;\r\n    };\r\n    MoveableGroup.prototype.updateRect = function (type, isTarget, isSetState) {\r\n        var _a;\r\n        if (isSetState === void 0) { isSetState = true; }\r\n        var state = this.state;\r\n        if (!this.controlBox || state.isPersisted) {\r\n            return;\r\n        }\r\n        setStoreCache(true);\r\n        this.moveables.forEach(function (moveable) {\r\n            moveable.updateRect(type, false, false);\r\n        });\r\n        var props = this.props;\r\n        var moveables = this.moveables;\r\n        var target = state.target || props.target;\r\n        var checkeds = moveables.map(function (moveable) { return ({ finded: false, manager: moveable }); });\r\n        var targetGroups = this.props.targetGroups || [];\r\n        var moveableGroups = findMoveableGroups(checkeds, targetGroups);\r\n        var useDefaultGroupRotate = props.useDefaultGroupRotate;\r\n        moveableGroups.push.apply(moveableGroups, __spreadArray([], __read(checkeds.filter(function (_a) {\r\n            var finded = _a.finded;\r\n            return !finded;\r\n        }).map(function (_a) {\r\n            var manager = _a.manager;\r\n            return manager;\r\n        })), false));\r\n        var renderGroupRects = [];\r\n        var isReset = !isTarget || (type !== \"\" && props.updateGroup);\r\n        var defaultGroupRotate = props.defaultGroupRotate || 0;\r\n        if (!this._hasFirstTargets) {\r\n            var persistedRoatation = (_a = props.persistData) === null || _a === void 0 ? void 0 : _a.rotation;\r\n            if (persistedRoatation != null) {\r\n                defaultGroupRotate = persistedRoatation;\r\n            }\r\n        }\r\n        function getMoveableGroupRect(group, parentRotation, isRoot) {\r\n            var posesRotations = group.map(function (moveable) {\r\n                if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(moveable)) {\r\n                    var rect = getMoveableGroupRect(moveable, parentRotation);\r\n                    var poses = [rect.pos1, rect.pos2, rect.pos3, rect.pos4];\r\n                    renderGroupRects.push(rect);\r\n                    return { poses: poses, rotation: rect.rotation };\r\n                }\r\n                else {\r\n                    return {\r\n                        poses: getAbsolutePosesByState(moveable.state),\r\n                        rotation: moveable.getRotation(),\r\n                    };\r\n                }\r\n            });\r\n            var rotations = posesRotations.map(function (_a) {\r\n                var rotation = _a.rotation;\r\n                return rotation;\r\n            });\r\n            var groupRotation = 0;\r\n            var firstRotation = rotations[0];\r\n            var isSameRotation = rotations.every(function (nextRotation) {\r\n                return Math.abs(firstRotation - nextRotation) < 0.1;\r\n            });\r\n            if (isReset) {\r\n                groupRotation = !useDefaultGroupRotate && isSameRotation ? firstRotation : defaultGroupRotate;\r\n            }\r\n            else {\r\n                groupRotation = !useDefaultGroupRotate && !isRoot && isSameRotation ? firstRotation : parentRotation;\r\n            }\r\n            var groupPoses = posesRotations.map(function (_a) {\r\n                var poses = _a.poses;\r\n                return poses;\r\n            });\r\n            var groupRect = getGroupRect(groupPoses, groupRotation);\r\n            return groupRect;\r\n        }\r\n        var rootGroupRect = getMoveableGroupRect(moveableGroups, this.rotation, true);\r\n        if (isReset) {\r\n            // reset rotataion\r\n            this.rotation = rootGroupRect.rotation;\r\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\r\n            this.scale = [1, 1];\r\n        }\r\n        this._targetGroups = targetGroups;\r\n        this.renderGroupRects = renderGroupRects;\r\n        var transformOrigin = this.transformOrigin;\r\n        var rotation = this.rotation;\r\n        var scale = this.scale;\r\n        var width = rootGroupRect.width, height = rootGroupRect.height, minX = rootGroupRect.minX, minY = rootGroupRect.minY;\r\n        var posesInfo = rotatePosesInfo([\r\n            [0, 0],\r\n            [width, 0],\r\n            [0, height],\r\n            [width, height],\r\n        ], convertTransformOriginArray(transformOrigin, width, height), this.rotation / 180 * Math.PI);\r\n        var _b = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)(posesInfo.result), deltaX = _b.minX, deltaY = _b.minY;\r\n        var rotateScale = \" rotate(\".concat(rotation, \"deg)\")\r\n            + \" scale(\".concat(sign(scale[0]), \", \").concat(sign(scale[1]), \")\");\r\n        var transform = \"translate(\".concat(-deltaX, \"px, \").concat(-deltaY, \"px)\").concat(rotateScale);\r\n        this.controlBox.style.transform\r\n            = \"translate3d(\".concat(minX, \"px, \").concat(minY, \"px, \").concat(this.props.translateZ || 0, \")\");\r\n        target.style.cssText += \"left:0px;top:0px;\"\r\n            + \"transform-origin:\".concat(transformOrigin, \";\")\r\n            + \"width:\".concat(width, \"px;height:\").concat(height, \"px;\")\r\n            + \"transform: \".concat(transform);\r\n        state.width = width;\r\n        state.height = height;\r\n        var container = this.getContainer();\r\n        var info = getMoveableTargetInfo(this.controlBox, target, this.controlBox, this.getContainer(), this._rootContainer || container, []);\r\n        var pos = [info.left, info.top];\r\n        var _c = __read(getAbsolutePosesByState(info), 4), pos1 = _c[0], pos2 = _c[1], pos3 = _c[2], pos4 = _c[3]; // info.left + info.pos(1 ~ 4)\r\n        var minPos = (0,overlap_area__WEBPACK_IMPORTED_MODULE_8__.getMinMaxs)([pos1, pos2, pos3, pos4]);\r\n        var delta = [minPos.minX, minPos.minY];\r\n        var direction = sign(scale[0] * scale[1]);\r\n        info.pos1 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos1, delta);\r\n        info.pos2 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos2, delta);\r\n        info.pos3 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos3, delta);\r\n        info.pos4 = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)(pos4, delta);\r\n        // info.left = info.left + delta[0];\r\n        // info.top = info.top + delta[1];\r\n        info.left = minX - info.left + delta[0];\r\n        info.top = minY - info.top + delta[1];\r\n        info.origin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.origin), delta);\r\n        info.beforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.beforeOrigin), delta);\r\n        info.originalBeforeOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.originalBeforeOrigin);\r\n        info.transformOrigin = (0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.minus)((0,_scena_matrix__WEBPACK_IMPORTED_MODULE_2__.plus)(pos, info.transformOrigin), delta);\r\n        target.style.transform\r\n            = \"translate(\".concat(-deltaX - delta[0], \"px, \").concat(-deltaY - delta[1], \"px)\")\r\n                + rotateScale;\r\n        setStoreCache();\r\n        this.updateState(__assign(__assign({}, info), { posDelta: delta, direction: direction, beforeDirection: direction }), isSetState);\r\n    };\r\n    MoveableGroup.prototype.getRect = function () {\r\n        return __assign(__assign({}, _super.prototype.getRect.call(this)), { children: this.moveables.map(function (child) { return child.getRect(); }) });\r\n    };\r\n    MoveableGroup.prototype.triggerEvent = function (name, e, isManager) {\r\n        if (isManager || name.indexOf(\"Group\") > -1) {\r\n            return _super.prototype.triggerEvent.call(this, name, e);\r\n        }\r\n        else {\r\n            this._emitter.trigger(name, e);\r\n        }\r\n    };\r\n    MoveableGroup.prototype.getRequestChildStyles = function () {\r\n        var styleNames = this.getEnabledAbles().reduce(function (names, able) {\r\n            var _a, _b;\r\n            var ableStyleNames = ((_b = (_a = able.requestChildStyle) === null || _a === void 0 ? void 0 : _a.call(able)) !== null && _b !== void 0 ? _b : []);\r\n            return __spreadArray(__spreadArray([], __read(names), false), __read(ableStyleNames), false);\r\n        }, []);\r\n        return styleNames;\r\n    };\r\n    MoveableGroup.prototype.getMoveables = function () {\r\n        return __spreadArray([], __read(this.moveables), false);\r\n    };\r\n    MoveableGroup.prototype.updateAbles = function () {\r\n        _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], __read(this.props.ables), false), [Groupable], false), \"Group\");\r\n    };\r\n    MoveableGroup.prototype._updateTargets = function () {\r\n        _super.prototype._updateTargets.call(this);\r\n        this._originalDragTarget = this.props.dragTarget || this.areaElement;\r\n        this._dragTarget = getRefTarget(this._originalDragTarget, true);\r\n    };\r\n    MoveableGroup.prototype._updateEvents = function () {\r\n        var state = this.state;\r\n        var props = this.props;\r\n        var prevTarget = this._prevDragTarget;\r\n        var nextTarget = props.dragTarget || this.areaElement;\r\n        var targets = props.targets;\r\n        var _a = this.differ.update(targets), added = _a.added, changed = _a.changed, removed = _a.removed;\r\n        var isTargetChanged = added.length || removed.length;\r\n        if (isTargetChanged || this._prevOriginalDragTarget !== this._originalDragTarget) {\r\n            unsetGesto(this, false);\r\n            unsetGesto(this, true);\r\n            this.updateState({ gestos: {} });\r\n        }\r\n        if (prevTarget !== nextTarget) {\r\n            state.target = null;\r\n        }\r\n        if (!state.target) {\r\n            state.target = this.areaElement;\r\n            this.controlBox.style.display = \"block\";\r\n        }\r\n        if (state.target) {\r\n            if (!this.targetGesto) {\r\n                this.targetGesto = getTargetAbleGesto(this, this._dragTarget, \"Group\");\r\n            }\r\n            if (!this.controlGesto) {\r\n                this.controlGesto = getControlAbleGesto(this, \"GroupControl\");\r\n            }\r\n        }\r\n        var isContainerChanged = !equals(state.container, props.container);\r\n        if (isContainerChanged) {\r\n            state.container = props.container;\r\n        }\r\n        if (isContainerChanged\r\n            || isTargetChanged\r\n            || this.transformOrigin !== (props.defaultGroupOrigin || \"50% 50%\")\r\n            || changed.length\r\n            || targets.length && !isDeepArrayEquals(this._targetGroups, props.targetGroups || [])) {\r\n            this.updateRect();\r\n            this._hasFirstTargets = true;\r\n        }\r\n        this._isPropTargetChanged = !!isTargetChanged;\r\n    };\r\n    MoveableGroup.prototype._updateObserver = function () { };\r\n    MoveableGroup.defaultProps = __assign(__assign({}, MoveableManager.defaultProps), { transformOrigin: [\"50%\", \"50%\"], groupable: true, dragArea: true, keepRatio: true, targets: [], defaultGroupRotate: 0, defaultGroupOrigin: \"50% 50%\" });\r\n    return MoveableGroup;\r\n}(MoveableManager));\n\n/**\r\n * @namespace Moveable.IndividualGroup\r\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\r\n */\r\nvar MoveableIndividualGroup = /*#__PURE__*/ (function (_super) {\r\n    __extends(MoveableIndividualGroup, _super);\r\n    function MoveableIndividualGroup() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.moveables = [];\r\n        return _this;\r\n    }\r\n    MoveableIndividualGroup.prototype.render = function () {\r\n        var _this = this;\r\n        var _a;\r\n        var props = this.props;\r\n        var cspNonce = props.cspNonce, ControlBoxElement = props.cssStyled, persistData = props.persistData;\r\n        var targets = props.targets || [];\r\n        var length = targets.length;\r\n        var canPersist = this.isUnmounted || !length;\r\n        var persistDatChildren = (_a = persistData === null || persistData === void 0 ? void 0 : persistData.children) !== null && _a !== void 0 ? _a : [];\r\n        if (canPersist && !length && persistDatChildren.length) {\r\n            targets = persistDatChildren.map(function () { return null; });\r\n        }\r\n        else if (!canPersist) {\r\n            persistDatChildren = [];\r\n        }\r\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(ControlBoxElement, { cspNonce: cspNonce, ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"controlBox\"), className: prefix(\"control-box\") }, targets.map(function (target, i) {\r\n            var _a, _b;\r\n            var individualProps = (_b = (_a = props.individualGroupableProps) === null || _a === void 0 ? void 0 : _a.call(props, target, i)) !== null && _b !== void 0 ? _b : {};\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableManager, __assign({ key: \"moveable\" + i, ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.refs)(_this, \"moveables\", i) }, props, individualProps, { target: target, wrapperMoveable: _this, isWrapperMounted: _this.isMoveableMounted, persistData: persistDatChildren[i] }));\r\n        }));\r\n    };\r\n    MoveableIndividualGroup.prototype.componentDidMount = function () { };\r\n    MoveableIndividualGroup.prototype.componentDidUpdate = function () { };\r\n    MoveableIndividualGroup.prototype.getTargets = function () {\r\n        return this.props.targets;\r\n    };\r\n    MoveableIndividualGroup.prototype.updateRect = function (type, isTarget, isSetState) {\r\n        if (isSetState === void 0) { isSetState = true; }\r\n        setStoreCache(true);\r\n        this.moveables.forEach(function (moveable) {\r\n            moveable.updateRect(type, isTarget, isSetState);\r\n        });\r\n        setStoreCache();\r\n    };\r\n    MoveableIndividualGroup.prototype.getRect = function () {\r\n        return __assign(__assign({}, _super.prototype.getRect.call(this)), { children: this.moveables.map(function (child) { return child.getRect(); }) });\r\n    };\r\n    MoveableIndividualGroup.prototype.request = function (ableName, param, isInstant) {\r\n        if (param === void 0) { param = {}; }\r\n        var results = this.moveables.map(function (m) { return m.request(ableName, __assign(__assign({}, param), { isInstant: false }), false); });\r\n        var requestInstant = isInstant || param.isInstant;\r\n        var requester = {\r\n            request: function (ableParam) {\r\n                results.forEach(function (r) { return r.request(ableParam); });\r\n                return this;\r\n            },\r\n            requestEnd: function () {\r\n                results.forEach(function (r) { return r.requestEnd(); });\r\n                return this;\r\n            },\r\n        };\r\n        return requestInstant ? requester.request(param).requestEnd() : requester;\r\n    };\r\n    MoveableIndividualGroup.prototype.dragStart = function (e, target) {\r\n        if (target === void 0) { target = e.target; }\r\n        var inputTarget = target;\r\n        var childMoveable = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(this.moveables, function (child) {\r\n            var target = child.getTargets()[0];\r\n            var controlBoxElement = child.getControlBoxElement();\r\n            var dragElement = child.getDragElement();\r\n            if (!target || !dragElement) {\r\n                return false;\r\n            }\r\n            return dragElement === inputTarget || dragElement.contains(inputTarget)\r\n                || (dragElement !== target && target === inputTarget || target.contains(inputTarget))\r\n                || controlBoxElement === inputTarget || controlBoxElement.contains(inputTarget);\r\n        });\r\n        if (childMoveable) {\r\n            childMoveable.dragStart(e, target);\r\n        }\r\n        return this;\r\n    };\r\n    MoveableIndividualGroup.prototype.hitTest = function () {\r\n        return 0;\r\n    };\r\n    MoveableIndividualGroup.prototype.isInside = function () {\r\n        return false;\r\n    };\r\n    MoveableIndividualGroup.prototype.isDragging = function () {\r\n        return false;\r\n    };\r\n    MoveableIndividualGroup.prototype.getDragElement = function () {\r\n        return null;\r\n    };\r\n    MoveableIndividualGroup.prototype.getMoveables = function () {\r\n        return __spreadArray([], __read(this.moveables), false);\r\n    };\r\n    MoveableIndividualGroup.prototype.updateRenderPoses = function () { };\r\n    MoveableIndividualGroup.prototype.checkUpdate = function () { };\r\n    MoveableIndividualGroup.prototype.triggerEvent = function () { };\r\n    MoveableIndividualGroup.prototype.updateAbles = function () { };\r\n    MoveableIndividualGroup.prototype._updateEvents = function () { };\r\n    MoveableIndividualGroup.prototype._updateObserver = function () { };\r\n    return MoveableIndividualGroup;\r\n}(MoveableManager));\n\nfunction getElementTargets(refTargets, selectorMap) {\r\n    var elementTargets = [];\r\n    refTargets.forEach(function (target) {\r\n        if (!target) {\r\n            return;\r\n        }\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\r\n            if (selectorMap[target]) {\r\n                elementTargets.push.apply(elementTargets, __spreadArray([], __read(selectorMap[target]), false));\r\n            }\r\n            return;\r\n        }\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\r\n            elementTargets.push.apply(elementTargets, __spreadArray([], __read(getElementTargets(target, selectorMap)), false));\r\n        }\r\n        else {\r\n            elementTargets.push(target);\r\n        }\r\n    });\r\n    return elementTargets;\r\n}\r\nfunction getTargetGroups(refTargets, selectorMap) {\r\n    var targetGroups = [];\r\n    refTargets.forEach(function (target) {\r\n        if (!target) {\r\n            return;\r\n        }\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\r\n            if (selectorMap[target]) {\r\n                targetGroups.push.apply(targetGroups, __spreadArray([], __read(selectorMap[target]), false));\r\n            }\r\n            return;\r\n        }\r\n        if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\r\n            targetGroups.push(getTargetGroups(target, selectorMap));\r\n        }\r\n        else {\r\n            targetGroups.push(target);\r\n        }\r\n    });\r\n    return targetGroups;\r\n}\r\nfunction compareRefTargets(prevRefTargets, nextRefTargets) {\r\n    return (prevRefTargets.length !== nextRefTargets.length) || prevRefTargets.some(function (target, i) {\r\n        var nextTarget = nextRefTargets[i];\r\n        if (!target && !nextTarget) {\r\n            return false;\r\n        }\r\n        else if (target != nextTarget) {\r\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target) && (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(nextTarget)) {\r\n                return compareRefTargets(target, nextTarget);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}\r\nvar InitialMoveable = /*#__PURE__*/ (function (_super) {\r\n    __extends(InitialMoveable, _super);\r\n    function InitialMoveable() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.refTargets = [];\r\n        _this.selectorMap = {};\r\n        _this._differ = new _egjs_children_differ__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\r\n        _this._elementTargets = [];\r\n        _this._tmpRefTargets = [];\r\n        _this._tmpSelectorMap = {};\r\n        _this._onChangeTargets = null;\r\n        return _this;\r\n    }\r\n    InitialMoveable.makeStyled = function () {\r\n        var cssMap = {};\r\n        var ables = this.getTotalAbles();\r\n        ables.forEach(function (_a) {\r\n            var css = _a.css;\r\n            if (!css) {\r\n                return;\r\n            }\r\n            css.forEach(function (text) {\r\n                cssMap[text] = true;\r\n            });\r\n        });\r\n        var style = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.getKeys)(cssMap).join(\"\\n\");\r\n        this.defaultStyled = (0,react_css_styled__WEBPACK_IMPORTED_MODULE_11__.styled)(\"div\", (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.prefixCSS)(PREFIX, MOVEABLE_CSS + style));\r\n    };\r\n    InitialMoveable.getTotalAbles = function () {\r\n        return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], __read(this.defaultAbles), false);\r\n    };\r\n    InitialMoveable.prototype.render = function () {\r\n        var _a;\r\n        var moveableContructor = this.constructor;\r\n        if (!moveableContructor.defaultStyled) {\r\n            moveableContructor.makeStyled();\r\n        }\r\n        var _b = this.props, userAbles = _b.ables, userProps = _b.props, props = __rest(_b, [\"ables\", \"props\"]);\r\n        var _c = __read(this._updateRefs(true), 2), refTargets = _c[0], nextSelectorMap = _c[1];\r\n        var elementTargets = getElementTargets(refTargets, nextSelectorMap);\r\n        var isGroup = elementTargets.length > 1;\r\n        var totalAbles = moveableContructor.getTotalAbles();\r\n        var ables = __spreadArray(__spreadArray([], __read(totalAbles), false), __read((userAbles || [])), false);\r\n        var nextProps = __assign(__assign(__assign({}, props), (userProps || {})), { ables: ables, cssStyled: moveableContructor.defaultStyled, customStyledMap: moveableContructor.customStyledMap });\r\n        this._elementTargets = elementTargets;\r\n        var firstRenderState = null;\r\n        var prevMoveable = this.moveable;\r\n        var persistData = props.persistData;\r\n        if (persistData === null || persistData === void 0 ? void 0 : persistData.children) {\r\n            isGroup = true;\r\n        }\r\n        // Even one child is treated as a group if individualGroupable is enabled. #867\r\n        if (props.individualGroupable) {\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableIndividualGroup, __assign({ key: \"individual-group\", ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"moveable\") }, nextProps, { target: null, targets: elementTargets }));\r\n        }\r\n        if (isGroup) {\r\n            var targetGroups = getTargetGroups(refTargets, nextSelectorMap);\r\n            // manager\r\n            if (prevMoveable && !prevMoveable.props.groupable && !prevMoveable.props.individualGroupable) {\r\n                var target = prevMoveable.props.target;\r\n                if (target && elementTargets.indexOf(target) > -1) {\r\n                    firstRenderState = __assign({}, prevMoveable.state);\r\n                }\r\n            }\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableGroup, __assign({ key: \"group\", ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"moveable\") }, nextProps, (_a = props.groupableProps) !== null && _a !== void 0 ? _a : {}, { target: null, targets: elementTargets, targetGroups: targetGroups, firstRenderState: firstRenderState }));\r\n        }\r\n        else {\r\n            var target_1 = elementTargets[0];\r\n            // manager\r\n            if (prevMoveable && (prevMoveable.props.groupable || prevMoveable.props.individualGroupable)) {\r\n                var moveables = prevMoveable.moveables || [];\r\n                var prevTargetMoveable = (0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.find)(moveables, function (mv) { return mv.props.target === target_1; });\r\n                if (prevTargetMoveable) {\r\n                    firstRenderState = __assign({}, prevTargetMoveable.state);\r\n                }\r\n            }\r\n            return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MoveableManager, __assign({ key: \"single\", ref: (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.ref)(this, \"moveable\") }, nextProps, { target: target_1, firstRenderState: firstRenderState }));\r\n        }\r\n    };\r\n    InitialMoveable.prototype.componentDidMount = function () {\r\n        this._checkChangeTargets();\r\n    };\r\n    InitialMoveable.prototype.componentDidUpdate = function () {\r\n        this._checkChangeTargets();\r\n    };\r\n    InitialMoveable.prototype.componentWillUnmount = function () {\r\n        this.selectorMap = {};\r\n        this.refTargets = [];\r\n    };\r\n    /**\r\n     * Get targets set in moveable through target or targets of props.\r\n     * @method Moveable#getTargets\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body, {\r\n     *    target: [targetRef, \".target\", document.querySelectorAll(\".target\")],\r\n     * });\r\n     *\r\n     * console.log(moveable.getTargets());\r\n     */\r\n    InitialMoveable.prototype.getTargets = function () {\r\n        var _a, _b;\r\n        return (_b = (_a = this.moveable) === null || _a === void 0 ? void 0 : _a.getTargets()) !== null && _b !== void 0 ? _b : [];\r\n    };\r\n    /**\r\n     * If the element list corresponding to the selector among the targets is changed, it is updated.\r\n     * @method Moveable#updateSelectors\r\n     * @example\r\n     * import Moveable from \"moveable\";\r\n     *\r\n     * const moveable = new Moveable(document.body, {\r\n     *    target: \".target\",\r\n     * });\r\n     *\r\n     * moveable.updateSelectors();\r\n     */\r\n    InitialMoveable.prototype.updateSelectors = function () {\r\n        this.selectorMap = {};\r\n        this._updateRefs();\r\n        this.forceUpdate();\r\n    };\r\n    /**\r\n     * User changes target and waits for target to change.\r\n     * @method Moveable#waitToChangeTarget\r\n     * @story combination-with-other-components--components-selecto\r\n     * @example\r\n     * document.querySelector(\".target\").addEventListener(\"mousedown\", e => {\r\n     *   moveable.waitToChangeTarget().then(() => {\r\n     *      moveable.dragStart(e, e.currentTarget);\r\n     *   });\r\n     *   moveable.target = e.currentTarget;\r\n     * });\r\n     */\r\n    InitialMoveable.prototype.waitToChangeTarget = function () {\r\n        // let resolvePromise: (e: OnChangeTarget) => void;\r\n        var _this = this;\r\n        // this._onChangeTargets = () => {\r\n        //     this._onChangeTargets = null;\r\n        //     resolvePromise({\r\n        //         moveable: this.getManager(),\r\n        //         targets: this._elementTargets,\r\n        //     });\r\n        // };\r\n        // return new Promise<OnChangeTarget>(resolve => {\r\n        //     resolvePromise = resolve;\r\n        // });\r\n        var resolvePromise;\r\n        this._onChangeTargets = function () {\r\n            _this._onChangeTargets = null;\r\n            resolvePromise();\r\n        };\r\n        return new Promise(function (resolve) {\r\n            resolvePromise = resolve;\r\n        });\r\n    };\r\n    InitialMoveable.prototype.waitToChangeTargets = function () {\r\n        return this.waitToChangeTarget();\r\n    };\r\n    InitialMoveable.prototype.getManager = function () {\r\n        return this.moveable;\r\n    };\r\n    InitialMoveable.prototype.getMoveables = function () {\r\n        return this.moveable.getMoveables();\r\n    };\r\n    InitialMoveable.prototype.getDragElement = function () {\r\n        return this.moveable.getDragElement();\r\n    };\r\n    InitialMoveable.prototype._updateRefs = function (isRender) {\r\n        var prevRefTargets = this.refTargets;\r\n        var nextRefTargets = getRefTargets((this.props.target || this.props.targets));\r\n        var isBrowser = typeof document !== \"undefined\";\r\n        var isUpdate = compareRefTargets(prevRefTargets, nextRefTargets);\r\n        var selectorMap = this.selectorMap;\r\n        var nextSelectorMap = {};\r\n        this.refTargets.forEach(function updateSelectorMap(target) {\r\n            if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isString)(target)) {\r\n                var selectorTarget = selectorMap[target];\r\n                if (selectorTarget) {\r\n                    nextSelectorMap[target] = selectorMap[target];\r\n                }\r\n                else if (isBrowser) {\r\n                    isUpdate = true;\r\n                    nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\r\n                }\r\n            }\r\n            else if ((0,_daybrush_utils__WEBPACK_IMPORTED_MODULE_3__.isArray)(target)) {\r\n                target.forEach(updateSelectorMap);\r\n            }\r\n        });\r\n        this._tmpRefTargets = nextRefTargets;\r\n        this._tmpSelectorMap = nextSelectorMap;\r\n        return [\r\n            nextRefTargets,\r\n            nextSelectorMap,\r\n            !isRender && isUpdate,\r\n        ];\r\n    };\r\n    InitialMoveable.prototype._checkChangeTargets = function () {\r\n        var _a, _b, _c;\r\n        this.refTargets = this._tmpRefTargets;\r\n        this.selectorMap = this._tmpSelectorMap;\r\n        var _d = this._differ.update(this._elementTargets), added = _d.added, removed = _d.removed;\r\n        var isTargetChanged = added.length || removed.length;\r\n        if (isTargetChanged) {\r\n            (_b = (_a = this.props).onChangeTargets) === null || _b === void 0 ? void 0 : _b.call(_a, {\r\n                moveable: this.moveable,\r\n                targets: this._elementTargets,\r\n            });\r\n            (_c = this._onChangeTargets) === null || _c === void 0 ? void 0 : _c.call(this);\r\n        }\r\n        var _e = __read(this._updateRefs(), 3), refTargets = _e[0], selectorMap = _e[1], isUpdate = _e[2];\r\n        this.refTargets = refTargets;\r\n        this.selectorMap = selectorMap;\r\n        if (isUpdate) {\r\n            this.forceUpdate();\r\n        }\r\n    };\r\n    InitialMoveable.defaultAbles = [];\r\n    InitialMoveable.customStyledMap = {};\r\n    InitialMoveable.defaultStyled = null;\r\n    __decorate([\r\n        (0,framework_utils__WEBPACK_IMPORTED_MODULE_6__.withMethods)(MOVEABLE_METHODS)\r\n    ], InitialMoveable.prototype, \"moveable\", void 0);\r\n    return InitialMoveable;\r\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent));\n\nvar Moveable = /*#__PURE__*/ (function (_super) {\r\n    __extends(Moveable, _super);\r\n    function Moveable() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Moveable.defaultAbles = MOVEABLE_ABLES;\r\n    return Moveable;\r\n}(InitialMoveable));\n\nfunction makeMoveable(ables) {\r\n    var _a;\r\n    return _a = /*#__PURE__*/ (function (_super) {\r\n            __extends(Moveable, _super);\r\n            function Moveable() {\r\n                return _super !== null && _super.apply(this, arguments) || this;\r\n            }\r\n            return Moveable;\r\n        }(InitialMoveable)),\r\n        _a.defaultAbles = ables,\r\n        _a;\r\n}\n\n\n//# sourceMappingURL=moveable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZWFibGUvZGlzdC9tb3ZlYWJsZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21DO0FBQzhDO0FBQ29hO0FBQ3ZMO0FBQ3JQO0FBQ1o7QUFDbEI7QUFDbUY7QUFDL0Y7QUFDTztBQUNaO0FBQ2dCO0FBQ007QUFDRzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkNBQTZDLHVDQUF1QztBQUNwRjtBQUNBO0FBQ0EsNkRBQTZELE9BQU8scURBQU0sYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLHVEQUFNO0FBQ3JCLEtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkJBQTJCLG9EQUFvRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsNkNBQTZDLHNCQUFzQixHQUFHO0FBQ3BILEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZELE9BQU8scURBQU0sYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxRQUFRLHVEQUFNO0FBQ2QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1REFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGtEQUFrRDtBQUN2SDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGdFQUFnRSw4Q0FBOEM7QUFDOUc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsV0FBVyx3REFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBUTtBQUNoQjtBQUNBO0FBQ0EsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyx5REFBVSxJQUFJLGlFQUFrQixxQkFBcUIsaUVBQWtCLDJCQUEyQixZQUFZO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQVM7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixxQkFBcUI7QUFDcEg7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQixRQUFRLGdFQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHlCQUF5QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHlCQUF5QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdFQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQWdCO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnRUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLCtEQUErRCxpRUFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBUyxTQUFTLG9FQUFxQjtBQUNsRDtBQUNBO0FBQ0EsbUZBQW1GLDJDQUEyQztBQUM5SDtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RCw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFVO0FBQ3hCO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscURBQU07QUFDeEMsb0JBQW9CLG9EQUFLO0FBQ3pCLG1CQUFtQix5REFBVSxrQkFBa0IsaUVBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQStDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBCQUEwQixNQUFNLHVEQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkUsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0REFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdFQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0VBQWU7QUFDbEUsa0RBQWtELGdFQUFlO0FBQ2pFLHVCQUF1QixnRUFBZTtBQUN0Qyx3QkFBd0IsZ0VBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFlO0FBQzVDLDhCQUE4QixnRUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQU87QUFDekI7QUFDQTtBQUNBLGtCQUFrQix3REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFlLGVBQWUsbUVBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFJO0FBQ1osUUFBUSxtREFBSTtBQUNaLFFBQVEsbURBQUk7QUFDWixRQUFRLG1EQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBTyw4QkFBOEIsaUJBQWlCLDJEQUFVLHlDQUF5QyxLQUFLO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2Qyx3Q0FBd0MsMkJBQTJCLHNCQUFzQixnRUFBZ0U7QUFDck87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixhQUFhLGtQQUFrUDtBQUM5UztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usc0JBQXNCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSxhQUFhLDREQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBUyxDQUFDLHFEQUFNLGFBQWEsb0VBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFRLCtDQUErQyx5REFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBSztBQUMzQiw2QkFBNkIscUNBQXFDO0FBQ2xFLDZCQUE2QixzQ0FBc0M7QUFDbkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGlEQUFLO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBSztBQUNwQyxnQ0FBZ0MsaURBQUs7QUFDckMsOEJBQThCLGlEQUFLO0FBQ25DLCtCQUErQixpREFBSztBQUNwQyw0QkFBNEIsdURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVE7QUFDekI7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBO0FBQ0EsV0FBVyx3REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTTtBQUNkO0FBQ0E7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFVO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLHlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUTtBQUNwQjtBQUNBO0FBQ0EsWUFBWSx3REFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsdURBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQU07QUFDOUI7QUFDQSx3QkFBd0IsK0RBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVEQUFNO0FBQ3hCLDBCQUEwQix1REFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBDQUEwQztBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRUFBZTtBQUN2QixRQUFRLGdFQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPLG9EQUFLLGdCQUFnQjtBQUMzRSxtREFBbUQsT0FBTyxxREFBTSxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPLG1EQUFJLGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFPO0FBQzlCLHVCQUF1Qix3REFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFPLCtCQUErQix5QkFBeUI7QUFDMUU7QUFDQTtBQUNBLFFBQVEseURBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixpREFBaUQ7QUFDdEYsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLHFFQUFxRTtBQUM3SDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFFBQVEsMEtBQTBLO0FBQ25QLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFFBQVEseUZBQXlGO0FBQ2xLLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLDZEQUE2RCxRQUFRLGlDQUFpQztBQUN0RyxLQUFLO0FBQ0w7QUFDQSx3REFBd0QsUUFBUSxpQ0FBaUM7QUFDakcsS0FBSztBQUNMO0FBQ0EsMkRBQTJELFFBQVEsaUNBQWlDO0FBQ3BHLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsSUFBSTtBQUNKLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLElBQUk7QUFDSiw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLElBQUk7QUFDSiwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLFFBQVE7QUFDdEM7QUFDQSxJQUFJO0FBQ0osK0JBQStCLFFBQVE7QUFDdkM7QUFDQSxJQUFJO0FBQ0osOEJBQThCLFFBQVE7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsU0FBUztBQUM5QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQVMsZUFBZSx3REFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLGFBQWEsZ0lBQWdJLDJDQUEyQyxrRkFBa0Y7QUFDMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQU87QUFDdkIseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQVE7QUFDdEM7QUFDQTtBQUNBLDhCQUE4Qix5REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseURBQVE7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQix5REFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1FQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGdEQUFnRCx1REFBdUQ7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvREFBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrSkFBa0o7QUFDMU07QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDZDQUE2QyxhQUFhLHVGQUF1RjtBQUNqSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGtCQUFrQixpQ0FBaUM7QUFDeEosU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdEQUFTLENBQUMsaUVBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQSw0QkFBNEIsbURBQUkscUNBQXFDO0FBQ3JFLFNBQVM7QUFDVCxvQ0FBb0MsaURBQWlEO0FBQ3JGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSx3Q0FBd0M7QUFDdkQsZ0JBQWdCLG9CQUFvQjtBQUNwQzs7QUFFQTtBQUNBLHNDQUFzQyxpQ0FBaUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsMkJBQTJCLGlDQUFpQztBQUM1RCwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEUsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEUsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0Esd0NBQXdDLE9BQU8sb0RBQUcsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQU07QUFDckIsZUFBZSx1REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtR0FBbUc7QUFDNUkseUNBQXlDLG1HQUFtRztBQUM1SSx5Q0FBeUMsbUdBQW1HO0FBQzVJLHlDQUF5QyxtR0FBbUc7QUFDNUk7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVEsaUNBQWlDLHlEQUFRO0FBQ2hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0RBQWdCO0FBQ3ZFLG9DQUFvQyw4REFBZSxDQUFDLHFEQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxvREFBSyx1QkFBdUI7QUFDaEU7QUFDQTtBQUNBLG1CQUFtQix3REFBUztBQUM1QixTQUFTO0FBQ1QsMkJBQTJCLG1FQUFvQjtBQUMvQywyQkFBMkIsbUVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsOEJBQThCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2Riw2REFBNkQsd0JBQXdCO0FBQ3JGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQTBDO0FBQzNFO0FBQ0E7QUFDQSwrQkFBK0IsbURBQUk7QUFDbkMsU0FBUztBQUNULHVEQUF1RCxpREFBaUQsa0JBQWtCLGtDQUFrQyxzQkFBc0IsS0FBSztBQUN2TDtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBUTtBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLHVEQUFRLENBQUMscURBQU07QUFDbkM7QUFDQSwwQkFBMEIsdURBQVE7QUFDbEM7QUFDQTtBQUNBLDRFQUE0RSwyREFBMkQsbURBQVEsNEJBQTRCO0FBQzNLO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEUsMEJBQTBCLG9DQUFvQztBQUM5RDtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEUsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFXO0FBQ2Ysb0NBQW9DLFVBQVUsNEJBQTRCO0FBQzFFO0FBQ0E7QUFDQSx5Q0FBeUMsNENBQTRDO0FBQ3JGLHFDQUFxQyx1QkFBdUI7QUFDNUQscUNBQXFDLHVCQUF1QjtBQUM1RCxxQ0FBcUMsdUJBQXVCO0FBQzVELHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0Isb0RBQUcsaURBQWlEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBZ0I7QUFDaEM7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0Isb0RBQUc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUF1RTtBQUNyRixjQUFjLHdFQUF3RTtBQUN0RixjQUFjLDRGQUE0RjtBQUMxRyxjQUFjLDRGQUE0RjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw4QkFBOEIsa0NBQWtDLG1DQUFtQztBQUNwSixTQUFTO0FBQ1QsUUFBUSx5REFBUTtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBcUI7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9EQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUZBQWlGO0FBQzFIO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkNBQTJDLG1DQUFtQztBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDJDQUEyQyx3REFBd0Q7QUFDbkcsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNERBQTRELFFBQVEsaUJBQWlCO0FBQ3JGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0REFBNEQsUUFBUSxpQ0FBaUM7QUFDckcsS0FBSztBQUNMO0FBQ0EsdURBQXVELFFBQVEsaUNBQWlDO0FBQ2hHLEtBQUs7QUFDTDtBQUNBLDBEQUEwRCxRQUFRLGlDQUFpQztBQUNuRyxLQUFLO0FBQ0w7QUFDQSw0REFBNEQsUUFBUSxrREFBa0Q7QUFDdEgsS0FBSztBQUNMO0FBQ0EsdURBQXVELFFBQVEsaUNBQWlDO0FBQ2hHLEtBQUs7QUFDTDtBQUNBLDBEQUEwRCxRQUFRLGlDQUFpQztBQUNuRyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQ0FBc0M7QUFDckQsSUFBSTtBQUNKLHdCQUF3QiwwQ0FBMEM7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixPQUFPLGdFQUFlLGVBQWU7QUFDNUgscUZBQXFGLE9BQU8sZ0VBQWUsZ0JBQWdCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUNBQXlDLGlCQUFpQjtBQUNyRjtBQUNBLGlDQUFpQyx5Q0FBeUMsMEJBQTBCLHFCQUFxQjtBQUN6SDtBQUNBLGlDQUFpQyx1Q0FBdUMsMEJBQTBCLHFCQUFxQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMEhBQTBIO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBLHFDQUFxQyxtRUFBbUU7QUFDeEc7QUFDQSw0QkFBNEIsb0RBQUs7QUFDakM7QUFDQSwyQ0FBMkMsV0FBVyxlQUFlO0FBQ3JFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFlO0FBQ25DLG9CQUFvQixnRUFBZTtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQix3REFBVSw0QkFBNEIsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnRUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWU7QUFDdkMsd0JBQXdCLGdFQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxZQUFZLGdFQUFlO0FBQzNCLFlBQVksZ0VBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxPQUFPLGdFQUFlLGdCQUFnQjtBQUMzRyxxRUFBcUUsT0FBTyxnRUFBZSxlQUFlO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBVTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTO0FBQ3BDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0Esb0VBQW9FLG9DQUFvQztBQUN4RyxzRUFBc0Usb0NBQW9DO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSw0SEFBNEg7QUFDcE07QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDhIQUE4SDtBQUN0TTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixrQkFBa0IsR0FBRyxxQ0FBcUMsbUJBQW1CLEdBQUcsbUJBQW1CLG1CQUFtQixlQUFlLGFBQWEsR0FBRyxjQUFjLHFCQUFxQixTQUFTLFVBQVUsR0FBRyxpQkFBaUIscUJBQXFCLGVBQWUseUJBQXlCLG1DQUFtQyxxQkFBcUIsNEJBQTRCLEdBQUc7QUFDdGEsZ0JBQWdCLHVCQUF1QixHQUFHO0FBQzFDLHFCQUFxQix1QkFBdUIsYUFBYSxHQUFHO0FBQzVELGlDQUFpQyxtQkFBbUIsa0NBQWtDLEdBQUc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1REFBTTtBQUNoQztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsdURBQXVEO0FBQzFJO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDhFQUE4RTtBQUNqSyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFLO0FBQzVDLHVDQUF1QyxvREFBSztBQUM1QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvREFBSztBQUM1Qyx1Q0FBdUMsb0RBQUs7QUFDNUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOERBQThELFFBQVEsb0JBQW9CO0FBQzFGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0Esc0RBQXNELE9BQU8sbURBQUksa0JBQWtCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csT0FBTyxnRUFBZSx5QkFBeUIsMkRBQTJELE9BQU8sZ0VBQWUsd0JBQXdCO0FBQ2hRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwyQkFBMkIsdUJBQXVCLGdCQUFnQjtBQUMvSCw2REFBNkQsMkJBQTJCLHVCQUF1QixnQkFBZ0I7QUFDL0g7QUFDQTtBQUNBLDhEQUE4RCxxQkFBcUIsdUJBQXVCLGdCQUFnQjtBQUMxSCw4REFBOEQscUJBQXFCLHVCQUF1QixnQkFBZ0I7QUFDMUg7QUFDQTtBQUNBLHlFQUF5RSwrQ0FBK0M7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQSx1RkFBdUYsK0NBQStDO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVEQUFRO0FBQ3BEO0FBQ0EsNEVBQTRFLDhJQUE4SSx3QkFBd0I7QUFDbFA7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBUSxxQkFBcUIsdURBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBSTtBQUN6QiwyQkFBMkIsbURBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LHdEQUFPO0FBQ2YsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxRQUFRLHdEQUFPO0FBQ2YsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4RUFBZ0M7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRWtVO0FBQ2xVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1tb3ZlYWJsZS9kaXN0L21vdmVhYmxlLmVzbS5qcz8zMmJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTkgRGF5YnJ1c2hcbm5hbWU6IHJlYWN0LW1vdmVhYmxlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogRGF5YnJ1c2hcbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXlicnVzaC9tb3ZlYWJsZS9ibG9iL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1tb3ZlYWJsZVxudmVyc2lvbjogMC41Ni4wXG4qL1xuaW1wb3J0IGdldEFnZW50IGZyb20gJ0BlZ2pzL2FnZW50JztcbmltcG9ydCB7IHByZWZpeE5hbWVzLCByZWYsIHJlZnMsIHByZWZpeENTUywgd2l0aE1ldGhvZHMgfSBmcm9tICdmcmFtZXdvcmstdXRpbHMnO1xuaW1wb3J0IHsgZmluZEluZGV4LCBmaW5kLCBpc0FycmF5LCBzcGxpdFNwYWNlLCBzcGxpdFVuaXQsIGRvdCwgaXNTdHJpbmcsIGdldERvY3VtZW50RWxlbWVudCwgZ2V0RG9jdW1lbnRCb2R5LCBnZXRXaW5kb3csIHRocm90dGxlLCBnZXRLZXlzLCBnZXRSYWQsIFRJTllfTlVNIGFzIFRJTllfTlVNJDEsIGF2ZXJhZ2UsIGdldERpc3QgYXMgZ2V0RGlzdCQxLCB0aHJvdHRsZUFycmF5LCBjYWxjdWxhdGVCb3VuZFNpemUsIGNvbnZlcnRVbml0U2l6ZSwgaXNOdW1iZXIsIGhhc0NsYXNzLCBpc09iamVjdCwgZmxhdCBhcyBmbGF0JDEsIGRlY2FtZWxpemUsIGlzTm9kZSwgaXNGdW5jdGlvbiwgaXNXaW5kb3csIGNvdW50ZXIsIGlzVW5kZWZpbmVkLCBiZXR3ZWVuLCBhZGRDbGFzcywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCByZW1vdmVDbGFzcywgc3BsaXRCcmFja2V0LCBzcGxpdENvbW1hLCBjYW5jZWxBbmltYXRpb25GcmFtZSwgcHVzaFNldCB9IGZyb20gJ0BkYXlicnVzaC91dGlscyc7XG5pbXBvcnQgeyBtaW51cywgaW52ZXJ0LCBjb252ZXJ0UG9zaXRpb25NYXRyaXgsIHBsdXMsIGNhbGN1bGF0ZSwgZnJvbVRyYW5zbGF0aW9uLCBtdWx0aXBseSwgY29udmVydERpbWVuc2lvbiwgY3JlYXRlU2NhbGVNYXRyaXgsIGNvbnZlcnRDU1N0b01hdHJpeCwgY3JlYXRlSWRlbnRpdHlNYXRyaXgsIGNyZWF0ZU9yaWdpbk1hdHJpeCwgY3JlYXRlUm90YXRlTWF0cml4LCByb3RhdGUsIGdldE9yaWdpbiwgbXVsdGlwbGllcywgY29udmVydE1hdHJpeHRvQ1NTLCBpZ25vcmVEaW1lbnNpb24sIGNyZWF0ZVdhcnBNYXRyaXggfSBmcm9tICdAc2NlbmEvbWF0cml4JztcbmltcG9ydCB7IHBhcnNlLCBwYXJzZU1hdCwgdG9NYXQsIGNhbGN1bGF0ZU1hdHJpeERpc3QgfSBmcm9tICdjc3MtdG8tbWF0JztcbmltcG9ydCBDaGlsZHJlbkRpZmZlciwgeyBkaWZmIH0gZnJvbSAnQGVnanMvY2hpbGRyZW4tZGlmZmVyJztcbmltcG9ydCBEcmFnU2Nyb2xsIGZyb20gJ0BzY2VuYS9kcmFnc2Nyb2xsJztcbmltcG9ydCB7IGdldE1pbk1heHMsIGZpdFBvaW50cywgZ2V0T3ZlcmxhcFNpemUsIGdldEFyZWFTaXplLCBpc0luc2lkZSwgZ2V0SW50ZXJzZWN0aW9uUG9pbnRzQnlDb25zdGFudHMgfSBmcm9tICdvdmVybGFwLWFyZWEnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBHZXN0byBmcm9tICdnZXN0byc7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tICdyZWFjdC1jc3Mtc3R5bGVkJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnQHNjZW5hL2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgZGlmZiBhcyBkaWZmJDEgfSBmcm9tICdAZWdqcy9saXN0LWRpZmZlcic7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cblxuZnVuY3Rpb24gbWFrZUFibGUobmFtZSwgYWJsZSkge1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKHsgZXZlbnRzOiBbXSwgcHJvcHM6IFtdLCBuYW1lOiBuYW1lIH0sIGFibGUpO1xyXG59XG5cbnZhciBESVJFQ1RJT05TNCA9IFtcIm5cIiwgXCJ3XCIsIFwic1wiLCBcImVcIl07XHJcbnZhciBESVJFQ1RJT05TID0gW1wiblwiLCBcIndcIiwgXCJzXCIsIFwiZVwiLCBcIm53XCIsIFwibmVcIiwgXCJzd1wiLCBcInNlXCJdO1xyXG5mdW5jdGlvbiBnZXRTVkdDdXJzb3Ioc2NhbGUsIGRlZ3JlZSkge1xyXG4gICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCJcIi5jb25jYXQoMzIgKiBzY2FsZSwgXCJweFxcXCIgaGVpZ2h0PVxcXCJcIikuY29uY2F0KDMyICogc2NhbGUsIFwicHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgPjxwYXRoIGQ9XFxcIk0gMTYsNSBMIDEyLDEwIEwgMTQuNSwxMCBMIDE0LjUsMjIgTCAxMiwyMiBMIDE2LDI3IEwgMjAsMjIgTCAxNy41LDIyIEwgMTcuNSwxMCBMIDIwLCAxMCBMIDE2LDUgWlxcXCIgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIGZpbGw9XFxcImJsYWNrXFxcIiBzdHJva2U9XFxcIndoaXRlXFxcIiBzdHlsZT1cXFwidHJhbnNmb3JtOnJvdGF0ZShcIikuY29uY2F0KGRlZ3JlZSwgXCJkZWcpO3RyYW5zZm9ybS1vcmlnaW46IDE2cHggMTZweFxcXCI+PC9wYXRoPjwvc3ZnPlwiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDdXJzb3JDU1MoZGVncmVlKSB7XHJcbiAgICB2YXIgeDEgPSBnZXRTVkdDdXJzb3IoMSwgZGVncmVlKTtcclxuICAgIC8vIGNvbnN0IHgyID0gZ2V0U1ZHQ3Vyc29yKDIsIGRlZ3JlZSk7XHJcbiAgICB2YXIgZGVncmVlNDUgPSAoTWF0aC5yb3VuZChkZWdyZWUgLyA0NSkgKiA0NSkgJSAxODA7XHJcbiAgICB2YXIgZGVmYXVsdEN1cnNvciA9IFwibnMtcmVzaXplXCI7XHJcbiAgICBpZiAoZGVncmVlNDUgPT09IDEzNSkge1xyXG4gICAgICAgIGRlZmF1bHRDdXJzb3IgPSBcIm53c2UtcmVzaXplXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkZWdyZWU0NSA9PT0gNDUpIHtcclxuICAgICAgICBkZWZhdWx0Q3Vyc29yID0gXCJuZXN3LXJlc2l6ZVwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGVncmVlNDUgPT09IDkwKSB7XHJcbiAgICAgICAgZGVmYXVsdEN1cnNvciA9IFwiZXctcmVzaXplXCI7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1heC1saW5lLWxlbmd0aFxyXG4gICAgcmV0dXJuIFwiY3Vyc29yOlwiLmNvbmNhdChkZWZhdWx0Q3Vyc29yLCBcIjtjdXJzb3I6IHVybCgnXCIpLmNvbmNhdCh4MSwgXCInKSAxNiAxNiwgXCIpLmNvbmNhdChkZWZhdWx0Q3Vyc29yLCBcIjtcIik7XHJcbn1cclxudmFyIGFnZW50ID0gZ2V0QWdlbnQoKTtcclxudmFyIElTX1dFQktJVCA9IGFnZW50LmJyb3dzZXIud2Via2l0O1xyXG52YXIgSVNfV0VCS0lUNjA1ID0gSVNfV0VCS0lUICYmIChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbmF2aSA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB7IHVzZXJBZ2VudDogXCJcIiB9IDogd2luZG93Lm5hdmlnYXRvcjtcclxuICAgIHZhciByZXMgPSAvYXBwbGV3ZWJraXRcXC8oW15cXHNdKykvZy5leGVjKG5hdmkudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgcmV0dXJuIHJlcyA/IHBhcnNlRmxvYXQocmVzWzFdKSA8IDYwNSA6IGZhbHNlO1xyXG59KSgpO1xyXG52YXIgYnJvd3Nlck5hbWUgPSBhZ2VudC5icm93c2VyLm5hbWU7XHJcbnZhciBicm93c2VyVmVyc2lvbiA9IHBhcnNlSW50KGFnZW50LmJyb3dzZXIudmVyc2lvbiwgMTApO1xyXG52YXIgSVNfQ0hST01FID0gYnJvd3Nlck5hbWUgPT09IFwiY2hyb21lXCI7XHJcbnZhciBJU19DSFJPTUlVTSA9IGFnZW50LmJyb3dzZXIuY2hyb21pdW07XHJcbnZhciBjaHJvbWl1bVZlcnNpb24gPSBwYXJzZUludChhZ2VudC5icm93c2VyLmNocm9taXVtVmVyc2lvbiwgMTApIHx8IDA7XHJcbnZhciBJU19DSFJPTUlVTTEwOSA9IChJU19DSFJPTUUgJiYgYnJvd3NlclZlcnNpb24gPj0gMTA5KVxyXG4gICAgfHwgKElTX0NIUk9NSVVNICYmIGNocm9taXVtVmVyc2lvbiA+PSAxMDkpO1xyXG52YXIgSVNfRklSRUZPWCA9IGJyb3dzZXJOYW1lID09PSBcImZpcmVmb3hcIjtcclxudmFyIElTX1NBRkFSSV9BQk9WRTE1ID0gcGFyc2VJbnQoYWdlbnQuYnJvd3Nlci53ZWJraXRWZXJzaW9uLCAxMCkgPj0gNjEyXHJcbiAgICB8fCBicm93c2VyVmVyc2lvbiA+PSAxNTtcclxudmFyIFBSRUZJWCA9IFwibW92ZWFibGUtXCI7XHJcbnZhciBkaXJlY3Rpb25DU1MgPSBESVJFQ1RJT05TLm1hcChmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICB2YXIgdG9wID0gXCJcIjtcclxuICAgIHZhciBsZWZ0ID0gXCJcIjtcclxuICAgIHZhciBvcmlnaW5YID0gXCJjZW50ZXJcIjtcclxuICAgIHZhciBvcmlnaW5ZID0gXCJjZW50ZXJcIjtcclxuICAgIHZhciBvZmZzZXQgPSBcImNhbGModmFyKC0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nLCAyMCkgKiAtMXB4KVwiO1xyXG4gICAgaWYgKGRpci5pbmRleE9mKFwiblwiKSA+IC0xKSB7XHJcbiAgICAgICAgdG9wID0gXCJ0b3A6IFwiLmNvbmNhdChvZmZzZXQsIFwiO1wiKTtcclxuICAgICAgICBvcmlnaW5ZID0gXCJib3R0b21cIjtcclxuICAgIH1cclxuICAgIGlmIChkaXIuaW5kZXhPZihcInNcIikgPiAtMSkge1xyXG4gICAgICAgIHRvcCA9IFwidG9wOiAwcHg7XCI7XHJcbiAgICAgICAgb3JpZ2luWSA9IFwidG9wXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlyLmluZGV4T2YoXCJ3XCIpID4gLTEpIHtcclxuICAgICAgICBsZWZ0ID0gXCJsZWZ0OiBcIi5jb25jYXQob2Zmc2V0LCBcIjtcIik7XHJcbiAgICAgICAgb3JpZ2luWCA9IFwicmlnaHRcIjtcclxuICAgIH1cclxuICAgIGlmIChkaXIuaW5kZXhPZihcImVcIikgPiAtMSkge1xyXG4gICAgICAgIGxlZnQgPSBcImxlZnQ6IDBweDtcIjtcclxuICAgICAgICBvcmlnaW5YID0gXCJsZWZ0XCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCIuYXJvdW5kLWNvbnRyb2xbZGF0YS1kaXJlY3Rpb24qPVxcXCJcIi5jb25jYXQoZGlyLCBcIlxcXCJdIHtcXG4gICAgICAgIFwiKS5jb25jYXQobGVmdCkuY29uY2F0KHRvcCwgXCJcXG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IFwiKS5jb25jYXQob3JpZ2luWCwgXCIgXCIpLmNvbmNhdChvcmlnaW5ZLCBcIjtcXG4gICAgfVwiKTtcclxufSkuam9pbihcIlxcblwiKTtcclxudmFyIE1PVkVBQkxFX0NTUyA9IFwiXFxue1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG53aWR0aDogMXB4O1xcbmhlaWdodDogMXB4O1xcbmxlZnQ6IDA7XFxudG9wOiAwO1xcbnotaW5kZXg6IDMwMDA7XFxuLS1tb3ZlYWJsZS1jb2xvcjogIzRhZjtcXG4tLXpvb206IDE7XFxuLS16b29tcHg6IDFweDtcXG4tLW1vdmVhYmxlLWxpbmUtcGFkZGluZzogMDtcXG4tLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZzogMDtcXG53aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbm91dGxpbmU6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG59XFxuLmNvbnRyb2wtYm94IHtcXG56LWluZGV4OiAwO1xcbn1cXG4ubGluZSwgLmNvbnRyb2wge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5sZWZ0OiAwO1xcbnRvcDogMDtcXG53aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG4uY29udHJvbCB7XFxud2lkdGg6IDE0cHg7XFxuaGVpZ2h0OiAxNHB4O1xcbmJvcmRlci1yYWRpdXM6IDUwJTtcXG5ib3JkZXI6IDJweCBzb2xpZCAjZmZmO1xcbmJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuYmFja2dyb3VuZDogIzRhZjtcXG5iYWNrZ3JvdW5kOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxubWFyZ2luLXRvcDogLTdweDtcXG5tYXJnaW4tbGVmdDogLTdweDtcXG5ib3JkZXI6IDJweCBzb2xpZCAjZmZmO1xcbnotaW5kZXg6IDEwO1xcbn1cXG4uYXJvdW5kLWNvbnRyb2wge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG53aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbndpZHRoOiBjYWxjKHZhcigtLW1vdmVhYmxlLWNvbnRyb2wtcGFkZGluZywgMjApICogMXB4KTtcXG5oZWlnaHQ6IGNhbGModmFyKC0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nLCAyMCkgKiAxcHgpO1xcbmxlZnQ6IGNhbGModmFyKC0tbW92ZWFibGUtY29udHJvbC1wYWRkaW5nLCAyMCkgKiAtMC41cHgpO1xcbnRvcDogY2FsYyh2YXIoLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmcsIDIwKSAqIC0wLjVweCk7XFxuYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG56LWluZGV4OiA4O1xcbmN1cnNvcjogYWxpYXM7XFxudHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG59XFxuXCIuY29uY2F0KGRpcmVjdGlvbkNTUywgXCJcXG4ucGFkZGluZyB7XFxucG9zaXRpb246IGFic29sdXRlO1xcbnRvcDogMHB4O1xcbmxlZnQ6IDBweDtcXG53aWR0aDogMTAwcHg7XFxuaGVpZ2h0OiAxMDBweDtcXG50cmFuc2Zvcm0tb3JpZ2luOiAwIDA7XFxufVxcbi5saW5lIHtcXG53aWR0aDogMXB4O1xcbmhlaWdodDogMXB4O1xcbmJhY2tncm91bmQ6ICM0YWY7XFxuYmFja2dyb3VuZDogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbnRyYW5zZm9ybS1vcmlnaW46IDBweCA1MCU7XFxufVxcbi5saW5lLmVkZ2Uge1xcbnotaW5kZXg6IDE7XFxuYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcbi5saW5lLmRhc2hlZCB7XFxuYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuLmxpbmUuZGFzaGVkLmhvcml6b250YWwge1xcbmJvcmRlci10b3A6IDFweCBkYXNoZWQgIzRhZjtcXG5ib3JkZXItdG9wLWNvbG9yOiAjNGFmO1xcbmJvcmRlci10b3AtY29sb3I6IHZhcigtLW1vdmVhYmxlLWNvbG9yKTtcXG59XFxuLmxpbmUuZGFzaGVkLnZlcnRpY2FsIHtcXG5ib3JkZXItbGVmdDogMXB4IGRhc2hlZCAjNGFmO1xcbmJvcmRlci1sZWZ0LWNvbG9yOiAjNGFmO1xcbmJvcmRlci1sZWZ0LWNvbG9yOiB2YXIoLS1tb3ZlYWJsZS1jb2xvcik7XFxufVxcbi5saW5lLnZlcnRpY2FsIHtcXG50cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxufVxcbi5saW5lLmhvcml6b250YWwge1xcbnRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuLmxpbmUudmVydGljYWwuYm9sZCB7XFxud2lkdGg6IDJweDtcXG59XFxuLmxpbmUuaG9yaXpvbnRhbC5ib2xkIHtcXG5oZWlnaHQ6IDJweDtcXG59XFxuXFxuLmNvbnRyb2wub3JpZ2luIHtcXG5ib3JkZXItY29sb3I6ICNmNTU7XFxuYmFja2dyb3VuZDogI2ZmZjtcXG53aWR0aDogMTJweDtcXG5oZWlnaHQ6IDEycHg7XFxubWFyZ2luLXRvcDogLTZweDtcXG5tYXJnaW4tbGVmdDogLTZweDtcXG5wb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXCIpLmNvbmNhdChbMCwgMTUsIDMwLCA0NSwgNjAsIDc1LCA5MCwgMTA1LCAxMjAsIDEzNSwgMTUwLCAxNjVdLm1hcChmdW5jdGlvbiAoZGVncmVlKSB7IHJldHVybiBcIlxcbi5kaXJlY3Rpb25bZGF0YS1yb3RhdGlvbj1cXFwiXCIuY29uY2F0KGRlZ3JlZSwgXCJcXFwiXSwgOmdsb2JhbCAudmlldy1jb250cm9sLXJvdGF0aW9uXCIpLmNvbmNhdChkZWdyZWUsIFwiIHtcXG5cIikuY29uY2F0KGdldEN1cnNvckNTUyhkZWdyZWUpLCBcIlxcbn1cXG5cIik7IH0pLmpvaW4oXCJcXG5cIiksIFwiXFxuXFxuLmxpbmUuZGlyZWN0aW9uOmJlZm9yZSB7XFxuY29udGVudDogXFxcIlxcXCI7XFxucG9zaXRpb246IGFic29sdXRlO1xcbndpZHRoOiAxMDAlO1xcbmhlaWdodDogY2FsYyh2YXIoLS1tb3ZlYWJsZS1saW5lLXBhZGRpbmcsIDApICogMXB4KTtcXG5ib3R0b206IDA7XFxubGVmdDogMDtcXG59XFxuLmdyb3VwIHtcXG56LWluZGV4OiAtMTtcXG59XFxuLmFyZWEge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLmFyZWEtcGllY2VzIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxudG9wOiAwO1xcbmxlZnQ6IDA7XFxuZGlzcGxheTogbm9uZTtcXG59XFxuLmFyZWEuYXZvaWQsIC5hcmVhLnBhc3Mge1xcbnBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4uYXJlYS5hdm9pZCsuYXJlYS1waWVjZXMge1xcbmRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uYXJlYS1waWVjZSB7XFxucG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG5cIikuY29uY2F0KElTX1dFQktJVDYwNSA/IFwiOmdsb2JhbCBzdmcgKjpiZWZvcmUge1xcbmNvbnRlbnQ6XFxcIlxcXCI7XFxudHJhbnNmb3JtLW9yaWdpbjogaW5oZXJpdDtcXG59XCIgOiBcIlwiLCBcIlxcblwiKTtcclxudmFyIE5FQVJCWV9QT1MgPSBbXHJcbiAgICBbMCwgMSwgMl0sXHJcbiAgICBbMSwgMCwgM10sXHJcbiAgICBbMiwgMCwgM10sXHJcbiAgICBbMywgMSwgMl0sXHJcbl07XHJcbnZhciBGTE9BVF9QT0lOVF9OVU0gPSAwLjAwMDE7XHJcbnZhciBUSU5ZX05VTSA9IDAuMDAwMDAwMTtcclxudmFyIE1JTl9TQ0FMRSA9IDAuMDAwMDAwMDAxO1xyXG52YXIgTUFYX05VTSA9IE1hdGgucG93KDEwLCAxMCk7XHJcbnZhciBNSU5fTlVNID0gLU1BWF9OVU07XHJcbnZhciBESVJFQ1RJT05fUkVHSU9OX1RPX0RJUkVDVElPTiA9IHtcclxuICAgIG46IFswLCAtMV0sXHJcbiAgICBlOiBbMSwgMF0sXHJcbiAgICBzOiBbMCwgMV0sXHJcbiAgICB3OiBbLTEsIDBdLFxyXG4gICAgbnc6IFstMSwgLTFdLFxyXG4gICAgbmU6IFsxLCAtMV0sXHJcbiAgICBzdzogWy0xLCAxXSxcclxuICAgIHNlOiBbMSwgMV0sXHJcbn07XHJcbnZhciBESVJFQ1RJT05fSU5ERVhFUyA9IHtcclxuICAgIG46IFswLCAxXSxcclxuICAgIGU6IFsxLCAzXSxcclxuICAgIHM6IFszLCAyXSxcclxuICAgIHc6IFsyLCAwXSxcclxuICAgIG53OiBbMF0sXHJcbiAgICBuZTogWzFdLFxyXG4gICAgc3c6IFsyXSxcclxuICAgIHNlOiBbM10sXHJcbn07XHJcbnZhciBESVJFQ1RJT05fUk9UQVRJT05TID0ge1xyXG4gICAgbjogMCxcclxuICAgIHM6IDE4MCxcclxuICAgIHc6IDI3MCxcclxuICAgIGU6IDkwLFxyXG4gICAgbnc6IDMxNSxcclxuICAgIG5lOiA0NSxcclxuICAgIHN3OiAyMjUsXHJcbiAgICBzZTogMTM1LFxyXG59O1xyXG52YXIgTU9WRUFCTEVfTUVUSE9EUyA9IFtcclxuICAgIFwiaXNNb3ZlYWJsZUVsZW1lbnRcIixcclxuICAgIFwidXBkYXRlUmVjdFwiLFxyXG4gICAgXCJ1cGRhdGVUYXJnZXRcIixcclxuICAgIFwiZGVzdHJveVwiLFxyXG4gICAgXCJkcmFnU3RhcnRcIixcclxuICAgIFwiaXNJbnNpZGVcIixcclxuICAgIFwiaGl0VGVzdFwiLFxyXG4gICAgXCJzZXRTdGF0ZVwiLFxyXG4gICAgXCJnZXRSZWN0XCIsXHJcbiAgICBcInJlcXVlc3RcIixcclxuICAgIFwiaXNEcmFnZ2luZ1wiLFxyXG4gICAgXCJnZXRNYW5hZ2VyXCIsXHJcbiAgICBcImZvcmNlVXBkYXRlXCIsXHJcbiAgICBcIndhaXRUb0NoYW5nZVRhcmdldFwiLFxyXG4gICAgXCJ1cGRhdGVTZWxlY3RvcnNcIixcclxuICAgIFwiZ2V0VGFyZ2V0c1wiLFxyXG4gICAgXCJzdG9wRHJhZ1wiLFxyXG4gICAgXCJnZXRDb250cm9sQm94RWxlbWVudFwiLFxyXG4gICAgXCJnZXRNb3ZlYWJsZXNcIixcclxuICAgIFwiZ2V0RHJhZ0VsZW1lbnRcIixcclxuXTtcblxuZnVuY3Rpb24gc2V0Q3VzdG9tRHJhZyhlLCBzdGF0ZSwgZGVsdGEsIGlzUGluY2gsIGlzQ29udmVydCwgYWJsZU5hbWUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBpZiAoYWJsZU5hbWUgPT09IHZvaWQgMCkgeyBhYmxlTmFtZSA9IFwiZHJhZ2dhYmxlXCI7IH1cclxuICAgIHZhciByZXN1bHQgPSAoX2IgPSAoX2EgPSBzdGF0ZS5nZXN0b3NbYWJsZU5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZShkZWx0YSwgZS5pbnB1dEV2ZW50KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgICB2YXIgZGF0YXMgPSByZXN1bHQub3JpZ2luYWxEYXRhcyB8fCByZXN1bHQuZGF0YXM7XHJcbiAgICB2YXIgYWJsZURhdGFzID0gZGF0YXNbYWJsZU5hbWVdIHx8IChkYXRhc1thYmxlTmFtZV0gPSB7fSk7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIChpc0NvbnZlcnQgPyBjb252ZXJ0RHJhZ0Rpc3Qoc3RhdGUsIHJlc3VsdCkgOiByZXN1bHQpKSwgeyBpc1BpbmNoOiAhIWlzUGluY2gsIHBhcmVudEV2ZW50OiB0cnVlLCBkYXRhczogYWJsZURhdGFzLCBvcmlnaW5hbERhdGFzOiBlLm9yaWdpbmFsRGF0YXMgfSk7XHJcbn1cclxudmFyIEN1c3RvbUdlc3RvID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ3VzdG9tR2VzdG8oYWJsZU5hbWUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKGFibGVOYW1lID09PSB2b2lkIDApIHsgYWJsZU5hbWUgPSBcImRyYWdnYWJsZVwiOyB9XHJcbiAgICAgICAgdGhpcy5hYmxlTmFtZSA9IGFibGVOYW1lO1xyXG4gICAgICAgIHRoaXMucHJldlggPSAwO1xyXG4gICAgICAgIHRoaXMucHJldlkgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRYID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0WSA9IDA7XHJcbiAgICAgICAgdGhpcy5pc0RyYWcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGF0YXMgPSB7XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZToge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRhdGFzID0gKF9hID0ge30sXHJcbiAgICAgICAgICAgIF9hW2FibGVOYW1lXSA9IHt9LFxyXG4gICAgICAgICAgICBfYSk7XHJcbiAgICB9XHJcbiAgICBDdXN0b21HZXN0by5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGNsaWVudCwgZSkge1xyXG4gICAgICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0ZsYWcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcclxuICAgICAgICB0aGlzLmRhdGFzID0gb3JpZ2luYWxEYXRhcztcclxuICAgICAgICBpZiAoIW9yaWdpbmFsRGF0YXNbdGhpcy5hYmxlTmFtZV0pIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxEYXRhc1t0aGlzLmFibGVOYW1lXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMubW92ZShjbGllbnQsIGUuaW5wdXRFdmVudCkpLCB7IHR5cGU6IFwiZHJhZ3N0YXJ0XCIgfSk7XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9tR2VzdG8ucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbiAoY2xpZW50LCBpbnB1dEV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZShbXHJcbiAgICAgICAgICAgIGNsaWVudFswXSAtIHRoaXMucHJldlgsXHJcbiAgICAgICAgICAgIGNsaWVudFsxXSAtIHRoaXMucHJldlksXHJcbiAgICAgICAgXSwgaW5wdXRFdmVudCk7XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9tR2VzdG8ucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZGVsdGEsIGlucHV0RXZlbnQpIHtcclxuICAgICAgICB2YXIgY2xpZW50WDtcclxuICAgICAgICB2YXIgY2xpZW50WTtcclxuICAgICAgICB2YXIgaXNGaXJzdERyYWcgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuaXNGbGFnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJldlggPSBkZWx0YVswXTtcclxuICAgICAgICAgICAgdGhpcy5wcmV2WSA9IGRlbHRhWzFdO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0WCA9IGRlbHRhWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0WSA9IGRlbHRhWzFdO1xyXG4gICAgICAgICAgICBjbGllbnRYID0gZGVsdGFbMF07XHJcbiAgICAgICAgICAgIGNsaWVudFkgPSBkZWx0YVsxXTtcclxuICAgICAgICAgICAgdGhpcy5pc0ZsYWcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGlzUHJldkRyYWcgPSB0aGlzLmlzRHJhZztcclxuICAgICAgICAgICAgY2xpZW50WCA9IHRoaXMucHJldlggKyBkZWx0YVswXTtcclxuICAgICAgICAgICAgY2xpZW50WSA9IHRoaXMucHJldlkgKyBkZWx0YVsxXTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhWzBdIHx8IGRlbHRhWzFdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc1ByZXZEcmFnICYmIHRoaXMuaXNEcmFnKSB7XHJcbiAgICAgICAgICAgICAgICBpc0ZpcnN0RHJhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmV2WCA9IGNsaWVudFg7XHJcbiAgICAgICAgdGhpcy5wcmV2WSA9IGNsaWVudFk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogXCJkcmFnXCIsXHJcbiAgICAgICAgICAgIGNsaWVudFg6IGNsaWVudFgsXHJcbiAgICAgICAgICAgIGNsaWVudFk6IGNsaWVudFksXHJcbiAgICAgICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXHJcbiAgICAgICAgICAgIGlzRmlyc3REcmFnOiBpc0ZpcnN0RHJhZyxcclxuICAgICAgICAgICAgaXNEcmFnOiB0aGlzLmlzRHJhZyxcclxuICAgICAgICAgICAgZGlzdFg6IGNsaWVudFggLSB0aGlzLnN0YXJ0WCxcclxuICAgICAgICAgICAgZGlzdFk6IGNsaWVudFkgLSB0aGlzLnN0YXJ0WSxcclxuICAgICAgICAgICAgZGVsdGFYOiBkZWx0YVswXSxcclxuICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVsxXSxcclxuICAgICAgICAgICAgZGF0YXM6IHRoaXMuZGF0YXNbdGhpcy5hYmxlTmFtZV0sXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRGF0YXM6IHRoaXMuZGF0YXMsXHJcbiAgICAgICAgICAgIHBhcmVudEV2ZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBwYXJlbnRHZXN0bzogdGhpcyxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDdXN0b21HZXN0bztcclxufSgpKTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlRWxlbWVudFBvc2l0aW9uKG1hdHJpeCwgb3JpZ2luLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgaXMzZCA9IG1hdHJpeC5sZW5ndGggPT09IDE2O1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pO1xyXG4gICAgdmFyIF9hID0gX19yZWFkKHBvc2VzLCA0KSwgX2IgPSBfX3JlYWQoX2FbMF0sIDIpLCB4MSA9IF9iWzBdLCB5MSA9IF9iWzFdLCBfYyA9IF9fcmVhZChfYVsxXSwgMiksIHgyID0gX2NbMF0sIHkyID0gX2NbMV0sIF9kID0gX19yZWFkKF9hWzJdLCAyKSwgeDMgPSBfZFswXSwgeTMgPSBfZFsxXSwgX2UgPSBfX3JlYWQoX2FbM10sIDIpLCB4NCA9IF9lWzBdLCB5NCA9IF9lWzFdO1xyXG4gICAgdmFyIF9mID0gX19yZWFkKGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgb3JpZ2luLCBuKSwgMiksIG9yaWdpblggPSBfZlswXSwgb3JpZ2luWSA9IF9mWzFdO1xyXG4gICAgdmFyIGxlZnQgPSBNYXRoLm1pbih4MSwgeDIsIHgzLCB4NCk7XHJcbiAgICB2YXIgdG9wID0gTWF0aC5taW4oeTEsIHkyLCB5MywgeTQpO1xyXG4gICAgdmFyIHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyLCB4MywgeDQpO1xyXG4gICAgdmFyIGJvdHRvbSA9IE1hdGgubWF4KHkxLCB5MiwgeTMsIHk0KTtcclxuICAgIHgxID0gKHgxIC0gbGVmdCkgfHwgMDtcclxuICAgIHgyID0gKHgyIC0gbGVmdCkgfHwgMDtcclxuICAgIHgzID0gKHgzIC0gbGVmdCkgfHwgMDtcclxuICAgIHg0ID0gKHg0IC0gbGVmdCkgfHwgMDtcclxuICAgIHkxID0gKHkxIC0gdG9wKSB8fCAwO1xyXG4gICAgeTIgPSAoeTIgLSB0b3ApIHx8IDA7XHJcbiAgICB5MyA9ICh5MyAtIHRvcCkgfHwgMDtcclxuICAgIHk0ID0gKHk0IC0gdG9wKSB8fCAwO1xyXG4gICAgb3JpZ2luWCA9IChvcmlnaW5YIC0gbGVmdCkgfHwgMDtcclxuICAgIG9yaWdpblkgPSAob3JpZ2luWSAtIHRvcCkgfHwgMDtcclxuICAgIHZhciBzeCA9IG1hdHJpeFswXTtcclxuICAgIHZhciBzeSA9IG1hdHJpeFtuICsgMV07XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gc2lnbihzeCAqIHN5KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICAgICAgb3JpZ2luOiBbb3JpZ2luWCwgb3JpZ2luWV0sXHJcbiAgICAgICAgcG9zMTogW3gxLCB5MV0sXHJcbiAgICAgICAgcG9zMjogW3gyLCB5Ml0sXHJcbiAgICAgICAgcG9zMzogW3gzLCB5M10sXHJcbiAgICAgICAgcG9zNDogW3g0LCB5NF0sXHJcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvaW50ZXJEaXN0KG1vdmVhYmxlLCBlKSB7XHJcbiAgICB2YXIgY2xpZW50WCA9IGUuY2xpZW50WCwgY2xpZW50WSA9IGUuY2xpZW50WSwgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIG1vdmVhYmxlQ2xpZW50UmVjdCA9IF9hLm1vdmVhYmxlQ2xpZW50UmVjdCwgcm9vdE1hdHJpeCA9IF9hLnJvb3RNYXRyaXgsIGlzM2QgPSBfYS5pczNkLCBwb3MxID0gX2EucG9zMTtcclxuICAgIHZhciBsZWZ0ID0gbW92ZWFibGVDbGllbnRSZWN0LmxlZnQsIHRvcCA9IG1vdmVhYmxlQ2xpZW50UmVjdC50b3A7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHZhciBfYiA9IF9fcmVhZChtaW51cyhjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NsaWVudFggLSBsZWZ0LCBjbGllbnRZIC0gdG9wXSwgbiksIHBvczEpLCAyKSwgcG9zWCA9IF9iWzBdLCBwb3NZID0gX2JbMV07XHJcbiAgICB2YXIgX2MgPSBfX3JlYWQoZ2V0RHJhZ0Rpc3QoeyBkYXRhczogZGF0YXMsIGRpc3RYOiBwb3NYLCBkaXN0WTogcG9zWSB9KSwgMiksIGRpc3RYID0gX2NbMF0sIGRpc3RZID0gX2NbMV07XHJcbiAgICByZXR1cm4gW2Rpc3RYLCBkaXN0WV07XHJcbn1cclxuZnVuY3Rpb24gc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBfYSkge1xyXG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXM7XHJcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSwgYWxsTWF0cml4ID0gX2IuYWxsTWF0cml4LCBiZWZvcmVNYXRyaXggPSBfYi5iZWZvcmVNYXRyaXgsIGlzM2QgPSBfYi5pczNkLCBsZWZ0ID0gX2IubGVmdCwgdG9wID0gX2IudG9wLCBvcmlnaW4gPSBfYi5vcmlnaW4sIG9mZnNldE1hdHJpeCA9IF9iLm9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4ID0gX2IudGFyZ2V0TWF0cml4LCB0cmFuc2Zvcm1PcmlnaW4gPSBfYi50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIGRhdGFzLmlzM2QgPSBpczNkO1xyXG4gICAgZGF0YXMubWF0cml4ID0gYWxsTWF0cml4O1xyXG4gICAgZGF0YXMudGFyZ2V0TWF0cml4ID0gdGFyZ2V0TWF0cml4O1xyXG4gICAgZGF0YXMuYmVmb3JlTWF0cml4ID0gYmVmb3JlTWF0cml4O1xyXG4gICAgZGF0YXMub2Zmc2V0TWF0cml4ID0gb2Zmc2V0TWF0cml4O1xyXG4gICAgZGF0YXMudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgZGF0YXMuaW52ZXJzZU1hdHJpeCA9IGludmVydChhbGxNYXRyaXgsIG4pO1xyXG4gICAgZGF0YXMuaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGludmVydChiZWZvcmVNYXRyaXgsIG4pO1xyXG4gICAgZGF0YXMuYWJzb2x1dGVPcmlnaW4gPSBjb252ZXJ0UG9zaXRpb25NYXRyaXgocGx1cyhbbGVmdCwgdG9wXSwgb3JpZ2luKSwgbik7XHJcbiAgICBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0ID0gY2FsY3VsYXRlKGRhdGFzLmludmVyc2VCZWZvcmVNYXRyaXgsIGRhdGFzLmFic29sdXRlT3JpZ2luLCBuKTtcclxuICAgIGRhdGFzLnN0YXJ0RHJhZ0Rpc3QgPSBjYWxjdWxhdGUoZGF0YXMuaW52ZXJzZU1hdHJpeCwgZGF0YXMuYWJzb2x1dGVPcmlnaW4sIG4pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zZm9ybURpcmVjdGlvbihlKSB7XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlRWxlbWVudFBvc2l0aW9uKGUuZGF0YXMuYmVmb3JlVHJhbnNmb3JtLCBbNTAsIDUwXSwgMTAwLCAxMDApLmRpcmVjdGlvbjtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIGV2ZW50LCBmdW5jdGlvbk5hbWUpIHtcclxuICAgIHZhciBkYXRhcyA9IGV2ZW50LmRhdGFzLCBvcmlnaW5hbERhdGFzID0gZXZlbnQub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xyXG4gICAgdmFyIGluZGV4ID0gZGF0YXMudHJhbnNmb3JtSW5kZXg7XHJcbiAgICB2YXIgbmV4dFRyYW5zZm9ybXMgPSBvcmlnaW5hbERhdGFzLm5leHRUcmFuc2Zvcm1zO1xyXG4gICAgdmFyIGxlbmd0aCA9IG5leHRUcmFuc2Zvcm1zLmxlbmd0aDtcclxuICAgIHZhciBuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzID0gb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzO1xyXG4gICAgdmFyIG5leHRJbmRleCA9IC0xO1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIC8vIHRyYW5zbGF0ZSA9PiByb3RhdGUgPT4gc2NhbGVcclxuICAgICAgICBpZiAoZnVuY3Rpb25OYW1lID09PSBcInRyYW5zbGF0ZVwiKSB7XHJcbiAgICAgICAgICAgIG5leHRJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gXCJyb3RhdGVcIikge1xyXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kSW5kZXgobmV4dFRyYW5zZm9ybXMsIGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0Lm1hdGNoKC9zY2FsZVxcKC9nKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIG5leHRJbmRleCA9IG5leHRUcmFuc2Zvcm1zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMudHJhbnNmb3JtSW5kZXggPSBuZXh0SW5kZXg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaW5kKG5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMsIGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLmluZGV4ID09PSBpbmRleCAmJiBpbmZvLmZ1bmN0aW9uTmFtZSA9PT0gZnVuY3Rpb25OYW1lOyB9KSkge1xyXG4gICAgICAgIG5leHRJbmRleCA9IGluZGV4O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbmV4dEluZGV4ID0gaW5kZXggKyBuZXh0VHJhbnNmb3JtQXBwZW5kZWRJbmRleGVzLmZpbHRlcihmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5pbmRleCA8IGluZGV4OyB9KS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gY29udmVydFRyYW5zZm9ybUluZm8obmV4dFRyYW5zZm9ybXMsIG1vdmVhYmxlLnN0YXRlLCBuZXh0SW5kZXgpO1xyXG4gICAgdmFyIHRhcmdldEZ1bmN0aW9uID0gcmVzdWx0LnRhcmdldEZ1bmN0aW9uO1xyXG4gICAgdmFyIG1hdEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZSA9PT0gXCJyb3RhdGVcIiA/IFwicm90YXRlWlwiIDogZnVuY3Rpb25OYW1lO1xyXG4gICAgZGF0YXMuYmVmb3JlRnVuY3Rpb25UZXh0cyA9IHJlc3VsdC5iZWZvcmVGdW5jdGlvblRleHRzO1xyXG4gICAgZGF0YXMuYWZ0ZXJGdW5jdGlvblRleHRzID0gcmVzdWx0LmFmdGVyRnVuY3Rpb25UZXh0cztcclxuICAgIGRhdGFzLmJlZm9yZVRyYW5zZm9ybSA9IHJlc3VsdC5iZWZvcmVGdW5jdGlvbk1hdHJpeDtcclxuICAgIGRhdGFzLmJlZm9yZVRyYW5zZm9ybTIgPSByZXN1bHQuYmVmb3JlRnVuY3Rpb25NYXRyaXgyO1xyXG4gICAgZGF0YXMudGFyZ2V0VGFuc2Zvcm0gPSByZXN1bHQudGFyZ2V0RnVuY3Rpb25NYXRyaXg7XHJcbiAgICBkYXRhcy5hZnRlclRyYW5zZm9ybSA9IHJlc3VsdC5hZnRlckZ1bmN0aW9uTWF0cml4O1xyXG4gICAgZGF0YXMuYWZ0ZXJUcmFuc2Zvcm0yID0gcmVzdWx0LmFmdGVyRnVuY3Rpb25NYXRyaXgyO1xyXG4gICAgZGF0YXMudGFyZ2V0QWxsVHJhbnNmb3JtID0gcmVzdWx0LmFsbEZ1bmN0aW9uTWF0cml4O1xyXG4gICAgaWYgKHRhcmdldEZ1bmN0aW9uLmZ1bmN0aW9uTmFtZSA9PT0gbWF0RnVuY3Rpb25OYW1lKSB7XHJcbiAgICAgICAgZGF0YXMuYWZ0ZXJGdW5jdGlvblRleHRzLnNwbGljZSgwLCAxKTtcclxuICAgICAgICBkYXRhcy5pc0FwcGVuZFRyYW5zZm9ybSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVuZ3RoID4gbmV4dEluZGV4KSB7XHJcbiAgICAgICAgZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPSB0cnVlO1xyXG4gICAgICAgIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybUFwcGVuZGVkSW5kZXhlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMpLCBmYWxzZSksIFt7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXHJcbiAgICAgICAgICAgICAgICBpc0FwcGVuZDogdHJ1ZSxcclxuICAgICAgICAgICAgfV0sIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtRm9ybWF0KGRhdGFzLCB2YWx1ZSwgZGlzdCkge1xyXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGRhdGFzLmJlZm9yZUZ1bmN0aW9uVGV4dHMuam9pbihcIiBcIiksIFwiIFwiKS5jb25jYXQoZGF0YXMuaXNBcHBlbmRUcmFuc2Zvcm0gPyBkaXN0IDogdmFsdWUsIFwiIFwiKS5jb25jYXQoZGF0YXMuYWZ0ZXJGdW5jdGlvblRleHRzLmpvaW4oXCIgXCIpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1EaXN0KF9hKSB7XHJcbiAgICB2YXIgZGF0YXMgPSBfYS5kYXRhcywgZGlzdFggPSBfYS5kaXN0WCwgZGlzdFkgPSBfYS5kaXN0WTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChnZXRCZWZvcmVEcmFnRGlzdCh7IGRhdGFzOiBkYXRhcywgZGlzdFg6IGRpc3RYLCBkaXN0WTogZGlzdFkgfSksIDIpLCBieCA9IF9iWzBdLCBieSA9IF9iWzFdO1xyXG4gICAgLy8gQiAqIFt0eCwgdHldICogQSA9IFtieCwgYnldICogdGFyZ2V0TWF0cml4O1xyXG4gICAgLy8gW3R4LCB0eV0gPSBCLTEgKiBbYngsIGJ5XSAqIHRhcmdldE1hdHJpeCAqIEEtMSAqIFswLCAwXTtcclxuICAgIHZhciByZXMgPSBnZXRUcmFuc2Zyb21NYXRyaXgoZGF0YXMsIGZyb21UcmFuc2xhdGlvbihbYngsIGJ5XSwgNCkpO1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZShyZXMsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChbMCwgMCwgMF0sIDQpLCA0KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2Zyb21NYXRyaXgoZGF0YXMsIHRhcmdldE1hdHJpeCwgaXNBZnRlcikge1xyXG4gICAgdmFyIGJlZm9yZVRyYW5zZm9ybSA9IGRhdGFzLmJlZm9yZVRyYW5zZm9ybSwgYWZ0ZXJUcmFuc2Zvcm0gPSBkYXRhcy5hZnRlclRyYW5zZm9ybSwgYmVmb3JlVHJhbnNmb3JtMiA9IGRhdGFzLmJlZm9yZVRyYW5zZm9ybTIsIGFmdGVyVHJhbnNmb3JtMiA9IGRhdGFzLmFmdGVyVHJhbnNmb3JtMiwgdGFyZ2V0QWxsVHJhbnNmb3JtID0gZGF0YXMudGFyZ2V0QWxsVHJhbnNmb3JtO1xyXG4gICAgLy8gQiAqIGFmdGVyVGFyZ2V0TWF0cml4ICogQSA9ICh0YXJnZXRNYXRyaXggKiB0YXJnZXRBbGxUcmFuc2Zvcm0pXHJcbiAgICAvLyBhZnRlclRhcmdldE1hdHJpeCA9IEItMSAqIHRhcmdldE1hdHJpeCAqIHRhcmdldEFsbFRyYW5zZm9ybSAqIEEtMVxyXG4gICAgLy8gbmV4dFRhcmdldE1hdHJpeCA9ICh0YXJnZXRNYXRyaXggKiB0YXJnZXRBbGxUcmFuc2Zvcm0pXHJcbiAgICB2YXIgbmV4dFRhcmdldE1hdHJpeCA9IGlzQWZ0ZXJcclxuICAgICAgICA/IG11bHRpcGx5KHRhcmdldEFsbFRyYW5zZm9ybSwgdGFyZ2V0TWF0cml4LCA0KVxyXG4gICAgICAgIDogbXVsdGlwbHkodGFyZ2V0TWF0cml4LCB0YXJnZXRBbGxUcmFuc2Zvcm0sIDQpO1xyXG4gICAgLy8gcmVzMSA9IEItMSAqIG5leHRUYXJnZXRNYXRyaXhcclxuICAgIHZhciByZXMxID0gbXVsdGlwbHkoaW52ZXJ0KGlzQWZ0ZXIgPyBiZWZvcmVUcmFuc2Zvcm0yIDogYmVmb3JlVHJhbnNmb3JtLCA0KSwgbmV4dFRhcmdldE1hdHJpeCwgNCk7XHJcbiAgICAvLyByZXMzID0gcmVzMiAqIEEtMVxyXG4gICAgdmFyIGFmdGVyVGFyZ2V0TWF0cml4ID0gbXVsdGlwbHkocmVzMSwgaW52ZXJ0KGlzQWZ0ZXIgPyBhZnRlclRyYW5zZm9ybTIgOiBhZnRlclRyYW5zZm9ybSwgNCksIDQpO1xyXG4gICAgcmV0dXJuIGFmdGVyVGFyZ2V0TWF0cml4O1xyXG59XHJcbmZ1bmN0aW9uIGdldEJlZm9yZURyYWdEaXN0KF9hKSB7XHJcbiAgICB2YXIgZGF0YXMgPSBfYS5kYXRhcywgZGlzdFggPSBfYS5kaXN0WCwgZGlzdFkgPSBfYS5kaXN0WTtcclxuICAgIC8vIFRUID0gQlRcclxuICAgIHZhciBpbnZlcnNlQmVmb3JlTWF0cml4ID0gZGF0YXMuaW52ZXJzZUJlZm9yZU1hdHJpeCwgaXMzZCA9IGRhdGFzLmlzM2QsIHN0YXJ0RHJhZ0JlZm9yZURpc3QgPSBkYXRhcy5zdGFydERyYWdCZWZvcmVEaXN0LCBhYnNvbHV0ZU9yaWdpbiA9IGRhdGFzLmFic29sdXRlT3JpZ2luO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICAvLyBBQlNfT1JJR0lOICogW2Rpc3RYLCBkaXN0WV0gPSBCTSAqIChPUklHSU4gKyBbdHgsIHR5XSlcclxuICAgIC8vIEJNIC0xICogQUJTX09SSUdJTiAqIFtkaXN0WCwgZGlzdFldIC0gT1JJR0lOID0gW3R4LCB0eV1cclxuICAgIHJldHVybiBtaW51cyhjYWxjdWxhdGUoaW52ZXJzZUJlZm9yZU1hdHJpeCwgcGx1cyhhYnNvbHV0ZU9yaWdpbiwgW2Rpc3RYLCBkaXN0WV0pLCBuKSwgc3RhcnREcmFnQmVmb3JlRGlzdCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RHJhZ0Rpc3QoX2EsIGlzQmVmb3JlKSB7XHJcbiAgICB2YXIgZGF0YXMgPSBfYS5kYXRhcywgZGlzdFggPSBfYS5kaXN0WCwgZGlzdFkgPSBfYS5kaXN0WTtcclxuICAgIHZhciBpbnZlcnNlQmVmb3JlTWF0cml4ID0gZGF0YXMuaW52ZXJzZUJlZm9yZU1hdHJpeCwgaW52ZXJzZU1hdHJpeCA9IGRhdGFzLmludmVyc2VNYXRyaXgsIGlzM2QgPSBkYXRhcy5pczNkLCBzdGFydERyYWdCZWZvcmVEaXN0ID0gZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCwgc3RhcnREcmFnRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0Rpc3QsIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHJldHVybiBtaW51cyhjYWxjdWxhdGUoaXNCZWZvcmUgPyBpbnZlcnNlQmVmb3JlTWF0cml4IDogaW52ZXJzZU1hdHJpeCwgcGx1cyhhYnNvbHV0ZU9yaWdpbiwgW2Rpc3RYLCBkaXN0WV0pLCBuKSwgaXNCZWZvcmUgPyBzdGFydERyYWdCZWZvcmVEaXN0IDogc3RhcnREcmFnRGlzdCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW52ZXJzZURyYWdEaXN0KF9hLCBpc0JlZm9yZSkge1xyXG4gICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsIGRpc3RYID0gX2EuZGlzdFgsIGRpc3RZID0gX2EuZGlzdFk7XHJcbiAgICB2YXIgYmVmb3JlTWF0cml4ID0gZGF0YXMuYmVmb3JlTWF0cml4LCBtYXRyaXggPSBkYXRhcy5tYXRyaXgsIGlzM2QgPSBkYXRhcy5pczNkLCBzdGFydERyYWdCZWZvcmVEaXN0ID0gZGF0YXMuc3RhcnREcmFnQmVmb3JlRGlzdCwgc3RhcnREcmFnRGlzdCA9IGRhdGFzLnN0YXJ0RHJhZ0Rpc3QsIGFic29sdXRlT3JpZ2luID0gZGF0YXMuYWJzb2x1dGVPcmlnaW47XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHJldHVybiBtaW51cyhjYWxjdWxhdGUoaXNCZWZvcmUgPyBiZWZvcmVNYXRyaXggOiBtYXRyaXgsIHBsdXMoaXNCZWZvcmUgPyBzdGFydERyYWdCZWZvcmVEaXN0IDogc3RhcnREcmFnRGlzdCwgW2Rpc3RYLCBkaXN0WV0pLCBuKSwgYWJzb2x1dGVPcmlnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4sIHdpZHRoLCBoZWlnaHQsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgcHJldk9yaWdpbikge1xyXG4gICAgaWYgKHByZXZXaWR0aCA9PT0gdm9pZCAwKSB7IHByZXZXaWR0aCA9IHdpZHRoOyB9XHJcbiAgICBpZiAocHJldkhlaWdodCA9PT0gdm9pZCAwKSB7IHByZXZIZWlnaHQgPSBoZWlnaHQ7IH1cclxuICAgIGlmIChwcmV2T3JpZ2luID09PSB2b2lkIDApIHsgcHJldk9yaWdpbiA9IFswLCAwXTsgfVxyXG4gICAgaWYgKCF0cmFuc2Zvcm1PcmlnaW4pIHtcclxuICAgICAgICByZXR1cm4gcHJldk9yaWdpbjtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2Zvcm1PcmlnaW4ubWFwKGZ1bmN0aW9uIChwb3MsIGkpIHtcclxuICAgICAgICB2YXIgX2EgPSBzcGxpdFVuaXQocG9zKSwgdmFsdWUgPSBfYS52YWx1ZSwgdW5pdCA9IF9hLnVuaXQ7XHJcbiAgICAgICAgdmFyIHByZXZTaXplID0gKGkgPyBwcmV2SGVpZ2h0IDogcHJldldpZHRoKTtcclxuICAgICAgICB2YXIgc2l6ZSA9IChpID8gaGVpZ2h0IDogd2lkdGgpO1xyXG4gICAgICAgIGlmIChwb3MgPT09IFwiJVwiIHx8IGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAvLyBubyB2YWx1ZSBidXQgJVxyXG4gICAgICAgICAgICB2YXIgbWVhc3VyZVJhdGlvID0gcHJldlNpemUgPyBwcmV2T3JpZ2luW2ldIC8gcHJldlNpemUgOiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSAqIG1lYXN1cmVSYXRpbztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodW5pdCAhPT0gXCIlXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2l6ZSAqIHZhbHVlIC8gMTAwO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UG9zSW5kZXhlc0J5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xyXG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcclxuICAgIGlmIChkaXJlY3Rpb25bMV0gPj0gMCkge1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPj0gMCkge1xyXG4gICAgICAgICAgICBpbmRleGVzLnB1c2goMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPD0gMCkge1xyXG4gICAgICAgICAgICBpbmRleGVzLnB1c2goMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcmVjdGlvblsxXSA8PSAwKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvblswXSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaCgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvblswXSA8PSAwKSB7XHJcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaCgwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5kZXhlcztcclxufVxyXG5mdW5jdGlvbiBnZXRQb3Nlc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pIHtcclxuICAgIC8qXHJcbiAgICBbLTEsIC0xXShwb3MxKSAgICAgICBbMCwgLTFdKHBvczEscG9zMikgICAgICAgWzEsIC0xXShwb3MyKVxyXG4gICAgWy0xLCAwXShwb3MxLCBwb3MzKSAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwXShwb3MyLCBwb3M0KVxyXG4gICAgWy0xLCAxXShwb3MzKSAgICAgICAgWzAsIDFdKHBvczMsIHBvczQpICAgICAgIFsxLCAxXShwb3M0KVxyXG4gICAgKi9cclxuICAgIHJldHVybiBnZXRQb3NJbmRleGVzQnlEaXJlY3Rpb24oZGlyZWN0aW9uKS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBwb3Nlc1tpbmRleF07IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBvc0J5U2luZ2xlRGlyZWN0aW9uKHBvc2VzLCBkaXJlY3Rpb24pIHtcclxuICAgIHZhciByYXRpbyA9IChkaXJlY3Rpb24gKyAxKSAvIDI7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGRvdChwb3Nlc1swXVswXSwgcG9zZXNbMV1bMF0sIHJhdGlvLCAxIC0gcmF0aW8pLFxyXG4gICAgICAgIGRvdChwb3Nlc1swXVsxXSwgcG9zZXNbMV1bMV0sIHJhdGlvLCAxIC0gcmF0aW8pLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgdG9wID0gZ2V0UG9zQnlTaW5nbGVEaXJlY3Rpb24oW3Bvc2VzWzBdLCBwb3Nlc1sxXV0sIGRpcmVjdGlvblswXSk7XHJcbiAgICB2YXIgYm90dG9tID0gZ2V0UG9zQnlTaW5nbGVEaXJlY3Rpb24oW3Bvc2VzWzJdLCBwb3Nlc1szXV0sIGRpcmVjdGlvblswXSk7XHJcbiAgICByZXR1cm4gZ2V0UG9zQnlTaW5nbGVEaXJlY3Rpb24oW3RvcCwgYm90dG9tXSwgZGlyZWN0aW9uWzFdKTtcclxufVxyXG5mdW5jdGlvbiBnZXREaXN0KHN0YXJ0UG9zLCBtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4sIGZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgcG9zZXMgPSBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pO1xyXG4gICAgdmFyIGZpeGVkUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGZpeGVkRGlyZWN0aW9uKTtcclxuICAgIHZhciBkaXN0WCA9IHN0YXJ0UG9zWzBdIC0gZml4ZWRQb3NbMF07XHJcbiAgICB2YXIgZGlzdFkgPSBzdGFydFBvc1sxXSAtIGZpeGVkUG9zWzFdO1xyXG4gICAgcmV0dXJuIFtkaXN0WCwgZGlzdFldO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5leHRNYXRyaXgob2Zmc2V0TWF0cml4LCB0YXJnZXRNYXRyaXgsIG9yaWdpbiwgbikge1xyXG4gICAgcmV0dXJuIG11bHRpcGx5KG9mZnNldE1hdHJpeCwgZ2V0QWJzb2x1dGVNYXRyaXgodGFyZ2V0TWF0cml4LCBuLCBvcmlnaW4pLCBuKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXh0VHJhbnNmb3JtTWF0cml4KHN0YXRlLCBkYXRhcywgdHJhbnNmb3JtLCBpc0FsbFRyYW5zZm9ybSkge1xyXG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbiwgb2Zmc2V0TWF0cml4ID0gc3RhdGUub2Zmc2V0TWF0cml4LCBpczNkID0gc3RhdGUuaXMzZDtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIHRhcmdldFRyYW5zZm9ybTtcclxuICAgIGlmIChpc1N0cmluZyh0cmFuc2Zvcm0pKSB7XHJcbiAgICAgICAgdmFyIGJlZm9yZVRyYW5zZm9ybSA9IGRhdGFzLmJlZm9yZVRyYW5zZm9ybSwgYWZ0ZXJUcmFuc2Zvcm0gPSBkYXRhcy5hZnRlclRyYW5zZm9ybTtcclxuICAgICAgICBpZiAoaXNBbGxUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdGFyZ2V0VHJhbnNmb3JtID0gY29udmVydERpbWVuc2lvbihwYXJzZU1hdCh0cmFuc2Zvcm0pLCA0LCBuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldFRyYW5zZm9ybSA9IGNvbnZlcnREaW1lbnNpb24obXVsdGlwbHkobXVsdGlwbHkoYmVmb3JlVHJhbnNmb3JtLCBwYXJzZU1hdChbdHJhbnNmb3JtXSksIDQpLCBhZnRlclRyYW5zZm9ybSwgNCksIDQsIG4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRhcmdldFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0VHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4sIG4pO1xyXG59XHJcbmZ1bmN0aW9uIHNjYWxlTWF0cml4KHN0YXRlLCBzY2FsZSkge1xyXG4gICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbiwgb2Zmc2V0TWF0cml4ID0gc3RhdGUub2Zmc2V0TWF0cml4LCBpczNkID0gc3RhdGUuaXMzZCwgdGFyZ2V0TWF0cml4ID0gc3RhdGUudGFyZ2V0TWF0cml4LCB0YXJnZXRBbGxUcmFuc2Zvcm0gPSBzdGF0ZS50YXJnZXRBbGxUcmFuc2Zvcm07XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHJldHVybiBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgbXVsdGlwbHkodGFyZ2V0QWxsVHJhbnNmb3JtIHx8IHRhcmdldE1hdHJpeCwgY3JlYXRlU2NhbGVNYXRyaXgoc2NhbGUsIG4pLCBuKSwgdHJhbnNmb3JtT3JpZ2luLCBuKTtcclxufVxyXG5mdW5jdGlvbiBmaWxsVHJhbnNmb3JtU3RhcnRFdmVudChtb3ZlYWJsZSwgZSkge1xyXG4gICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBnZXRCZWZvcmVSZW5kZXJhYmxlRGF0YXMoZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKHRyYW5zZm9ybSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxyXG4gICAgICAgICAgICBvcmlnaW5hbERhdGFzLnN0YXJ0VHJhbnNmb3JtcyA9IGlzQXJyYXkodHJhbnNmb3JtKSA/IHRyYW5zZm9ybSA6IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIGluZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFRyYW5zZm9ybUluZGV4OiBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgc2V0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIGluZGV4KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIHByb3BlcnR5KSB7XHJcbiAgICB2YXIgb3JpZ2luYWxEYXRhcyA9IGdldEJlZm9yZVJlbmRlcmFibGVEYXRhcyhlKTtcclxuICAgIHZhciBzdGFydFRyYW5zZm9ybXMgPSBvcmlnaW5hbERhdGFzLnN0YXJ0VHJhbnNmb3JtcztcclxuICAgIHNldFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBmaW5kSW5kZXgoc3RhcnRUcmFuc2Zvcm1zLCBmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYy5pbmRleE9mKFwiXCIuY29uY2F0KHByb3BlcnR5LCBcIihcIikpID09PSAwOyB9KSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIGluZGV4KSB7XHJcbiAgICB2YXIgb3JpZ2luYWxEYXRhcyA9IGdldEJlZm9yZVJlbmRlcmFibGVEYXRhcyhlKTtcclxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICBkYXRhcy50cmFuc2Zvcm1JbmRleCA9IGluZGV4O1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB0cmFuc2Zvcm0gPSBvcmlnaW5hbERhdGFzLnN0YXJ0VHJhbnNmb3Jtc1tpbmRleF07XHJcbiAgICBpZiAoIXRyYW5zZm9ybSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIGluZm8gPSBwYXJzZShbdHJhbnNmb3JtXSwge1xyXG4gICAgICAgIFwieCVcIjogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgLyAxMDAgKiBzdGF0ZS5vZmZzZXRXaWR0aDsgfSxcclxuICAgICAgICBcInklXCI6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IC8gMTAwICogc3RhdGUub2Zmc2V0SGVpZ2h0OyB9LFxyXG4gICAgfSk7XHJcbiAgICBkYXRhcy5zdGFydFZhbHVlID0gaW5mb1swXS5mdW5jdGlvblZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCB0cmFuc2Zvcm0pIHtcclxuICAgIHZhciBvcmlnaW5hbERhdGFzID0gZ2V0QmVmb3JlUmVuZGVyYWJsZURhdGFzKGUpO1xyXG4gICAgb3JpZ2luYWxEYXRhcy5uZXh0VHJhbnNmb3JtcyA9IHNwbGl0U3BhY2UodHJhbnNmb3JtKTtcclxuICAgIC8vIG9yaWdpbmFsRGF0YXMubmV4dFRhcmdldE1hdHJpeCA9IHBhcnNlTWF0KHRyYW5zZm9ybSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmVmb3JlUmVuZGVyYWJsZURhdGFzKGUpIHtcclxuICAgIHJldHVybiBlLm9yaWdpbmFsRGF0YXMuYmVmb3JlUmVuZGVyYWJsZTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXh0VHJhbnNmb3JtcyhlKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxEYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5iZWZvcmVSZW5kZXJhYmxlO1xyXG4gICAgcmV0dXJuIG9yaWdpbmFsRGF0YXMubmV4dFRyYW5zZm9ybXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV4dFRyYW5zZm9ybVRleHQoZSkge1xyXG4gICAgcmV0dXJuIChnZXROZXh0VHJhbnNmb3JtcyhlKSB8fCBbXSkuam9pbihcIiBcIik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV4dFN0eWxlKGUpIHtcclxuICAgIHJldHVybiBnZXRCZWZvcmVSZW5kZXJhYmxlRGF0YXMoZSkubmV4dFN0eWxlO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGxUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgbmV4dFRyYW5zZm9ybSwgZGVsdGEsIGlzUGluY2gsIGUpIHtcclxuICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcclxuICAgIHZhciBkcmFnID0gRHJhZ2dhYmxlLmRyYWcobW92ZWFibGUsIHNldEN1c3RvbURyYWcoZSwgbW92ZWFibGUuc3RhdGUsIGRlbHRhLCBpc1BpbmNoLCBmYWxzZSkpO1xyXG4gICAgdmFyIGFmdGVyVHJhbnNmb3JtID0gZHJhZyA/IGRyYWcudHJhbnNmb3JtIDogbmV4dFRyYW5zZm9ybTtcclxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7IHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSwgZHJhZzogZHJhZyB9LCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICB0cmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLFxyXG4gICAgfSwgZSkpLCB7IGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybSB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGVGaXhlZFBvc2l0aW9uKG1vdmVhYmxlLCB0cmFuc2Zvcm0sIGZpeGVkRGlyZWN0aW9uLCBmaXhlZE9mZnNldCwgZGF0YXMsIGlzQWxsVHJhbnNmb3JtKSB7XHJcbiAgICB2YXIgbmV4dE1hdHJpeCA9IGdldE5leHRUcmFuc2Zvcm1NYXRyaXgobW92ZWFibGUuc3RhdGUsIGRhdGFzLCB0cmFuc2Zvcm0sIGlzQWxsVHJhbnNmb3JtKTtcclxuICAgIHZhciBuZXh0Rml4ZWRQb3NpdGlvbiA9IGdldERpcmVjdGlvbk9mZnNldChtb3ZlYWJsZSwgZml4ZWREaXJlY3Rpb24sIGZpeGVkT2Zmc2V0LCBuZXh0TWF0cml4KTtcclxuICAgIHJldHVybiBuZXh0Rml4ZWRQb3NpdGlvbjtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGVEaXN0KG1vdmVhYmxlLCB0cmFuc2Zvcm0sIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBmaXhlZE9mZnNldCwgZGF0YXMsIGlzQWxsVHJhbnNmb3JtKSB7XHJcbiAgICB2YXIgbmV4dEZpeGVkUG9zaXRpb24gPSBnZXRUcmFuc2xhdGVGaXhlZFBvc2l0aW9uKG1vdmVhYmxlLCB0cmFuc2Zvcm0sIGZpeGVkRGlyZWN0aW9uLCBmaXhlZE9mZnNldCwgZGF0YXMsIGlzQWxsVHJhbnNmb3JtKTtcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIGxlZnQgPSBzdGF0ZS5sZWZ0LCB0b3AgPSBzdGF0ZS50b3A7XHJcbiAgICB2YXIgZ3JvdXBhYmxlID0gbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlO1xyXG4gICAgdmFyIGdyb3VwTGVmdCA9IGdyb3VwYWJsZSA/IGxlZnQgOiAwO1xyXG4gICAgdmFyIGdyb3VwVG9wID0gZ3JvdXBhYmxlID8gdG9wIDogMDtcclxuICAgIHZhciBkaXN0ID0gbWludXMoZml4ZWRQb3NpdGlvbiwgbmV4dEZpeGVkUG9zaXRpb24pO1xyXG4gICAgcmV0dXJuIG1pbnVzKGRpc3QsIFtncm91cExlZnQsIGdyb3VwVG9wXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2NhbGVEaXN0KG1vdmVhYmxlLCB0cmFuc2Zvcm0sIGZpeGVkRGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBmaXhlZE9mZnNldCwgZGF0YXMsIGlzQWxsVHJhbnNmb3JtKSB7XHJcbiAgICB2YXIgZGlzdCA9IGdldFRyYW5zbGF0ZURpc3QobW92ZWFibGUsIHRyYW5zZm9ybSwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGZpeGVkT2Zmc2V0LCBkYXRhcywgaXNBbGxUcmFuc2Zvcm0pO1xyXG4gICAgcmV0dXJuIGRpc3Q7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uQnlQb3MocG9zLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHdpZHRoID8gLTEgKyBwb3NbMF0gLyAod2lkdGggLyAyKSA6IDAsXHJcbiAgICAgICAgaGVpZ2h0ID8gLTEgKyBwb3NbMV0gLyAoaGVpZ2h0IC8gMikgOiAwLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25PZmZzZXQobW92ZWFibGUsIGZpeGVkRGlyZWN0aW9uLCBmaXhlZE9mZnNldCwgbmV4dE1hdHJpeCkge1xyXG4gICAgaWYgKG5leHRNYXRyaXggPT09IHZvaWQgMCkgeyBuZXh0TWF0cml4ID0gbW92ZWFibGUuc3RhdGUuYWxsTWF0cml4OyB9XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5zdGF0ZSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBpczNkID0gX2EuaXMzZDtcclxuICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIGZpeGVkT2Zmc2V0UG9zaXRpb24gPSBbXHJcbiAgICAgICAgd2lkdGggLyAyICogKDEgKyBmaXhlZERpcmVjdGlvblswXSkgKyBmaXhlZE9mZnNldFswXSxcclxuICAgICAgICBoZWlnaHQgLyAyICogKDEgKyBmaXhlZERpcmVjdGlvblsxXSkgKyBmaXhlZE9mZnNldFsxXSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlUG9zaXRpb24obmV4dE1hdHJpeCwgZml4ZWRPZmZzZXRQb3NpdGlvbiwgbik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Um90YXRlRGlzdChtb3ZlYWJsZSwgcm90YXRlRGlzdCwgZGF0YXMpIHtcclxuICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xyXG4gICAgdmFyIGZpeGVkT2Zmc2V0ID0gZGF0YXMuZml4ZWRPZmZzZXQ7XHJcbiAgICByZXR1cm4gZ2V0VHJhbnNsYXRlRGlzdChtb3ZlYWJsZSwgXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZURpc3QsIFwiZGVnKVwiKSwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGZpeGVkT2Zmc2V0LCBkYXRhcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVzaXplRGlzdChtb3ZlYWJsZSwgd2lkdGgsIGhlaWdodCwgZml4ZWRQb3NpdGlvbiwgdHJhbnNmb3JtT3JpZ2luLCBkYXRhcykge1xyXG4gICAgdmFyIGdyb3VwYWJsZSA9IG1vdmVhYmxlLnByb3BzLmdyb3VwYWJsZTtcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIHByZXZPcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW4sIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2QsIHByZXZXaWR0aCA9IHN0YXRlLndpZHRoLCBwcmV2SGVpZ2h0ID0gc3RhdGUuaGVpZ2h0LCBsZWZ0ID0gc3RhdGUubGVmdCwgdG9wID0gc3RhdGUudG9wO1xyXG4gICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb247XHJcbiAgICB2YXIgdGFyZ2V0TWF0cml4ID0gZGF0YXMubmV4dFRhcmdldE1hdHJpeCB8fCBzdGF0ZS50YXJnZXRNYXRyaXg7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHZhciBuZXh0T3JpZ2luID0gY2FsY3VsYXRlVHJhbnNmb3JtT3JpZ2luKHRyYW5zZm9ybU9yaWdpbiwgd2lkdGgsIGhlaWdodCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCBwcmV2T3JpZ2luKTtcclxuICAgIHZhciBncm91cExlZnQgPSBncm91cGFibGUgPyBsZWZ0IDogMDtcclxuICAgIHZhciBncm91cFRvcCA9IGdyb3VwYWJsZSA/IHRvcCA6IDA7XHJcbiAgICB2YXIgbmV4dE1hdHJpeCA9IGdldE5leHRNYXRyaXgob2Zmc2V0TWF0cml4LCB0YXJnZXRNYXRyaXgsIG5leHRPcmlnaW4sIG4pO1xyXG4gICAgdmFyIGRpc3QgPSBnZXREaXN0KGZpeGVkUG9zaXRpb24sIG5leHRNYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4sIGZpeGVkRGlyZWN0aW9uKTtcclxuICAgIHJldHVybiBtaW51cyhkaXN0LCBbZ3JvdXBMZWZ0LCBncm91cFRvcF0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFic29sdXRlUG9zaXRpb24obW92ZWFibGUsIGRpcmVjdGlvbikge1xyXG4gICAgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKSwgZGlyZWN0aW9uKTtcclxufVxuXG5mdW5jdGlvbiBnZXRHZXN0b0RhdGEobW92ZWFibGUsIGFibGVOYW1lKSB7XHJcbiAgICB2YXIgdGFyZ2V0R2VzdG8gPSBtb3ZlYWJsZS50YXJnZXRHZXN0bztcclxuICAgIHZhciBjb250cm9sR2VzdG8gPSBtb3ZlYWJsZS5jb250cm9sR2VzdG87XHJcbiAgICB2YXIgZGF0YTtcclxuICAgIGlmICh0YXJnZXRHZXN0byA9PT0gbnVsbCB8fCB0YXJnZXRHZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0R2VzdG8uaXNGbGFnKCkpIHtcclxuICAgICAgICBkYXRhID0gdGFyZ2V0R2VzdG8uZ2V0RXZlbnREYXRhKClbYWJsZU5hbWVdO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkYXRhICYmIChjb250cm9sR2VzdG8gPT09IG51bGwgfHwgY29udHJvbEdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cm9sR2VzdG8uaXNGbGFnKCkpKSB7XHJcbiAgICAgICAgZGF0YSA9IGNvbnRyb2xHZXN0by5nZXRFdmVudERhdGEoKVthYmxlTmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YSB8fCB7fTtcclxufVxuXG5mdW5jdGlvbiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpIHtcclxuICAgIGlmIChwYXJlbnRFbGVtZW50ICYmIHBhcmVudEVsZW1lbnQuZ2V0Um9vdE5vZGUpIHtcclxuICAgICAgICB2YXIgcm9vdE5vZGUgPSBwYXJlbnRFbGVtZW50LmdldFJvb3ROb2RlKCk7XHJcbiAgICAgICAgaWYgKHJvb3ROb2RlLm5vZGVUeXBlID09PSAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG59XHJcbmZ1bmN0aW9uIGdldEluZGl2aWR1YWxUcmFuc2Zvcm1zKGdldFN0eWxlKSB7XHJcbiAgICB2YXIgc2NhbGUgPSBnZXRTdHlsZShcInNjYWxlXCIpO1xyXG4gICAgdmFyIHJvdGF0ZSA9IGdldFN0eWxlKFwicm90YXRlXCIpO1xyXG4gICAgdmFyIHRyYW5zbGF0ZSA9IGdldFN0eWxlKFwidHJhbnNsYXRlXCIpO1xyXG4gICAgdmFyIGluZGl2aWR1YWxUcmFuc2Zvcm1zID0gW107XHJcbiAgICBpZiAodHJhbnNsYXRlICYmIHRyYW5zbGF0ZSAhPT0gXCIwcHhcIiAmJiB0cmFuc2xhdGUgIT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgaW5kaXZpZHVhbFRyYW5zZm9ybXMucHVzaChcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlLnNwbGl0KC9cXHMrLykuam9pbihcIixcIiksIFwiKVwiKSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm90YXRlICYmIHJvdGF0ZSAhPT0gXCIxXCIgJiYgcm90YXRlICE9PSBcIm5vbmVcIikge1xyXG4gICAgICAgIGluZGl2aWR1YWxUcmFuc2Zvcm1zLnB1c2goXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCIpXCIpKTtcclxuICAgIH1cclxuICAgIGlmIChzY2FsZSAmJiBzY2FsZSAhPT0gXCIxXCIgJiYgc2NhbGUgIT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgaW5kaXZpZHVhbFRyYW5zZm9ybXMucHVzaChcInNjYWxlKFwiLmNvbmNhdChzY2FsZS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIsXCIpLCBcIilcIikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGl2aWR1YWxUcmFuc2Zvcm1zO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1hdHJpeFN0YWNrSW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgY2hlY2tDb250YWluZXIpIHtcclxuICAgIHZhciBlbCA9IHRhcmdldDtcclxuICAgIHZhciBtYXRyaXhlcyA9IFtdO1xyXG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudCh0YXJnZXQpIHx8IGdldERvY3VtZW50Qm9keSh0YXJnZXQpO1xyXG4gICAgdmFyIHJlcXVlc3RFbmQgPSAhY2hlY2tDb250YWluZXIgJiYgdGFyZ2V0ID09PSBjb250YWluZXIgfHwgdGFyZ2V0ID09PSBkb2N1bWVudEVsZW1lbnQ7XHJcbiAgICB2YXIgaXNFbmQgPSByZXF1ZXN0RW5kO1xyXG4gICAgdmFyIGlzM2QgPSBmYWxzZTtcclxuICAgIHZhciBuID0gMztcclxuICAgIHZhciB0cmFuc2Zvcm1PcmlnaW47XHJcbiAgICB2YXIgdGFyZ2V0VHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgdmFyIHRhcmdldE1hdHJpeDtcclxuICAgIHZhciBoYXNGaXhlZCA9IGZhbHNlO1xyXG4gICAgdmFyIG9mZnNldENvbnRhaW5lciA9IGdldE9mZnNldEluZm8oY29udGFpbmVyLCBjb250YWluZXIsIHRydWUpLm9mZnNldFBhcmVudDtcclxuICAgIHZhciB6b29tID0gMTtcclxuICAgIHdoaWxlIChlbCAmJiAhaXNFbmQpIHtcclxuICAgICAgICBpc0VuZCA9IHJlcXVlc3RFbmQ7XHJcbiAgICAgICAgdmFyIGdldFN0eWxlID0gZ2V0Q2FjaGVkU3R5bGUoZWwpO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFN0eWxlKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldEVsZW1lbnRUcmFuc2Zvcm0oZWwpO1xyXG4gICAgICAgIHZhciBpc0ZpeGVkID0gcG9zaXRpb24gPT09IFwiZml4ZWRcIjtcclxuICAgICAgICB2YXIgaW5kaXZpZHVhbFRyYW5zZm9ybXMgPSBnZXRJbmRpdmlkdWFsVHJhbnNmb3JtcyhnZXRTdHlsZSk7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IGNvbnZlcnRDU1N0b01hdHJpeChnZXRUcmFuc2Zvcm1NYXRyaXgodHJhbnNmb3JtKSk7XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IHZvaWQgMDtcclxuICAgICAgICB2YXIgaXNPZmZzZXRFbmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcGFyZW50Q2xpZW50TGVmdCA9IDA7XHJcbiAgICAgICAgdmFyIHBhcmVudENsaWVudFRvcCA9IDA7XHJcbiAgICAgICAgdmFyIGZpeGVkQ2xpZW50TGVmdCA9IDA7XHJcbiAgICAgICAgdmFyIGZpeGVkQ2xpZW50VG9wID0gMDtcclxuICAgICAgICB2YXIgZml4ZWRJbmZvID0ge1xyXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm06IGZhbHNlLFxyXG4gICAgICAgICAgICBmaXhlZENvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpc0ZpeGVkKSB7XHJcbiAgICAgICAgICAgIGhhc0ZpeGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZml4ZWRJbmZvID0gZ2V0UG9zaXRpb25GaXhlZEluZm8oZWwpO1xyXG4gICAgICAgICAgICBvZmZzZXRDb250YWluZXIgPSBmaXhlZEluZm8uZml4ZWRDb250YWluZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnZlcnQgMyB0byA0XHJcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gbWF0cml4Lmxlbmd0aDtcclxuICAgICAgICBpZiAoIWlzM2QgJiYgKGxlbmd0aF8xID09PSAxNiB8fCBpbmRpdmlkdWFsVHJhbnNmb3Jtcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGlzM2QgPSB0cnVlO1xyXG4gICAgICAgICAgICBuID0gNDtcclxuICAgICAgICAgICAgY29udmVydDNETWF0cml4ZXMobWF0cml4ZXMpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXRyaXggPSBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgMywgNCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzM2QgJiYgbGVuZ3RoXzEgPT09IDkpIHtcclxuICAgICAgICAgICAgbWF0cml4ID0gY29udmVydERpbWVuc2lvbihtYXRyaXgsIDMsIDQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBnZXRPZmZzZXRQb3NJbmZvKGVsLCB0YXJnZXQpLCB0YWdOYW1lID0gX2EudGFnTmFtZSwgaGFzT2Zmc2V0ID0gX2EuaGFzT2Zmc2V0LCBpc1NWRyA9IF9hLmlzU1ZHLCBvcmlnaW5fMSA9IF9hLm9yaWdpbiwgdGFyZ2V0T3JpZ2luID0gX2EudGFyZ2V0T3JpZ2luLCBvZmZzZXRQb3MgPSBfYS5vZmZzZXQ7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKG9mZnNldFBvcywgMiksIG9mZnNldExlZnQgPSBfYlswXSwgb2Zmc2V0VG9wID0gX2JbMV07XHJcbiAgICAgICAgLy8gbm8gdGFyZ2V0IHdpdGggc3ZnXHJcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09IFwic3ZnXCIgJiYgIWVsLm93bmVyU1ZHRWxlbWVudCAmJiB0YXJnZXRNYXRyaXgpIHtcclxuICAgICAgICAgICAgLy8gc2NhbGUgbWF0cml4IGZvciBzdmcncyBTVkdFbGVtZW50cy5cclxuICAgICAgICAgICAgbWF0cml4ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRhcmdldFwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogZ2V0U1ZHTWF0cml4KGVsLCBuKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldFpvb20gPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwiem9vbVwiKSkgfHwgMTtcclxuICAgICAgICBpZiAoaXNGaXhlZCkge1xyXG4gICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBmaXhlZEluZm8uZml4ZWRDb250YWluZXI7XHJcbiAgICAgICAgICAgIGlzT2Zmc2V0RW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRJbmZvID0gZ2V0T2Zmc2V0SW5mbyhlbCwgY29udGFpbmVyLCBmYWxzZSwgdHJ1ZSwgZ2V0U3R5bGUpO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0Wm9vbSA9IG9mZnNldEluZm8ub2Zmc2V0Wm9vbTtcclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0SW5mby5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgIGlzT2Zmc2V0RW5kID0gb2Zmc2V0SW5mby5pc0VuZDtcclxuICAgICAgICAgICAgaXNTdGF0aWMgPSBvZmZzZXRJbmZvLmlzU3RhdGljO1xyXG4gICAgICAgICAgICB6b29tICo9IG9mZnNldFpvb207XHJcbiAgICAgICAgICAgIGlmICgob2Zmc2V0SW5mby5pc0N1c3RvbUVsZW1lbnQgfHwgb2Zmc2V0Wm9vbSAhPT0gMSkgJiYgaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gb2Zmc2V0UGFyZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRUb3AgLT0gb2Zmc2V0UGFyZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChJU19GSVJFRk9YIHx8IElTX0NIUk9NSVVNMTA5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50U2xvdEVsZW1lbnQgPSBvZmZzZXRJbmZvLnBhcmVudFNsb3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNsb3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbU9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tT2Zmc2V0TGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbU9mZnNldFRvcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1c3RvbU9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFNoYWRvd1Jvb3QoY3VzdG9tT2Zmc2V0UGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tT2Zmc2V0TGVmdCArPSBjdXN0b21PZmZzZXRQYXJlbnQub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tT2Zmc2V0VG9wICs9IGN1c3RvbU9mZnNldFBhcmVudC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbU9mZnNldFBhcmVudCA9IGN1c3RvbU9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgLT0gY3VzdG9tT2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3AgLT0gY3VzdG9tT2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChJU19XRUJLSVQgJiYgIUlTX1NBRkFSSV9BQk9WRTE1XHJcbiAgICAgICAgICAgICYmIGhhc09mZnNldCAmJiAhaXNTVkcgJiYgaXNTdGF0aWNcclxuICAgICAgICAgICAgJiYgKHBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcG9zaXRpb24gPT09IFwic3RhdGljXCIpKSB7XHJcbiAgICAgICAgICAgIG9mZnNldExlZnQgLT0gb2Zmc2V0UGFyZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgIG9mZnNldFRvcCAtPSBvZmZzZXRQYXJlbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICByZXF1ZXN0RW5kID0gcmVxdWVzdEVuZCB8fCBpc09mZnNldEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRml4ZWQpIHtcclxuICAgICAgICAgICAgaWYgKGhhc09mZnNldCAmJiBmaXhlZEluZm8uaGFzVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBib3JkZXJcclxuICAgICAgICAgICAgICAgIGZpeGVkQ2xpZW50TGVmdCA9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xyXG4gICAgICAgICAgICAgICAgZml4ZWRDbGllbnRUb3AgPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaGFzT2Zmc2V0ICYmIG9mZnNldENvbnRhaW5lciAhPT0gb2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBib3JkZXJcclxuICAgICAgICAgICAgICAgIHBhcmVudENsaWVudExlZnQgPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcclxuICAgICAgICAgICAgICAgIHBhcmVudENsaWVudFRvcCA9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc09mZnNldCAmJiBvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IGdldEJvZHlPZmZzZXQoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldExlZnQgKz0gbWFyZ2luWzBdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0VG9wICs9IG1hcmdpblsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXRyaXhlcy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogXCJ0YXJnZXRcIixcclxuICAgICAgICAgICAgdGFyZ2V0OiBlbCxcclxuICAgICAgICAgICAgbWF0cml4OiBnZXRBYnNvbHV0ZU1hdHJpeChtYXRyaXgsIG4sIG9yaWdpbl8xKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaW5kaXZpZHVhbFRyYW5zZm9ybXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJvZmZzZXRcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbWF0cml4ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRhcmdldFwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogZ2V0QWJzb2x1dGVNYXRyaXgocGFyc2VNYXQoaW5kaXZpZHVhbFRyYW5zZm9ybXMpLCBuLCBvcmlnaW5fMSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0VsZW1lbnRUYXJnZXQgPSBlbCA9PT0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGlzRWxlbWVudFRhcmdldCA/IDAgOiBlbC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gaXNFbGVtZW50VGFyZ2V0ID8gMCA6IGVsLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgbWF0cml4ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9mZnNldFwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogY3JlYXRlT3JpZ2luTWF0cml4KFtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0IC0gc2Nyb2xsTGVmdCArIHBhcmVudENsaWVudExlZnQgLSBmaXhlZENsaWVudExlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wIC0gc2Nyb2xsVG9wICsgcGFyZW50Q2xpZW50VG9wIC0gZml4ZWRDbGllbnRUb3AsXHJcbiAgICAgICAgICAgICAgICBdLCBuKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzdmdcclxuICAgICAgICAgICAgbWF0cml4ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9mZnNldFwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXzEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cmFuc2Zvcm3snLzroZwg6rOE7IKw65CY7KeAIOyViuuKlCB6b29t7J2EIOychO2VnCAoMCwgMCkg7J2EIOq4sOykgCBtYXRyaXgg7LaU6rCALlxyXG4gICAgICAgIGlmICh0YXJnZXRab29tICE9PSAxKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ6b29tXCIsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGVsLFxyXG4gICAgICAgICAgICAgICAgbWF0cml4OiBnZXRBYnNvbHV0ZU1hdHJpeChjcmVhdGVTY2FsZU1hdHJpeChbdGFyZ2V0Wm9vbSwgdGFyZ2V0Wm9vbV0sIG4pLCBuLCBbMCwgMF0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXRNYXRyaXgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0TWF0cml4ID0gbWF0cml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRyYW5zZm9ybU9yaWdpbikge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW5fMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm1PcmlnaW4pIHtcclxuICAgICAgICAgICAgdGFyZ2V0VHJhbnNmb3JtT3JpZ2luID0gdGFyZ2V0T3JpZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNFbmQgfHwgaXNGaXhlZCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gb2Zmc2V0UGFyZW50O1xyXG4gICAgICAgICAgICByZXF1ZXN0RW5kID0gaXNPZmZzZXRFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2hlY2tDb250YWluZXIgfHwgZWwgPT09IGRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICBpc0VuZCA9IHJlcXVlc3RFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0YXJnZXRNYXRyaXgpIHtcclxuICAgICAgICB0YXJnZXRNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIH1cclxuICAgIGlmICghdHJhbnNmb3JtT3JpZ2luKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gWzAsIDBdO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm1PcmlnaW4pIHtcclxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm1PcmlnaW4gPSBbMCwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHpvb206IHpvb20sXHJcbiAgICAgICAgb2Zmc2V0Q29udGFpbmVyOiBvZmZzZXRDb250YWluZXIsXHJcbiAgICAgICAgbWF0cml4ZXM6IG1hdHJpeGVzLFxyXG4gICAgICAgIHRhcmdldE1hdHJpeDogdGFyZ2V0TWF0cml4LFxyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogdHJhbnNmb3JtT3JpZ2luLFxyXG4gICAgICAgIHRhcmdldE9yaWdpbjogdGFyZ2V0VHJhbnNmb3JtT3JpZ2luLFxyXG4gICAgICAgIGlzM2Q6IGlzM2QsXHJcbiAgICAgICAgaGFzRml4ZWQ6IGhhc0ZpeGVkLFxyXG4gICAgfTtcclxufVxuXG52YXIgY2FjaGVTdHlsZU1hcCA9IG51bGw7XHJcbnZhciBjbGllbnRSZWN0U3R5bGVNYXAgPSBudWxsO1xyXG52YXIgbWF0cml4Q29udGFpbmVySW5mb3MgPSBudWxsO1xyXG5mdW5jdGlvbiBzZXRTdG9yZUNhY2hlKHVzZUNhY2hlKSB7XHJcbiAgICBpZiAodXNlQ2FjaGUpIHtcclxuICAgICAgICBpZiAod2luZG93Lk1hcCkge1xyXG4gICAgICAgICAgICBjYWNoZVN0eWxlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBjbGllbnRSZWN0U3R5bGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdHJpeENvbnRhaW5lckluZm9zID0gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjYWNoZVN0eWxlTWFwID0gbnVsbDtcclxuICAgICAgICBtYXRyaXhDb250YWluZXJJbmZvcyA9IG51bGw7XHJcbiAgICAgICAgY2xpZW50UmVjdFN0eWxlTWFwID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDYWNoZWRDbGllbnRSZWN0KGVsKSB7XHJcbiAgICB2YXIgY2xpZW50UmVjdCA9IGNsaWVudFJlY3RTdHlsZU1hcCA9PT0gbnVsbCB8fCBjbGllbnRSZWN0U3R5bGVNYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFJlY3RTdHlsZU1hcC5nZXQoZWwpO1xyXG4gICAgaWYgKGNsaWVudFJlY3QpIHtcclxuICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcclxuICAgIH1cclxuICAgIHZhciBuZXh0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QoZWwsIHRydWUpO1xyXG4gICAgaWYgKGNsaWVudFJlY3RTdHlsZU1hcCkge1xyXG4gICAgICAgIGNsaWVudFJlY3RTdHlsZU1hcC5zZXQoZWwsIG5leHRDbGllbnRSZWN0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0Q2xpZW50UmVjdDtcclxufVxyXG5mdW5jdGlvbiBnZXRDYWNoZWRNYXRyaXhDb250YWluZXJJbmZvKHRhcmdldCwgY29udGFpbmVyKSB7XHJcbiAgICBpZiAobWF0cml4Q29udGFpbmVySW5mb3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0XzEgPSBmaW5kKG1hdHJpeENvbnRhaW5lckluZm9zLCBmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mb1swXVswXSA9PSB0YXJnZXQgJiYgaW5mb1swXVsxXSA9PSBjb250YWluZXI7IH0pO1xyXG4gICAgICAgIGlmIChyZXN1bHRfMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XzFbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IGdldE1hdHJpeFN0YWNrSW5mbyh0YXJnZXQsIGNvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICBpZiAobWF0cml4Q29udGFpbmVySW5mb3MpIHtcclxuICAgICAgICBtYXRyaXhDb250YWluZXJJbmZvcy5wdXNoKFtbdGFyZ2V0LCBjb250YWluZXJdLCByZXN1bHRdKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2FjaGVkU3R5bGUoZWxlbWVudCkge1xyXG4gICAgdmFyIGNhY2hlID0gY2FjaGVTdHlsZU1hcCA9PT0gbnVsbCB8fCBjYWNoZVN0eWxlTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWNoZVN0eWxlTWFwLmdldChlbGVtZW50KTtcclxuICAgIGlmICghY2FjaGUpIHtcclxuICAgICAgICB2YXIgbmV4dFN0eWxlXzEgPSBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgICAgICBpZiAoIWNhY2hlU3R5bGVNYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTdHlsZV8xW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FjaGUgPSB7XHJcbiAgICAgICAgICAgIHN0eWxlOiBuZXh0U3R5bGVfMSxcclxuICAgICAgICAgICAgY2FjaGVkOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNhY2hlU3R5bGVNYXAuc2V0KGVsZW1lbnQsIGNhY2hlKTtcclxuICAgIH1cclxuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5jYWNoZWQ7XHJcbiAgICB2YXIgc3R5bGUgPSBjYWNoZS5zdHlsZTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICBpZiAoIShwcm9wZXJ0eSBpbiBjYWNoZWQpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZFtwcm9wZXJ0eV0gPSBzdHlsZVtwcm9wZXJ0eV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYWNoZWRbcHJvcGVydHldO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIG5hbWUsIGUpIHtcclxuICAgIHZhciBkYXRhcyA9IGUub3JpZ2luYWxEYXRhcztcclxuICAgIGRhdGFzLmdyb3VwYWJsZSA9IGRhdGFzLmdyb3VwYWJsZSB8fCB7fTtcclxuICAgIHZhciBncm91cGFibGVEYXRhcyA9IGRhdGFzLmdyb3VwYWJsZTtcclxuICAgIGdyb3VwYWJsZURhdGFzLmNoaWxkRGF0YXMgPSBncm91cGFibGVEYXRhcy5jaGlsZERhdGFzIHx8IFtdO1xyXG4gICAgdmFyIGNoaWxkRGF0YXMgPSBncm91cGFibGVEYXRhcy5jaGlsZERhdGFzO1xyXG4gICAgcmV0dXJuIG1vdmVhYmxlLm1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcclxuICAgICAgICBjaGlsZERhdGFzW2ldID0gY2hpbGREYXRhc1tpXSB8fCB7fTtcclxuICAgICAgICBjaGlsZERhdGFzW2ldW25hbWVdID0gY2hpbGREYXRhc1tpXVtuYW1lXSB8fCB7fTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGlzUmVxdWVzdENoaWxkOiB0cnVlLCBkYXRhczogY2hpbGREYXRhc1tpXVtuYW1lXSwgb3JpZ2luYWxEYXRhczogY2hpbGREYXRhc1tpXSB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCBhYmxlLCB0eXBlLCBkZWx0YSwgZSwgaXNDb252ZXJ0LCBhYmxlTmFtZSkge1xyXG4gICAgdmFyIGlzU3RhcnQgPSAhIXR5cGUubWF0Y2goL1N0YXJ0JC9nKTtcclxuICAgIHZhciBpc0VuZCA9ICEhdHlwZS5tYXRjaCgvRW5kJC9nKTtcclxuICAgIHZhciBpc1BpbmNoID0gZS5pc1BpbmNoO1xyXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIGFibGUubmFtZSwgZSk7XHJcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgdmFyIGNoaWxkRXZlbnRzID0gW107XHJcbiAgICB2YXIgZXZlbnRQYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGNoaWxkTW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIGdlc3RvcyA9IHN0YXRlLmdlc3RvcztcclxuICAgICAgICB2YXIgY2hpbGRFdmVudCA9IGV2O1xyXG4gICAgICAgIGlmIChpc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIGNoaWxkRXZlbnQgPSBuZXcgQ3VzdG9tR2VzdG8oYWJsZU5hbWUpLmRyYWdTdGFydChkZWx0YSwgZXYpO1xyXG4gICAgICAgICAgICBjaGlsZEV2ZW50cy5wdXNoKGNoaWxkRXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFnZXN0b3NbYWJsZU5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBnZXN0b3NbYWJsZU5hbWVdID0gZGF0YXMuY2hpbGRHZXN0b3NbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFnZXN0b3NbYWJsZU5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hpbGRFdmVudCA9IHNldEN1c3RvbURyYWcoZXYsIHN0YXRlLCBkZWx0YSwgaXNQaW5jaCwgaXNDb252ZXJ0LCBhYmxlTmFtZSk7XHJcbiAgICAgICAgICAgIGNoaWxkRXZlbnRzLnB1c2goY2hpbGRFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBhYmxlW3R5cGVdKGNoaWxkTW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGlsZEV2ZW50KSwgeyBwYXJlbnRGbGFnOiB0cnVlIH0pKTtcclxuICAgICAgICBpZiAoaXNFbmQpIHtcclxuICAgICAgICAgICAgZ2VzdG9zW2FibGVOYW1lXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxuICAgIGlmIChpc1N0YXJ0KSB7XHJcbiAgICAgICAgZGF0YXMuY2hpbGRHZXN0b3MgPSBtb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQuc3RhdGUuZ2VzdG9zW2FibGVOYW1lXTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV2ZW50UGFyYW1zOiBldmVudFBhcmFtcyxcclxuICAgICAgICBjaGlsZEV2ZW50czogY2hpbGRFdmVudHMsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCBhYmxlLCB0eXBlLCBlLCBlYWNoRXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZWFjaEV2ZW50ID09PSB2b2lkIDApIHsgZWFjaEV2ZW50ID0gZnVuY3Rpb24gKF8sIGV2KSB7IHJldHVybiBldjsgfTsgfVxyXG4gICAgdmFyIGlzRW5kID0gISF0eXBlLm1hdGNoKC9FbmQkL2cpO1xyXG4gICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgYWJsZS5uYW1lLCBlKTtcclxuICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XHJcbiAgICB2YXIgY2hpbGRzID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYsIGkpIHtcclxuICAgICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IG1vdmVhYmxlc1tpXTtcclxuICAgICAgICB2YXIgY2hpbGRFdmVudCA9IGV2O1xyXG4gICAgICAgIGNoaWxkRXZlbnQgPSBlYWNoRXZlbnQoY2hpbGRNb3ZlYWJsZSwgZXYpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBhYmxlW3R5cGVdKGNoaWxkTW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjaGlsZEV2ZW50KSwgeyBwYXJlbnRGbGFnOiB0cnVlIH0pKTtcclxuICAgICAgICByZXN1bHQgJiYgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2hpbGRNb3ZlYWJsZSwgZXYsIHJlc3VsdCwgaSk7XHJcbiAgICAgICAgaWYgKGlzRW5kKSB7XHJcbiAgICAgICAgICAgIGNoaWxkTW92ZWFibGUuc3RhdGUuZ2VzdG9zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjaGlsZHM7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRDaGlsZERpc3QobW92ZWFibGUsIGNoaWxkLCBwYXJlbnREYXRhcywgY2hpbGRFdmVudCkge1xyXG4gICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gcGFyZW50RGF0YXMuZml4ZWREaXJlY3Rpb247XHJcbiAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IHBhcmVudERhdGFzLmZpeGVkUG9zaXRpb247XHJcbiAgICB2YXIgc3RhcnRQb3NpdGlvbnMgPSBjaGlsZEV2ZW50LmRhdGFzLnN0YXJ0UG9zaXRpb25zIHx8IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKGNoaWxkLnN0YXRlKTtcclxuICAgIHZhciBwb3MgPSBnZXRQb3NCeURpcmVjdGlvbihzdGFydFBvc2l0aW9ucywgZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgdmFyIF9hID0gX19yZWFkKGNhbGN1bGF0ZShjcmVhdGVSb3RhdGVNYXRyaXgoLW1vdmVhYmxlLnJvdGF0aW9uIC8gMTgwICogTWF0aC5QSSwgMyksIFtwb3NbMF0gLSBmaXhlZFBvc2l0aW9uWzBdLCBwb3NbMV0gLSBmaXhlZFBvc2l0aW9uWzFdLCAxXSwgMyksIDIpLCBvcmlnaW5hbFggPSBfYVswXSwgb3JpZ2luYWxZID0gX2FbMV07XHJcbiAgICBjaGlsZEV2ZW50LmRhdGFzLm9yaWdpbmFsWCA9IG9yaWdpbmFsWDtcclxuICAgIGNoaWxkRXZlbnQuZGF0YXMub3JpZ2luYWxZID0gb3JpZ2luYWxZO1xyXG4gICAgcmV0dXJuIGNoaWxkRXZlbnQ7XHJcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlyZWN0aW9uQ29udHJvbHNCeUluZm9zKG1vdmVhYmxlLCBhYmxlTmFtZSwgcmVuZGVyRGlyZWN0aW9ucywgUmVhY3QpIHtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLmdldFN0YXRlKCksIHJlbmRlclBvc2VzID0gX2EucmVuZGVyUG9zZXMsIHJvdGF0aW9uUmFkID0gX2Eucm90YXRpb24sIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcclxuICAgIHZhciB6b29tID0gZ2V0UHJvcHMobW92ZWFibGUucHJvcHMsIGFibGVOYW1lKS56b29tO1xyXG4gICAgdmFyIGRlZ1JvdGF0aW9uID0gYWJzRGVncmVlKHJvdGF0aW9uUmFkIC8gTWF0aC5QSSAqIDE4MCk7XHJcbiAgICB2YXIgZGlyZWN0aW9uTWFwID0ge307XHJcbiAgICB2YXIgcmVuZGVyU3RhdGUgPSBtb3ZlYWJsZS5yZW5kZXJTdGF0ZTtcclxuICAgIGlmICghcmVuZGVyU3RhdGUucmVuZGVyRGlyZWN0aW9uTWFwKSB7XHJcbiAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyRGlyZWN0aW9uTWFwID0ge307XHJcbiAgICB9XHJcbiAgICB2YXIgcmVuZGVyRGlyZWN0aW9uTWFwID0gcmVuZGVyU3RhdGUucmVuZGVyRGlyZWN0aW9uTWFwO1xyXG4gICAgcmVuZGVyRGlyZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBkaXIgPSBfYS5kaXI7XHJcbiAgICAgICAgZGlyZWN0aW9uTWFwW2Rpcl0gPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgZGlyZWN0aW9uU2lnbiA9IHNpZ24oZGlyZWN0aW9uKTtcclxuICAgIHJldHVybiByZW5kZXJEaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLCBkaXIgPSBfYS5kaXI7XHJcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBESVJFQ1RJT05fSU5ERVhFU1tkaXJdO1xyXG4gICAgICAgIGlmICghaW5kZXhlcyB8fCAhZGlyZWN0aW9uTWFwW2Rpcl0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckRpcmVjdGlvbk1hcFtkaXJdID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uUm90YXRpb24gPSAodGhyb3R0bGUoZGVnUm90YXRpb24sIDE1KSArIGRpcmVjdGlvblNpZ24gKiBESVJFQ1RJT05fUk9UQVRJT05TW2Rpcl0gKyA3MjApICUgMTgwO1xyXG4gICAgICAgIHZhciBkYXRhQXR0cnMgPSB7fTtcclxuICAgICAgICBnZXRLZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgZGF0YUF0dHJzW1wiZGF0YS1cIi5jb25jYXQobmFtZSldID0gZGF0YVtuYW1lXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IHByZWZpeC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW1wiY29udHJvbFwiLCBcImRpcmVjdGlvblwiLCBkaXIsIGFibGVOYW1lXSwgX19yZWFkKGNsYXNzTmFtZXMpLCBmYWxzZSkpLCBcImRhdGEtcm90YXRpb25cIjogZGlyZWN0aW9uUm90YXRpb24sIFwiZGF0YS1kaXJlY3Rpb25cIjogZGlyIH0sIGRhdGFBdHRycywgeyBrZXk6IFwiZGlyZWN0aW9uLVwiLmNvbmNhdChkaXIpLCBzdHlsZTogZ2V0Q29udHJvbFRyYW5zZm9ybS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW3JvdGF0aW9uUmFkLCB6b29tXSwgX19yZWFkKGluZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gcmVuZGVyUG9zZXNbaW5kZXhdOyB9KSksIGZhbHNlKSkgfSkpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzKG1vdmVhYmxlLCBkZWZhdWx0RGlyZWN0aW9ucywgYWJsZU5hbWUsIFJlYWN0KSB7XHJcbiAgICB2YXIgX2EgPSBnZXRQcm9wcyhtb3ZlYWJsZS5wcm9wcywgYWJsZU5hbWUpLCBfYiA9IF9hLnJlbmRlckRpcmVjdGlvbnMsIGRpcmVjdGlvbnMgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdERpcmVjdGlvbnMgOiBfYiwgZGlzcGxheUFyb3VuZENvbnRyb2xzID0gX2EuZGlzcGxheUFyb3VuZENvbnRyb2xzO1xyXG4gICAgaWYgKCFkaXJlY3Rpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlbmRlckRpcmVjdGlvbnMgPSBkaXJlY3Rpb25zID09PSB0cnVlID8gRElSRUNUSU9OUyA6IGRpcmVjdGlvbnM7XHJcbiAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoKGRpc3BsYXlBcm91bmRDb250cm9scyA/IHJlbmRlckFyb3VuZENvbnRyb2xzKG1vdmVhYmxlLCBSZWFjdCwgYWJsZU5hbWUsIHJlbmRlckRpcmVjdGlvbnMpIDogW10pKSwgZmFsc2UpLCBfX3JlYWQocmVuZGVyRGlyZWN0aW9uQ29udHJvbHNCeUluZm9zKG1vdmVhYmxlLCBhYmxlTmFtZSwgcmVuZGVyRGlyZWN0aW9ucy5tYXAoZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHt9LFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbXSxcclxuICAgICAgICAgICAgZGlyOiBkaXIsXHJcbiAgICAgICAgfTtcclxuICAgIH0pLCBSZWFjdCkpLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyTGluZShSZWFjdCwgZGlyZWN0aW9uLCBwb3MxLCBwb3MyLCB6b29tLCBrZXkpIHtcclxuICAgIHZhciBjbGFzc05hbWVzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDY7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGNsYXNzTmFtZXNbX2kgLSA2XSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgcmFkID0gZ2V0UmFkKHBvczEsIHBvczIpO1xyXG4gICAgdmFyIHJvdGF0aW9uID0gZGlyZWN0aW9uID8gKHRocm90dGxlKHJhZCAvIE1hdGguUEkgKiAxODAsIDE1KSkgJSAxODAgOiAtMTtcclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImxpbmUtXCIuY29uY2F0KGtleSksIGNsYXNzTmFtZTogcHJlZml4LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXCJsaW5lXCIsIFwiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbiA/IFwiZWRnZVwiIDogXCJcIiwgZGlyZWN0aW9uXSwgX19yZWFkKGNsYXNzTmFtZXMpLCBmYWxzZSkpLCBcImRhdGEtcm90YXRpb25cIjogcm90YXRpb24sIFwiZGF0YS1saW5lLWtleVwiOiBrZXksIFwiZGF0YS1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLCBzdHlsZTogZ2V0TGluZVN0eWxlKHBvczEsIHBvczIsIHpvb20sIHJhZCkgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyRWRnZUxpbmVzKFJlYWN0LCBhYmxlTmFtZSwgZWRnZSwgcG9zZXMsIHpvb20pIHtcclxuICAgIHZhciBkaXJlY3Rpb25zID0gZWRnZSA9PT0gdHJ1ZSA/IERJUkVDVElPTlM0IDogZWRnZTtcclxuICAgIHJldHVybiBkaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGlyZWN0aW9uLCBpKSB7XHJcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKERJUkVDVElPTl9JTkRFWEVTW2RpcmVjdGlvbl0sIDIpLCBpbmRleDEgPSBfYVswXSwgaW5kZXgyID0gX2FbMV07XHJcbiAgICAgICAgaWYgKGluZGV4MiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckxpbmUoUmVhY3QsIGRpcmVjdGlvbiwgcG9zZXNbaW5kZXgxXSwgcG9zZXNbaW5kZXgyXSwgem9vbSwgXCJcIi5jb25jYXQoYWJsZU5hbWUsIFwiRWRnZVwiKS5jb25jYXQoaSksIGFibGVOYW1lKTtcclxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcclxufVxyXG5mdW5jdGlvbiBnZXRSZW5kZXJEaXJlY3Rpb25zKGFibGVOYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBlZGdlID0gZ2V0UHJvcHMobW92ZWFibGUucHJvcHMsIGFibGVOYW1lKS5lZGdlO1xyXG4gICAgICAgIGlmIChlZGdlICYmIChlZGdlID09PSB0cnVlIHx8IGVkZ2UubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocmVuZGVyRWRnZUxpbmVzKFJlYWN0LCBhYmxlTmFtZSwgZWRnZSwgbW92ZWFibGUuZ2V0U3RhdGUoKS5yZW5kZXJQb3NlcywgbW92ZWFibGUucHJvcHMuem9vbSkpLCBmYWxzZSksIF9fcmVhZChyZW5kZXJEaWFnb25hbERpcmVjdGlvbnMobW92ZWFibGUsIGFibGVOYW1lLCBSZWFjdCkpLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBhYmxlTmFtZSwgUmVhY3QpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBhYmxlTmFtZSwgUmVhY3QpIHtcclxuICAgIHJldHVybiByZW5kZXJEaXJlY3Rpb25Db250cm9scyhtb3ZlYWJsZSwgRElSRUNUSU9OUywgYWJsZU5hbWUsIFJlYWN0KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJEaWFnb25hbERpcmVjdGlvbnMobW92ZWFibGUsIGFibGVOYW1lLCBSZWFjdCkge1xyXG4gICAgcmV0dXJuIHJlbmRlckRpcmVjdGlvbkNvbnRyb2xzKG1vdmVhYmxlLCBbXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXSwgYWJsZU5hbWUsIFJlYWN0KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJBcm91bmRDb250cm9scyhtb3ZlYWJsZSwgUmVhY3QsIGFibGVOYW1lLCByZW5kZXJEaXJlY3Rpb25zKSB7XHJcbiAgICB2YXIgcmVuZGVyU3RhdGUgPSBtb3ZlYWJsZS5yZW5kZXJTdGF0ZTtcclxuICAgIGlmICghcmVuZGVyU3RhdGUucmVuZGVyRGlyZWN0aW9uTWFwKSB7XHJcbiAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyRGlyZWN0aW9uTWFwID0ge307XHJcbiAgICB9XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCByZW5kZXJQb3NlcyA9IF9hLnJlbmRlclBvc2VzLCByb3RhdGlvblJhZCA9IF9hLnJvdGF0aW9uLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb247XHJcbiAgICB2YXIgcmVuZGVyRGlyZWN0aW9uTWFwID0gcmVuZGVyU3RhdGUucmVuZGVyRGlyZWN0aW9uTWFwO1xyXG4gICAgdmFyIHpvb20gPSBtb3ZlYWJsZS5wcm9wcy56b29tO1xyXG4gICAgdmFyIGRpcmVjdGlvblNpZ24gPSBzaWduKGRpcmVjdGlvbik7XHJcbiAgICB2YXIgZGVnUm90YXRpb24gPSByb3RhdGlvblJhZCAvIE1hdGguUEkgKiAxODA7XHJcbiAgICByZXR1cm4gKHJlbmRlckRpcmVjdGlvbnMgfHwgZ2V0S2V5cyhyZW5kZXJEaXJlY3Rpb25NYXApKS5tYXAoZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgIHZhciBpbmRleGVzID0gRElSRUNUSU9OX0lOREVYRVNbZGlyXTtcclxuICAgICAgICBpZiAoIWluZGV4ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaXJlY3Rpb25Sb3RhdGlvbiA9ICh0aHJvdHRsZShkZWdSb3RhdGlvbiwgMTUpICsgZGlyZWN0aW9uU2lnbiAqIERJUkVDVElPTl9ST1RBVElPTlNbZGlyXSArIDcyMCkgJSAxODA7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXCJhcm91bmQtY29udHJvbFwiXTtcclxuICAgICAgICBpZiAoYWJsZU5hbWUpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKFwiZGlyZWN0aW9uXCIsIGFibGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXguYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoY2xhc3NOYW1lcyksIGZhbHNlKSksIFwiZGF0YS1yb3RhdGlvblwiOiBkaXJlY3Rpb25Sb3RhdGlvbiwgXCJkYXRhLWRpcmVjdGlvblwiOiBkaXIsIGtleTogXCJkaXJlY3Rpb24tYXJvdW5kLVwiLmNvbmNhdChkaXIpLCBzdHlsZTogZ2V0Q29udHJvbFRyYW5zZm9ybS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW3JvdGF0aW9uUmFkLCB6b29tXSwgX19yZWFkKGluZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gcmVuZGVyUG9zZXNbaW5kZXhdOyB9KSksIGZhbHNlKSkgfSkpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZFBvc2VzKGJvdW5kcywgdmVydGljYWxQb3NlcywgaG9yaXpvbnRhbFBvc2VzKSB7XHJcbiAgICB2YXIgX2EgPSBib3VuZHMgfHwge30sIF9iID0gX2EucG9zaXRpb24sIHBvc2l0aW9uID0gX2IgPT09IHZvaWQgMCA/IFwiY2xpZW50XCIgOiBfYiwgX2MgPSBfYS5sZWZ0LCBsZWZ0ID0gX2MgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9jLCBfZCA9IF9hLnRvcCwgdG9wID0gX2QgPT09IHZvaWQgMCA/IC1JbmZpbml0eSA6IF9kLCBfZSA9IF9hLnJpZ2h0LCByaWdodCA9IF9lID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9lLCBfZiA9IF9hLmJvdHRvbSwgYm90dG9tID0gX2YgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2Y7XHJcbiAgICB2YXIgbmV4dEJvdW5kcyA9IHtcclxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0aWNhbDogY2hlY2tCb3VuZHMobmV4dEJvdW5kcywgdmVydGljYWxQb3NlcywgdHJ1ZSksXHJcbiAgICAgICAgaG9yaXpvbnRhbDogY2hlY2tCb3VuZHMobmV4dEJvdW5kcywgaG9yaXpvbnRhbFBvc2VzLCBmYWxzZSksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldEJvdW5kcyhtb3ZlYWJsZSwgZXh0ZXJuYWxCb3VuZHMpIHtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCBfYiA9IF9hLmNvbnRhaW5lckNsaWVudFJlY3QsIGNvbnRhaW5lckhlaWdodCA9IF9iLmNsaWVudEhlaWdodCwgY29udGFpbmVyV2lkdGggPSBfYi5jbGllbnRXaWR0aCwgY2xpZW50TGVmdCA9IF9iLmNsaWVudExlZnQsIGNsaWVudFRvcCA9IF9iLmNsaWVudFRvcCwgX2MgPSBfYS5zbmFwT2Zmc2V0LCBzbmFwT2Zmc2V0TGVmdCA9IF9jLmxlZnQsIHNuYXBPZmZzZXRUb3AgPSBfYy50b3AsIHNuYXBPZmZzZXRSaWdodCA9IF9jLnJpZ2h0LCBzbmFwT2Zmc2V0Qm90dG9tID0gX2MuYm90dG9tO1xyXG4gICAgdmFyIGJvdW5kcyA9IGV4dGVybmFsQm91bmRzIHx8IG1vdmVhYmxlLnByb3BzLmJvdW5kcyB8fCB7fTtcclxuICAgIHZhciBwb3NpdGlvbiA9IGJvdW5kcy5wb3NpdGlvbiB8fCBcImNsaWVudFwiO1xyXG4gICAgdmFyIGlzQ1NTID0gcG9zaXRpb24gPT09IFwiY3NzXCI7XHJcbiAgICB2YXIgX2QgPSBib3VuZHMubGVmdCwgbGVmdCA9IF9kID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfZCwgX2UgPSBib3VuZHMudG9wLCB0b3AgPSBfZSA9PT0gdm9pZCAwID8gLUluZmluaXR5IDogX2U7XHJcbiAgICB2YXIgX2YgPSBib3VuZHMucmlnaHQsIHJpZ2h0ID0gX2YgPT09IHZvaWQgMCA/IGlzQ1NTID8gLUluZmluaXR5IDogSW5maW5pdHkgOiBfZiwgX2cgPSBib3VuZHMuYm90dG9tLCBib3R0b20gPSBfZyA9PT0gdm9pZCAwID8gaXNDU1MgPyAtSW5maW5pdHkgOiBJbmZpbml0eSA6IF9nO1xyXG4gICAgaWYgKGlzQ1NTKSB7XHJcbiAgICAgICAgcmlnaHQgPSBjb250YWluZXJXaWR0aCArIHNuYXBPZmZzZXRSaWdodCAtIHNuYXBPZmZzZXRMZWZ0IC0gcmlnaHQ7XHJcbiAgICAgICAgYm90dG9tID0gY29udGFpbmVySGVpZ2h0ICsgc25hcE9mZnNldEJvdHRvbSAtIHNuYXBPZmZzZXRUb3AgLSBib3R0b207XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQgKyBzbmFwT2Zmc2V0TGVmdCAtIGNsaWVudExlZnQsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0ICsgc25hcE9mZnNldExlZnQgLSBjbGllbnRMZWZ0LFxyXG4gICAgICAgIHRvcDogdG9wICsgc25hcE9mZnNldFRvcCAtIGNsaWVudFRvcCxcclxuICAgICAgICBib3R0b206IGJvdHRvbSArIHNuYXBPZmZzZXRUb3AgLSBjbGllbnRUb3AsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQm91bmRLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcclxuICAgIHZhciBfYSA9IGdldEJvdW5kcyhtb3ZlYWJsZSksIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcclxuICAgIHZhciBfYiA9IF9fcmVhZChlbmRQb3MsIDIpLCBlbmRYID0gX2JbMF0sIGVuZFkgPSBfYlsxXTtcclxuICAgIHZhciBfYyA9IF9fcmVhZChtaW51cyhlbmRQb3MsIHN0YXJ0UG9zKSwgMiksIGR4ID0gX2NbMF0sIGR5ID0gX2NbMV07XHJcbiAgICBpZiAoYWJzKGR4KSA8IFRJTllfTlVNKSB7XHJcbiAgICAgICAgZHggPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGFicyhkeSkgPCBUSU5ZX05VTSkge1xyXG4gICAgICAgIGR5ID0gMDtcclxuICAgIH1cclxuICAgIHZhciBpc0JvdHRvbSA9IGR5ID4gMDtcclxuICAgIHZhciBpc1JpZ2h0ID0gZHggPiAwO1xyXG4gICAgdmFyIHZlcnRpY2FsSW5mbyA9IHtcclxuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgcG9zOiAwLFxyXG4gICAgfTtcclxuICAgIHZhciBob3Jpem9udGFsSW5mbyA9IHtcclxuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgcG9zOiAwLFxyXG4gICAgfTtcclxuICAgIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXHJcbiAgICAgICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxJbmZvLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkeCA9PT0gMCkge1xyXG4gICAgICAgIGlmIChpc0JvdHRvbSkge1xyXG4gICAgICAgICAgICBpZiAoYm90dG9tIDwgZW5kWSkge1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEluZm8ub2Zmc2V0ID0gZW5kWSAtIGJvdHRvbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRvcCA+IGVuZFkpIHtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IHRvcDtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSB0b3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkeSA9PT0gMCkge1xyXG4gICAgICAgIGlmIChpc1JpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodCA8IGVuZFgpIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSByaWdodDtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsSW5mby5vZmZzZXQgPSBlbmRYIC0gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID4gZW5kWCkge1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWxJbmZvLnBvcyA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB5IC0geTEgPSBhICogKHggLSB4MSlcclxuICAgICAgICB2YXIgYSA9IGR5IC8gZHg7XHJcbiAgICAgICAgdmFyIGIgPSBlbmRQb3NbMV0gLSBhICogZW5kWDtcclxuICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciBpc0JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzUmlnaHQgJiYgcmlnaHQgPD0gZW5kWCkge1xyXG4gICAgICAgICAgICB5ID0gYSAqIHJpZ2h0ICsgYjtcclxuICAgICAgICAgICAgeCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzUmlnaHQgJiYgZW5kWCA8PSBsZWZ0KSB7XHJcbiAgICAgICAgICAgIHkgPSBhICogbGVmdCArIGI7XHJcbiAgICAgICAgICAgIHggPSBsZWZ0O1xyXG4gICAgICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQm91bmQpIHtcclxuICAgICAgICAgICAgaWYgKHkgPCB0b3AgfHwgeSA+IGJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNCb3VuZCkge1xyXG4gICAgICAgICAgICBpZiAoaXNCb3R0b20gJiYgYm90dG9tIDw9IGVuZFkpIHtcclxuICAgICAgICAgICAgICAgIHkgPSBib3R0b207XHJcbiAgICAgICAgICAgICAgICB4ID0gKHkgLSBiKSAvIGE7XHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNCb3R0b20gJiYgZW5kWSA8PSB0b3ApIHtcclxuICAgICAgICAgICAgICAgIHkgPSB0b3A7XHJcbiAgICAgICAgICAgICAgICB4ID0gKHkgLSBiKSAvIGE7XHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNCb3VuZCkge1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbEluZm8uaXNCb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSB4O1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHg7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLmlzQm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5wb3MgPSB5O1xyXG4gICAgICAgICAgICBob3Jpem9udGFsSW5mby5vZmZzZXQgPSBlbmRZIC0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbEluZm8sXHJcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm8sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQm91bmRzKGJvdW5kcywgcG9zZXMsIGlzVmVydGljYWwpIHtcclxuICAgIC8vIDAgICBbMTAwIC0gMjAwXSAgMzAwXHJcbiAgICB2YXIgc3RhcnRCb3VuZFBvcyA9IGJvdW5kc1tpc1ZlcnRpY2FsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTtcclxuICAgIHZhciBlbmRCb3VuZFBvcyA9IGJvdW5kc1tpc1ZlcnRpY2FsID8gXCJyaWdodFwiIDogXCJib3R0b21cIl07XHJcbiAgICAvLyA0NTBcclxuICAgIHZhciBtaW5Qb3MgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocG9zZXMpLCBmYWxzZSkpO1xyXG4gICAgdmFyIG1heFBvcyA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3NlcyksIGZhbHNlKSk7XHJcbiAgICB2YXIgYm91bmRJbmZvcyA9IFtdO1xyXG4gICAgaWYgKHN0YXJ0Qm91bmRQb3MgKyAxID4gbWluUG9zKSB7XHJcbiAgICAgICAgYm91bmRJbmZvcy5wdXNoKHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcInN0YXJ0XCIsXHJcbiAgICAgICAgICAgIGlzQm91bmQ6IHRydWUsXHJcbiAgICAgICAgICAgIG9mZnNldDogbWluUG9zIC0gc3RhcnRCb3VuZFBvcyxcclxuICAgICAgICAgICAgcG9zOiBzdGFydEJvdW5kUG9zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGVuZEJvdW5kUG9zIC0gMSA8IG1heFBvcykge1xyXG4gICAgICAgIGJvdW5kSW5mb3MucHVzaCh7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJlbmRcIixcclxuICAgICAgICAgICAgaXNCb3VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBtYXhQb3MgLSBlbmRCb3VuZFBvcyxcclxuICAgICAgICAgICAgcG9zOiBlbmRCb3VuZFBvcyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICghYm91bmRJbmZvcy5sZW5ndGgpIHtcclxuICAgICAgICBib3VuZEluZm9zLnB1c2goe1xyXG4gICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICBwb3M6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYm91bmRJbmZvcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhYnMoYi5vZmZzZXQpIC0gYWJzKGEub2Zmc2V0KTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCb3VuZFJvdGF0ZSQxKHJlbGF0aXZlUG9zZXMsIGJvdW5kUmVjdCwgcmFkKSB7XHJcbiAgICB2YXIgbmV4dFBvc2VzID0gcmFkID8gcmVsYXRpdmVQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcm90YXRlKHBvcywgcmFkKTsgfSkgOiByZWxhdGl2ZVBvc2VzO1xyXG4gICAgcmV0dXJuIG5leHRQb3Nlcy5zb21lKGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICByZXR1cm4gKHBvc1swXSA8IGJvdW5kUmVjdC5sZWZ0ICYmIGFicyhwb3NbMF0gLSBib3VuZFJlY3QubGVmdCkgPiAwLjEpXHJcbiAgICAgICAgICAgIHx8IChwb3NbMF0gPiBib3VuZFJlY3QucmlnaHQgJiYgYWJzKHBvc1swXSAtIGJvdW5kUmVjdC5yaWdodCkgPiAwLjEpXHJcbiAgICAgICAgICAgIHx8IChwb3NbMV0gPCBib3VuZFJlY3QudG9wICYmIGFicyhwb3NbMV0gLSBib3VuZFJlY3QudG9wKSA+IDAuMSlcclxuICAgICAgICAgICAgfHwgKHBvc1sxXSA+IGJvdW5kUmVjdC5ib3R0b20gJiYgYWJzKHBvc1sxXSAtIGJvdW5kUmVjdC5ib3R0b20pID4gMC4xKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGJvdW5kUm90YXRlKHZlYywgYm91bmRQb3MsIGluZGV4KSB7XHJcbiAgICB2YXIgciA9IGdldERpc3RTaXplKHZlYyk7XHJcbiAgICB2YXIgbmV4dFBvcyA9IE1hdGguc3FydChyICogciAtIGJvdW5kUG9zICogYm91bmRQb3MpIHx8IDA7XHJcbiAgICByZXR1cm4gW25leHRQb3MsIC1uZXh0UG9zXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGFicyhhIC0gdmVjW2luZGV4ID8gMCA6IDFdKSAtIGFicyhiIC0gdmVjW2luZGV4ID8gMCA6IDFdKTtcclxuICAgIH0pLm1hcChmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFJhZChbMCwgMF0sIGluZGV4ID8gW3BvcywgYm91bmRQb3NdIDogW2JvdW5kUG9zLCBwb3NdKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUm90YXRlQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luLCByb3RhdGlvbikge1xyXG4gICAgaWYgKCFtb3ZlYWJsZS5wcm9wcy5ib3VuZHMpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgcmFkID0gcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgdmFyIF9hID0gZ2V0Qm91bmRzKG1vdmVhYmxlKSwgbGVmdCA9IF9hLmxlZnQsIHRvcCA9IF9hLnRvcCwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tO1xyXG4gICAgdmFyIHJlbGF0aXZlTGVmdCA9IGxlZnQgLSBvcmlnaW5bMF07XHJcbiAgICB2YXIgcmVsYXRpdmVSaWdodCA9IHJpZ2h0IC0gb3JpZ2luWzBdO1xyXG4gICAgdmFyIHJlbGF0aXZlVG9wID0gdG9wIC0gb3JpZ2luWzFdO1xyXG4gICAgdmFyIHJlbGF0aXZlQm90dG9tID0gYm90dG9tIC0gb3JpZ2luWzFdO1xyXG4gICAgdmFyIGJvdW5kUmVjdCA9IHtcclxuICAgICAgICBsZWZ0OiByZWxhdGl2ZUxlZnQsXHJcbiAgICAgICAgdG9wOiByZWxhdGl2ZVRvcCxcclxuICAgICAgICByaWdodDogcmVsYXRpdmVSaWdodCxcclxuICAgICAgICBib3R0b206IHJlbGF0aXZlQm90dG9tLFxyXG4gICAgfTtcclxuICAgIGlmICghaXNCb3VuZFJvdGF0ZSQxKG5leHRQb3NlcywgYm91bmRSZWN0LCAwKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIFtcclxuICAgICAgICBbcmVsYXRpdmVMZWZ0LCAwXSxcclxuICAgICAgICBbcmVsYXRpdmVSaWdodCwgMF0sXHJcbiAgICAgICAgW3JlbGF0aXZlVG9wLCAxXSxcclxuICAgICAgICBbcmVsYXRpdmVCb3R0b20sIDFdLFxyXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGJvdW5kUG9zID0gX2JbMF0sIGluZGV4ID0gX2JbMV07XHJcbiAgICAgICAgbmV4dFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKG5leHRQb3MpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlUmFkMSA9IGdldFJhZChbMCwgMF0sIG5leHRQb3MpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChib3VuZFJvdGF0ZShuZXh0UG9zLCBib3VuZFBvcywgaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZWxhdGl2ZVJhZDIpIHsgcmV0dXJuIHJhZCArIHJlbGF0aXZlUmFkMiAtIHJlbGF0aXZlUmFkMTsgfSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5leHRSYWQpIHsgcmV0dXJuICFpc0JvdW5kUm90YXRlJDEocHJldlBvc2VzLCBib3VuZFJlY3QsIG5leHRSYWQpOyB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobmV4dFJhZCkgeyByZXR1cm4gdGhyb3R0bGUobmV4dFJhZCAqIDE4MCAvIE1hdGguUEksIFRJTllfTlVNKTsgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XG5cbnZhciBWRVJUSUNBTF9OQU1FUyA9IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImNlbnRlclwiXTtcclxudmFyIEhPUklaT05UQUxfTkFNRVMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJtaWRkbGVcIl07XHJcbnZhciBTTkFQX1NLSVBfTkFNRVNfTUFQID0ge1xyXG4gICAgXCJsZWZ0XCI6IFwic3RhcnRcIixcclxuICAgIFwicmlnaHRcIjogXCJlbmRcIixcclxuICAgIFwiY2VudGVyXCI6IFwiY2VudGVyXCIsXHJcbiAgICBcInRvcFwiOiBcInN0YXJ0XCIsXHJcbiAgICBcImJvdHRvbVwiOiBcImVuZFwiLFxyXG4gICAgXCJtaWRkbGVcIjogXCJjZW50ZXJcIixcclxufTtcclxudmFyIFZFUlRJQ0FMX05BTUVTX01BUCA9IHtcclxuICAgIHN0YXJ0OiBcImxlZnRcIixcclxuICAgIGVuZDogXCJyaWdodFwiLFxyXG4gICAgY2VudGVyOiBcImNlbnRlclwiLFxyXG59O1xyXG52YXIgSE9SSVpPTlRBTF9OQU1FU19NQVAgPSB7XHJcbiAgICBzdGFydDogXCJ0b3BcIixcclxuICAgIGVuZDogXCJib3R0b21cIixcclxuICAgIGNlbnRlcjogXCJtaWRkbGVcIixcclxufTtcclxuZnVuY3Rpb24gZ2V0SW5pdGlhbEJvdW5kcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogZmFsc2UsXHJcbiAgICAgICAgdG9wOiBmYWxzZSxcclxuICAgICAgICByaWdodDogZmFsc2UsXHJcbiAgICAgICAgYm90dG9tOiBmYWxzZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgYWJsZU5hbWUpIHtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCBzbmFwcGFibGUgPSBfYS5zbmFwcGFibGUsIGJvdW5kcyA9IF9hLmJvdW5kcywgaW5uZXJCb3VuZHMgPSBfYS5pbm5lckJvdW5kcywgdmVydGljYWxHdWlkZWxpbmVzID0gX2EudmVydGljYWxHdWlkZWxpbmVzLCBob3Jpem9udGFsR3VpZGVsaW5lcyA9IF9hLmhvcml6b250YWxHdWlkZWxpbmVzLCBzbmFwR3JpZFdpZHRoID0gX2Euc25hcEdyaWRXaWR0aCwgc25hcEdyaWRIZWlnaHQgPSBfYS5zbmFwR3JpZEhlaWdodCwgX2IgPSBtb3ZlYWJsZS5zdGF0ZSwgZ3VpZGVsaW5lcyA9IF9iLmd1aWRlbGluZXMsIGVuYWJsZVNuYXAgPSBfYi5lbmFibGVTbmFwO1xyXG4gICAgaWYgKCFzbmFwcGFibGUgfHxcclxuICAgICAgICAhZW5hYmxlU25hcCB8fFxyXG4gICAgICAgIChhYmxlTmFtZSAmJiBzbmFwcGFibGUgIT09IHRydWUgJiYgc25hcHBhYmxlLmluZGV4T2YoYWJsZU5hbWUpIDwgMCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc25hcEdyaWRXaWR0aCB8fFxyXG4gICAgICAgIHNuYXBHcmlkSGVpZ2h0IHx8XHJcbiAgICAgICAgYm91bmRzIHx8XHJcbiAgICAgICAgaW5uZXJCb3VuZHMgfHxcclxuICAgICAgICAoZ3VpZGVsaW5lcyAmJiBndWlkZWxpbmVzLmxlbmd0aCkgfHxcclxuICAgICAgICAodmVydGljYWxHdWlkZWxpbmVzICYmIHZlcnRpY2FsR3VpZGVsaW5lcy5sZW5ndGgpIHx8XHJcbiAgICAgICAgKGhvcml6b250YWxHdWlkZWxpbmVzICYmIGhvcml6b250YWxHdWlkZWxpbmVzLmxlbmd0aCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBnZXRTbmFwRGlyZWN0aW9ucyhzbmFwRGlyZWN0aW9ucykge1xyXG4gICAgaWYgKHNuYXBEaXJlY3Rpb25zID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNuYXBEaXJlY3Rpb25zID09PSB0cnVlIHx8ICFzbmFwRGlyZWN0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IHRydWUsIHJpZ2h0OiB0cnVlLCB0b3A6IHRydWUsIGJvdHRvbTogdHJ1ZSB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNuYXBEaXJlY3Rpb25zO1xyXG59XHJcbmZ1bmN0aW9uIG1hcFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywgc25hcFBvc2VzKSB7XHJcbiAgICB2YXIgbmV4dFNuYXBEaXJlY3Rpb25zID0gZ2V0U25hcERpcmVjdGlvbnMoc25hcERpcmVjdGlvbnMpO1xyXG4gICAgdmFyIG5leHRTbmFwUG9zZXMgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWVfMSBpbiBuZXh0U25hcERpcmVjdGlvbnMpIHtcclxuICAgICAgICBpZiAobmFtZV8xIGluIHNuYXBQb3NlcyAmJiBuZXh0U25hcERpcmVjdGlvbnNbbmFtZV8xXSkge1xyXG4gICAgICAgICAgICBuZXh0U25hcFBvc2VzW25hbWVfMV0gPSBzbmFwUG9zZXNbbmFtZV8xXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dFNuYXBQb3NlcztcclxufVxyXG5mdW5jdGlvbiBzcGxpdFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywgc25hcFBvc2VzKSB7XHJcbiAgICB2YXIgbmV4dFNuYXBQb3NlcyA9IG1hcFNuYXBEaXJlY3Rpb25Qb3NlcyhzbmFwRGlyZWN0aW9ucywgc25hcFBvc2VzKTtcclxuICAgIHZhciBob3Jpem9udGFsTmFtZXMgPSBIT1JJWk9OVEFMX05BTUVTLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSBpbiBuZXh0U25hcFBvc2VzOyB9KTtcclxuICAgIHZhciB2ZXJ0aWNhbE5hbWVzID0gVkVSVElDQUxfTkFNRVMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lIGluIG5leHRTbmFwUG9zZXM7IH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3Jpem9udGFsTmFtZXM6IGhvcml6b250YWxOYW1lcyxcclxuICAgICAgICB2ZXJ0aWNhbE5hbWVzOiB2ZXJ0aWNhbE5hbWVzLFxyXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5leHRTbmFwUG9zZXNbbmFtZV07IH0pLFxyXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbE5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmV4dFNuYXBQb3Nlc1tuYW1lXTsgfSksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRhaW5lclBvcyhyb290TWF0cml4LCBjb250YWluZXJSZWN0LCBuKSB7XHJcbiAgICB2YXIgY2xpZW50UG9zID0gY2FsY3VsYXRlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NvbnRhaW5lclJlY3QuY2xpZW50TGVmdCwgY29udGFpbmVyUmVjdC5jbGllbnRUb3BdLCBuKTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgY29udGFpbmVyUmVjdC5sZWZ0ICsgY2xpZW50UG9zWzBdLFxyXG4gICAgICAgIGNvbnRhaW5lclJlY3QudG9wICsgY2xpZW50UG9zWzFdLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBzb2x2ZUxpbmVDb25zdGFudHMoX2EpIHtcclxuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBvaW50MSA9IF9iWzBdLCBwb2ludDIgPSBfYlsxXTtcclxuICAgIHZhciBkeCA9IHBvaW50MlswXSAtIHBvaW50MVswXTtcclxuICAgIHZhciBkeSA9IHBvaW50MlsxXSAtIHBvaW50MVsxXTtcclxuICAgIGlmIChNYXRoLmFicyhkeCkgPCBUSU5ZX05VTSQxKSB7XHJcbiAgICAgICAgZHggPSAwO1xyXG4gICAgfVxyXG4gICAgaWYgKE1hdGguYWJzKGR5KSA8IFRJTllfTlVNJDEpIHtcclxuICAgICAgICBkeSA9IDA7XHJcbiAgICB9XHJcbiAgICAvLyBiID4gMFxyXG4gICAgLy8gYXggKyBieSArIGMgPSAwXHJcbiAgICB2YXIgYSA9IDA7XHJcbiAgICB2YXIgYiA9IDA7XHJcbiAgICB2YXIgYyA9IDA7XHJcbiAgICBpZiAoIWR4KSB7XHJcbiAgICAgICAgLy8gLXggKyAxID0gMFxyXG4gICAgICAgIGEgPSAtMTtcclxuICAgICAgICBjID0gcG9pbnQxWzBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWR5KSB7XHJcbiAgICAgICAgLy8geSAtIDEgPSAwXHJcbiAgICAgICAgYiA9IDE7XHJcbiAgICAgICAgYyA9IC1wb2ludDFbMV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB5ID0gLWEoeCAtIHgxKSArIHkxXHJcbiAgICAgICAgLy8gYXggKyB5ICsgYSAqIHgxIC0geTEgPSAwXHJcbiAgICAgICAgYSA9IC1keSAvIGR4O1xyXG4gICAgICAgIGIgPSAxO1xyXG4gICAgICAgIGMgPSBhICogcG9pbnQxWzBdIC0gcG9pbnQxWzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFthLCBiLCBjXS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRocm90dGxlKHYsIFRJTllfTlVNJDEpOyB9KTtcclxufVxuXG52YXIgTkFNRV9zbmFwUm90YXRpb25UaHJlc2hvbGQgPSBcInNuYXBSb3RhdGlvblRocmVzaG9sZFwiO1xyXG52YXIgTkFNRV9zbmFwUm90YXRpb25EZWdyZWVzID0gXCJzbmFwUm90YXRpb25EZWdyZWVzXCI7XHJcbnZhciBOQU1FX3NuYXBIb3Jpem9udGFsVGhyZXNob2xkID0gXCJzbmFwSG9yaXpvbnRhbFRocmVzaG9sZFwiO1xyXG52YXIgTkFNRV9zbmFwVmVydGljYWxUaHJlc2hvbGQgPSBcInNuYXBWZXJ0aWNhbFRocmVzaG9sZFwiO1xuXG5mdW5jdGlvbiBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCBwb3Nlc1gsIHBvc2VzWSwgZGlyWHMsIGRpcllzLCBjdXN0b21TbmFwVmVydGljYWxUaHJlc2hvbGQsIGN1c3RvbVNuYXBIb3Jpem9udGFsVGhyZXNob2xkKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoZGlyWHMgPT09IHZvaWQgMCkgeyBkaXJYcyA9IFtdOyB9XHJcbiAgICBpZiAoZGlyWXMgPT09IHZvaWQgMCkgeyBkaXJZcyA9IFtdOyB9XHJcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgIHZhciBzbmFwVGhyZXNob2xkTXVsdGlwbGVzID0gKChfYSA9IG1vdmVhYmxlLnN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubXVsdGlwbGVzKSB8fCBbMSwgMV07XHJcbiAgICB2YXIgc25hcEhvcml6b250YWxUaHJlc2hvbGQgPSBzZWxlY3RWYWx1ZShjdXN0b21TbmFwSG9yaXpvbnRhbFRocmVzaG9sZCwgcHJvcHNbTkFNRV9zbmFwSG9yaXpvbnRhbFRocmVzaG9sZF0sIDUpO1xyXG4gICAgdmFyIHNuYXBWZXJ0aWNhbFRocmVzaG9sZCA9IHNlbGVjdFZhbHVlKGN1c3RvbVNuYXBWZXJ0aWNhbFRocmVzaG9sZCwgcHJvcHNbTkFNRV9zbmFwVmVydGljYWxUaHJlc2hvbGRdLCA1KTtcclxuICAgIHJldHVybiBjaGVja1NuYXBQb3Nlcyhtb3ZlYWJsZS5zdGF0ZS5ndWlkZWxpbmVzLCBwb3Nlc1gsIHBvc2VzWSwgZGlyWHMsIGRpcllzLCBzbmFwSG9yaXpvbnRhbFRocmVzaG9sZCwgc25hcFZlcnRpY2FsVGhyZXNob2xkLCBzbmFwVGhyZXNob2xkTXVsdGlwbGVzKTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBQb3NlcyhndWlkZWxpbmVzLCBwb3Nlc1gsIHBvc2VzWSwgZGlyWHMsIGRpcllzLCBzbmFwSG9yaXpvbnRhbFRocmVzaG9sZCwgc25hcFZlcnRpY2FsVGhyZXNob2xkLCBtdWx0aXBsZXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVydGljYWw6IGNoZWNrU25hcChndWlkZWxpbmVzLCBcInZlcnRpY2FsXCIsIHBvc2VzWCwgc25hcFZlcnRpY2FsVGhyZXNob2xkICogbXVsdGlwbGVzWzBdLCBkaXJYcyksXHJcbiAgICAgICAgaG9yaXpvbnRhbDogY2hlY2tTbmFwKGd1aWRlbGluZXMsIFwiaG9yaXpvbnRhbFwiLCBwb3Nlc1ksIHNuYXBIb3Jpem9udGFsVGhyZXNob2xkICogbXVsdGlwbGVzWzFdLCBkaXJZcyksXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU25hcEtlZXBSYXRpbyhtb3ZlYWJsZSwgc3RhcnRQb3MsIGVuZFBvcykge1xyXG4gICAgdmFyIF9hID0gX19yZWFkKGVuZFBvcywgMiksIGVuZFggPSBfYVswXSwgZW5kWSA9IF9hWzFdO1xyXG4gICAgdmFyIF9iID0gX19yZWFkKHN0YXJ0UG9zLCAyKSwgc3RhcnRYID0gX2JbMF0sIHN0YXJ0WSA9IF9iWzFdO1xyXG4gICAgdmFyIF9jID0gX19yZWFkKG1pbnVzKGVuZFBvcywgc3RhcnRQb3MpLCAyKSwgZHggPSBfY1swXSwgZHkgPSBfY1sxXTtcclxuICAgIHZhciBpc0JvdHRvbSA9IGR5ID4gMDtcclxuICAgIHZhciBpc1JpZ2h0ID0gZHggPiAwO1xyXG4gICAgZHggPSBnZXRUaW55RGlzdChkeCk7XHJcbiAgICBkeSA9IGdldFRpbnlEaXN0KGR5KTtcclxuICAgIHZhciB2ZXJ0aWNhbEluZm8gPSB7XHJcbiAgICAgICAgaXNTbmFwOiBmYWxzZSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgcG9zOiAwLFxyXG4gICAgfTtcclxuICAgIHZhciBob3Jpem9udGFsSW5mbyA9IHtcclxuICAgICAgICBpc1NuYXA6IGZhbHNlLFxyXG4gICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICBwb3M6IDAsXHJcbiAgICB9O1xyXG4gICAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVydGljYWw6IHZlcnRpY2FsSW5mbyxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEluZm8sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHZhciBfZCA9IGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIGR4ID8gW2VuZFhdIDogW10sIGR5ID8gW2VuZFldIDogW10sIFtdLCBbXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpLCB2ZXJ0aWNhbFNuYXBJbmZvID0gX2QudmVydGljYWwsIGhvcml6b250YWxTbmFwSW5mbyA9IF9kLmhvcml6b250YWw7XHJcbiAgICB2ZXJ0aWNhbFNuYXBJbmZvLnBvc0luZm9zLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgcG9zID0gX2EucG9zO1xyXG4gICAgICAgIHJldHVybiBpc1JpZ2h0ID8gcG9zID49IHN0YXJ0WCA6IHBvcyA8PSBzdGFydFg7XHJcbiAgICB9KTtcclxuICAgIGhvcml6b250YWxTbmFwSW5mby5wb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcclxuICAgICAgICByZXR1cm4gaXNCb3R0b20gPyBwb3MgPj0gc3RhcnRZIDogcG9zIDw9IHN0YXJ0WTtcclxuICAgIH0pO1xyXG4gICAgdmVydGljYWxTbmFwSW5mby5pc1NuYXAgPSB2ZXJ0aWNhbFNuYXBJbmZvLnBvc0luZm9zLmxlbmd0aCA+IDA7XHJcbiAgICBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwID0gaG9yaXpvbnRhbFNuYXBJbmZvLnBvc0luZm9zLmxlbmd0aCA+IDA7XHJcbiAgICB2YXIgX2UgPSBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8odmVydGljYWxTbmFwSW5mbyksIGlzVmVydGljYWxTbmFwID0gX2UuaXNTbmFwLCB2ZXJ0aWNhbEd1aWRlbGluZSA9IF9lLmd1aWRlbGluZTtcclxuICAgIHZhciBfZiA9IGdldE5lYXJlc3RTbmFwR3VpZGVsaW5lSW5mbyhob3Jpem9udGFsU25hcEluZm8pLCBpc0hvcml6b250YWxTbmFwID0gX2YuaXNTbmFwLCBob3Jpem9udGFsR3VpZGVsaW5lID0gX2YuZ3VpZGVsaW5lO1xyXG4gICAgdmFyIGhvcml6b250YWxQb3MgPSBpc0hvcml6b250YWxTbmFwID8gaG9yaXpvbnRhbEd1aWRlbGluZS5wb3NbMV0gOiAwO1xyXG4gICAgdmFyIHZlcnRpY2FsUG9zID0gaXNWZXJ0aWNhbFNuYXAgPyB2ZXJ0aWNhbEd1aWRlbGluZS5wb3NbMF0gOiAwO1xyXG4gICAgaWYgKGR4ID09PSAwKSB7XHJcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbFNuYXApIHtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbEluZm8uaXNTbmFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbEluZm8ucG9zID0gaG9yaXpvbnRhbEd1aWRlbGluZS5wb3NbMV07XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSBob3Jpem9udGFsSW5mby5wb3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZHkgPT09IDApIHtcclxuICAgICAgICBpZiAoaXNWZXJ0aWNhbFNuYXApIHtcclxuICAgICAgICAgICAgdmVydGljYWxJbmZvLmlzU25hcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSB2ZXJ0aWNhbFBvcztcclxuICAgICAgICAgICAgdmVydGljYWxJbmZvLm9mZnNldCA9IGVuZFggLSB2ZXJ0aWNhbFBvcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB5IC0geTEgPSBhICogKHggLSB4MSlcclxuICAgICAgICB2YXIgYSA9IGR5IC8gZHg7XHJcbiAgICAgICAgdmFyIGIgPSBlbmRQb3NbMV0gLSBhICogZW5kWDtcclxuICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciBpc1NuYXAgPSBmYWxzZTtcclxuICAgICAgICBpZiAoaXNWZXJ0aWNhbFNuYXApIHtcclxuICAgICAgICAgICAgeCA9IHZlcnRpY2FsUG9zO1xyXG4gICAgICAgICAgICB5ID0gYSAqIHggKyBiO1xyXG4gICAgICAgICAgICBpc1NuYXAgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0hvcml6b250YWxTbmFwKSB7XHJcbiAgICAgICAgICAgIHkgPSBob3Jpem9udGFsUG9zO1xyXG4gICAgICAgICAgICB4ID0gKHkgLSBiKSAvIGE7XHJcbiAgICAgICAgICAgIGlzU25hcCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NuYXApIHtcclxuICAgICAgICAgICAgdmVydGljYWxJbmZvLmlzU25hcCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsSW5mby5wb3MgPSB4O1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbEluZm8ub2Zmc2V0ID0gZW5kWCAtIHg7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLmlzU25hcCA9IHRydWU7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLnBvcyA9IHk7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxJbmZvLm9mZnNldCA9IGVuZFkgLSB5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVydGljYWw6IHZlcnRpY2FsSW5mbyxcclxuICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsSW5mbyxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3RyaW5nRGlyZWN0aW9uKGRpcikge1xyXG4gICAgdmFyIHN0cmluZ0RpcmVjdGlvbiA9IFwiXCI7XHJcbiAgICBpZiAoZGlyID09PSAtMSB8fCBkaXIgPT09IFwidG9wXCIgfHwgZGlyID09PSBcImxlZnRcIikge1xyXG4gICAgICAgIHN0cmluZ0RpcmVjdGlvbiA9IFwic3RhcnRcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRpciA9PT0gMCB8fCBkaXIgPT09IFwiY2VudGVyXCIgfHwgZGlyID09PSBcIm1pZGRsZVwiKSB7XHJcbiAgICAgICAgc3RyaW5nRGlyZWN0aW9uID0gXCJjZW50ZXJcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRpciA9PT0gMSB8fCBkaXIgPT09IFwicmlnaHRcIiB8fCBkaXIgPT09IFwiYm90dG9tXCIpIHtcclxuICAgICAgICBzdHJpbmdEaXJlY3Rpb24gPSBcImVuZFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cmluZ0RpcmVjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBzKG1vdmVhYmxlLCByZWN0LCBjdXN0b21TbmFwVmVydGljYWxUaHJlc2hvbGQsIGN1c3RvbVNuYXBIb3Jpem9udGFsVGhyZXNob2xkKSB7XHJcbiAgICB2YXIgcG9zZXMgPSBzcGxpdFNuYXBEaXJlY3Rpb25Qb3Nlcyhtb3ZlYWJsZS5wcm9wcy5zbmFwRGlyZWN0aW9ucywgcmVjdCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gY2hlY2tNb3ZlYWJsZVNuYXBQb3Nlcyhtb3ZlYWJsZSwgcG9zZXMudmVydGljYWwsIHBvc2VzLmhvcml6b250YWwsIHBvc2VzLnZlcnRpY2FsTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnZXRTdHJpbmdEaXJlY3Rpb24obmFtZSk7IH0pLCBwb3Nlcy5ob3Jpem9udGFsTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnZXRTdHJpbmdEaXJlY3Rpb24obmFtZSk7IH0pLCBjdXN0b21TbmFwVmVydGljYWxUaHJlc2hvbGQsIGN1c3RvbVNuYXBIb3Jpem9udGFsVGhyZXNob2xkKTtcclxuICAgIHZhciBob3Jpem9udGFsRGlyZWN0aW9uID0gZ2V0U3RyaW5nRGlyZWN0aW9uKHBvc2VzLmhvcml6b250YWxOYW1lc1tyZXN1bHQuaG9yaXpvbnRhbC5pbmRleF0pO1xyXG4gICAgdmFyIHZlcnRpY2FsRGlyZWN0aW9uID0gZ2V0U3RyaW5nRGlyZWN0aW9uKHBvc2VzLnZlcnRpY2FsTmFtZXNbcmVzdWx0LnZlcnRpY2FsLmluZGV4XSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnRpY2FsOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0LnZlcnRpY2FsKSwgeyBkaXJlY3Rpb246IHZlcnRpY2FsRGlyZWN0aW9uIH0pLFxyXG4gICAgICAgIGhvcml6b250YWw6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQuaG9yaXpvbnRhbCksIHsgZGlyZWN0aW9uOiBob3Jpem9udGFsRGlyZWN0aW9uIH0pLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXROZWFyZXN0U25hcEd1aWRlbGluZUluZm8oc25hcEluZm8pIHtcclxuICAgIHZhciBpc1NuYXAgPSBzbmFwSW5mby5pc1NuYXA7XHJcbiAgICBpZiAoIWlzU25hcCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgZGlzdDogLTEsXHJcbiAgICAgICAgICAgIHBvczogMCxcclxuICAgICAgICAgICAgZ3VpZGVsaW5lOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgcG9zSW5mbyA9IHNuYXBJbmZvLnBvc0luZm9zWzBdO1xyXG4gICAgdmFyIGd1aWRlbGluZUluZm8gPSBwb3NJbmZvLmd1aWRlbGluZUluZm9zWzBdO1xyXG4gICAgdmFyIG9mZnNldCA9IGd1aWRlbGluZUluZm8ub2Zmc2V0O1xyXG4gICAgdmFyIGRpc3QgPSBndWlkZWxpbmVJbmZvLmRpc3Q7XHJcbiAgICB2YXIgZ3VpZGVsaW5lID0gZ3VpZGVsaW5lSW5mby5ndWlkZWxpbmU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzU25hcDogaXNTbmFwLFxyXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG4gICAgICAgIGRpc3Q6IGRpc3QsXHJcbiAgICAgICAgcG9zOiBwb3NJbmZvLnBvcyxcclxuICAgICAgICBndWlkZWxpbmU6IGd1aWRlbGluZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwKGd1aWRlbGluZXMsIHRhcmdldFR5cGUsIHRhcmdldFBvc2VzLCBzbmFwVGhyZXNob2xkLCBkaXJzKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgaWYgKGRpcnMgPT09IHZvaWQgMCkgeyBkaXJzID0gW107IH1cclxuICAgIGlmICghZ3VpZGVsaW5lcyB8fCAhZ3VpZGVsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc1NuYXA6IGZhbHNlLFxyXG4gICAgICAgICAgICBpbmRleDogLTEsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcclxuICAgICAgICAgICAgcG9zSW5mb3M6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IHRhcmdldFR5cGUgPT09IFwidmVydGljYWxcIjtcclxuICAgIHZhciBwb3NUeXBlID0gaXNWZXJ0aWNhbCA/IDAgOiAxO1xyXG4gICAgdmFyIHNuYXBQb3NJbmZvcyA9IHRhcmdldFBvc2VzLm1hcChmdW5jdGlvbiAodGFyZ2V0UG9zLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJzW2luZGV4XSB8fCBcIlwiO1xyXG4gICAgICAgIHZhciBndWlkZWxpbmVJbmZvcyA9IGd1aWRlbGluZXMubWFwKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IGd1aWRlbGluZS5wb3M7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0YXJnZXRQb3MgLSBwb3NbcG9zVHlwZV07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgICAgICAgICAgIGRpc3Q6IGFicyhvZmZzZXQpLFxyXG4gICAgICAgICAgICAgICAgZ3VpZGVsaW5lOiBndWlkZWxpbmUsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmUsIGRpc3QgPSBfYS5kaXN0O1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGd1aWRlbGluZS50eXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gdGFyZ2V0VHlwZVxyXG4gICAgICAgICAgICAgICAgfHwgZGlzdCA+IHNuYXBUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmRpc3QgLSBiLmRpc3Q7IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgIGd1aWRlbGluZUluZm9zOiBndWlkZWxpbmVJbmZvcyxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgfTtcclxuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoc25hcFBvc0luZm8pIHtcclxuICAgICAgICByZXR1cm4gc25hcFBvc0luZm8uZ3VpZGVsaW5lSW5mb3MubGVuZ3RoID4gMDtcclxuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS5ndWlkZWxpbmVJbmZvc1swXS5kaXN0IC0gYi5ndWlkZWxpbmVJbmZvc1swXS5kaXN0O1xyXG4gICAgfSk7XHJcbiAgICB2YXIgaXNTbmFwID0gc25hcFBvc0luZm9zLmxlbmd0aCA+IDA7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzU25hcDogaXNTbmFwLFxyXG4gICAgICAgIGluZGV4OiBpc1NuYXAgPyBzbmFwUG9zSW5mb3NbMF0uaW5kZXggOiAtMSxcclxuICAgICAgICBkaXJlY3Rpb246IChfYiA9IChfYSA9IHNuYXBQb3NJbmZvc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpcmVjdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIixcclxuICAgICAgICBwb3NJbmZvczogc25hcFBvc0luZm9zLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRTbmFwSW5mb3NCeURpcmVjdGlvbihtb3ZlYWJsZSwgXHJcbi8vIHBvczEgcG9zMiBwb3MzIHBvczRcclxucG9zZXMsIHNuYXBEaXJlY3Rpb24sIGN1c3RvbVNuYXBWZXJ0aWNhbFRocmVzaG9sZCwgY3VzdG9tU25hcEhvcml6b250YWxUaHJlc2hvbGQpIHtcclxuICAgIHZhciBkaXJzID0gW107XHJcbiAgICBpZiAoc25hcERpcmVjdGlvblswXSAmJiBzbmFwRGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgZGlycyA9IFtcclxuICAgICAgICAgICAgc25hcERpcmVjdGlvbixcclxuICAgICAgICAgICAgWy1zbmFwRGlyZWN0aW9uWzBdLCBzbmFwRGlyZWN0aW9uWzFdXSxcclxuICAgICAgICAgICAgW3NuYXBEaXJlY3Rpb25bMF0sIC1zbmFwRGlyZWN0aW9uWzFdXSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIXNuYXBEaXJlY3Rpb25bMF0gJiYgIXNuYXBEaXJlY3Rpb25bMV0pIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIFstMSwgLTFdLFxyXG4gICAgICAgICAgICBbMSwgLTFdLFxyXG4gICAgICAgICAgICBbMSwgMV0sXHJcbiAgICAgICAgICAgIFstMSwgMV0sXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXIsIGksIGFycikge1xyXG4gICAgICAgICAgICB2YXIgbmV4dERpciA9IChhcnJbaSArIDFdIHx8IGFyclswXSk7XHJcbiAgICAgICAgICAgIGRpcnMucHVzaChkaXIpO1xyXG4gICAgICAgICAgICBkaXJzLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgKGRpclswXSArIG5leHREaXJbMF0pIC8gMixcclxuICAgICAgICAgICAgICAgIChkaXJbMV0gKyBuZXh0RGlyWzFdKSAvIDIsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICBkaXJzLnB1c2goWy0xLCAtMV0sIFstMSwgMV0sIFsxLCAtMV0sIFsxLCAxXSwgc25hcERpcmVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkaXJzLnB1c2guYXBwbHkoZGlycywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldFBvc2VzQnlEaXJlY3Rpb24oW1xyXG4gICAgICAgICAgICAgICAgWy0xLCAtMV0sXHJcbiAgICAgICAgICAgICAgICBbMSwgLTFdLFxyXG4gICAgICAgICAgICAgICAgWy0xLCAtMV0sXHJcbiAgICAgICAgICAgICAgICBbMSwgMV0sXHJcbiAgICAgICAgICAgIF0sIHNuYXBEaXJlY3Rpb24pKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgaWYgKGRpcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZGlycy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAoZGlyc1swXVswXSArIGRpcnNbMV1bMF0pIC8gMixcclxuICAgICAgICAgICAgICAgICAgICAoZGlyc1swXVsxXSArIGRpcnNbMV1bMV0pIC8gMixcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIG5leHRQb3NlcyA9IGRpcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBkaXIpOyB9KTtcclxuICAgIHZhciB4cyA9IG5leHRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzBdOyB9KTtcclxuICAgIHZhciB5cyA9IG5leHRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzFdOyB9KTtcclxuICAgIHZhciByZXN1bHQgPSBjaGVja01vdmVhYmxlU25hcFBvc2VzKG1vdmVhYmxlLCB4cywgeXMsIGRpcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGdldFN0cmluZ0RpcmVjdGlvbihkaXJbMF0pOyB9KSwgZGlycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZ2V0U3RyaW5nRGlyZWN0aW9uKGRpclsxXSk7IH0pLCBjdXN0b21TbmFwVmVydGljYWxUaHJlc2hvbGQsIGN1c3RvbVNuYXBIb3Jpem9udGFsVGhyZXNob2xkKTtcclxuICAgIHZhciB2ZXJ0aWNhbERpcmVjdGlvbiA9IGdldFN0cmluZ0RpcmVjdGlvbihkaXJzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBkaXJbMF07IH0pW3Jlc3VsdC52ZXJ0aWNhbC5pbmRleF0pO1xyXG4gICAgdmFyIGhvcml6b250YWxEaXJlY3Rpb24gPSBnZXRTdHJpbmdEaXJlY3Rpb24oZGlycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyWzFdOyB9KVtyZXN1bHQuaG9yaXpvbnRhbC5pbmRleF0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0aWNhbDogX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdC52ZXJ0aWNhbCksIHsgZGlyZWN0aW9uOiB2ZXJ0aWNhbERpcmVjdGlvbiB9KSxcclxuICAgICAgICBob3Jpem9udGFsOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzdWx0Lmhvcml6b250YWwpLCB7IGRpcmVjdGlvbjogaG9yaXpvbnRhbERpcmVjdGlvbiB9KSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwQm91bmRQcmlvcml0eShhLCBiKSB7XHJcbiAgICB2YXIgYURpc3QgPSBhYnMoYS5vZmZzZXQpO1xyXG4gICAgdmFyIGJEaXN0ID0gYWJzKGIub2Zmc2V0KTtcclxuICAgIGlmIChhLmlzQm91bmQgJiYgYi5pc0JvdW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIGJEaXN0IC0gYURpc3Q7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhLmlzQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiLmlzQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEuaXNTbmFwICYmIGIuaXNTbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGJEaXN0IC0gYURpc3Q7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhLmlzU25hcCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGIuaXNTbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhRGlzdCA8IFRJTllfTlVNKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiRGlzdCA8IFRJTllfTlVNKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFEaXN0IC0gYkRpc3Q7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgaW5kZXgpIHtcclxuICAgIHJldHVybiBvZmZzZXRzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBhU2lnbiA9IGEuc2lnbltpbmRleF07XHJcbiAgICAgICAgdmFyIGJTaWduID0gYi5zaWduW2luZGV4XTtcclxuICAgICAgICB2YXIgYU9mZnNldCA9IGEub2Zmc2V0W2luZGV4XTtcclxuICAgICAgICB2YXIgYk9mZnNldCA9IGIub2Zmc2V0W2luZGV4XTtcclxuICAgICAgICAvLyAtMSBUaGUgcG9zaXRpb25zIG9mIGEgYW5kIGIgZG8gbm90IGNoYW5nZS5cclxuICAgICAgICAvLyAxIFRoZSBwb3NpdGlvbnMgb2YgYSBhbmQgYiBhcmUgcmV2ZXJzZWQuXHJcbiAgICAgICAgaWYgKCFhU2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWJTaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrU25hcEJvdW5kUHJpb3JpdHkoeyBpc0JvdW5kOiBhLmlzQm91bmQsIGlzU25hcDogYS5pc1NuYXAsIG9mZnNldDogYU9mZnNldCB9LCB7IGlzQm91bmQ6IGIuaXNCb3VuZCwgaXNTbmFwOiBiLmlzU25hcCwgb2Zmc2V0OiBiT2Zmc2V0IH0pO1xyXG4gICAgfSlbMF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2hlY2tTbmFwRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGZpeGVkRGlyZWN0aW9uLCBrZWVwUmF0aW8pIHtcclxuICAgIHZhciBkaXJlY3Rpb25zID0gW107XHJcbiAgICAvLyBjb25zdCBmaXhlZERpcmVjdGlvbiA9IFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXTtcclxuICAgIGlmIChrZWVwUmF0aW8pIHtcclxuICAgICAgICBpZiAoYWJzKGZpeGVkRGlyZWN0aW9uWzBdKSAhPT0gMSB8fCBhYnMoZml4ZWREaXJlY3Rpb25bMV0pICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIFstMSwgLTFdXSwgW2ZpeGVkRGlyZWN0aW9uLCBbLTEsIDFdXSwgW2ZpeGVkRGlyZWN0aW9uLCBbMSwgLTFdXSwgW2ZpeGVkRGlyZWN0aW9uLCBbMSwgMV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChbZml4ZWREaXJlY3Rpb24sIFtkaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dXSwgW2ZpeGVkRGlyZWN0aW9uLCBbLWRpcmVjdGlvblswXSwgZGlyZWN0aW9uWzFdXV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXJlY3Rpb25zLnB1c2goW2ZpeGVkRGlyZWN0aW9uLCBkaXJlY3Rpb25dKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICgoZGlyZWN0aW9uWzBdICYmIGRpcmVjdGlvblsxXSkgfHwgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkpIHtcclxuICAgICAgICAgICAgdmFyIGVuZERpcmVjdGlvbl8xID0gZGlyZWN0aW9uWzBdID8gZGlyZWN0aW9uIDogWzEsIDFdO1xyXG4gICAgICAgICAgICBbMSwgLTFdLmZvckVhY2goZnVuY3Rpb24gKHNpZ25YKSB7XHJcbiAgICAgICAgICAgICAgICBbMSwgLTFdLmZvckVhY2goZnVuY3Rpb24gKHNpZ25ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHREaXJlY3Rpb24gPSBbc2lnblggKiBlbmREaXJlY3Rpb25fMVswXSwgc2lnblkgKiBlbmREaXJlY3Rpb25fMVsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkRGlyZWN0aW9uWzBdID09PSBuZXh0RGlyZWN0aW9uWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGZpeGVkRGlyZWN0aW9uWzFdID09PSBuZXh0RGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9ucy5wdXNoKFtmaXhlZERpcmVjdGlvbiwgbmV4dERpcmVjdGlvbl0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb25bMF0pIHtcclxuICAgICAgICAgICAgdmFyIHNpZ25zID0gYWJzKGZpeGVkRGlyZWN0aW9uWzBdKSA9PT0gMSA/IFsxXSA6IFsxLCAtMV07XHJcbiAgICAgICAgICAgIHNpZ25zLmZvckVhY2goZnVuY3Rpb24gKHNpZ24pIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgW2ZpeGVkRGlyZWN0aW9uWzBdLCAtMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgW3NpZ24gKiBkaXJlY3Rpb25bMF0sIC0xXSxcclxuICAgICAgICAgICAgICAgIF0sIFtcclxuICAgICAgICAgICAgICAgICAgICBbZml4ZWREaXJlY3Rpb25bMF0sIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtzaWduICogZGlyZWN0aW9uWzBdLCAwXSxcclxuICAgICAgICAgICAgICAgIF0sIFtcclxuICAgICAgICAgICAgICAgICAgICBbZml4ZWREaXJlY3Rpb25bMF0sIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtzaWduICogZGlyZWN0aW9uWzBdLCAxXSxcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWducyA9IGFicyhmaXhlZERpcmVjdGlvblsxXSkgPT09IDEgPyBbMV0gOiBbMSwgLTFdO1xyXG4gICAgICAgICAgICBzaWducy5mb3JFYWNoKGZ1bmN0aW9uIChzaWduKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgIFstMSwgZml4ZWREaXJlY3Rpb25bMV1dLFxyXG4gICAgICAgICAgICAgICAgICAgIFstMSwgc2lnbiAqIGRpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICBdLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzAsIGZpeGVkRGlyZWN0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICBbMCwgc2lnbiAqIGRpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICBdLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgWzEsIGZpeGVkRGlyZWN0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICBbMSwgc2lnbiAqIGRpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpcmVjdGlvbnM7XHJcbn1cblxuZnVuY3Rpb24gaXNTdGFydExpbmUoZG90LCBsaW5lKSB7XHJcbiAgICAvLyBsICAgIG8gICAgID0+IHRydWVcclxuICAgIC8vIG8gICAgbCAgICA9PiBmYWxzZVxyXG4gICAgdmFyIGN4ID0gYXZlcmFnZShbbGluZVswXVswXSwgbGluZVsxXVswXV0pO1xyXG4gICAgdmFyIGN5ID0gYXZlcmFnZShbbGluZVswXVsxXSwgbGluZVsxXVsxXV0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2ZXJ0aWNhbDogY3ggPD0gZG90WzBdLFxyXG4gICAgICAgIGhvcml6b250YWw6IGN5IDw9IGRvdFsxXSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaGl0VGVzdExpbmUoZG90LCBfYSkge1xyXG4gICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgcG9zMSA9IF9iWzBdLCBwb3MyID0gX2JbMV07XHJcbiAgICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcclxuICAgIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xyXG4gICAgaWYgKGFicyhkeCkgPCBUSU5ZX05VTSkge1xyXG4gICAgICAgIGR4ID0gMDtcclxuICAgIH1cclxuICAgIGlmIChhYnMoZHkpIDwgVElOWV9OVU0pIHtcclxuICAgICAgICBkeSA9IDA7XHJcbiAgICB9XHJcbiAgICB2YXIgdGVzdDE7XHJcbiAgICB2YXIgdGVzdDI7XHJcbiAgICBpZiAoIWR4KSB7XHJcbiAgICAgICAgdGVzdDEgPSBwb3MxWzBdO1xyXG4gICAgICAgIHRlc3QyID0gZG90WzBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWR5KSB7XHJcbiAgICAgICAgdGVzdDEgPSBwb3MxWzFdO1xyXG4gICAgICAgIHRlc3QyID0gZG90WzFdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGEgPSBkeSAvIGR4O1xyXG4gICAgICAgIC8vIHkgPSBhICogKHggLSBwb3MxKSArIHBvczFcclxuICAgICAgICB0ZXN0MSA9IGEgKiAoZG90WzBdIC0gcG9zMVswXSkgKyBwb3MxWzFdO1xyXG4gICAgICAgIHRlc3QyID0gZG90WzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRlc3QxIC0gdGVzdDI7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lU3RhcnRMaW5lKGRvdHMsIGxpbmUsIGNlbnRlclNpZ24sIGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IFRJTllfTlVNOyB9XHJcbiAgICByZXR1cm4gZG90cy5ldmVyeShmdW5jdGlvbiAoZG90KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gaGl0VGVzdExpbmUoZG90LCBsaW5lKTtcclxuICAgICAgICB2YXIgc2lnbiA9IHZhbHVlIDw9IDA7XHJcbiAgICAgICAgcmV0dXJuIHNpZ24gPT09IGNlbnRlclNpZ24gfHwgYWJzKHZhbHVlKSA8PSBlcnJvcjtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrSW5uZXJCb3VuZERvdChwb3MsIHN0YXJ0LCBlbmQsIGlzU3RhcnQsIHRocmVzaG9sZCkge1xyXG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHRocmVzaG9sZCA9IDA7IH1cclxuICAgIGlmICgoaXNTdGFydCAmJiBzdGFydCAtIHRocmVzaG9sZCA8PSBwb3MpXHJcbiAgICAgICAgfHwgKCFpc1N0YXJ0ICYmIHBvcyA8PSBlbmQgKyB0aHJlc2hvbGQpKSB7XHJcbiAgICAgICAgLy8gZmFsc2UgNDAyIDU2NSA2MDIgPT4gMzcgKFswLCAzN10pXHJcbiAgICAgICAgLy8gdHJ1ZSA0MDAgNTI0Ljk3MTI2MDM1NDAwMzYgNjAwID0+IDEyNCAoWzEyNCwgMF0pXHJcbiAgICAgICAgLy8gdHJ1ZSA0MDAgNDEwIDYwMCA9PiAxMCAoWzEwLCAwXSlcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiB0cnVlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGlzU3RhcnQgPyBzdGFydCAtIHBvcyA6IGVuZCAtIHBvcyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrSW5uZXJCb3VuZChtb3ZlYWJsZSwgX2EpIHtcclxuICAgIHZhciBsaW5lID0gX2EubGluZSwgY2VudGVyU2lnbiA9IF9hLmNlbnRlclNpZ24sIHZlcnRpY2FsU2lnbiA9IF9hLnZlcnRpY2FsU2lnbiwgaG9yaXpvbnRhbFNpZ24gPSBfYS5ob3Jpem9udGFsU2lnbiwgbGluZUNvbnN0YW50cyA9IF9hLmxpbmVDb25zdGFudHM7XHJcbiAgICB2YXIgYm91bmRzID0gbW92ZWFibGUucHJvcHMuaW5uZXJCb3VuZHM7XHJcbiAgICBpZiAoIWJvdW5kcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzQWxsQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbEJvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGxlZnQgPSBib3VuZHMubGVmdCwgdG9wID0gYm91bmRzLnRvcCwgd2lkdGggPSBib3VuZHMud2lkdGgsIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XHJcbiAgICB2YXIgbGVmdExpbmUgPSBbW2xlZnQsIHRvcF0sIFtsZWZ0LCB0b3AgKyBoZWlnaHRdXTtcclxuICAgIHZhciB0b3BMaW5lID0gW1tsZWZ0LCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3BdXTtcclxuICAgIHZhciByaWdodExpbmUgPSBbW2xlZnQgKyB3aWR0aCwgdG9wXSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XHJcbiAgICB2YXIgYm90dG9tTGluZSA9IFtbbGVmdCwgdG9wICsgaGVpZ2h0XSwgW2xlZnQgKyB3aWR0aCwgdG9wICsgaGVpZ2h0XV07XHJcbiAgICBpZiAoaXNTYW1lU3RhcnRMaW5lKFtcclxuICAgICAgICBbbGVmdCwgdG9wXSxcclxuICAgICAgICBbbGVmdCArIHdpZHRoLCB0b3BdLFxyXG4gICAgICAgIFtsZWZ0LCB0b3AgKyBoZWlnaHRdLFxyXG4gICAgICAgIFtsZWZ0ICsgd2lkdGgsIHRvcCArIGhlaWdodF0sXHJcbiAgICBdLCBsaW5lLCBjZW50ZXJTaWduKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzQWxsQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbEJvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gdGVzdCB2ZXJ0aWNhbFxyXG4gICAgdmFyIHRvcEJvdW5kSW5mbyA9IGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIGxpbmVDb25zdGFudHMsIHRvcExpbmUsIHZlcnRpY2FsU2lnbik7XHJcbiAgICB2YXIgYm90dG9tQm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgYm90dG9tTGluZSwgdmVydGljYWxTaWduKTtcclxuICAgIC8vIHRlc3QgaG9yaXpvbnRhbFxyXG4gICAgdmFyIGxlZnRCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCBsZWZ0TGluZSwgaG9yaXpvbnRhbFNpZ24pO1xyXG4gICAgdmFyIHJpZ2h0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgcmlnaHRMaW5lLCBob3Jpem9udGFsU2lnbik7XHJcbiAgICB2YXIgaXNBbGxWZXJ0aWNhbEJvdW5kID0gdG9wQm91bmRJbmZvLmlzQm91bmQgJiYgYm90dG9tQm91bmRJbmZvLmlzQm91bmQ7XHJcbiAgICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gdG9wQm91bmRJbmZvLmlzQm91bmQgfHwgYm90dG9tQm91bmRJbmZvLmlzQm91bmQ7XHJcbiAgICB2YXIgaXNBbGxIb3Jpem9udGFsQm91bmQgPSBsZWZ0Qm91bmRJbmZvLmlzQm91bmQgJiYgcmlnaHRCb3VuZEluZm8uaXNCb3VuZDtcclxuICAgIHZhciBpc0hvcml6b250YWxCb3VuZCA9IGxlZnRCb3VuZEluZm8uaXNCb3VuZCB8fCByaWdodEJvdW5kSW5mby5pc0JvdW5kO1xyXG4gICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gbWF4T2Zmc2V0KHRvcEJvdW5kSW5mby5vZmZzZXQsIGJvdHRvbUJvdW5kSW5mby5vZmZzZXQpO1xyXG4gICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBtYXhPZmZzZXQobGVmdEJvdW5kSW5mby5vZmZzZXQsIHJpZ2h0Qm91bmRJbmZvLm9mZnNldCk7XHJcbiAgICB2YXIgb2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgdmFyIGlzQm91bmQgPSBmYWxzZTtcclxuICAgIHZhciBpc0FsbEJvdW5kID0gZmFsc2U7XHJcbiAgICBpZiAoYWJzKGhvcml6b250YWxPZmZzZXQpIDwgYWJzKHZlcnRpY2FsT2Zmc2V0KSkge1xyXG4gICAgICAgIG9mZnNldCA9IFt2ZXJ0aWNhbE9mZnNldCwgMF07XHJcbiAgICAgICAgaXNCb3VuZCA9IGlzVmVydGljYWxCb3VuZDtcclxuICAgICAgICBpc0FsbEJvdW5kID0gaXNBbGxWZXJ0aWNhbEJvdW5kO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gWzAsIGhvcml6b250YWxPZmZzZXRdO1xyXG4gICAgICAgIGlzQm91bmQgPSBpc0hvcml6b250YWxCb3VuZDtcclxuICAgICAgICBpc0FsbEJvdW5kID0gaXNBbGxIb3Jpem9udGFsQm91bmQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzQWxsQm91bmQ6IGlzQWxsQm91bmQsXHJcbiAgICAgICAgaXNWZXJ0aWNhbEJvdW5kOiBpc1ZlcnRpY2FsQm91bmQsXHJcbiAgICAgICAgaXNIb3Jpem9udGFsQm91bmQ6IGlzSG9yaXpvbnRhbEJvdW5kLFxyXG4gICAgICAgIGlzQm91bmQ6IGlzQm91bmQsXHJcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrTGluZUJvdW5kQ29sbGlzaW9uKGxpbmUsIF9hLCBib3VuZExpbmUsIGlzU3RhcnQsIHRocmVzaG9sZCwgaXNSZW5kZXIpIHtcclxuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGEgPSBfYlswXSwgYiA9IF9iWzFdO1xyXG4gICAgdmFyIGRvdDEgPSBsaW5lWzBdO1xyXG4gICAgLy8gY29uc3QgZG90MiA9IGxpbmVbMV07XHJcbiAgICB2YXIgYm91bmREb3QxID0gYm91bmRMaW5lWzBdO1xyXG4gICAgdmFyIGJvdW5kRG90MiA9IGJvdW5kTGluZVsxXTtcclxuICAgIC8vIGNvbnN0IGR5MSA9IGdldFRpbnlEaXN0KGRvdDJbMV0gLSBkb3QxWzFdKTtcclxuICAgIC8vIGNvbnN0IGR4MSA9IGdldFRpbnlEaXN0KGRvdDJbMF0gLSBkb3QxWzBdKTtcclxuICAgIHZhciBkeTIgPSBnZXRUaW55RGlzdChib3VuZERvdDJbMV0gLSBib3VuZERvdDFbMV0pO1xyXG4gICAgdmFyIGR4MiA9IGdldFRpbnlEaXN0KGJvdW5kRG90MlswXSAtIGJvdW5kRG90MVswXSk7XHJcbiAgICB2YXIgaGFzRHggPSBiO1xyXG4gICAgdmFyIGhhc0R5ID0gYTtcclxuICAgIHZhciBzbG9wZSA9IC1hIC8gYjtcclxuICAgIC8vIGxpbmVDb25zdGFudHNcclxuICAgIC8vIGF4ICsgYnkgKyBjID0gMFxyXG4gICAgLy8gZHgyIG9yIGR5MiBpcyB6ZXJvXHJcbiAgICBpZiAoIWR4Mikge1xyXG4gICAgICAgIC8vIHZlcnRpY2FsXHJcbiAgICAgICAgLy8gYnkgKyBjID0gMFxyXG4gICAgICAgIGlmIChpc1JlbmRlciAmJiAhaGFzRHkpIHtcclxuICAgICAgICAgICAgLy8gOTBkZWdcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNEeCkge1xyXG4gICAgICAgICAgICAvLyBheCArIGJ5ICsgYyA9IDBcclxuICAgICAgICAgICAgLy8gY29uc3QgeSA9IGR5MSA/IGR5MSAvIGR4MSAqIChib3VuZERvdDFbMF0gLSBkb3QxWzBdKSArIGRvdDFbMV0gOiBkb3QxWzFdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNsb3BlICogKGJvdW5kRG90MVswXSAtIGRvdDFbMF0pICsgZG90MVsxXTtcclxuICAgICAgICAgICAgLy8gYm91bmREb3QxWzFdIDw9IHkgIDw9IGJvdW5kRG90MlsxXVxyXG4gICAgICAgICAgICByZXR1cm4gY2hlY2tJbm5lckJvdW5kRG90KHksIGJvdW5kRG90MVsxXSwgYm91bmREb3QyWzFdLCBpc1N0YXJ0LCB0aHJlc2hvbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYXggKyBjID0gMFxyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYm91bmREb3QxWzBdIC0gZG90MVswXTtcclxuICAgICAgICAgICAgdmFyIGlzQm91bmQgPSBhYnMob2Zmc2V0KSA8PSAodGhyZXNob2xkIHx8IDApO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXNCb3VuZDogaXNCb3VuZCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogaXNCb3VuZCA/IG9mZnNldCA6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIWR5Mikge1xyXG4gICAgICAgIC8vIGhvcml6b250YWxcclxuICAgICAgICBpZiAoaXNSZW5kZXIgJiYgIWhhc0R4KSB7XHJcbiAgICAgICAgICAgIC8vIDkwZGVnXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzRHkpIHtcclxuICAgICAgICAgICAgLy8geSA9IGEgKiAoeCAtIHgxKSArIHkxXHJcbiAgICAgICAgICAgIC8vIHggPSAoeSAtIHkxKSAvIGEgKyB4MVxyXG4gICAgICAgICAgICAvLyBjb25zdCBhID0gZHkxIC8gZHgxO1xyXG4gICAgICAgICAgICAvLyBjb25zdCB4ID0gZHgxID8gKGJvdW5kRG90MVsxXSAtIGRvdDFbMV0pIC8gYSArIGRvdDFbMF0gOiBkb3QxWzBdO1xyXG4gICAgICAgICAgICB2YXIgeCA9IChib3VuZERvdDFbMV0gLSBkb3QxWzFdKSAvIHNsb3BlICsgZG90MVswXTtcclxuICAgICAgICAgICAgLy8gYm91bmREb3QxWzBdIDw9IHggJiYgeCA8PSBib3VuZERvdDJbMF1cclxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrSW5uZXJCb3VuZERvdCh4LCBib3VuZERvdDFbMF0sIGJvdW5kRG90MlswXSwgaXNTdGFydCwgdGhyZXNob2xkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBib3VuZERvdDFbMV0gLSBkb3QxWzFdO1xyXG4gICAgICAgICAgICB2YXIgaXNCb3VuZCA9IGFicyhvZmZzZXQpIDw9ICh0aHJlc2hvbGQgfHwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBpc0JvdW5kLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBpc0JvdW5kID8gb2Zmc2V0IDogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgIG9mZnNldDogMCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZEluZm8obW92ZWFibGUsIGxpbmVJbmZvcywgZGF0YXMpIHtcclxuICAgIHJldHVybiBsaW5lSW5mb3MubWFwKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgdmFyIF9hID0gY2hlY2tJbm5lckJvdW5kKG1vdmVhYmxlLCBpbmZvKSwgaXNCb3VuZCA9IF9hLmlzQm91bmQsIG9mZnNldCA9IF9hLm9mZnNldCwgaXNWZXJ0aWNhbEJvdW5kID0gX2EuaXNWZXJ0aWNhbEJvdW5kLCBpc0hvcml6b250YWxCb3VuZCA9IF9hLmlzSG9yaXpvbnRhbEJvdW5kO1xyXG4gICAgICAgIHZhciBtdWx0aXBsZSA9IGluZm8ubXVsdGlwbGU7XHJcbiAgICAgICAgdmFyIHNpemVPZmZzZXQgPSBnZXREcmFnRGlzdCh7XHJcbiAgICAgICAgICAgIGRhdGFzOiBkYXRhcyxcclxuICAgICAgICAgICAgZGlzdFg6IG9mZnNldFswXSxcclxuICAgICAgICAgICAgZGlzdFk6IG9mZnNldFsxXSxcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHNpemUsIGkpIHsgcmV0dXJuIHNpemUgKiAobXVsdGlwbGVbaV0gPyAyIC8gbXVsdGlwbGVbaV0gOiAwKTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2lnbjogbXVsdGlwbGUsXHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGlzQm91bmQsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWxCb3VuZDogaXNWZXJ0aWNhbEJvdW5kLFxyXG4gICAgICAgICAgICBpc0hvcml6b250YWxCb3VuZDogaXNIb3Jpem9udGFsQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgICAgIG9mZnNldDogc2l6ZU9mZnNldCxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZERyYWdJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGF0YXMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBsaW5lcyA9IGdldENoZWNrSW5uZXJCb3VuZExpbmVJbmZvcyhtb3ZlYWJsZSwgcG9zZXMsIFswLCAwXSwgZmFsc2UpLm1hcChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHsgbXVsdGlwbGU6IGluZm8ubXVsdGlwbGUubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGFicyhkaXIpICogMjsgfSkgfSk7XHJcbiAgICB9KTtcclxuICAgIHZhciBpbm5lckJvdW5kSW5mbyA9IGdldElubmVyQm91bmRJbmZvKG1vdmVhYmxlLCBsaW5lcywgZGF0YXMpO1xyXG4gICAgdmFyIHdpZHRoT2Zmc2V0SW5mbyA9IGdldE5lYXJPZmZzZXRJbmZvKGlubmVyQm91bmRJbmZvLCAwKTtcclxuICAgIHZhciBoZWlnaHRPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8oaW5uZXJCb3VuZEluZm8sIDEpO1xyXG4gICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gMDtcclxuICAgIHZhciBob3Jpem9udGFsT2Zmc2V0ID0gMDtcclxuICAgIHZhciBpc1ZlcnRpY2FsQm91bmQgPSB3aWR0aE9mZnNldEluZm8uaXNWZXJ0aWNhbEJvdW5kIHx8IGhlaWdodE9mZnNldEluZm8uaXNWZXJ0aWNhbEJvdW5kO1xyXG4gICAgdmFyIGlzSG9yaXpvbnRhbEJvdW5kID0gd2lkdGhPZmZzZXRJbmZvLmlzSG9yaXpvbnRhbEJvdW5kIHx8IGhlaWdodE9mZnNldEluZm8uaXNIb3Jpem9udGFsQm91bmQ7XHJcbiAgICBpZiAoaXNWZXJ0aWNhbEJvdW5kIHx8IGlzSG9yaXpvbnRhbEJvdW5kKSB7XHJcbiAgICAgICAgX2EgPSBfX3JlYWQoZ2V0SW52ZXJzZURyYWdEaXN0KHtcclxuICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICBkaXN0WDogLXdpZHRoT2Zmc2V0SW5mby5vZmZzZXRbMF0sXHJcbiAgICAgICAgICAgIGRpc3RZOiAtaGVpZ2h0T2Zmc2V0SW5mby5vZmZzZXRbMV0sXHJcbiAgICAgICAgfSksIDIpLCB2ZXJ0aWNhbE9mZnNldCA9IF9hWzBdLCBob3Jpem9udGFsT2Zmc2V0ID0gX2FbMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGlzVmVydGljYWxCb3VuZCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhvcml6b250YWw6IHtcclxuICAgICAgICAgICAgaXNCb3VuZDogaXNIb3Jpem9udGFsQm91bmQsXHJcbiAgICAgICAgICAgIG9mZnNldDogaG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRDaGVja1NuYXBMaW5lRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGtlZXBSYXRpbykge1xyXG4gICAgdmFyIGxpbmVEaXJlY3Rpb25zID0gW107XHJcbiAgICB2YXIgeCA9IGRpcmVjdGlvblswXTtcclxuICAgIHZhciB5ID0gZGlyZWN0aW9uWzFdO1xyXG4gICAgaWYgKHggJiYgeSkge1xyXG4gICAgICAgIGxpbmVEaXJlY3Rpb25zLnB1c2goW1swLCB5ICogMl0sIGRpcmVjdGlvbiwgWy14LCB5XV0sIFtbeCAqIDIsIDBdLCBkaXJlY3Rpb24sIFt4LCAteV1dKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHgpIHtcclxuICAgICAgICAvLyB2ZXJ0Y2FsXHJcbiAgICAgICAgbGluZURpcmVjdGlvbnMucHVzaChbW3ggKiAyLCAwXSwgW3gsIDFdLCBbeCwgLTFdXSk7XHJcbiAgICAgICAgaWYgKGtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbMCwgLTFdLCBbeCwgLTFdLCBbLXgsIC0xXV0sIFtbMCwgMV0sIFt4LCAxXSwgWy14LCAxXV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHkpIHtcclxuICAgICAgICAvLyBob3Jpem9udGFsXHJcbiAgICAgICAgbGluZURpcmVjdGlvbnMucHVzaChbWzAsIHkgKiAyXSwgWzEsIHldLCBbLTEsIHldXSk7XHJcbiAgICAgICAgaWYgKGtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICBsaW5lRGlyZWN0aW9ucy5wdXNoKFtbLTEsIDBdLCBbLTEsIHldLCBbLTEsIC15XV0sIFtbMSwgMF0sIFsxLCB5XSwgWzEsIC15XV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFswLCAwXSB0byBhbGwgZGlyZWN0aW9uXHJcbiAgICAgICAgbGluZURpcmVjdGlvbnMucHVzaChbWy0xLCAwXSwgWy0xLCAtMV0sIFstMSwgMV1dLCBbWzEsIDBdLCBbMSwgLTFdLCBbMSwgMV1dLCBbWzAsIC0xXSwgWy0xLCAtMV0sIFsxLCAtMV1dLCBbWzAsIDFdLCBbLTEsIDFdLCBbMSwgMV1dKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaW5lRGlyZWN0aW9ucztcclxufVxyXG5mdW5jdGlvbiBnZXRDaGVja0lubmVyQm91bmRMaW5lSW5mb3MobW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb24sIGtlZXBSYXRpbykge1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIGFsbE1hdHJpeCA9IF9hLmFsbE1hdHJpeCwgaXMzZCA9IF9hLmlzM2Q7XHJcbiAgICB2YXIgdmlydHVhbFBvc2VzID0gY2FsY3VsYXRlUG9zZXMoYWxsTWF0cml4LCAxMDAsIDEwMCwgaXMzZCA/IDQgOiAzKTtcclxuICAgIHZhciBjZW50ZXIgPSBnZXRQb3NCeURpcmVjdGlvbih2aXJ0dWFsUG9zZXMsIFswLCAwXSk7XHJcbiAgICByZXR1cm4gZ2V0Q2hlY2tTbmFwTGluZURpcmVjdGlvbnMoZGlyZWN0aW9uLCBrZWVwUmF0aW8pLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBtdWx0aXBsZSA9IF9iWzBdLCBkaXIxID0gX2JbMV0sIGRpcjIgPSBfYlsyXTtcclxuICAgICAgICB2YXIgdmlydHVhbExpbmUgPSBbXHJcbiAgICAgICAgICAgIGdldFBvc0J5RGlyZWN0aW9uKHZpcnR1YWxQb3NlcywgZGlyMSksXHJcbiAgICAgICAgICAgIGdldFBvc0J5RGlyZWN0aW9uKHZpcnR1YWxQb3NlcywgZGlyMiksXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgbGluZUNvbnN0YW50cyA9IHNvbHZlTGluZUNvbnN0YW50cyh2aXJ0dWFsTGluZSk7XHJcbiAgICAgICAgdmFyIF9jID0gaXNTdGFydExpbmUoY2VudGVyLCB2aXJ0dWFsTGluZSksIHZlcnRpY2FsU2lnbiA9IF9jLnZlcnRpY2FsLCBob3Jpem9udGFsU2lnbiA9IF9jLmhvcml6b250YWw7XHJcbiAgICAgICAgdmFyIGNlbnRlclNpZ24gPSBoaXRUZXN0TGluZShjZW50ZXIsIHZpcnR1YWxMaW5lKSA8PSAwO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG11bHRpcGxlOiBtdWx0aXBsZSxcclxuICAgICAgICAgICAgY2VudGVyU2lnbjogY2VudGVyU2lnbixcclxuICAgICAgICAgICAgdmVydGljYWxTaWduOiB2ZXJ0aWNhbFNpZ24sXHJcbiAgICAgICAgICAgIGhvcml6b250YWxTaWduOiBob3Jpem9udGFsU2lnbixcclxuICAgICAgICAgICAgbGluZUNvbnN0YW50czogbGluZUNvbnN0YW50cyxcclxuICAgICAgICAgICAgbGluZTogW1xyXG4gICAgICAgICAgICAgICAgZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcjEpLFxyXG4gICAgICAgICAgICAgICAgZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcjIpLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpc0JvdW5kUm90YXRlKHJlbGF0aXZlUG9zZXMsIGJvdW5kRG90cywgY2VudGVyLCByYWQpIHtcclxuICAgIHZhciBuZXh0UG9zZXMgPSByYWQgPyByZWxhdGl2ZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiByb3RhdGUocG9zLCByYWQpOyB9KSA6IHJlbGF0aXZlUG9zZXM7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIFtuZXh0UG9zZXNbMF0sIG5leHRQb3Nlc1sxXV0sXHJcbiAgICAgICAgW25leHRQb3Nlc1sxXSwgbmV4dFBvc2VzWzNdXSxcclxuICAgICAgICBbbmV4dFBvc2VzWzNdLCBuZXh0UG9zZXNbMl1dLFxyXG4gICAgICAgIFtuZXh0UG9zZXNbMl0sIG5leHRQb3Nlc1swXV0sXHJcbiAgICBdLnNvbWUoZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICB2YXIgY2VudGVyU2lnbiA9IGhpdFRlc3RMaW5lKGNlbnRlciwgbGluZSkgPD0gMDtcclxuICAgICAgICByZXR1cm4gIWlzU2FtZVN0YXJ0TGluZShib3VuZERvdHMsIGxpbmUsIGNlbnRlclNpZ24pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlzdFBvaW50TGluZShfYSkge1xyXG4gICAgLy8geCA9IDAsIHkgPSAwXHJcbiAgICAvLyBkID0gKGF4ICsgYnkgKyBjKSAvIHJvb3QoYTIgKyBiMilcclxuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBvczEgPSBfYlswXSwgcG9zMiA9IF9iWzFdO1xyXG4gICAgdmFyIGR4ID0gcG9zMlswXSAtIHBvczFbMF07XHJcbiAgICB2YXIgZHkgPSBwb3MyWzFdIC0gcG9zMVsxXTtcclxuICAgIGlmICghZHgpIHtcclxuICAgICAgICByZXR1cm4gYWJzKHBvczFbMF0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkeSkge1xyXG4gICAgICAgIHJldHVybiBhYnMocG9zMVsxXSk7XHJcbiAgICB9XHJcbiAgICAvLyB5IC0geTEgPSBhKHggLSB4MSlcclxuICAgIC8vIDAgPSBheCAteSArIC1hICogeDEgKyB5MVxyXG4gICAgdmFyIGEgPSBkeSAvIGR4O1xyXG4gICAgcmV0dXJuIGFicygoLWEgKiBwb3MxWzBdICsgcG9zMVsxXSkgLyBNYXRoLnNxcnQoTWF0aC5wb3coYSwgMikgKyAxKSk7XHJcbn1cclxuZnVuY3Rpb24gc29sdmVSZXZlcnNlTGluZShfYSkge1xyXG4gICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgcG9zMSA9IF9iWzBdLCBwb3MyID0gX2JbMV07XHJcbiAgICB2YXIgZHggPSBwb3MyWzBdIC0gcG9zMVswXTtcclxuICAgIHZhciBkeSA9IHBvczJbMV0gLSBwb3MxWzFdO1xyXG4gICAgaWYgKCFkeCkge1xyXG4gICAgICAgIHJldHVybiBbcG9zMVswXSwgMF07XHJcbiAgICB9XHJcbiAgICBpZiAoIWR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCBwb3MxWzFdXTtcclxuICAgIH1cclxuICAgIHZhciBhID0gZHkgLyBkeDtcclxuICAgIC8vIHkgLSB5MSA9IGEgKHggIC0geDEpXHJcbiAgICAvLyB5ID0gYXggLSBhICogeDEgKyB5MVxyXG4gICAgdmFyIGIgPSAtYSAqIHBvczFbMF0gKyBwb3MxWzFdO1xyXG4gICAgLy8geSA9IGF4ICsgYiA9IC0xL2EgeFxyXG4gICAgLy8geCA9IC1iIC8gKGEgKyAxIC8gYSlcclxuICAgIC8vIHkgPSBiIC8gKDEgKyAxIC8gYV4yKVxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAtYiAvIChhICsgMSAvIGEpLFxyXG4gICAgICAgIGIgLyAoKGEgKiBhKSArIDEpLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1JvdGF0ZUlubmVyQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luLCByb3RhdGlvbikge1xyXG4gICAgdmFyIGJvdW5kcyA9IG1vdmVhYmxlLnByb3BzLmlubmVyQm91bmRzO1xyXG4gICAgdmFyIHJhZCA9IHJvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuICAgIGlmICghYm91bmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlZnQgPSBib3VuZHMubGVmdCwgdG9wID0gYm91bmRzLnRvcCwgd2lkdGggPSBib3VuZHMud2lkdGgsIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XHJcbiAgICB2YXIgcmVsYXRpdmVMZWZ0ID0gbGVmdCAtIG9yaWdpblswXTtcclxuICAgIHZhciByZWxhdGl2ZVJpZ2h0ID0gbGVmdCArIHdpZHRoIC0gb3JpZ2luWzBdO1xyXG4gICAgdmFyIHJlbGF0aXZlVG9wID0gdG9wIC0gb3JpZ2luWzFdO1xyXG4gICAgdmFyIHJlbGF0aXZlQm90dG9tID0gdG9wICsgaGVpZ2h0IC0gb3JpZ2luWzFdO1xyXG4gICAgdmFyIGRvdHMgPSBbXHJcbiAgICAgICAgW3JlbGF0aXZlTGVmdCwgcmVsYXRpdmVUb3BdLFxyXG4gICAgICAgIFtyZWxhdGl2ZVJpZ2h0LCByZWxhdGl2ZVRvcF0sXHJcbiAgICAgICAgW3JlbGF0aXZlTGVmdCwgcmVsYXRpdmVCb3R0b21dLFxyXG4gICAgICAgIFtyZWxhdGl2ZVJpZ2h0LCByZWxhdGl2ZUJvdHRvbV0sXHJcbiAgICBdO1xyXG4gICAgdmFyIGNlbnRlciA9IGdldFBvc0J5RGlyZWN0aW9uKG5leHRQb3NlcywgWzAsIDBdKTtcclxuICAgIGlmICghaXNCb3VuZFJvdGF0ZShuZXh0UG9zZXMsIGRvdHMsIGNlbnRlciwgMCkpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgZG90SW5mb3MgPSBkb3RzLm1hcChmdW5jdGlvbiAoZG90KSB7IHJldHVybiBbXHJcbiAgICAgICAgZ2V0RGlzdFNpemUoZG90KSxcclxuICAgICAgICBnZXRSYWQoWzAsIDBdLCBkb3QpLFxyXG4gICAgXTsgfSk7XHJcbiAgICBbXHJcbiAgICAgICAgW25leHRQb3Nlc1swXSwgbmV4dFBvc2VzWzFdXSxcclxuICAgICAgICBbbmV4dFBvc2VzWzFdLCBuZXh0UG9zZXNbM11dLFxyXG4gICAgICAgIFtuZXh0UG9zZXNbM10sIG5leHRQb3Nlc1syXV0sXHJcbiAgICAgICAgW25leHRQb3Nlc1syXSwgbmV4dFBvc2VzWzBdXSxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgIHZhciBsaW5lUmFkID0gZ2V0UmFkKFswLCAwXSwgc29sdmVSZXZlcnNlTGluZShsaW5lKSk7XHJcbiAgICAgICAgdmFyIGxpbmVEaXN0ID0gZ2V0RGlzdFBvaW50TGluZShsaW5lKTtcclxuICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkb3RJbmZvc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDEpLCBkb3REaXN0ID0gX2JbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBkb3REaXN0ICYmIGxpbmVEaXN0IDw9IGRvdERpc3Q7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgZG90RGlzdCA9IF9iWzBdLCBkb3RSYWQgPSBfYlsxXTtcclxuICAgICAgICAgICAgdmFyIGRpc3RSYWQgPSBNYXRoLmFjb3MoZG90RGlzdCA/IGxpbmVEaXN0IC8gZG90RGlzdCA6IDApO1xyXG4gICAgICAgICAgICB2YXIgbmV4dFJhZDEgPSBkb3RSYWQgKyBkaXN0UmFkO1xyXG4gICAgICAgICAgICB2YXIgbmV4dFJhZDIgPSBkb3RSYWQgLSBkaXN0UmFkO1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgcmFkICsgbmV4dFJhZDEgLSBsaW5lUmFkLFxyXG4gICAgICAgICAgICAgICAgcmFkICsgbmV4dFJhZDIgLSBsaW5lUmFkLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xyXG4gICAgICAgICAgICBwcmV2LnB1c2guYXBwbHkocHJldiwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGN1ciksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuZXh0UmFkKSB7IHJldHVybiAhaXNCb3VuZFJvdGF0ZShwcmV2UG9zZXMsIGRvdHMsIGNlbnRlciwgbmV4dFJhZCk7IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG5leHRSYWQpIHsgcmV0dXJuIHRocm90dGxlKG5leHRSYWQgKiAxODAgLyBNYXRoLlBJLCBUSU5ZX05VTSk7IH0pKSwgZmFsc2UpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjaGVja0lubmVyQm91bmRQb3Nlcyhtb3ZlYWJsZSkge1xyXG4gICAgdmFyIGlubmVyQm91bmRzID0gbW92ZWFibGUucHJvcHMuaW5uZXJCb3VuZHM7XHJcbiAgICB2YXIgYm91bmRNYXAgPSBnZXRJbml0aWFsQm91bmRzKCk7XHJcbiAgICBpZiAoIWlubmVyQm91bmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYm91bmRNYXA6IGJvdW5kTWFwLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbDogW10sXHJcbiAgICAgICAgICAgIGhvcml6b250YWw6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5nZXRSZWN0KCksIHBvczEgPSBfYS5wb3MxLCBwb3MyID0gX2EucG9zMiwgcG9zMyA9IF9hLnBvczMsIHBvczQgPSBfYS5wb3M0O1xyXG4gICAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xyXG4gICAgdmFyIGNlbnRlciA9IGdldFBvc0J5RGlyZWN0aW9uKHBvc2VzLCBbMCwgMF0pO1xyXG4gICAgdmFyIGxlZnQgPSBpbm5lckJvdW5kcy5sZWZ0LCB0b3AgPSBpbm5lckJvdW5kcy50b3AsIHdpZHRoID0gaW5uZXJCb3VuZHMud2lkdGgsIGhlaWdodCA9IGlubmVyQm91bmRzLmhlaWdodDtcclxuICAgIHZhciBsZWZ0TGluZSA9IFtbbGVmdCwgdG9wXSwgW2xlZnQsIHRvcCArIGhlaWdodF1dO1xyXG4gICAgdmFyIHRvcExpbmUgPSBbW2xlZnQsIHRvcF0sIFtsZWZ0ICsgd2lkdGgsIHRvcF1dO1xyXG4gICAgdmFyIHJpZ2h0TGluZSA9IFtbbGVmdCArIHdpZHRoLCB0b3BdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcclxuICAgIHZhciBib3R0b21MaW5lID0gW1tsZWZ0LCB0b3AgKyBoZWlnaHRdLCBbbGVmdCArIHdpZHRoLCB0b3AgKyBoZWlnaHRdXTtcclxuICAgIHZhciBsaW5lSW5mb3MgPSBnZXRDaGVja0lubmVyQm91bmRMaW5lSW5mb3MobW92ZWFibGUsIHBvc2VzLCBbMCwgMF0sIGZhbHNlKTtcclxuICAgIHZhciBob3Jpem9udGFsUG9zZXMgPSBbXTtcclxuICAgIHZhciB2ZXJ0aWNhbFBvc2VzID0gW107XHJcbiAgICBsaW5lSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAobGluZUluZm8pIHtcclxuICAgICAgICB2YXIgbGluZSA9IGxpbmVJbmZvLmxpbmUsIGxpbmVDb25zdGFudHMgPSBsaW5lSW5mby5saW5lQ29uc3RhbnRzO1xyXG4gICAgICAgIHZhciBfYSA9IGlzU3RhcnRMaW5lKGNlbnRlciwgbGluZSksIGlzSG9yaXpvbnRhbFN0YXJ0ID0gX2EuaG9yaXpvbnRhbCwgaXNWZXJ0aWNhbFN0YXJ0ID0gX2EudmVydGljYWw7XHJcbiAgICAgICAgLy8gdGVzdCB2ZXJ0aWNhbFxyXG4gICAgICAgIHZhciB0b3BCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCB0b3BMaW5lLCBpc1ZlcnRpY2FsU3RhcnQsIDEsIHRydWUpO1xyXG4gICAgICAgIHZhciBib3R0b21Cb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCBib3R0b21MaW5lLCBpc1ZlcnRpY2FsU3RhcnQsIDEsIHRydWUpO1xyXG4gICAgICAgIC8vIHRlc3QgaG9yaXpvbnRhbFxyXG4gICAgICAgIHZhciBsZWZ0Qm91bmRJbmZvID0gY2hlY2tMaW5lQm91bmRDb2xsaXNpb24obGluZSwgbGluZUNvbnN0YW50cywgbGVmdExpbmUsIGlzSG9yaXpvbnRhbFN0YXJ0LCAxLCB0cnVlKTtcclxuICAgICAgICB2YXIgcmlnaHRCb3VuZEluZm8gPSBjaGVja0xpbmVCb3VuZENvbGxpc2lvbihsaW5lLCBsaW5lQ29uc3RhbnRzLCByaWdodExpbmUsIGlzSG9yaXpvbnRhbFN0YXJ0LCAxLCB0cnVlKTtcclxuICAgICAgICBpZiAodG9wQm91bmRJbmZvLmlzQm91bmQgJiYgIWJvdW5kTWFwLnRvcCkge1xyXG4gICAgICAgICAgICBob3Jpem9udGFsUG9zZXMucHVzaCh0b3ApO1xyXG4gICAgICAgICAgICBib3VuZE1hcC50b3AgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm90dG9tQm91bmRJbmZvLmlzQm91bmQgJiYgIWJvdW5kTWFwLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBob3Jpem9udGFsUG9zZXMucHVzaCh0b3AgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBib3VuZE1hcC5ib3R0b20gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVmdEJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC5sZWZ0KSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsUG9zZXMucHVzaChsZWZ0KTtcclxuICAgICAgICAgICAgYm91bmRNYXAubGVmdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyaWdodEJvdW5kSW5mby5pc0JvdW5kICYmICFib3VuZE1hcC5yaWdodCkge1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbFBvc2VzLnB1c2gobGVmdCArIHdpZHRoKTtcclxuICAgICAgICAgICAgYm91bmRNYXAucmlnaHQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBib3VuZE1hcDogYm91bmRNYXAsXHJcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbFBvc2VzLFxyXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbFBvc2VzLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBzb2x2ZUVxdWF0aW9uKHBvczEsIHBvczIsIHNuYXBPZmZzZXQsIGlzVmVydGljYWwpIHtcclxuICAgIHZhciBkeCA9IHBvczJbMF0gLSBwb3MxWzBdO1xyXG4gICAgdmFyIGR5ID0gcG9zMlsxXSAtIHBvczFbMV07XHJcbiAgICBpZiAoYWJzKGR4KSA8IFRJTllfTlVNJDEpIHtcclxuICAgICAgICBkeCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoYWJzKGR5KSA8IFRJTllfTlVNJDEpIHtcclxuICAgICAgICBkeSA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoIWR4KSB7XHJcbiAgICAgICAgLy8geSA9IDAgKiB4ICsgYlxyXG4gICAgICAgIC8vIG9ubHkgaG9yaXpvbnRhbFxyXG4gICAgICAgIGlmICghaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWzAsIHNuYXBPZmZzZXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gWzAsIDBdO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkeSkge1xyXG4gICAgICAgIC8vIG9ubHkgdmVydGljYWxcclxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3NuYXBPZmZzZXQsIDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gWzAsIDBdO1xyXG4gICAgfVxyXG4gICAgLy8geSA9IGF4ICsgYlxyXG4gICAgdmFyIGEgPSBkeSAvIGR4O1xyXG4gICAgdmFyIGIgPSBwb3MxWzFdIC0gYSAqIHBvczFbMF07XHJcbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgIC8vIHkgPSBhICogeCArIGJcclxuICAgICAgICB2YXIgeSA9IGEgKiAocG9zMlswXSArIHNuYXBPZmZzZXQpICsgYjtcclxuICAgICAgICByZXR1cm4gW3NuYXBPZmZzZXQsIHkgLSBwb3MyWzFdXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHggPSAoeSAtIGIpIC8gYVxyXG4gICAgICAgIHZhciB4ID0gKHBvczJbMV0gKyBzbmFwT2Zmc2V0IC0gYikgLyBhO1xyXG4gICAgICAgIHJldHVybiBbeCAtIHBvczJbMF0sIHNuYXBPZmZzZXRdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNvbHZlTmV4dE9mZnNldChwb3MxLCBwb3MyLCBvZmZzZXQsIGlzVmVydGljYWwsIGRhdGFzKSB7XHJcbiAgICB2YXIgc2l6ZU9mZnNldCA9IHNvbHZlRXF1YXRpb24ocG9zMSwgcG9zMiwgb2Zmc2V0LCBpc1ZlcnRpY2FsKTtcclxuICAgIGlmICghc2l6ZU9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzT3V0c2lkZTogZmFsc2UsXHJcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgc2l6ZSA9IGdldERpc3QkMShwb3MxLCBwb3MyKTtcclxuICAgIHZhciBkaXN0MSA9IGdldERpc3QkMShzaXplT2Zmc2V0LCBwb3MxKTtcclxuICAgIHZhciBkaXN0MiA9IGdldERpc3QkMShzaXplT2Zmc2V0LCBwb3MyKTtcclxuICAgIHZhciBpc091dHNpZGUgPSBkaXN0MSA+IHNpemUgfHwgZGlzdDIgPiBzaXplO1xyXG4gICAgdmFyIF9hID0gX19yZWFkKGdldERyYWdEaXN0KHtcclxuICAgICAgICBkYXRhczogZGF0YXMsXHJcbiAgICAgICAgZGlzdFg6IHNpemVPZmZzZXRbMF0sXHJcbiAgICAgICAgZGlzdFk6IHNpemVPZmZzZXRbMV0sXHJcbiAgICB9KSwgMiksIHdpZHRoT2Zmc2V0ID0gX2FbMF0sIGhlaWdodE9mZnNldCA9IF9hWzFdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvZmZzZXQ6IFt3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0XSxcclxuICAgICAgICBpc091dHNpZGU6IGlzT3V0c2lkZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kKGJvdW5kSW5mbywgc25hcEluZm8pIHtcclxuICAgIGlmIChib3VuZEluZm8uaXNCb3VuZCkge1xyXG4gICAgICAgIHJldHVybiBib3VuZEluZm8ub2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc25hcEluZm8uaXNTbmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5lYXJlc3RTbmFwR3VpZGVsaW5lSW5mbyhzbmFwSW5mbykub2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tUaHJvdHRsZURyYWdSb3RhdGUodGhyb3R0bGVEcmFnUm90YXRlLCBfYSwgX2IsIF9jLCBfZCkge1xyXG4gICAgdmFyIF9lID0gX19yZWFkKF9hLCAyKSwgZGlzdFggPSBfZVswXSwgZGlzdFkgPSBfZVsxXTtcclxuICAgIHZhciBfZiA9IF9fcmVhZChfYiwgMiksIGlzVmVydGljYWxCb3VuZCA9IF9mWzBdLCBpc0hvcml6b250YWxCb3VuZCA9IF9mWzFdO1xyXG4gICAgdmFyIF9nID0gX19yZWFkKF9jLCAyKSwgaXNWZXJ0aWNhbFNuYXAgPSBfZ1swXSwgaXNIb3Jpem9udGFsU25hcCA9IF9nWzFdO1xyXG4gICAgdmFyIF9oID0gX19yZWFkKF9kLCAyKSwgdmVydGljYWxPZmZzZXQgPSBfaFswXSwgaG9yaXpvbnRhbE9mZnNldCA9IF9oWzFdO1xyXG4gICAgdmFyIG9mZnNldFggPSAtdmVydGljYWxPZmZzZXQ7XHJcbiAgICB2YXIgb2Zmc2V0WSA9IC1ob3Jpem9udGFsT2Zmc2V0O1xyXG4gICAgaWYgKHRocm90dGxlRHJhZ1JvdGF0ZSAmJiBkaXN0WCAmJiBkaXN0WSkge1xyXG4gICAgICAgIG9mZnNldFggPSAwO1xyXG4gICAgICAgIG9mZnNldFkgPSAwO1xyXG4gICAgICAgIHZhciBhZGp1c3RQb3NlcyA9IFtdO1xyXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsQm91bmQgJiYgaXNIb3Jpem9udGFsQm91bmQpIHtcclxuICAgICAgICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0sIFt2ZXJ0aWNhbE9mZnNldCwgMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ZlcnRpY2FsQm91bmQpIHtcclxuICAgICAgICAgICAgYWRqdXN0UG9zZXMucHVzaChbdmVydGljYWxPZmZzZXQsIDBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNIb3Jpem9udGFsQm91bmQpIHtcclxuICAgICAgICAgICAgYWRqdXN0UG9zZXMucHVzaChbMCwgaG9yaXpvbnRhbE9mZnNldF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ZlcnRpY2FsU25hcCAmJiBpc0hvcml6b250YWxTbmFwKSB7XHJcbiAgICAgICAgICAgIGFkanVzdFBvc2VzLnB1c2goWzAsIGhvcml6b250YWxPZmZzZXRdLCBbdmVydGljYWxPZmZzZXQsIDBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNWZXJ0aWNhbFNuYXApIHtcclxuICAgICAgICAgICAgYWRqdXN0UG9zZXMucHVzaChbdmVydGljYWxPZmZzZXQsIDBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNIb3Jpem9udGFsU25hcCkge1xyXG4gICAgICAgICAgICBhZGp1c3RQb3Nlcy5wdXNoKFswLCBob3Jpem9udGFsT2Zmc2V0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGp1c3RQb3Nlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYWRqdXN0UG9zZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChnZXREaXN0U2l6ZShtaW51cyhbZGlzdFgsIGRpc3RZXSwgYSkpIC1cclxuICAgICAgICAgICAgICAgICAgICBnZXREaXN0U2l6ZShtaW51cyhbZGlzdFgsIGRpc3RZXSwgYikpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBhZGp1c3RQb3MgPSBhZGp1c3RQb3Nlc1swXTtcclxuICAgICAgICAgICAgaWYgKGFkanVzdFBvc1swXSAmJiBhYnMoZGlzdFgpID4gVElOWV9OVU0kMSkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IC1hZGp1c3RQb3NbMF07XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZID1cclxuICAgICAgICAgICAgICAgICAgICAoZGlzdFkgKiBhYnMoZGlzdFggKyBvZmZzZXRYKSkgLyBhYnMoZGlzdFgpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWRqdXN0UG9zWzFdICYmIGFicyhkaXN0WSkgPiBUSU5ZX05VTSQxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldkRpc3RZID0gZGlzdFk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gLWFkanVzdFBvc1sxXTtcclxuICAgICAgICAgICAgICAgIG9mZnNldFggPVxyXG4gICAgICAgICAgICAgICAgICAgIChkaXN0WCAqIGFicyhkaXN0WSArIG9mZnNldFkpKSAvIGFicyhwcmV2RGlzdFkpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdFg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRocm90dGxlRHJhZ1JvdGF0ZSAmJiBpc0hvcml6b250YWxCb3VuZCAmJiBpc1ZlcnRpY2FsQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYnMob2Zmc2V0WCkgPiBUSU5ZX05VTSQxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWJzKG9mZnNldFgpIDwgYWJzKHZlcnRpY2FsT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGFicyh2ZXJ0aWNhbE9mZnNldCkgLyBhYnMob2Zmc2V0WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCAqPSBzY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWJzKG9mZnNldFkpID4gVElOWV9OVU0kMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFicyhvZmZzZXRZKSA8IGFicyhob3Jpem9udGFsT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGFicyhob3Jpem9udGFsT2Zmc2V0KSAvIGFicyhvZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYICo9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFkgKj0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYID0gbWF4T2Zmc2V0KC12ZXJ0aWNhbE9mZnNldCwgb2Zmc2V0WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IG1heE9mZnNldCgtaG9yaXpvbnRhbE9mZnNldCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvZmZzZXRYID0gZGlzdFggfHwgaXNWZXJ0aWNhbEJvdW5kID8gLXZlcnRpY2FsT2Zmc2V0IDogMDtcclxuICAgICAgICBvZmZzZXRZID0gZGlzdFkgfHwgaXNIb3Jpem9udGFsQm91bmQgPyAtaG9yaXpvbnRhbE9mZnNldCA6IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW29mZnNldFgsIG9mZnNldFldO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrU25hcEJvdW5kc0RyYWcobW92ZWFibGUsIGRpc3RYLCBkaXN0WSwgdGhyb3R0bGVEcmFnUm90YXRlLCBpZ25vcmVTbmFwLCBkYXRhcykge1xyXG4gICAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcImRyYWdnYWJsZVwiKSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaXNTbmFwOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICB2YXIgcG9zZXMgPSBnZXRBYnNvbHV0ZVBvc2VzKGRhdGFzLmFic29sdXRlUG9zZXMsIFtkaXN0WCwgZGlzdFldKTtcclxuICAgIHZhciBfYSA9IGdldFJlY3QocG9zZXMpLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgdG9wID0gX2EudG9wLCBib3R0b20gPSBfYS5ib3R0b207XHJcbiAgICB2YXIgYm91bmRQb3NlcyA9IHtcclxuICAgICAgICBob3Jpem9udGFsOiBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzFdOyB9KSxcclxuICAgICAgICB2ZXJ0aWNhbDogcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1swXTsgfSksXHJcbiAgICB9O1xyXG4gICAgdmFyIHNuYXBEaXJlY3Rpb25zID0gZ2V0U25hcERpcmVjdGlvbnMobW92ZWFibGUucHJvcHMuc25hcERpcmVjdGlvbnMpO1xyXG4gICAgdmFyIHNuYXBQb3NlcyA9IHNwbGl0U25hcERpcmVjdGlvblBvc2VzKHNuYXBEaXJlY3Rpb25zLCB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICAgICAgY2VudGVyOiAobGVmdCArIHJpZ2h0KSAvIDIsXHJcbiAgICAgICAgbWlkZGxlOiAodG9wICsgYm90dG9tKSAvIDIsXHJcbiAgICB9KTtcclxuICAgIHZhciBfYiA9IGNoZWNrTW92ZWFibGVTbmFwQm91bmRzKG1vdmVhYmxlLCBpZ25vcmVTbmFwLCBzbmFwUG9zZXMsIGJvdW5kUG9zZXMpLCB2ZXJ0aWNhbFNuYXBCb3VuZEluZm8gPSBfYi52ZXJ0aWNhbCwgaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8gPSBfYi5ob3Jpem9udGFsO1xyXG4gICAgdmFyIF9jID0gZ2V0SW5uZXJCb3VuZERyYWdJbmZvKG1vdmVhYmxlLCBwb3NlcywgZGF0YXMpLCB2ZXJ0aWNhbElubmVyQm91bmRJbmZvID0gX2MudmVydGljYWwsIGhvcml6b250YWxJbm5lckJvdW5kSW5mbyA9IF9jLmhvcml6b250YWw7XHJcbiAgICB2YXIgaXNWZXJ0aWNhbFNuYXAgPSB2ZXJ0aWNhbFNuYXBCb3VuZEluZm8uaXNTbmFwO1xyXG4gICAgdmFyIGlzSG9yaXpvbnRhbFNuYXAgPSBob3Jpem9udGFsU25hcEJvdW5kSW5mby5pc1NuYXA7XHJcbiAgICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gdmVydGljYWxTbmFwQm91bmRJbmZvLmlzQm91bmQgfHwgdmVydGljYWxJbm5lckJvdW5kSW5mby5pc0JvdW5kO1xyXG4gICAgdmFyIGlzSG9yaXpvbnRhbEJvdW5kID0gaG9yaXpvbnRhbFNuYXBCb3VuZEluZm8uaXNCb3VuZCB8fCBob3Jpem9udGFsSW5uZXJCb3VuZEluZm8uaXNCb3VuZDtcclxuICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IG1heE9mZnNldCh2ZXJ0aWNhbFNuYXBCb3VuZEluZm8ub2Zmc2V0LCB2ZXJ0aWNhbElubmVyQm91bmRJbmZvLm9mZnNldCk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IG1heE9mZnNldChob3Jpem9udGFsU25hcEJvdW5kSW5mby5vZmZzZXQsIGhvcml6b250YWxJbm5lckJvdW5kSW5mby5vZmZzZXQpO1xyXG4gICAgdmFyIF9kID0gX19yZWFkKGNoZWNrVGhyb3R0bGVEcmFnUm90YXRlKHRocm90dGxlRHJhZ1JvdGF0ZSwgW2Rpc3RYLCBkaXN0WV0sIFtpc1ZlcnRpY2FsQm91bmQsIGlzSG9yaXpvbnRhbEJvdW5kXSwgW2lzVmVydGljYWxTbmFwLCBpc0hvcml6b250YWxTbmFwXSwgW3ZlcnRpY2FsT2Zmc2V0LCBob3Jpem9udGFsT2Zmc2V0XSksIDIpLCBvZmZzZXRYID0gX2RbMF0sIG9mZnNldFkgPSBfZFsxXTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpc0JvdW5kOiBpc1ZlcnRpY2FsQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogaXNWZXJ0aWNhbFNuYXAsXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0WCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaXNCb3VuZDogaXNIb3Jpem9udGFsQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogaXNIb3Jpem9udGFsU25hcCxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRZLFxyXG4gICAgICAgIH0sXHJcbiAgICBdO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrTW92ZWFibGVTbmFwQm91bmRzKG1vdmVhYmxlLCBpZ25vcmVTbmFwLCBwb3NlcywgYm91bmRQb3Nlcykge1xyXG4gICAgaWYgKGJvdW5kUG9zZXMgPT09IHZvaWQgMCkgeyBib3VuZFBvc2VzID0gcG9zZXM7IH1cclxuICAgIHZhciBfYSA9IGNoZWNrQm91bmRQb3NlcyhnZXRCb3VuZHMobW92ZWFibGUpLCBib3VuZFBvc2VzLnZlcnRpY2FsLCBib3VuZFBvc2VzLmhvcml6b250YWwpLCBob3Jpem9udGFsQm91bmRJbmZvcyA9IF9hLmhvcml6b250YWwsIHZlcnRpY2FsQm91bmRJbmZvcyA9IF9hLnZlcnRpY2FsO1xyXG4gICAgdmFyIF9iID0gaWdub3JlU25hcCA/IHtcclxuICAgICAgICBob3Jpem9udGFsOiB7IGlzU25hcDogZmFsc2UsIGluZGV4OiAtMSB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7IGlzU25hcDogZmFsc2UsIGluZGV4OiAtMSB9LFxyXG4gICAgfSA6IGNoZWNrTW92ZWFibGVTbmFwUG9zZXMobW92ZWFibGUsIHBvc2VzLnZlcnRpY2FsLCBwb3Nlcy5ob3Jpem9udGFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpLCBob3Jpem9udGFsU25hcEluZm8gPSBfYi5ob3Jpem9udGFsLCB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWw7XHJcbiAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGdldFNuYXBCb3VuZChob3Jpem9udGFsQm91bmRJbmZvc1swXSwgaG9yaXpvbnRhbFNuYXBJbmZvKTtcclxuICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IGdldFNuYXBCb3VuZCh2ZXJ0aWNhbEJvdW5kSW5mb3NbMF0sIHZlcnRpY2FsU25hcEluZm8pO1xyXG4gICAgdmFyIGhvcml6b250YWxEaXN0ID0gYWJzKGhvcml6b250YWxPZmZzZXQpO1xyXG4gICAgdmFyIHZlcnRpY2FsRGlzdCA9IGFicyh2ZXJ0aWNhbE9mZnNldCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhvcml6b250YWw6IHtcclxuICAgICAgICAgICAgaXNCb3VuZDogaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0uaXNCb3VuZCxcclxuICAgICAgICAgICAgaXNTbmFwOiBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwLFxyXG4gICAgICAgICAgICBzbmFwSW5kZXg6IGhvcml6b250YWxTbmFwSW5mby5pbmRleCxcclxuICAgICAgICAgICAgb2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0LFxyXG4gICAgICAgICAgICBkaXN0OiBob3Jpem9udGFsRGlzdCxcclxuICAgICAgICAgICAgYm91bmRzOiBob3Jpem9udGFsQm91bmRJbmZvcyxcclxuICAgICAgICAgICAgc25hcDogaG9yaXpvbnRhbFNuYXBJbmZvLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmVydGljYWw6IHtcclxuICAgICAgICAgICAgaXNCb3VuZDogdmVydGljYWxCb3VuZEluZm9zWzBdLmlzQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogdmVydGljYWxTbmFwSW5mby5pc1NuYXAsXHJcbiAgICAgICAgICAgIHNuYXBJbmRleDogdmVydGljYWxTbmFwSW5mby5pbmRleCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcclxuICAgICAgICAgICAgZGlzdDogdmVydGljYWxEaXN0LFxyXG4gICAgICAgICAgICBib3VuZHM6IHZlcnRpY2FsQm91bmRJbmZvcyxcclxuICAgICAgICAgICAgc25hcDogdmVydGljYWxTbmFwSW5mbyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHMoZ3VpZGVpbmVzLCBib3VuZHMsIHBvc2VzWCwgcG9zZXNZLCBzbmFwSG9yaXpvbnRhbFRocmVzaG9sZCwgc25hcFZlcnRpY2FsVGhyZXNob2xkLCBtdWx0aXBsZXMpIHtcclxuICAgIGlmIChtdWx0aXBsZXMgPT09IHZvaWQgMCkgeyBtdWx0aXBsZXMgPSBbMSwgMV07IH1cclxuICAgIHZhciBfYSA9IGNoZWNrQm91bmRQb3Nlcyhib3VuZHMsIHBvc2VzWCwgcG9zZXNZKSwgaG9yaXpvbnRhbEJvdW5kSW5mb3MgPSBfYS5ob3Jpem9udGFsLCB2ZXJ0aWNhbEJvdW5kSW5mb3MgPSBfYS52ZXJ0aWNhbDtcclxuICAgIC8vIG9wdGlvbnMuaXNSZXF1ZXN0ID8ge1xyXG4gICAgLy8gICAgIGhvcml6b250YWw6IHsgaXNTbmFwOiBmYWxzZSwgaW5kZXg6IC0xIH0gYXMgU25hcEluZm8sXHJcbiAgICAvLyAgICAgdmVydGljYWw6IHsgaXNTbmFwOiBmYWxzZSwgaW5kZXg6IC0xIH0gYXMgU25hcEluZm8sXHJcbiAgICAvLyB9IDpcclxuICAgIHZhciBfYiA9IGNoZWNrU25hcFBvc2VzKGd1aWRlaW5lcywgcG9zZXNYLCBwb3Nlc1ksIFtdLCBbXSwgc25hcEhvcml6b250YWxUaHJlc2hvbGQsIHNuYXBWZXJ0aWNhbFRocmVzaG9sZCwgbXVsdGlwbGVzKSwgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2IuaG9yaXpvbnRhbCwgdmVydGljYWxTbmFwSW5mbyA9IF9iLnZlcnRpY2FsO1xyXG4gICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBnZXRTbmFwQm91bmQoaG9yaXpvbnRhbEJvdW5kSW5mb3NbMF0sIGhvcml6b250YWxTbmFwSW5mbyk7XHJcbiAgICB2YXIgdmVydGljYWxPZmZzZXQgPSBnZXRTbmFwQm91bmQodmVydGljYWxCb3VuZEluZm9zWzBdLCB2ZXJ0aWNhbFNuYXBJbmZvKTtcclxuICAgIHZhciBob3Jpem9udGFsRGlzdCA9IGFicyhob3Jpem9udGFsT2Zmc2V0KTtcclxuICAgIHZhciB2ZXJ0aWNhbERpc3QgPSBhYnModmVydGljYWxPZmZzZXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3Jpem9udGFsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGhvcml6b250YWxCb3VuZEluZm9zWzBdLmlzQm91bmQsXHJcbiAgICAgICAgICAgIGlzU25hcDogaG9yaXpvbnRhbFNuYXBJbmZvLmlzU25hcCxcclxuICAgICAgICAgICAgc25hcEluZGV4OiBob3Jpem9udGFsU25hcEluZm8uaW5kZXgsXHJcbiAgICAgICAgICAgIG9mZnNldDogaG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgICAgICAgZGlzdDogaG9yaXpvbnRhbERpc3QsXHJcbiAgICAgICAgICAgIGJvdW5kczogaG9yaXpvbnRhbEJvdW5kSW5mb3MsXHJcbiAgICAgICAgICAgIHNuYXA6IGhvcml6b250YWxTbmFwSW5mbyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IHZlcnRpY2FsQm91bmRJbmZvc1swXS5pc0JvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IHZlcnRpY2FsU25hcEluZm8uaXNTbmFwLFxyXG4gICAgICAgICAgICBzbmFwSW5kZXg6IHZlcnRpY2FsU25hcEluZm8uaW5kZXgsXHJcbiAgICAgICAgICAgIG9mZnNldDogdmVydGljYWxPZmZzZXQsXHJcbiAgICAgICAgICAgIGRpc3Q6IHZlcnRpY2FsRGlzdCxcclxuICAgICAgICAgICAgYm91bmRzOiB2ZXJ0aWNhbEJvdW5kSW5mb3MsXHJcbiAgICAgICAgICAgIHNuYXA6IHZlcnRpY2FsU25hcEluZm8sXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwUmlnaHRMaW5lKHN0YXJ0UG9zLCBlbmRQb3MsIHNuYXBCb3VuZEluZm8sIGtlZXBSYXRpbykge1xyXG4gICAgdmFyIHJhZCA9IChnZXRSYWQoc3RhcnRQb3MsIGVuZFBvcykgLyBNYXRoLlBJKSAqIDE4MDtcclxuICAgIHZhciBfYSA9IHNuYXBCb3VuZEluZm8udmVydGljYWwsIGlzVmVydGljYWxCb3VuZCA9IF9hLmlzQm91bmQsIGlzVmVydGljYWxTbmFwID0gX2EuaXNTbmFwLCB2ZXJ0aWNhbERpc3QgPSBfYS5kaXN0LCBfYiA9IHNuYXBCb3VuZEluZm8uaG9yaXpvbnRhbCwgaXNIb3Jpem9udGFsQm91bmQgPSBfYi5pc0JvdW5kLCBpc0hvcml6b250YWxTbmFwID0gX2IuaXNTbmFwLCBob3Jpem9udGFsRGlzdCA9IF9iLmRpc3Q7XHJcbiAgICB2YXIgcmFkMTgwID0gcmFkICUgMTgwO1xyXG4gICAgdmFyIGlzSG9yaXpvbnRhbExpbmUgPSByYWQxODAgPCAzIHx8IHJhZDE4MCA+IDE3NztcclxuICAgIHZhciBpc1ZlcnRpY2FsTGluZSA9IHJhZDE4MCA+IDg3ICYmIHJhZDE4MCA8IDkzO1xyXG4gICAgaWYgKGhvcml6b250YWxEaXN0IDwgdmVydGljYWxEaXN0KSB7XHJcbiAgICAgICAgaWYgKGlzVmVydGljYWxCb3VuZCB8fFxyXG4gICAgICAgICAgICAoaXNWZXJ0aWNhbFNuYXAgJiZcclxuICAgICAgICAgICAgICAgICFpc1ZlcnRpY2FsTGluZSAmJlxyXG4gICAgICAgICAgICAgICAgKCFrZWVwUmF0aW8gfHwgIWlzSG9yaXpvbnRhbExpbmUpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0hvcml6b250YWxCb3VuZCB8fFxyXG4gICAgICAgIChpc0hvcml6b250YWxTbmFwICYmXHJcbiAgICAgICAgICAgICFpc0hvcml6b250YWxMaW5lICYmXHJcbiAgICAgICAgICAgICgha2VlcFJhdGlvIHx8ICFpc1ZlcnRpY2FsTGluZSkpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiXCI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U25hcEJvdW5kSW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbnMsIGtlZXBSYXRpbywgaXNSZXF1ZXN0LCBkYXRhcykge1xyXG4gICAgcmV0dXJuIGRpcmVjdGlvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHN0YXJ0RGlyZWN0aW9uID0gX2JbMF0sIGVuZERpcmVjdGlvbiA9IF9iWzFdO1xyXG4gICAgICAgIHZhciBvdGhlclN0YXJ0UG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIHN0YXJ0RGlyZWN0aW9uKTtcclxuICAgICAgICB2YXIgb3RoZXJFbmRQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihwb3NlcywgZW5kRGlyZWN0aW9uKTtcclxuICAgICAgICB2YXIgc25hcEJvdW5kSW5mbyA9IGtlZXBSYXRpb1xyXG4gICAgICAgICAgICA/IGNoZWNrU25hcEJvdW5kc0tlZXBSYXRpbyhtb3ZlYWJsZSwgb3RoZXJTdGFydFBvcywgb3RoZXJFbmRQb3MsIGlzUmVxdWVzdClcclxuICAgICAgICAgICAgOiBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogW290aGVyRW5kUG9zWzBdXSxcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IFtvdGhlckVuZFBvc1sxXV0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfYyA9IHNuYXBCb3VuZEluZm8uaG9yaXpvbnRhbCwgXHJcbiAgICAgICAgLy8gZGlzdDogb3RoZXJIb3Jpem9udGFsRGlzdCxcclxuICAgICAgICBvdGhlckhvcml6b250YWxPZmZzZXQgPSBfYy5vZmZzZXQsIGlzT3RoZXJIb3Jpem9udGFsQm91bmQgPSBfYy5pc0JvdW5kLCBpc090aGVySG9yaXpvbnRhbFNuYXAgPSBfYy5pc1NuYXAsIF9kID0gc25hcEJvdW5kSW5mby52ZXJ0aWNhbCwgXHJcbiAgICAgICAgLy8gZGlzdDogb3RoZXJWZXJ0aWNhbERpc3QsXHJcbiAgICAgICAgb3RoZXJWZXJ0aWNhbE9mZnNldCA9IF9kLm9mZnNldCwgaXNPdGhlclZlcnRpY2FsQm91bmQgPSBfZC5pc0JvdW5kLCBpc090aGVyVmVydGljYWxTbmFwID0gX2QuaXNTbmFwO1xyXG4gICAgICAgIHZhciBtdWx0aXBsZSA9IG1pbnVzKGVuZERpcmVjdGlvbiwgc3RhcnREaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmICghb3RoZXJWZXJ0aWNhbE9mZnNldCAmJiAhb3RoZXJIb3Jpem9udGFsT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc0JvdW5kOiBpc090aGVyVmVydGljYWxCb3VuZCB8fCBpc090aGVySG9yaXpvbnRhbEJvdW5kLFxyXG4gICAgICAgICAgICAgICAgaXNTbmFwOiBpc090aGVyVmVydGljYWxTbmFwIHx8IGlzT3RoZXJIb3Jpem9udGFsU25hcCxcclxuICAgICAgICAgICAgICAgIHNpZ246IG11bHRpcGxlLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzbmFwTGluZSA9IGNoZWNrU25hcFJpZ2h0TGluZShvdGhlclN0YXJ0UG9zLCBvdGhlckVuZFBvcywgc25hcEJvdW5kSW5mbywga2VlcFJhdGlvKTtcclxuICAgICAgICBpZiAoIXNuYXBMaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzaWduOiBtdWx0aXBsZSxcclxuICAgICAgICAgICAgICAgIGlzQm91bmQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNTbmFwOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogWzAsIDBdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IHNuYXBMaW5lID09PSBcInZlcnRpY2FsXCI7XHJcbiAgICAgICAgdmFyIHNpemVPZmZzZXQgPSBbMCwgMF07XHJcbiAgICAgICAgaWYgKCFrZWVwUmF0aW9cclxuICAgICAgICAgICAgJiYgYWJzKGVuZERpcmVjdGlvblswXSkgPT09IDFcclxuICAgICAgICAgICAgJiYgYWJzKGVuZERpcmVjdGlvblsxXSkgPT09IDFcclxuICAgICAgICAgICAgJiYgc3RhcnREaXJlY3Rpb25bMF0gIT09IGVuZERpcmVjdGlvblswXVxyXG4gICAgICAgICAgICAmJiBzdGFydERpcmVjdGlvblsxXSAhPT0gZW5kRGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgIHNpemVPZmZzZXQgPSBnZXREcmFnRGlzdCh7XHJcbiAgICAgICAgICAgICAgICBkYXRhczogZGF0YXMsXHJcbiAgICAgICAgICAgICAgICBkaXN0WDogLW90aGVyVmVydGljYWxPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBkaXN0WTogLW90aGVySG9yaXpvbnRhbE9mZnNldCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzaXplT2Zmc2V0ID0gc29sdmVOZXh0T2Zmc2V0KG90aGVyU3RhcnRQb3MsIG90aGVyRW5kUG9zLCAtKGlzVmVydGljYWwgPyBvdGhlclZlcnRpY2FsT2Zmc2V0IDogb3RoZXJIb3Jpem9udGFsT2Zmc2V0KSwgaXNWZXJ0aWNhbCwgZGF0YXMpLm9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2l6ZU9mZnNldCA9IHNpemVPZmZzZXQubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7IHJldHVybiBzaXplICogKG11bHRpcGxlW2ldID8gMiAvIG11bHRpcGxlW2ldIDogMCk7IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNpZ246IG11bHRpcGxlLFxyXG4gICAgICAgICAgICBpc0JvdW5kOiBpc1ZlcnRpY2FsID8gaXNPdGhlclZlcnRpY2FsQm91bmQgOiBpc090aGVySG9yaXpvbnRhbEJvdW5kLFxyXG4gICAgICAgICAgICBpc1NuYXA6IGlzVmVydGljYWwgPyBpc090aGVyVmVydGljYWxTbmFwIDogaXNPdGhlckhvcml6b250YWxTbmFwLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHNpemVPZmZzZXQsXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNuYXBCb3VuZE9mZnNldChib3VuZEluZm8sIHNuYXBJbmZvKSB7XHJcbiAgICBpZiAoYm91bmRJbmZvLmlzQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gYm91bmRJbmZvLm9mZnNldDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNuYXBJbmZvLmlzU25hcCkge1xyXG4gICAgICAgIHJldHVybiBzbmFwSW5mby5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBCb3VuZHNLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MsIGlzUmVxdWVzdCkge1xyXG4gICAgdmFyIF9hID0gY2hlY2tCb3VuZEtlZXBSYXRpbyhtb3ZlYWJsZSwgc3RhcnRQb3MsIGVuZFBvcyksIGhvcml6b250YWxCb3VuZEluZm8gPSBfYS5ob3Jpem9udGFsLCB2ZXJ0aWNhbEJvdW5kSW5mbyA9IF9hLnZlcnRpY2FsO1xyXG4gICAgdmFyIF9iID0gaXNSZXF1ZXN0ID8ge1xyXG4gICAgICAgIGhvcml6b250YWw6IHsgaXNTbmFwOiBmYWxzZSB9LFxyXG4gICAgICAgIHZlcnRpY2FsOiB7IGlzU25hcDogZmFsc2UgfSxcclxuICAgIH0gOiBjaGVja1NuYXBLZWVwUmF0aW8obW92ZWFibGUsIHN0YXJ0UG9zLCBlbmRQb3MpLCBob3Jpem9udGFsU25hcEluZm8gPSBfYi5ob3Jpem9udGFsLCB2ZXJ0aWNhbFNuYXBJbmZvID0gX2IudmVydGljYWw7XHJcbiAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGdldFNuYXBCb3VuZE9mZnNldChob3Jpem9udGFsQm91bmRJbmZvLCBob3Jpem9udGFsU25hcEluZm8pO1xyXG4gICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gZ2V0U25hcEJvdW5kT2Zmc2V0KHZlcnRpY2FsQm91bmRJbmZvLCB2ZXJ0aWNhbFNuYXBJbmZvKTtcclxuICAgIHZhciBob3Jpem9udGFsRGlzdCA9IGFicyhob3Jpem9udGFsT2Zmc2V0KTtcclxuICAgIHZhciB2ZXJ0aWNhbERpc3QgPSBhYnModmVydGljYWxPZmZzZXQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3Jpem9udGFsOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IGhvcml6b250YWxCb3VuZEluZm8uaXNCb3VuZCxcclxuICAgICAgICAgICAgaXNTbmFwOiBob3Jpem9udGFsU25hcEluZm8uaXNTbmFwLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgICAgICAgIGRpc3Q6IGhvcml6b250YWxEaXN0LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmVydGljYWw6IHtcclxuICAgICAgICAgICAgaXNCb3VuZDogdmVydGljYWxCb3VuZEluZm8uaXNCb3VuZCxcclxuICAgICAgICAgICAgaXNTbmFwOiB2ZXJ0aWNhbFNuYXBJbmZvLmlzU25hcCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcclxuICAgICAgICAgICAgZGlzdDogdmVydGljYWxEaXN0LFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrTWF4Qm91bmRzKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcykge1xyXG4gICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gWy1kaXJlY3Rpb25bMF0sIC1kaXJlY3Rpb25bMV1dO1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIHZhciBib3VuZHMgPSBtb3ZlYWJsZS5wcm9wcy5ib3VuZHM7XHJcbiAgICB2YXIgbWF4V2lkdGggPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhIZWlnaHQgPSBJbmZpbml0eTtcclxuICAgIGlmIChib3VuZHMpIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IFtcclxuICAgICAgICAgICAgW2RpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0sXHJcbiAgICAgICAgICAgIFstZGlyZWN0aW9uWzBdLCBkaXJlY3Rpb25bMV1dLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIF9iID0gYm91bmRzLmxlZnQsIGxlZnRfMSA9IF9iID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfYiwgX2MgPSBib3VuZHMudG9wLCB0b3BfMSA9IF9jID09PSB2b2lkIDAgPyAtSW5maW5pdHkgOiBfYywgX2QgPSBib3VuZHMucmlnaHQsIHJpZ2h0XzEgPSBfZCA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZCwgX2UgPSBib3VuZHMuYm90dG9tLCBib3R0b21fMSA9IF9lID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9lO1xyXG4gICAgICAgIGRpcmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3RoZXJEaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGlzQ2hlY2tWZXJ0aWNhbCA9IG90aGVyRGlyZWN0aW9uWzBdICE9PSBmaXhlZERpcmVjdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIGlzQ2hlY2tIb3Jpem9udGFsID0gb3RoZXJEaXJlY3Rpb25bMV0gIT09IGZpeGVkRGlyZWN0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSBnZXRQb3NCeURpcmVjdGlvbihwb3Nlcywgb3RoZXJEaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICB2YXIgZGVnID0gKGdldFJhZChmaXhlZFBvc2l0aW9uLCBvdGhlclBvcykgKiAzNjApIC8gTWF0aC5QSTtcclxuICAgICAgICAgICAgaWYgKGlzQ2hlY2tIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dE90aGVyUG9zID0gb3RoZXJQb3Muc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhYnMoZGVnIC0gMzYwKSA8IDIgfHwgYWJzKGRlZyAtIDE4MCkgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE90aGVyUG9zWzFdID0gZml4ZWRQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNvbHZlTmV4dE9mZnNldChmaXhlZFBvc2l0aW9uLCBuZXh0T3RoZXJQb3MsIChmaXhlZFBvc2l0aW9uWzFdIDwgb3RoZXJQb3NbMV0gPyBib3R0b21fMSA6IHRvcF8xKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJQb3NbMV0sIGZhbHNlLCBkYXRhcyksIF9iID0gX19yZWFkKF9hLm9mZnNldCwgMiksIGhlaWdodE9mZnNldCA9IF9iWzFdLCBpc0hlaWdodE91dHNpZGUgPSBfYS5pc091dHNpZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGhlaWdodE9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHQgKyAoaXNIZWlnaHRPdXRzaWRlID8gMSA6IC0xKSAqIGFicyhoZWlnaHRPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0NoZWNrVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0T3RoZXJQb3MgPSBvdGhlclBvcy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFicyhkZWcgLSA5MCkgPCAyIHx8IGFicyhkZWcgLSAyNzApIDwgMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRPdGhlclBvc1swXSA9IGZpeGVkUG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBzb2x2ZU5leHRPZmZzZXQoZml4ZWRQb3NpdGlvbiwgbmV4dE90aGVyUG9zLCAoZml4ZWRQb3NpdGlvblswXSA8IG90aGVyUG9zWzBdID8gcmlnaHRfMSA6IGxlZnRfMSkgLSBvdGhlclBvc1swXSwgdHJ1ZSwgZGF0YXMpLCBfZCA9IF9fcmVhZChfYy5vZmZzZXQsIDEpLCB3aWR0aE9mZnNldCA9IF9kWzBdLCBpc1dpZHRoT3V0c2lkZSA9IF9jLmlzT3V0c2lkZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4od2lkdGhPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggPSB3aWR0aCArIChpc1dpZHRoT3V0c2lkZSA/IDEgOiAtMSkgKiBhYnMod2lkdGhPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1heFdpZHRoOiBtYXhXaWR0aCxcclxuICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCxcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgRHJhZ2dhYmxlXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gRHJhZ2dhYmxlIHJlZmVycyB0byB0aGUgYWJpbGl0eSB0byBkcmFnIGFuZCBtb3ZlIHRhcmdldHMuXHJcbiAqL1xyXG52YXIgRHJhZ2dhYmxlID0ge1xyXG4gICAgbmFtZTogXCJkcmFnZ2FibGVcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJkcmFnZ2FibGVcIixcclxuICAgICAgICBcInRocm90dGxlRHJhZ1wiLFxyXG4gICAgICAgIFwidGhyb3R0bGVEcmFnUm90YXRlXCIsXHJcbiAgICAgICAgXCJoaWRlVGhyb3R0bGVEcmFnUm90YXRlTGluZVwiLFxyXG4gICAgICAgIFwic3RhcnREcmFnUm90YXRlXCIsXHJcbiAgICAgICAgXCJlZGdlRHJhZ2dhYmxlXCIsXHJcbiAgICBdLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICAgXCJkcmFnU3RhcnRcIixcclxuICAgICAgICBcImRyYWdcIixcclxuICAgICAgICBcImRyYWdFbmRcIixcclxuICAgICAgICBcImRyYWdHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJkcmFnR3JvdXBcIixcclxuICAgICAgICBcImRyYWdHcm91cEVuZFwiLFxyXG4gICAgXSxcclxuICAgIHJlcXVlc3RTdHlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl07XHJcbiAgICB9LFxyXG4gICAgcmVxdWVzdENoaWxkU3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1wibGVmdFwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCBoaWRlVGhyb3R0bGVEcmFnUm90YXRlTGluZSA9IF9hLmhpZGVUaHJvdHRsZURyYWdSb3RhdGVMaW5lLCB0aHJvdHRsZURyYWdSb3RhdGUgPSBfYS50aHJvdHRsZURyYWdSb3RhdGUsIHpvb20gPSBfYS56b29tO1xyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLmdldFN0YXRlKCksIGRyYWdJbmZvID0gX2IuZHJhZ0luZm8sIGJlZm9yZU9yaWdpbiA9IF9iLmJlZm9yZU9yaWdpbjtcclxuICAgICAgICBpZiAoaGlkZVRocm90dGxlRHJhZ1JvdGF0ZUxpbmUgfHwgIXRocm90dGxlRHJhZ1JvdGF0ZSB8fCAhZHJhZ0luZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlzdCA9IGRyYWdJbmZvLmRpc3Q7XHJcbiAgICAgICAgaWYgKCFkaXN0WzBdICYmICFkaXN0WzFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0RGlzdFNpemUoZGlzdCk7XHJcbiAgICAgICAgdmFyIHJhZCA9IGdldFJhZChkaXN0LCBbMCwgMF0pO1xyXG4gICAgICAgIHJldHVybiBbUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiLCBcImhvcml6b250YWxcIiwgXCJkcmFnbGluZVwiLCBcImRhc2hlZFwiKSwga2V5OiBcImRyYWdSb3RhdGVHdWlkZWxpbmVcIiwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoYmVmb3JlT3JpZ2luWzBdLCBcInB4LCBcIikuY29uY2F0KGJlZm9yZU9yaWdpblsxXSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocmFkLCBcInJhZCkgc2NhbGVZKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgfSB9KV07XHJcbiAgICB9LFxyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQsIHBhcmVudEdlc3RvID0gZS5wYXJlbnRHZXN0bztcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgZ2VzdG9zID0gc3RhdGUuZ2VzdG9zLCBzdHlsZSA9IHN0YXRlLnN0eWxlO1xyXG4gICAgICAgIGlmIChnZXN0b3MuZHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2VzdG9zLmRyYWdnYWJsZSA9IHBhcmVudEdlc3RvIHx8IG1vdmVhYmxlLnRhcmdldEdlc3RvO1xyXG4gICAgICAgIGRhdGFzLmRhdGFzID0ge307XHJcbiAgICAgICAgZGF0YXMubGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUubGVmdCB8fCBcIlwiKSB8fCAwO1xyXG4gICAgICAgIGRhdGFzLnRvcCA9IHBhcnNlRmxvYXQoc3R5bGUudG9wIHx8IFwiXCIpIHx8IDA7XHJcbiAgICAgICAgZGF0YXMuYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5ib3R0b20gfHwgXCJcIikgfHwgMDtcclxuICAgICAgICBkYXRhcy5yaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUucmlnaHQgfHwgXCJcIikgfHwgMDtcclxuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gWzAsIDBdO1xyXG4gICAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgc2V0RGVmYXVsdFRyYW5zZm9ybUluZGV4KG1vdmVhYmxlLCBlLCBcInRyYW5zbGF0ZVwiKTtcclxuICAgICAgICBzdGFydENoZWNrU25hcERyYWcobW92ZWFibGUsIGRhdGFzKTtcclxuICAgICAgICBkYXRhcy5wcmV2RGlzdCA9IFswLCAwXTtcclxuICAgICAgICBkYXRhcy5wcmV2QmVmb3JlRGlzdCA9IFswLCAwXTtcclxuICAgICAgICBkYXRhcy5pc0RyYWcgPSBmYWxzZTtcclxuICAgICAgICBkYXRhcy5kZWx0YU9mZnNldCA9IFswLCAwXTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyBzZXQ6IGZ1bmN0aW9uICh0cmFuc2xhdGUpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSB0cmFuc2xhdGU7XHJcbiAgICAgICAgICAgIH0gfSwgZmlsbFRyYW5zZm9ybVN0YXJ0RXZlbnQobW92ZWFibGUsIGUpKSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcmVudEV2ZW50IHx8IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdTdGFydFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmlzRHJhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlLnN0YXRlLmRyYWdJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRSZWN0OiBtb3ZlYWJsZS5nZXRSZWN0KCksXHJcbiAgICAgICAgICAgICAgICBkaXN0OiBbMCwgMF0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZXN0b3MuZHJhZ2dhYmxlID0gbnVsbDtcclxuICAgICAgICAgICAgZGF0YXMuaXNQaW5jaCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNEcmFnID8gcGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBlLCBcInRyYW5zbGF0ZVwiKTtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQsIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsIGlzUGluY2ggPSBlLmlzUGluY2gsIGRlbHRhT2Zmc2V0ID0gZS5kZWx0YU9mZnNldCwgdXNlU25hcCA9IGUudXNlU25hcCwgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3QsIGlzR3JvdXAgPSBlLmlzR3JvdXAsIHBhcmVudFRocm90dGxlRHJhZyA9IGUucGFyZW50VGhyb3R0bGVEcmFnO1xyXG4gICAgICAgIHZhciBkaXN0WCA9IGUuZGlzdFgsIGRpc3RZID0gZS5kaXN0WTtcclxuICAgICAgICB2YXIgaXNEcmFnID0gZGF0YXMuaXNEcmFnLCBwcmV2RGlzdCA9IGRhdGFzLnByZXZEaXN0LCBwcmV2QmVmb3JlRGlzdCA9IGRhdGFzLnByZXZCZWZvcmVEaXN0LCBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZTtcclxuICAgICAgICBpZiAoIWlzRHJhZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWx0YU9mZnNldCkge1xyXG4gICAgICAgICAgICBkaXN0WCArPSBkZWx0YU9mZnNldFswXTtcclxuICAgICAgICAgICAgZGlzdFkgKz0gZGVsdGFPZmZzZXRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IHByb3BzLnBhcmVudE1vdmVhYmxlO1xyXG4gICAgICAgIHZhciB0aHJvdHRsZURyYWcgPSBpc0dyb3VwID8gMCA6IChwcm9wcy50aHJvdHRsZURyYWcgfHwgcGFyZW50VGhyb3R0bGVEcmFnIHx8IDApO1xyXG4gICAgICAgIHZhciB0aHJvdHRsZURyYWdSb3RhdGUgPSBwYXJlbnRFdmVudCA/IDAgOiAocHJvcHMudGhyb3R0bGVEcmFnUm90YXRlIHx8IDApO1xyXG4gICAgICAgIHZhciBkcmFnUm90YXRlUmFkID0gMDtcclxuICAgICAgICB2YXIgaXNWZXJ0aWNhbFNuYXAgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaXNWZXJ0aWNhbEJvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbFNuYXAgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaXNIb3Jpem9udGFsQm91bmQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXBhcmVudEV2ZW50ICYmIHRocm90dGxlRHJhZ1JvdGF0ZSA+IDAgJiYgKGRpc3RYIHx8IGRpc3RZKSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnREcmFnUm90YXRlID0gcHJvcHMuc3RhcnREcmFnUm90YXRlIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBkZWcgPSB0aHJvdHRsZShzdGFydERyYWdSb3RhdGUgKyBnZXRSYWQoWzAsIDBdLCBbZGlzdFgsIGRpc3RZXSkgKiAxODAgLyBNYXRoLlBJLCB0aHJvdHRsZURyYWdSb3RhdGUpXHJcbiAgICAgICAgICAgICAgICAtIHN0YXJ0RHJhZ1JvdGF0ZTtcclxuICAgICAgICAgICAgdmFyIHJ5ID0gZGlzdFkgKiBNYXRoLmFicyhNYXRoLmNvcygoZGVnIC0gOTApIC8gMTgwICogTWF0aC5QSSkpO1xyXG4gICAgICAgICAgICB2YXIgcnggPSBkaXN0WCAqIE1hdGguYWJzKE1hdGguY29zKGRlZyAvIDE4MCAqIE1hdGguUEkpKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBnZXREaXN0U2l6ZShbcngsIHJ5XSk7XHJcbiAgICAgICAgICAgIGRyYWdSb3RhdGVSYWQgPSBkZWcgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICBkaXN0WCA9IHIgKiBNYXRoLmNvcyhkcmFnUm90YXRlUmFkKTtcclxuICAgICAgICAgICAgZGlzdFkgPSByICogTWF0aC5zaW4oZHJhZ1JvdGF0ZVJhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNQaW5jaCAmJiAhcGFyZW50RXZlbnQgJiYgIXBhcmVudEZsYWcpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGNoZWNrU25hcEJvdW5kc0RyYWcobW92ZWFibGUsIGRpc3RYLCBkaXN0WSwgdGhyb3R0bGVEcmFnUm90YXRlLCAoIXVzZVNuYXAgJiYgaXNSZXF1ZXN0KSB8fCBkZWx0YU9mZnNldCwgZGF0YXMpLCAyKSwgdmVydGljYWxJbmZvID0gX2FbMF0sIGhvcml6b250YWxJbmZvID0gX2FbMV07XHJcbiAgICAgICAgICAgIGlzVmVydGljYWxTbmFwID0gdmVydGljYWxJbmZvLmlzU25hcDtcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbEJvdW5kID0gdmVydGljYWxJbmZvLmlzQm91bmQ7XHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbFNuYXAgPSBob3Jpem9udGFsSW5mby5pc1NuYXA7XHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbEJvdW5kID0gaG9yaXpvbnRhbEluZm8uaXNCb3VuZDtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxJbmZvLm9mZnNldDtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBob3Jpem9udGFsSW5mby5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGRpc3RYICs9IHZlcnRpY2FsT2Zmc2V0O1xyXG4gICAgICAgICAgICBkaXN0WSArPSBob3Jpem9udGFsT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmVmb3JlVHJhbnNsYXRlID0gcGx1cyhnZXRCZWZvcmVEcmFnRGlzdCh7IGRhdGFzOiBkYXRhcywgZGlzdFg6IGRpc3RYLCBkaXN0WTogZGlzdFkgfSksIHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSBwbHVzKGdldFRyYW5zZm9ybURpc3QoeyBkYXRhczogZGF0YXMsIGRpc3RYOiBkaXN0WCwgZGlzdFk6IGRpc3RZIH0pLCBzdGFydFZhbHVlKTtcclxuICAgICAgICB0aHJvdHRsZUFycmF5KHRyYW5zbGF0ZSwgVElOWV9OVU0pO1xyXG4gICAgICAgIHRocm90dGxlQXJyYXkoYmVmb3JlVHJhbnNsYXRlLCBUSU5ZX05VTSk7XHJcbiAgICAgICAgaWYgKCF0aHJvdHRsZURyYWdSb3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1ZlcnRpY2FsU25hcCAmJiAhaXNWZXJ0aWNhbEJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVbMF0gPSB0aHJvdHRsZSh0cmFuc2xhdGVbMF0sIHRocm90dGxlRHJhZyk7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVUcmFuc2xhdGVbMF0gPSB0aHJvdHRsZShiZWZvcmVUcmFuc2xhdGVbMF0sIHRocm90dGxlRHJhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0hvcml6b250YWxTbmFwICYmICFpc0hvcml6b250YWxCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWzFdID0gdGhyb3R0bGUodHJhbnNsYXRlWzFdLCB0aHJvdHRsZURyYWcpO1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlVHJhbnNsYXRlWzFdID0gdGhyb3R0bGUoYmVmb3JlVHJhbnNsYXRlWzFdLCB0aHJvdHRsZURyYWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiZWZvcmVEaXN0ID0gbWludXMoYmVmb3JlVHJhbnNsYXRlLCBzdGFydFZhbHVlKTtcclxuICAgICAgICB2YXIgZGlzdCA9IG1pbnVzKHRyYW5zbGF0ZSwgc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gbWludXMoZGlzdCwgcHJldkRpc3QpO1xyXG4gICAgICAgIHZhciBiZWZvcmVEZWx0YSA9IG1pbnVzKGJlZm9yZURpc3QsIHByZXZCZWZvcmVEaXN0KTtcclxuICAgICAgICBkYXRhcy5wcmV2RGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgZGF0YXMucHJldkJlZm9yZURpc3QgPSBiZWZvcmVEaXN0O1xyXG4gICAgICAgIGRhdGFzLnBhc3NEZWx0YSA9IGRlbHRhOyAvL2Rpc3RYIC0gKGRhdGFzLnBhc3NEaXN0WCB8fCAwKTtcclxuICAgICAgICAvLyBkYXRhcy5wYXNzRGVsdGFZID0gZGlzdFkgLSAoZGF0YXMucGFzc0Rpc3RZIHx8IDApO1xyXG4gICAgICAgIGRhdGFzLnBhc3NEaXN0ID0gZGlzdDsgLy9kaXN0WDtcclxuICAgICAgICAvLyBkYXRhcy5wYXNzRGlzdFkgPSBkaXN0WTtcclxuICAgICAgICB2YXIgbGVmdCA9IGRhdGFzLmxlZnQgKyBiZWZvcmVEaXN0WzBdO1xyXG4gICAgICAgIHZhciB0b3AgPSBkYXRhcy50b3AgKyBiZWZvcmVEaXN0WzFdO1xyXG4gICAgICAgIHZhciByaWdodCA9IGRhdGFzLnJpZ2h0IC0gYmVmb3JlRGlzdFswXTtcclxuICAgICAgICB2YXIgYm90dG9tID0gZGF0YXMuYm90dG9tIC0gYmVmb3JlRGlzdFsxXTtcclxuICAgICAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIFwidHJhbnNsYXRlKFwiLmNvbmNhdCh0cmFuc2xhdGVbMF0sIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWzFdLCBcInB4KVwiKSwgXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGRpc3RbMF0sIFwicHgsIFwiKS5jb25jYXQoZGlzdFsxXSwgXCJweClcIikpO1xyXG4gICAgICAgIGZpbGxPcmlnaW5hbFRyYW5zZm9ybShlLCBuZXh0VHJhbnNmb3JtKTtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mby5kaXN0ID0gcGFyZW50RXZlbnQgPyBbMCwgMF0gOiBkaXN0O1xyXG4gICAgICAgIGlmICghcGFyZW50RXZlbnQgJiYgIXBhcmVudE1vdmVhYmxlICYmIGRlbHRhLmV2ZXJ5KGZ1bmN0aW9uIChudW0pIHsgcmV0dXJuICFudW07IH0pICYmIGJlZm9yZURlbHRhLnNvbWUoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gIW51bTsgfSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5zdGF0ZSwgd2lkdGggPSBfYi53aWR0aCwgaGVpZ2h0ID0gX2IuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSwgZGlzdDogZGlzdCwgZGVsdGE6IGRlbHRhLCB0cmFuc2xhdGU6IHRyYW5zbGF0ZSwgYmVmb3JlRGlzdDogYmVmb3JlRGlzdCwgYmVmb3JlRGVsdGE6IGJlZm9yZURlbHRhLCBiZWZvcmVUcmFuc2xhdGU6IGJlZm9yZVRyYW5zbGF0ZSwgbGVmdDogbGVmdCwgdG9wOiB0b3AsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGlzUGluY2g6IGlzUGluY2ggfSwgZmlsbENTU09iamVjdCh7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSxcclxuICAgICAgICB9LCBlKSkpO1xyXG4gICAgICAgICFwYXJlbnRFdmVudCAmJiB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnXCIsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnQWZ0ZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgdmFyIGRlbHRhT2Zmc2V0ID0gZGF0YXMuZGVsdGFPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGRlbHRhT2Zmc2V0WzBdIHx8IGRlbHRhT2Zmc2V0WzFdKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmRlbHRhT2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgZGVsdGFPZmZzZXQ6IGRlbHRhT2Zmc2V0IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnRFdmVudCA9IGUucGFyZW50RXZlbnQsIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnSW5mbyA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc0RyYWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5pc0RyYWcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcGFyYW0gPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XHJcbiAgICAgICAgIXBhcmVudEV2ZW50ICYmIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkRyYWdFbmRcIiwgcGFyYW0pO1xyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBjbGllbnRYID0gZS5jbGllbnRYLCBjbGllbnRZID0gZS5jbGllbnRZO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2MgPSB0cmlnZ2VyQ2hpbGRHZXN0byhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnU3RhcnRcIiwgW1xyXG4gICAgICAgICAgICBjbGllbnRYIHx8IDAsXHJcbiAgICAgICAgICAgIGNsaWVudFkgfHwgMCxcclxuICAgICAgICBdLCBlLCBmYWxzZSwgXCJkcmFnZ2FibGVcIiksIGNoaWxkRXZlbnRzID0gX2MuY2hpbGRFdmVudHMsIGV2ZW50UGFyYW1zID0gX2MuZXZlbnRQYXJhbXM7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50UGFyYW1zIH0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnR3JvdXBTdGFydFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICBkYXRhcy5pc0RyYWcgPSByZXN1bHQgIT09IGZhbHNlO1xyXG4gICAgICAgIC8vIGZpbmQgZGF0YS5zdGFydFZhbHVlIGFuZCBiYXNlZCBvbiBmaXJzdCBjaGlsZCBtb3ZlYWJsZVxyXG4gICAgICAgIHZhciBzdGFydFZhbHVlID0gKF9iID0gKF9hID0gY2hpbGRFdmVudHNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhcy5zdGFydFZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbMCwgMF07XHJcbiAgICAgICAgZGF0YXMudGhyb3R0bGVPZmZzZXQgPSBbc3RhcnRWYWx1ZVswXSAlIDEsIHN0YXJ0VmFsdWVbMV0gJSAxXTtcclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNEcmFnID8gcGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNEcmFnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZyhtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHBhcmVudFRocm90dGxlRHJhZzogbW92ZWFibGUucHJvcHMudGhyb3R0bGVEcmFnIH0pKTtcclxuICAgICAgICB2YXIgcGFzc0RlbHRhID0gZS5kYXRhcy5wYXNzRGVsdGE7XHJcbiAgICAgICAgdmFyIGV2ZW50UGFyYW1zID0gdHJpZ2dlckNoaWxkR2VzdG8obW92ZWFibGUsIHRoaXMsIFwiZHJhZ1wiLCBwYXNzRGVsdGEsIGUsIGZhbHNlLCBcImRyYWdnYWJsZVwiKS5ldmVudFBhcmFtcztcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50UGFyYW1zIH0sIHBhcmFtcyk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0dyb3VwXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0UGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLCBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc0RyYWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHZhciBldmVudFBhcmFtcyA9IHRyaWdnZXJDaGlsZEdlc3RvKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdFbmRcIiwgWzAsIDBdLCBlLCBmYWxzZSwgXCJkcmFnZ2FibGVcIikuZXZlbnRQYXJhbXM7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ0dyb3VwRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcclxuICAgICAgICAgICAgZXZlbnRzOiBldmVudFBhcmFtcyxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGlzRHJhZztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUuRHJhZ2dhYmxlI3JlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZV0gLSB0aGUgZHJhZ2dhYmxlJ3MgcmVxdWVzdCBwYXJhbWV0ZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS54XSAtIHggcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS55XSAtIHkgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5kZWx0YVhdIC0gWCBudW1iZXIgdG8gbW92ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWV0gLSBZIG51bWJlciB0byBtb3ZlXHJcbiAgICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxyXG4gICAgICogQGV4YW1wbGVcclxuXG4gICAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxyXG4gICAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXHJcbiAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwiZHJhZ2dhYmxlXCIsIHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9LCB0cnVlKTtcclxuICAgICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0sIHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RTdGFydFxyXG4gICAgICogY29uc3QgcmVxdWVzdGVyID0gbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0XHJcbiAgICAgKiAvLyBVc2UgUmVsYXRpdmUgVmFsdWVcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcclxuICAgICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0pO1xyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDIyMCwgeTogMTAwIH0pO1xyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcImRyYWdnYWJsZVwiLCB7IHg6IDI0MCwgeTogMTAwIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RFbmRcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IHt9O1xyXG4gICAgICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIHZhciBkaXN0WCA9IDA7XHJcbiAgICAgICAgdmFyIGRpc3RZID0gMDtcclxuICAgICAgICB2YXIgdXNlU25hcCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzQ29udHJvbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHVzZVNuYXAgPSBlLnVzZVNuYXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhczogZGF0YXMsIHVzZVNuYXA6IHVzZVNuYXAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcInhcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFggPSBlLnggLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImRlbHRhWFwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0WCArPSBlLmRlbHRhWDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChcInlcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFkgPSBlLnkgLSByZWN0LnRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZGVsdGFZXCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RZICs9IGUuZGVsdGFZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCBkaXN0WDogZGlzdFgsIGRpc3RZOiBkaXN0WSwgdXNlU25hcDogdXNlU25hcCB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhczogZGF0YXMsIGlzRHJhZzogdHJ1ZSwgdXNlU25hcDogdXNlU25hcCB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLmdlc3Rvcy5kcmFnZ2FibGUgPSBudWxsO1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLmRyYWdJbmZvID0gbnVsbDtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIGRyYWdnZWQuIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI2RyYWdnYWJsZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIHRocm90dGxlIG9mIHgsIHkgd2hlbiBkcmFnLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjdGhyb3R0bGVEcmFnXHJcbiAqIEBkZWZhdWx0IDBcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUudGhyb3R0bGVEcmFnID0gMTtcclxuICovXHJcbi8qKlxyXG4qIHRocm90dGxlIG9mIGFuZ2xlIG9mIHgsIHkgd2hlbiBkcmFnLlxyXG4qIEBuYW1lIE1vdmVhYmxlLkRyYWdnYWJsZSN0aHJvdHRsZURyYWdSb3RhdGVcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4qXHJcbiogbW92ZWFibGUudGhyb3R0bGVEcmFnUm90YXRlID0gNDU7XHJcbiovXHJcbi8qKlxyXG4qIHN0YXJ0IGFuZ2xlIG9mIHRocm90dGxlRHJhZ1JvdGF0ZSBvZiB4LCB5IHdoZW4gZHJhZy5cclxuKiBAbmFtZSBNb3ZlYWJsZS5EcmFnZ2FibGUjc3RhcnREcmFnUm90YXRlXHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuKlxyXG4qIC8vIDQ1LCAxMzUsIDIyNSwgMzE1XHJcbiogbW92ZWFibGUudGhyb3R0bGVEcmFnUm90YXRlID0gOTA7XHJcbiogbW92ZWFibGUuc3RhcnREcmFnUm90YXRlID0gNDU7XHJcbiovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBkcmFnIHN0YXJ0cywgdGhlIGRyYWdTdGFydCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcclxuICogQGV2ZW50IGRyYWdTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgZHJhZ1N0YXJ0IGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBkcmFnZ2FibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ1N0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIGRyYWdnaW5nLCB0aGUgZHJhZyBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcclxuICogQGV2ZW50IGRyYWdcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBkcmFnZ2FibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ1wiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSB9KSA9PiB7XHJcbiAqICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBkcmFnIGZpbmlzaGVzLCB0aGUgZHJhZ0VuZCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5EcmFnZ2FibGVcclxuICogQGV2ZW50IGRyYWdFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBkcmFnRW5kIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBkcmFnZ2FibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiZHJhZ0VuZFwiLCAoeyB0YXJnZXQsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQsIGlzRHJhZyk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiogV2hlbiB0aGUgZ3JvdXAgZHJhZyBzdGFydHMsIHRoZSBgZHJhZ0dyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXHJcbiogQGV2ZW50IGRyYWdHcm91cFN0YXJ0XHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdHcm91cFN0YXJ0YCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4qICAgICBkcmFnZ2FibGU6IHRydWVcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcImRyYWdHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xyXG4qICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZ0dyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIGRyYWcsIHRoZSBgZHJhZ0dyb3VwYCBldmVudCBpcyBjYWxsZWQuXHJcbiogQG1lbWJlcm9mIE1vdmVhYmxlLkRyYWdnYWJsZVxyXG4qIEBldmVudCBkcmFnR3JvdXBcclxuKiBAcGFyYW0ge01vdmVhYmxlLkRyYWdnYWJsZS5PbkRyYWdHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdHcm91cGAgZXZlbnRcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuKiAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcbiogfSk7XHJcbiogbW92ZWFibGUub24oXCJkcmFnR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvbkRyYWdHcm91cFwiLCB0YXJnZXRzKTtcclxuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xyXG4qICAgICAgICAgIC8vIGRyYWcgZXZlbnRcclxuKiAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uRHJhZyBsZWZ0LCB0b3BcIiwgZXYubGVmdCwgZXYudG9wKTtcclxuKiAgICAgICAgICAvLyBldi50YXJnZXQhLnN0eWxlLmxlZnQgPSBgJHtldi5sZWZ0fXB4YDtcclxuKiAgICAgICAgICAvLyBldi50YXJnZXQhLnN0eWxlLnRvcCA9IGAke2V2LnRvcH1weGA7XHJcbiogICAgICAgICAgY29uc29sZS5sb2coXCJvbkRyYWcgdHJhbnNsYXRlXCIsIGV2LmRpc3QpO1xyXG4qICAgICAgICAgIGV2LnRhcmdldCEuc3R5bGUudHJhbnNmb3JtID0gZXYudHJhbnNmb3JtOylcclxuKiAgICAgfSk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBncm91cCBkcmFnIGZpbmlzaGVzLCB0aGUgYGRyYWdHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuRHJhZ2dhYmxlXHJcbiAqIEBldmVudCBkcmFnR3JvdXBFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5EcmFnZ2FibGUuT25EcmFnR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnR3JvdXBFbmRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJkcmFnR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25EcmFnR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZERpcmVjdGlvbkluZm8oc3RhcnRQb3NpdGlvbnMsIGZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGdldFBvc0J5RGlyZWN0aW9uKHN0YXJ0UG9zaXRpb25zLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICB2YXIgZml4ZWRPZmZzZXQgPSBbMCwgMF07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpeGVkUG9zaXRpb246IGZpeGVkUG9zaXRpb24sXHJcbiAgICAgICAgZml4ZWREaXJlY3Rpb246IGZpeGVkRGlyZWN0aW9uLFxyXG4gICAgICAgIGZpeGVkT2Zmc2V0OiBmaXhlZE9mZnNldCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2Zmc2V0Rml4ZWREaXJlY3Rpb25JbmZvKHN0YXRlLCBmaXhlZERpcmVjdGlvbikge1xyXG4gICAgLy8gZm9yIHN0YXJ0XHJcbiAgICB2YXIgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4LCBpczNkID0gc3RhdGUuaXMzZCwgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgbmV4dEZpeGVkT2Zmc2V0ID0gW1xyXG4gICAgICAgIHdpZHRoIC8gMiAqICgxICsgZml4ZWREaXJlY3Rpb25bMF0pLFxyXG4gICAgICAgIGhlaWdodCAvIDIgKiAoMSArIGZpeGVkRGlyZWN0aW9uWzFdKSxcclxuICAgIF07XHJcbiAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgbmV4dEZpeGVkT2Zmc2V0LCBuKTtcclxuICAgIHZhciBmaXhlZE9mZnNldCA9IFswLCAwXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZml4ZWRQb3NpdGlvbjogZml4ZWRQb3NpdGlvbixcclxuICAgICAgICBmaXhlZERpcmVjdGlvbjogZml4ZWREaXJlY3Rpb24sXHJcbiAgICAgICAgZml4ZWRPZmZzZXQ6IGZpeGVkT2Zmc2V0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRPZmZzZXRGaXhlZFBvc2l0aW9uSW5mbyhzdGF0ZSwgb2Zmc2V0Rml4ZWRQb3NpdGlvbikge1xyXG4gICAgLy8gZm9yIHN0YXJ0XHJcbiAgICB2YXIgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4LCBpczNkID0gc3RhdGUuaXMzZCwgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgZml4ZWREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb25CeVBvcyhvZmZzZXRGaXhlZFBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHZhciBuZXh0Rml4ZWRQb3NpdGlvbiA9IGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgb2Zmc2V0Rml4ZWRQb3NpdGlvbiwgbik7XHJcbiAgICB2YXIgZml4ZWRPZmZzZXQgPSBbXHJcbiAgICAgICAgd2lkdGggPyAwIDogb2Zmc2V0Rml4ZWRQb3NpdGlvblswXSxcclxuICAgICAgICBoZWlnaHQgPyAwIDogb2Zmc2V0Rml4ZWRQb3NpdGlvblsxXSxcclxuICAgIF07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpeGVkUG9zaXRpb246IG5leHRGaXhlZFBvc2l0aW9uLFxyXG4gICAgICAgIGZpeGVkRGlyZWN0aW9uOiBmaXhlZERpcmVjdGlvbixcclxuICAgICAgICBmaXhlZE9mZnNldDogZml4ZWRPZmZzZXQsXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIFJlc2l6YWJsZVxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGRlc2NyaXB0aW9uIFJlc2l6YWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0J3Mgd2lkdGggYW5kIGhlaWdodCBjYW4gYmUgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZC5cclxuICovXHJcbnZhciBkaXJlY3Rpb25Db25kaXRpb24kMiA9IGdldERpcmVjdGlvbkNvbmRpdGlvbihcInJlc2l6YWJsZVwiKTtcclxudmFyIFJlc2l6YWJsZSA9IHtcclxuICAgIG5hbWU6IFwicmVzaXphYmxlXCIsXHJcbiAgICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxyXG4gICAgY2FuUGluY2g6IHRydWUsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwicmVzaXphYmxlXCIsXHJcbiAgICAgICAgXCJ0aHJvdHRsZVJlc2l6ZVwiLFxyXG4gICAgICAgIFwicmVuZGVyRGlyZWN0aW9uc1wiLFxyXG4gICAgICAgIFwiZGlzcGxheUFyb3VuZENvbnRyb2xzXCIsXHJcbiAgICAgICAgXCJrZWVwUmF0aW9cIixcclxuICAgICAgICBcInJlc2l6ZUZvcm1hdFwiLFxyXG4gICAgICAgIFwia2VlcFJhdGlvRmluYWxseVwiLFxyXG4gICAgICAgIFwiZWRnZVwiLFxyXG4gICAgICAgIFwiY2hlY2tSZXNpemFibGVFcnJvclwiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwicmVzaXplU3RhcnRcIixcclxuICAgICAgICBcImJlZm9yZVJlc2l6ZVwiLFxyXG4gICAgICAgIFwicmVzaXplXCIsXHJcbiAgICAgICAgXCJyZXNpemVFbmRcIixcclxuICAgICAgICBcInJlc2l6ZUdyb3VwU3RhcnRcIixcclxuICAgICAgICBcImJlZm9yZVJlc2l6ZUdyb3VwXCIsXHJcbiAgICAgICAgXCJyZXNpemVHcm91cFwiLFxyXG4gICAgICAgIFwicmVzaXplR3JvdXBFbmRcIixcclxuICAgIF0sXHJcbiAgICByZW5kZXI6IGdldFJlbmRlckRpcmVjdGlvbnMoXCJyZXNpemFibGVcIiksXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZGlyZWN0aW9uQ29uZGl0aW9uJDIsXHJcbiAgICB2aWV3Q2xhc3NOYW1lOiBnZXREaXJlY3Rpb25WaWV3Q2xhc3NOYW1lKFwicmVzaXphYmxlXCIpLFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LCBpc1BpbmNoID0gZS5pc1BpbmNoLCBpc0dyb3VwID0gZS5pc0dyb3VwLCBwYXJlbnREaXJlY3Rpb24gPSBlLnBhcmVudERpcmVjdGlvbiwgcGFyZW50R2VzdG8gPSBlLnBhcmVudEdlc3RvLCBkYXRhcyA9IGUuZGF0YXMsIHBhcmVudEZpeGVkRGlyZWN0aW9uID0gZS5wYXJlbnRGaXhlZERpcmVjdGlvbiwgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50O1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBnZXRUb3RhbERpcmVjdGlvbihwYXJlbnREaXJlY3Rpb24sIGlzUGluY2gsIGlucHV0RXZlbnQsIGRhdGFzKTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LCB3aWR0aCA9IHN0YXRlLndpZHRoLCBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQsIGdlc3RvcyA9IHN0YXRlLmdlc3RvcztcclxuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdlc3Rvcy5yZXNpemFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXN0b3MucmVzaXphYmxlID0gcGFyZW50R2VzdG8gfHwgbW92ZWFibGUuY29udHJvbEdlc3RvO1xyXG4gICAgICAgICFpc1BpbmNoICYmIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgZGF0YXMuZGF0YXMgPSB7fTtcclxuICAgICAgICBkYXRhcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcbiAgICAgICAgZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGRhdGFzLnByZXZXaWR0aCA9IDA7XHJcbiAgICAgICAgZGF0YXMucHJldkhlaWdodCA9IDA7XHJcbiAgICAgICAgZGF0YXMubWluU2l6ZSA9IFswLCAwXTtcclxuICAgICAgICBkYXRhcy5zdGFydFdpZHRoID0gc3RhdGUuaW5saW5lQ1NTV2lkdGggfHwgc3RhdGUuY3NzV2lkdGg7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRIZWlnaHQgPSBzdGF0ZS5pbmxpbmVDU1NIZWlnaHQgfHwgc3RhdGUuY3NzSGVpZ2h0O1xyXG4gICAgICAgIGRhdGFzLm1heFNpemUgPSBbSW5maW5pdHksIEluZmluaXR5XTtcclxuICAgICAgICBpZiAoIWlzR3JvdXApIHtcclxuICAgICAgICAgICAgZGF0YXMubWluU2l6ZSA9IFtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm1pbk9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUubWluT2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBkYXRhcy5tYXhTaXplID0gW1xyXG4gICAgICAgICAgICAgICAgc3RhdGUubWF4T2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYXhPZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBtb3ZlYWJsZS5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gfHwgXCIlICVcIjtcclxuICAgICAgICBkYXRhcy50cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1PcmlnaW4gJiYgaXNTdHJpbmcodHJhbnNmb3JtT3JpZ2luKVxyXG4gICAgICAgICAgICA/IHRyYW5zZm9ybU9yaWdpbi5zcGxpdChcIiBcIilcclxuICAgICAgICAgICAgOiB0cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgZGF0YXMuc3RhcnRPZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXg7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRUcmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgZGF0YXMuaXNXaWR0aCA9IChfYSA9IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wYXJlbnRJc1dpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkgfHwgZGlyZWN0aW9uWzBdIHx8ICFkaXJlY3Rpb25bMV0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldFJhdGlvKHJhdGlvKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLnJhdGlvID0gcmF0aW8gJiYgaXNGaW5pdGUocmF0aW8pID8gcmF0aW8gOiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5zdGFydFBvc2l0aW9ucyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcclxuICAgICAgICBmdW5jdGlvbiBzZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0Rml4ZWREaXJlY3Rpb25JbmZvKGRhdGFzLnN0YXJ0UG9zaXRpb25zLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gcmVzdWx0LmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZFBvc2l0aW9uID0gcmVzdWx0LmZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkT2Zmc2V0ID0gcmVzdWx0LmZpeGVkT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzZXRGaXhlZFBvc2l0aW9uKGZpeGVkUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldE9mZnNldEZpeGVkUG9zaXRpb25JbmZvKG1vdmVhYmxlLnN0YXRlLCBmaXhlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWREaXJlY3Rpb24gPSByZXN1bHQuZml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSByZXN1bHQuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRPZmZzZXQgPSByZXN1bHQuZml4ZWRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldE1pbihtaW5TaXplKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLm1pblNpemUgPSBbXHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5pdFNpemUoXCJcIi5jb25jYXQobWluU2l6ZVswXSksIDApIHx8IDAsXHJcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5pdFNpemUoXCJcIi5jb25jYXQobWluU2l6ZVsxXSksIDApIHx8IDAsXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldE1heChtYXhTaXplKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXh0TWF4U2l6ZSA9IFtcclxuICAgICAgICAgICAgICAgIG1heFNpemVbMF0gfHwgSW5maW5pdHksXHJcbiAgICAgICAgICAgICAgICBtYXhTaXplWzFdIHx8IEluZmluaXR5LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKG5leHRNYXhTaXplWzBdKSB8fCBpc0Zpbml0ZShuZXh0TWF4U2l6ZVswXSkpIHtcclxuICAgICAgICAgICAgICAgIG5leHRNYXhTaXplWzBdID0gY29udmVydFVuaXRTaXplKFwiXCIuY29uY2F0KG5leHRNYXhTaXplWzBdKSwgMCkgfHwgSW5maW5pdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bWJlcihuZXh0TWF4U2l6ZVsxXSkgfHwgaXNGaW5pdGUobmV4dE1heFNpemVbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0TWF4U2l6ZVsxXSA9IGNvbnZlcnRVbml0U2l6ZShcIlwiLmNvbmNhdChuZXh0TWF4U2l6ZVsxXSksIDApIHx8IEluZmluaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGFzLm1heFNpemUgPSBuZXh0TWF4U2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0UmF0aW8od2lkdGggLyBoZWlnaHQpO1xyXG4gICAgICAgIHNldEZpeGVkRGlyZWN0aW9uKHBhcmVudEZpeGVkRGlyZWN0aW9uIHx8IFstZGlyZWN0aW9uWzBdLCAtZGlyZWN0aW9uWzFdXSk7XHJcbiAgICAgICAgZGF0YXMuc2V0Rml4ZWREaXJlY3Rpb24gPSBzZXRGaXhlZERpcmVjdGlvbjtcclxuICAgICAgICBkYXRhcy5zZXRGaXhlZFBvc2l0aW9uID0gc2V0Rml4ZWRQb3NpdGlvbjtcclxuICAgICAgICBkYXRhcy5zZXRNaW4gPSBzZXRNaW47XHJcbiAgICAgICAgZGF0YXMuc2V0TWF4ID0gc2V0TWF4O1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBzdGFydFJhdGlvOiBkYXRhcy5yYXRpbyxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHN0YXJ0V2lkdGggPSBfYlswXSwgc3RhcnRIZWlnaHQgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIGRhdGFzLnN0YXJ0V2lkdGggPSBzdGFydFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgZGF0YXMuc3RhcnRIZWlnaHQgPSBzdGFydEhlaWdodDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0TWluOiBzZXRNaW4sXHJcbiAgICAgICAgICAgIHNldE1heDogc2V0TWF4LFxyXG4gICAgICAgICAgICBzZXRSYXRpbzogc2V0UmF0aW8sXHJcbiAgICAgICAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBzZXRGaXhlZERpcmVjdGlvbixcclxuICAgICAgICAgICAgc2V0Rml4ZWRQb3NpdGlvbjogc2V0Rml4ZWRQb3NpdGlvbixcclxuICAgICAgICAgICAgc2V0T3JpZ2luOiBmdW5jdGlvbiAob3JpZ2luKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogRHJhZ2dhYmxlLmRyYWdTdGFydChtb3ZlYWJsZSwgbmV3IEN1c3RvbUdlc3RvKCkuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJlbnRFdmVudCB8fCB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVTdGFydFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0Rml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcclxuICAgICAgICBkYXRhcy5zdGFydEZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmlzUmVzaXplID0gdHJ1ZTtcclxuICAgICAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNSZXNpemUgPyBwYXJhbXMgOiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsIGlzUGluY2ggPSBlLmlzUGluY2gsIHBhcmVudEtlZXBSYXRpbyA9IGUucGFyZW50S2VlcFJhdGlvLCBkcmFnQ2xpZW50ID0gZS5kcmFnQ2xpZW50LCBwYXJlbnREaXN0ID0gZS5wYXJlbnREaXN0LCB1c2VTbmFwID0gZS51c2VTbmFwLCBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdCwgaXNHcm91cCA9IGUuaXNHcm91cCwgcGFyZW50RXZlbnQgPSBlLnBhcmVudEV2ZW50LCByZXNvbHZlTWF0cml4ID0gZS5yZXNvbHZlTWF0cml4O1xyXG4gICAgICAgIHZhciBpc1Jlc2l6ZSA9IGRhdGFzLmlzUmVzaXplLCB0cmFuc2Zvcm1PcmlnaW4gPSBkYXRhcy50cmFuc2Zvcm1PcmlnaW4sIHN0YXJ0V2lkdGggPSBkYXRhcy5zdGFydFdpZHRoLCBzdGFydEhlaWdodCA9IGRhdGFzLnN0YXJ0SGVpZ2h0LCBwcmV2V2lkdGggPSBkYXRhcy5wcmV2V2lkdGgsIHByZXZIZWlnaHQgPSBkYXRhcy5wcmV2SGVpZ2h0LCBtaW5TaXplID0gZGF0YXMubWluU2l6ZSwgbWF4U2l6ZSA9IGRhdGFzLm1heFNpemUsIHJhdGlvID0gZGF0YXMucmF0aW8sIHN0YXJ0T2Zmc2V0V2lkdGggPSBkYXRhcy5zdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0LCBpc1dpZHRoID0gZGF0YXMuaXNXaWR0aDtcclxuICAgICAgICBpZiAoIWlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc29sdmVNYXRyaXgpIHtcclxuICAgICAgICAgICAgdmFyIGlzM2QgPSBtb3ZlYWJsZS5zdGF0ZS5pczNkO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXRNYXRyaXggPSBkYXRhcy5zdGFydE9mZnNldE1hdHJpeCwgc3RhcnRUcmFuc2Zvcm1PcmlnaW4gPSBkYXRhcy5zdGFydFRyYW5zZm9ybU9yaWdpbjtcclxuICAgICAgICAgICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXRyaXggPSBwYXJzZU1hdChnZXROZXh0VHJhbnNmb3JtcyhlKSk7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXROID0gTWF0aC5zcXJ0KHRhcmdldE1hdHJpeC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdGFyZ2V0Tikge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0TWF0cml4ID0gY29udmVydERpbWVuc2lvbih0YXJnZXRNYXRyaXgsIHRhcmdldE4sIG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXh0QWxsTWF0cml4ID0gZ2V0TmV4dE1hdHJpeChzdGFydE9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBzdGFydFRyYW5zZm9ybU9yaWdpbiwgbik7XHJcbiAgICAgICAgICAgIHZhciBwb3NlcyA9IGNhbGN1bGF0ZVBvc2VzKG5leHRBbGxNYXRyaXgsIHN0YXJ0T2Zmc2V0V2lkdGgsIHN0YXJ0T2Zmc2V0SGVpZ2h0LCBuKTtcclxuICAgICAgICAgICAgZGF0YXMuc3RhcnRQb3NpdGlvbnMgPSBwb3NlcztcclxuICAgICAgICAgICAgZGF0YXMubmV4dFRhcmdldE1hdHJpeCA9IHRhcmdldE1hdHJpeDtcclxuICAgICAgICAgICAgZGF0YXMubmV4dEFsbE1hdHJpeCA9IG5leHRBbGxNYXRyaXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IGdldFByb3BzKG1vdmVhYmxlLnByb3BzLCBcInJlc2l6YWJsZVwiKTtcclxuICAgICAgICB2YXIgcmVzaXplRm9ybWF0ID0gcHJvcHMucmVzaXplRm9ybWF0LCBfYiA9IHByb3BzLnRocm90dGxlUmVzaXplLCB0aHJvdHRsZVJlc2l6ZSA9IF9iID09PSB2b2lkIDAgPyBwYXJlbnRGbGFnID8gMCA6IDEgOiBfYiwgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZSwga2VlcFJhdGlvRmluYWxseSA9IHByb3BzLmtlZXBSYXRpb0ZpbmFsbHk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRhdGFzLmRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgc2l6ZURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcclxuICAgICAgICB2YXIgZGlzdFdpZHRoID0gMDtcclxuICAgICAgICB2YXIgZGlzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgaWYgKCFkaXJlY3Rpb25bMF0gJiYgIWRpcmVjdGlvblsxXSkge1xyXG4gICAgICAgICAgICBzaXplRGlyZWN0aW9uID0gWzEsIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2VlcFJhdGlvID0gKHJhdGlvICYmIChwYXJlbnRLZWVwUmF0aW8gIT0gbnVsbCA/IHBhcmVudEtlZXBSYXRpbyA6IHByb3BzLmtlZXBSYXRpbykpIHx8IGZhbHNlO1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRCb3VuZGluZ1NpemUoKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICB2YXIgbmV4dFNpemUgPSBnZXRPZmZzZXRTaXplRGlzdChzaXplRGlyZWN0aW9uLCBrZWVwUmF0aW8sIGRhdGFzLCBlKTtcclxuICAgICAgICAgICAgZGlzdFdpZHRoID0gbmV4dFNpemUuZGlzdFdpZHRoO1xyXG4gICAgICAgICAgICBkaXN0SGVpZ2h0ID0gbmV4dFNpemUuZGlzdEhlaWdodDtcclxuICAgICAgICAgICAgdmFyIG5leHRXaWR0aCA9IChzaXplRGlyZWN0aW9uWzBdIC0gZml4ZWREaXJlY3Rpb25bMF0pIHx8IGtlZXBSYXRpb1xyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heChzdGFydE9mZnNldFdpZHRoICsgZGlzdFdpZHRoLCBUSU5ZX05VTSkgOiBzdGFydE9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgbmV4dEhlaWdodCA9IChzaXplRGlyZWN0aW9uWzFdIC0gZml4ZWREaXJlY3Rpb25bMV0pIHx8IGtlZXBSYXRpb1xyXG4gICAgICAgICAgICAgICAgPyBNYXRoLm1heChzdGFydE9mZnNldEhlaWdodCArIGRpc3RIZWlnaHQsIFRJTllfTlVNKSA6IHN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoa2VlcFJhdGlvICYmIHN0YXJ0T2Zmc2V0V2lkdGggJiYgc3RhcnRPZmZzZXRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0T2Zmc2V0V2lkdGggOiBzdGFydE9mZnNldEhlaWdodCA9IG5leHRXaWR0aCA6IG5leHRIZWlnaHRcclxuICAgICAgICAgICAgICAgIGlmIChpc1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEhlaWdodCA9IG5leHRXaWR0aCAvIHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFdpZHRoID0gbmV4dEhlaWdodCAqIHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbbmV4dFdpZHRoLCBuZXh0SGVpZ2h0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKGdldE5leHRCb3VuZGluZ1NpemUoKSwgMiksIGJvdW5kaW5nV2lkdGggPSBfY1swXSwgYm91bmRpbmdIZWlnaHQgPSBfY1sxXTtcclxuICAgICAgICBpZiAoIXBhcmVudEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uKGRhdGFzLmZpeGVkRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVzaXplXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Rml4ZWREaXJlY3Rpb246IGRhdGFzLnN0YXJ0Rml4ZWREaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBzdGFydEZpeGVkUG9zaXRpb246IGRhdGFzLnN0YXJ0Rml4ZWRQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIHNldEZpeGVkRGlyZWN0aW9uOiBmdW5jdGlvbiAobmV4dEZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uKG5leHRGaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQoZ2V0TmV4dEJvdW5kaW5nU2l6ZSgpLCAyKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldEZpeGVkUG9zaXRpb246IGZ1bmN0aW9uIChuZXh0Rml4ZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhcy5zZXRGaXhlZFBvc2l0aW9uKG5leHRGaXhlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9fcmVhZChnZXROZXh0Qm91bmRpbmdTaXplKCksIDIpLCBib3VuZGluZ1dpZHRoID0gX2FbMF0sIGJvdW5kaW5nSGVpZ2h0ID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodF07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdXaWR0aDogYm91bmRpbmdXaWR0aCxcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nSGVpZ2h0OiBib3VuZGluZ0hlaWdodCxcclxuICAgICAgICAgICAgICAgIHNldFNpemU6IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gX19yZWFkKHNpemUsIDIpLCBib3VuZGluZ1dpZHRoID0gX2FbMF0sIGJvdW5kaW5nSGVpZ2h0ID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZHJhZ0NsaWVudDtcclxuICAgICAgICBpZiAoIWRyYWdDbGllbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnRGbGFnICYmIGlzUGluY2gpIHtcclxuICAgICAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBnZXRBYnNvbHV0ZVBvc2l0aW9uKG1vdmVhYmxlLCBbMCwgMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNuYXBEaXN0ID0gWzAsIDBdO1xyXG4gICAgICAgIGlmICghaXNQaW5jaCkge1xyXG4gICAgICAgICAgICBzbmFwRGlzdCA9IGNoZWNrU25hcFJlc2l6ZShtb3ZlYWJsZSwgYm91bmRpbmdXaWR0aCwgYm91bmRpbmdIZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgIXVzZVNuYXAgJiYgaXNSZXF1ZXN0LCBkYXRhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJlbnREaXN0KSB7XHJcbiAgICAgICAgICAgICFwYXJlbnREaXN0WzBdICYmIChzbmFwRGlzdFswXSA9IDApO1xyXG4gICAgICAgICAgICAhcGFyZW50RGlzdFsxXSAmJiAoc25hcERpc3RbMV0gPSAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVNpemUoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgaWYgKHJlc2l6ZUZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQocmVzaXplRm9ybWF0KFtib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodF0pLCAyKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvdW5kaW5nV2lkdGggPSB0aHJvdHRsZShib3VuZGluZ1dpZHRoLCB0aHJvdHRsZVJlc2l6ZSk7XHJcbiAgICAgICAgICAgIGJvdW5kaW5nSGVpZ2h0ID0gdGhyb3R0bGUoYm91bmRpbmdIZWlnaHQsIHRocm90dGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiBzaXplRGlyZWN0aW9uWzFdICYmIHNuYXBEaXN0WzBdICYmIHNuYXBEaXN0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzKHNuYXBEaXN0WzBdKSA+IGFicyhzbmFwRGlzdFsxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbmFwRGlzdFsxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbmFwRGlzdFswXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzTm9TbmFwID0gIXNuYXBEaXN0WzBdICYmICFzbmFwRGlzdFsxXTtcclxuICAgICAgICAgICAgaWYgKGlzTm9TbmFwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmUtY29tcHV0ZSBiZWZvcmUgbWFpbnRhaW5pbmcgdGhlIHJhdGlvXHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoc2l6ZURpcmVjdGlvblswXSAmJiAhc2l6ZURpcmVjdGlvblsxXSlcclxuICAgICAgICAgICAgICAgIHx8IChzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoaXNOb1NuYXAgJiYgaXNXaWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nV2lkdGggKz0gc25hcERpc3RbMF07XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nV2lkdGggLyByYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoIXNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSlcclxuICAgICAgICAgICAgICAgIHx8ICghc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoaXNOb1NuYXAgJiYgIWlzV2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ0hlaWdodCArPSBzbmFwRGlzdFsxXTtcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nV2lkdGggPSBib3VuZGluZ0hlaWdodCAqIHJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZGluZ1dpZHRoICs9IHNuYXBEaXN0WzBdO1xyXG4gICAgICAgICAgICBib3VuZGluZ0hlaWdodCArPSBzbmFwRGlzdFsxXTtcclxuICAgICAgICAgICAgYm91bmRpbmdXaWR0aCA9IE1hdGgubWF4KDAsIGJvdW5kaW5nV2lkdGgpO1xyXG4gICAgICAgICAgICBib3VuZGluZ0hlaWdodCA9IE1hdGgubWF4KDAsIGJvdW5kaW5nSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2EgPSBfX3JlYWQoY2FsY3VsYXRlQm91bmRTaXplKFtib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodF0sIG1pblNpemUsIG1heFNpemUsIGtlZXBSYXRpbyA/IHJhdGlvIDogZmFsc2UpLCAyKSwgYm91bmRpbmdXaWR0aCA9IF9hWzBdLCBib3VuZGluZ0hlaWdodCA9IF9hWzFdO1xyXG4gICAgICAgIGNvbXB1dGVTaXplKCk7XHJcbiAgICAgICAgaWYgKGtlZXBSYXRpbyAmJiAoaXNHcm91cCB8fCBrZWVwUmF0aW9GaW5hbGx5KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZ1dpZHRoIC8gcmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1dpZHRoID0gYm91bmRpbmdIZWlnaHQgKiByYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaXN0V2lkdGggPSBib3VuZGluZ1dpZHRoIC0gc3RhcnRPZmZzZXRXaWR0aDtcclxuICAgICAgICBkaXN0SGVpZ2h0ID0gYm91bmRpbmdIZWlnaHQgLSBzdGFydE9mZnNldEhlaWdodDtcclxuICAgICAgICB2YXIgZGVsdGEgPSBbZGlzdFdpZHRoIC0gcHJldldpZHRoLCBkaXN0SGVpZ2h0IC0gcHJldkhlaWdodF07XHJcbiAgICAgICAgZGF0YXMucHJldldpZHRoID0gZGlzdFdpZHRoO1xyXG4gICAgICAgIGRhdGFzLnByZXZIZWlnaHQgPSBkaXN0SGVpZ2h0O1xyXG4gICAgICAgIHZhciBpbnZlcnNlRGVsdGEgPSBnZXRSZXNpemVEaXN0KG1vdmVhYmxlLCBib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodCwgZml4ZWRQb3NpdGlvbiwgdHJhbnNmb3JtT3JpZ2luLCBkYXRhcyk7XHJcbiAgICAgICAgaWYgKCFwYXJlbnRNb3ZlYWJsZSAmJiBkZWx0YS5ldmVyeShmdW5jdGlvbiAobnVtKSB7IHJldHVybiAhbnVtOyB9KSAmJiBpbnZlcnNlRGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gIW51bTsgfSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZHJhZyA9IERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBzZXRDdXN0b21EcmFnKGUsIG1vdmVhYmxlLnN0YXRlLCBpbnZlcnNlRGVsdGEsICEhaXNQaW5jaCwgZmFsc2UsIFwiZHJhZ2dhYmxlXCIpKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gZHJhZy50cmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIG5leHRXaWR0aCA9IHN0YXJ0V2lkdGggKyBkaXN0V2lkdGg7XHJcbiAgICAgICAgdmFyIG5leHRIZWlnaHQgPSBzdGFydEhlaWdodCArIGRpc3RIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgd2lkdGg6IG5leHRXaWR0aCwgaGVpZ2h0OiBuZXh0SGVpZ2h0LCBvZmZzZXRXaWR0aDogTWF0aC5yb3VuZChib3VuZGluZ1dpZHRoKSwgb2Zmc2V0SGVpZ2h0OiBNYXRoLnJvdW5kKGJvdW5kaW5nSGVpZ2h0KSwgc3RhcnRSYXRpbzogcmF0aW8sIGJvdW5kaW5nV2lkdGg6IGJvdW5kaW5nV2lkdGgsIGJvdW5kaW5nSGVpZ2h0OiBib3VuZGluZ0hlaWdodCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGRpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdLCBkZWx0YTogZGVsdGEsIGlzUGluY2g6ICEhaXNQaW5jaCwgZHJhZzogZHJhZyB9LCBmaWxsQWZ0ZXJUcmFuc2Zvcm0oe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KG5leHRXaWR0aCwgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQobmV4dEhlaWdodCwgXCJweFwiKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXHJcbiAgICAgICAgfSwgZHJhZywgZSkpKTtcclxuICAgICAgICAhcGFyZW50RXZlbnQgJiYgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplXCIsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEFmdGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6ZSA9IGRhdGFzLmlzUmVzaXplLCBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodCwgcHJldldpZHRoID0gZGF0YXMucHJldldpZHRoLCBwcmV2SGVpZ2h0ID0gZGF0YXMucHJldkhlaWdodDtcclxuICAgICAgICBpZiAoIWlzUmVzaXplIHx8IG1vdmVhYmxlLnByb3BzLmNoZWNrUmVzaXphYmxlRXJyb3IgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB2YXIgZXJyb3JXaWR0aCA9IHdpZHRoIC0gKHN0YXJ0T2Zmc2V0V2lkdGggKyBwcmV2V2lkdGgpO1xyXG4gICAgICAgIHZhciBlcnJvckhlaWdodCA9IGhlaWdodCAtIChzdGFydE9mZnNldEhlaWdodCArIHByZXZIZWlnaHQpO1xyXG4gICAgICAgIHZhciBpc0Vycm9yV2lkdGggPSBhYnMoZXJyb3JXaWR0aCkgPiAzO1xyXG4gICAgICAgIHZhciBpc0Vycm9ySGVpZ2h0ID0gYWJzKGVycm9ySGVpZ2h0KSA+IDM7XHJcbiAgICAgICAgaWYgKGlzRXJyb3JXaWR0aCkge1xyXG4gICAgICAgICAgICBkYXRhcy5zdGFydFdpZHRoICs9IGVycm9yV2lkdGg7XHJcbiAgICAgICAgICAgIGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGggKz0gZXJyb3JXaWR0aDtcclxuICAgICAgICAgICAgZGF0YXMucHJldldpZHRoICs9IGVycm9yV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Vycm9ySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGRhdGFzLnN0YXJ0SGVpZ2h0ICs9IGVycm9ySGVpZ2h0O1xyXG4gICAgICAgICAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCArPSBlcnJvckhlaWdodDtcclxuICAgICAgICAgICAgZGF0YXMucHJldkhlaWdodCArPSBlcnJvckhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRXJyb3JXaWR0aCB8fCBpc0Vycm9ySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIHBhcmVudEV2ZW50ID0gZS5wYXJlbnRFdmVudDtcclxuICAgICAgICBpZiAoIWRhdGFzLmlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuaXNSZXNpemUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xyXG4gICAgICAgICFwYXJlbnRFdmVudCAmJiB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZXNpemVFbmRcIiwgcGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbiQyLFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBpc0dyb3VwOiB0cnVlIH0pKTtcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbEV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIiwgZSk7XHJcbiAgICAgICAgdmFyIHBhcmVudFN0YXJ0T2Zmc2V0V2lkdGggPSBkYXRhcy5zdGFydE9mZnNldFdpZHRoLCBwYXJlbnRTdGFydE9mZnNldEhlaWdodCA9IGRhdGFzLnN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUdyb3VwTWluKCkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxNaW5TaXplID0gZGF0YXMubWluU2l6ZTtcclxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IGV2LmRhdGFzLCBjaGlsZE1pblNpemUgPSBfYS5taW5TaXplLCBjaGlsZFN0YXJ0T2Zmc2V0V2lkdGggPSBfYS5zdGFydE9mZnNldFdpZHRoLCBjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0ID0gX2Euc3RhcnRPZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TWluV2lkdGggPSBwYXJlbnRTdGFydE9mZnNldFdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgKiAoY2hpbGRTdGFydE9mZnNldFdpZHRoID8gY2hpbGRNaW5TaXplWzBdIC8gY2hpbGRTdGFydE9mZnNldFdpZHRoIDogMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TWluSGVpZ2h0ID0gcGFyZW50U3RhcnRPZmZzZXRIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAqIChjaGlsZFN0YXJ0T2Zmc2V0SGVpZ2h0ID8gY2hpbGRNaW5TaXplWzFdIC8gY2hpbGRTdGFydE9mZnNldEhlaWdodCA6IDApO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNaW5TaXplWzBdID0gTWF0aC5tYXgob3JpZ2luYWxNaW5TaXplWzBdLCBwYXJlbnRNaW5XaWR0aCk7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1pblNpemVbMV0gPSBNYXRoLm1heChvcmlnaW5hbE1pblNpemVbMV0sIHBhcmVudE1pbkhlaWdodCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVHcm91cE1heCgpIHtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTWF4U2l6ZSA9IGRhdGFzLm1heFNpemU7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBldi5kYXRhcywgY2hpbGRNYXhTaXplID0gX2EubWF4U2l6ZSwgY2hpbGRTdGFydE9mZnNldFdpZHRoID0gX2Euc3RhcnRPZmZzZXRXaWR0aCwgY2hpbGRTdGFydE9mZnNldEhlaWdodCA9IF9hLnN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE1heFdpZHRoID0gcGFyZW50U3RhcnRPZmZzZXRXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICogKGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA/IGNoaWxkTWF4U2l6ZVswXSAvIGNoaWxkU3RhcnRPZmZzZXRXaWR0aCA6IDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudE1heEhlaWdodCA9IHBhcmVudFN0YXJ0T2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgKiAoY2hpbGRTdGFydE9mZnNldEhlaWdodCA/IGNoaWxkTWF4U2l6ZVsxXSAvIGNoaWxkU3RhcnRPZmZzZXRIZWlnaHQgOiAwKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF4U2l6ZVswXSA9IE1hdGgubWluKG9yaWdpbmFsTWF4U2l6ZVswXSwgcGFyZW50TWF4V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNYXhTaXplWzFdID0gTWF0aC5taW4ob3JpZ2luYWxNYXhTaXplWzFdLCBwYXJlbnRNYXhIZWlnaHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sU3RhcnRcIiwgZSwgZnVuY3Rpb24gKGNoaWxkLCBldikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRDaGlsZERpc3QobW92ZWFibGUsIGNoaWxkLCBkYXRhcywgZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVwZGF0ZUdyb3VwTWluKCk7XHJcbiAgICAgICAgdXBkYXRlR3JvdXBNYXgoKTtcclxuICAgICAgICB2YXIgc2V0Rml4ZWREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZml4ZWREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgcGFyYW1zLnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBldi5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdGFydENoaWxkRGlzdChtb3ZlYWJsZSwgZXYubW92ZWFibGUsIGRhdGFzLCBvcmlnaW5hbEV2ZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGF0YXMuc2V0Rml4ZWREaXJlY3Rpb24gPSBzZXRGaXhlZERpcmVjdGlvbjtcclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsIGV2ZW50czogZXZlbnRzLm1hcChmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7IHNldE1pbjogZnVuY3Rpb24gKG1pblNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYuc2V0TWluKG1pblNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHcm91cE1pbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHNldE1heDogZnVuY3Rpb24gKG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYuc2V0TWF4KG1heFNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVHcm91cE1heCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gfSk7XHJcbiAgICAgICAgICAgIH0pLCBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb24sIHNldE1pbjogZnVuY3Rpb24gKG1pblNpemUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5zZXRNaW4obWluU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVHcm91cE1pbigpO1xyXG4gICAgICAgICAgICB9LCBzZXRNYXg6IGZ1bmN0aW9uIChtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0TWF4KG1heFNpemUpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlR3JvdXBNYXgoKTtcclxuICAgICAgICAgICAgfSB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplR3JvdXBTdGFydFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICBkYXRhcy5pc1Jlc2l6ZSA9IHJlc3VsdCAhPT0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzUmVzaXplID8gcGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWRhdGFzLmlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3BzID0gZ2V0UHJvcHMobW92ZWFibGUucHJvcHMsIFwicmVzaXphYmxlXCIpO1xyXG4gICAgICAgIGNhdGNoRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZXNpemVcIiwgZnVuY3Rpb24gKHBhcmVudEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlc2l6ZUdyb3VwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJlbnRFdmVudCksIHsgdGFyZ2V0czogcHJvcHMudGFyZ2V0cyB9KSwgdHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmRyYWdDb250cm9sKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgaXNHcm91cDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYm91bmRpbmdXaWR0aCA9IHBhcmFtcy5ib3VuZGluZ1dpZHRoLCBib3VuZGluZ0hlaWdodCA9IHBhcmFtcy5ib3VuZGluZ0hlaWdodCwgZGlzdCA9IHBhcmFtcy5kaXN0O1xyXG4gICAgICAgIHZhciBrZWVwUmF0aW8gPSBwcm9wcy5rZWVwUmF0aW87XHJcbiAgICAgICAgdmFyIHBhcmVudFNjYWxlID0gW1xyXG4gICAgICAgICAgICBib3VuZGluZ1dpZHRoIC8gKGJvdW5kaW5nV2lkdGggLSBkaXN0WzBdKSxcclxuICAgICAgICAgICAgYm91bmRpbmdIZWlnaHQgLyAoYm91bmRpbmdIZWlnaHQgLSBkaXN0WzFdKSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZGF0YXMuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xcIiwgZSwgZnVuY3Rpb24gKF8sIGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChjYWxjdWxhdGUoY3JlYXRlUm90YXRlTWF0cml4KG1vdmVhYmxlLnJvdGF0aW9uIC8gMTgwICogTWF0aC5QSSwgMyksIFtcclxuICAgICAgICAgICAgICAgIGV2LmRhdGFzLm9yaWdpbmFsWCAqIHBhcmVudFNjYWxlWzBdLFxyXG4gICAgICAgICAgICAgICAgZXYuZGF0YXMub3JpZ2luYWxZICogcGFyZW50U2NhbGVbMV0sXHJcbiAgICAgICAgICAgICAgICAxLFxyXG4gICAgICAgICAgICBdLCAzKSwgMiksIGNsaWVudFggPSBfYVswXSwgY2xpZW50WSA9IF9hWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwgeyBwYXJlbnREaXN0OiBudWxsLCBwYXJlbnRTY2FsZTogcGFyZW50U2NhbGUsIGRyYWdDbGllbnQ6IHBsdXMoZml4ZWRQb3NpdGlvbiwgW2NsaWVudFgsIGNsaWVudFldKSwgcGFyZW50S2VlcFJhdGlvOiBrZWVwUmF0aW8gfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbih7IHRhcmdldHM6IHByb3BzLnRhcmdldHMsIGV2ZW50czogZXZlbnRzIH0sIHBhcmFtcyk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplR3JvdXBcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHRQYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLCBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJhZ0NvbnRyb2xFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbEVuZFwiLCBlKTtcclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcclxuICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVzaXplR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIGlzRHJhZztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUuUmVzaXphYmxlI3JlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLlJlc2l6YWJsZVJlcXVlc3RQYXJhbX0gZSAtIHRoZSBSZXNpemFibGUncyByZXF1ZXN0IHBhcmFtZXRlclxyXG4gICAgICogQHJldHVybiB7TW92ZWFibGUuUmVxdWVzdGVyfSBNb3ZlYWJsZSBSZXF1ZXN0ZXJcclxuICAgICAqIEBleGFtcGxlXHJcblxuICAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcclxuICAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSwgdHJ1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gVXNlIEFic29sdXRlIFZhbHVlXHJcbiAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicmVzaXphYmxlXCIsIHsgb2Zmc2V0V2lkdGg6IDEwMCwgb2Zmc2V0SGVpZ2h0OiAxMDAgfSwgdHJ1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdFN0YXJ0XHJcbiAgICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwicmVzaXphYmxlXCIpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RcclxuICAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVdpZHRoOiAxMCwgZGVsdGFIZWlnaHQ6IDEwIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIFVzZSBBYnNvbHV0ZSBWYWx1ZVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMDAsIG9mZnNldEhlaWdodDogMTAwIH0pO1xyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMTAsIG9mZnNldEhlaWdodDogMTAwIH0pO1xyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInJlc2l6YWJsZVwiLCB7IG9mZnNldFdpZHRoOiAxMjAsIG9mZnNldEhlaWdodDogMTAwIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RFbmRcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0RW5kKCk7XHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IHt9O1xyXG4gICAgICAgIHZhciBkaXN0V2lkdGggPSAwO1xyXG4gICAgICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICB2YXIgdXNlU25hcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzQ29udHJvbDogdHJ1ZSxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgdXNlU25hcCA9IGUudXNlU25hcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERpcmVjdGlvbjogZS5kaXJlY3Rpb24gfHwgWzEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElzV2lkdGg6IChfYSA9IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5ob3Jpem9udGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZVNuYXA6IHVzZVNuYXAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwib2Zmc2V0V2lkdGhcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFdpZHRoID0gZS5vZmZzZXRXaWR0aCAtIHJlY3Qub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImRlbHRhV2lkdGhcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFdpZHRoICs9IGUuZGVsdGFXaWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChcIm9mZnNldEhlaWdodFwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0SGVpZ2h0ID0gZS5vZmZzZXRIZWlnaHQgLSByZWN0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZGVsdGFIZWlnaHRcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdEhlaWdodCArPSBlLmRlbHRhSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhczogZGF0YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGlzdDogW2Rpc3RXaWR0aCwgZGlzdEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50S2VlcFJhdGlvOiBlLmtlZXBSYXRpbyxcclxuICAgICAgICAgICAgICAgICAgICB1c2VTbmFwOiB1c2VTbmFwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCBpc0RyYWc6IHRydWUsIHVzZVNuYXA6IHVzZVNuYXAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5nZXN0b3MucmVzaXphYmxlID0gbnVsbDtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHJlc2l6ZWQuXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNyZXNpemFibGVcclxuICogQGRlZmF1bHQgZmFsc2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByZXNpemFibGU6IGZhbHNlLFxyXG4gKiB9KTtcclxuICpcclxuICogbW92ZWFibGUucmVzaXphYmxlID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiB0aHJvdHRsZSBvZiB3aWR0aCwgaGVpZ2h0IHdoZW4gcmVzaXplLiBJZiB0aHJvdHRsZVJlc2l6ZSBpcyBzZXQgdG8gbGVzcyB0aGFuIDEsIHRoZSB0YXJnZXQgbWF5IHNoYWtlLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5SZXNpemFibGUjdGhyb3R0bGVSZXNpemVcclxuICogQGRlZmF1bHQgMVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICByZXNpemFibGU6IHRydWUsXHJcbiAqICAgdGhyb3R0bGVSZXNpemU6IDEsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS50aHJvdHRsZVJlc2l6ZSA9IDA7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiByZXNpemUgb3Igc2NhbGUsIGtlZXBzIGEgcmF0aW8gb2YgdGhlIHdpZHRoLCBoZWlnaHQuXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJlc2l6YWJsZSNrZWVwUmF0aW9cclxuICogQGRlZmF1bHQgZmFsc2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgcmVzaXphYmxlOiB0cnVlLFxyXG4gKiB9KTtcclxuICpcclxuICogbW92ZWFibGUua2VlcFJhdGlvID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4gKiBTZXQgZGlyZWN0aW9ucyB0byBzaG93IHRoZSBjb250cm9sIGJveC5cclxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3JlbmRlckRpcmVjdGlvbnNcclxuICogQGRlZmF1bHQgW1wiblwiLCBcIm53XCIsIFwibmVcIiwgXCJzXCIsIFwic2VcIiwgXCJzd1wiLCBcImVcIiwgXCJ3XCJdXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcclxuICogICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XHJcbiAqL1xyXG4vKipcclxuICogRnVuY3Rpb24gdG8gY29udmVydCBzaXplIGZvciByZXNpemVcclxuICogQG5hbWUgTW92ZWFibGUuUmVzaXphYmxlI3Jlc2l6ZUZvcm1hdFxyXG4gKiBAZGVmYXVsdCBvbmVzZWxmXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIHJlc2l6YWJsZTogdHJ1ZSxcclxuICogICByZXNpemVGb3JtYXQ6IHYgPT4gdixcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnJlc2l6ZUZvcm1hdCA9IChzaXplOiBudW1iZXJbXSkgPT4gKFtNYXRoLnRydW5jKHNpemVbMF0pLCBNYXRoLnRydW5jKHNpemVbMV0pXTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSByZXNpemUgc3RhcnRzLCB0aGUgcmVzaXplU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUmVzaXphYmxlXHJcbiAqIEBldmVudCByZXNpemVTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PblJlc2l6ZVN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemVTdGFydCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcmVzaXphYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZVN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHJlc2l6aW5nLCBgYmVmb3JlUmVzaXplYCBpcyBjYWxsZWQgYmVmb3JlIGByZXNpemVgIG9jY3Vycy4gSW4gYGJlZm9yZVJlc2l6ZWAsIHlvdSBjYW4gZ2V0IGFuZCBzZXQgdGhlIHByZS12YWx1ZSBiZWZvcmUgcmVzaXppbmcuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcclxuICogQGV2ZW50IGJlZm9yZVJlc2l6ZVxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5PbkJlZm9yZVJlc2l6ZX0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGJlZm9yZVJlc2l6ZWAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJiZWZvcmVSZXNpemVcIiwgKHsgc2V0Rml4ZWREaXJlY3Rpb24gfSkgPT4ge1xyXG4gKiAgICAgaWYgKHNoaWZ0S2V5KSB7XHJcbiAqICAgICAgICBzZXRGaXhlZERpcmVjdGlvbihbMCwgMF0pO1xyXG4gKiAgICAgfVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZXNpemVcIiwgKHsgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0LCBkcmFnIH0pID0+IHtcclxuICogICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcclxuICogICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xyXG4gKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGRyYWcudHJhbnNmb3JtO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHJlc2l6aW5nLCB0aGUgcmVzaXplIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxyXG4gKiBAZXZlbnQgcmVzaXplXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemUgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJyZXNpemVcIiwgKHsgdGFyZ2V0LCB3aWR0aCwgaGVpZ2h0IH0pID0+IHtcclxuICogICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IGAke2Uud2lkdGh9cHhgO1xyXG4gKiAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGAke2UuaGVpZ2h0fXB4YDtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgcmVzaXplIGZpbmlzaGVzLCB0aGUgcmVzaXplRW5kIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJlc2l6YWJsZVxyXG4gKiBAZXZlbnQgcmVzaXplRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByZXNpemVFbmQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJlc2l6YWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJyZXNpemVFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSBzdGFydHMsIHRoZSBgcmVzaXplR3JvdXBTdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcclxuKiBAZXZlbnQgcmVzaXplR3JvdXBTdGFydFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlc2l6ZUdyb3VwU3RhcnRgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiogICAgIHJlc2l6YWJsZTogdHJ1ZVxyXG4qIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwicmVzaXplR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwU3RhcnRcIiwgdGFyZ2V0cyk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIHJlc2l6ZSwgdGhlIGByZXNpemVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcclxuKiBAZXZlbnQgcmVzaXplR3JvdXBcclxuKiBAcGFyYW0ge01vdmVhYmxlLlJlc2l6YWJsZS5vblJlc2l6ZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVzaXplR3JvdXBgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiogICAgIHJlc2l6YWJsZTogdHJ1ZVxyXG4qIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwicmVzaXplR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvblJlc2l6ZUdyb3VwXCIsIHRhcmdldHMpO1xyXG4qICAgICBldmVudHMuZm9yRWFjaChldiA9PiB7XHJcbiogICAgICAgICBjb25zdCBvZmZzZXQgPSBbXHJcbiogICAgICAgICAgICAgZGlyZWN0aW9uWzBdIDwgMCA/IC1ldi5kZWx0YVswXSA6IDAsXHJcbiogICAgICAgICAgICAgZGlyZWN0aW9uWzFdIDwgMCA/IC1ldi5kZWx0YVsxXSA6IDAsXHJcbiogICAgICAgICBdO1xyXG4qICAgICAgICAgLy8gZXYuZHJhZyBpcyBhIGRyYWcgZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgZ3JvdXAgcmVzaXplLlxyXG4qICAgICAgICAgY29uc3QgbGVmdCA9IG9mZnNldFswXSArIGV2LmRyYWcuYmVmb3JlRGlzdFswXTtcclxuKiAgICAgICAgIGNvbnN0IHRvcCA9IG9mZnNldFsxXSArIGV2LmRyYWcuYmVmb3JlRGlzdFsxXTtcclxuKiAgICAgICAgIGNvbnN0IHdpZHRoID0gZXYud2lkdGg7XHJcbiogICAgICAgICBjb25zdCB0b3AgPSBldi50b3A7XHJcbiogICAgIH0pO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgcmVzaXplIGZpbmlzaGVzLCB0aGUgYHJlc2l6ZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5SZXNpemFibGVcclxuICogQGV2ZW50IHJlc2l6ZUdyb3VwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUmVzaXphYmxlLk9uUmVzaXplR3JvdXBFbmR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZXNpemVHcm91cEVuZGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiAgICAgcmVzaXphYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJlc2l6ZUdyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVzaXplR3JvdXBFbmRcIiwgdGFyZ2V0cywgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xuXG4vKipcclxuICogQG5hbWVzcGFjZSBSb3RhdGFibGVcclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBSb3RhdGFibGUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRhcmdldCBjYW4gYmUgcm90YXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMsIGNsaWVudFgsIGNsaWVudFksIHJlY3QpIHtcclxuICAgIHZhciBncm91cGFibGUgPSBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGU7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBuID0gc3RhdGUuaXMzZCA/IDQgOiAzO1xyXG4gICAgdmFyIG9yaWdpbiA9IGRhdGFzLm9yaWdpbjtcclxuICAgIHZhciBuZXh0T3JpZ2luID0gY2FsY3VsYXRlUG9zaXRpb24obW92ZWFibGUuc3RhdGUucm9vdE1hdHJpeCwgXHJcbiAgICAvLyBUTy1ETyAjNzEwXHJcbiAgICBtaW51cyhbb3JpZ2luWzBdLCBvcmlnaW5bMV1dLCBncm91cGFibGUgPyBbMCwgMF0gOiBbc3RhdGUubGVmdCwgc3RhdGUudG9wXSksIG4pO1xyXG4gICAgdmFyIHN0YXJ0QWJzb2x1dGVPcmlnaW4gPSBwbHVzKFtyZWN0LmxlZnQsIHJlY3QudG9wXSwgbmV4dE9yaWdpbik7XHJcbiAgICBkYXRhcy5zdGFydEFic29sdXRlT3JpZ2luID0gc3RhcnRBYnNvbHV0ZU9yaWdpbjtcclxuICAgIGRhdGFzLnByZXZEZWcgPSBnZXRSYWQoc3RhcnRBYnNvbHV0ZU9yaWdpbiwgW2NsaWVudFgsIGNsaWVudFldKSAvIE1hdGguUEkgKiAxODA7XHJcbiAgICBkYXRhcy5kZWZhdWx0RGVnID0gZGF0YXMucHJldkRlZztcclxuICAgIGRhdGFzLnByZXZTbmFwRGVnID0gMDtcclxuICAgIGRhdGFzLmxvb3AgPSAwO1xyXG4gICAgZGF0YXMuc3RhcnREaXN0ID0gZ2V0RGlzdCQxKHN0YXJ0QWJzb2x1dGVPcmlnaW4sIFtjbGllbnRYLCBjbGllbnRZXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVEaXN0KGRlZywgZGlyZWN0aW9uLCBkYXRhcykge1xyXG4gICAgdmFyIGRlZmF1bHREZWcgPSBkYXRhcy5kZWZhdWx0RGVnLCBwcmV2RGVnID0gZGF0YXMucHJldkRlZztcclxuICAgIHZhciBub3JtYWxpemVkUHJldkRlZyA9IHByZXZEZWcgJSAzNjA7XHJcbiAgICB2YXIgbG9vcCA9IE1hdGguZmxvb3IocHJldkRlZyAvIDM2MCk7XHJcbiAgICBpZiAobm9ybWFsaXplZFByZXZEZWcgPCAwKSB7XHJcbiAgICAgICAgbm9ybWFsaXplZFByZXZEZWcgKz0gMzYwO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vcm1hbGl6ZWRQcmV2RGVnID4gZGVnICYmIG5vcm1hbGl6ZWRQcmV2RGVnID4gMjcwICYmIGRlZyA8IDkwKSB7XHJcbiAgICAgICAgLy8gMzYwID0+IDBcclxuICAgICAgICArK2xvb3A7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChub3JtYWxpemVkUHJldkRlZyA8IGRlZyAmJiBub3JtYWxpemVkUHJldkRlZyA8IDkwICYmIGRlZyA+IDI3MCkge1xyXG4gICAgICAgIC8vIDAgPT4gMzYwXHJcbiAgICAgICAgLS1sb29wO1xyXG4gICAgfVxyXG4gICAgdmFyIGRpc3QgPSBkaXJlY3Rpb24gKiAobG9vcCAqIDM2MCArIGRlZyAtIGRlZmF1bHREZWcpO1xyXG4gICAgZGF0YXMucHJldkRlZyA9IGRlZmF1bHREZWcgKyBkaXN0O1xyXG4gICAgcmV0dXJuIGRpc3Q7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVEaXN0QnlDbGllbnQoY2xpZW50WCwgY2xpZW50WSwgZGlyZWN0aW9uLCBkYXRhcykge1xyXG4gICAgcmV0dXJuIGdldEFic29sdXRlRGlzdChnZXRSYWQoZGF0YXMuc3RhcnRBYnNvbHV0ZU9yaWdpbiwgW2NsaWVudFgsIGNsaWVudFldKSAvIE1hdGguUEkgKiAxODAsIGRpcmVjdGlvbiwgZGF0YXMpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJvdGF0ZUluZm8obW92ZWFibGUsIG1vdmVhYmxlUmVjdCwgZGF0YXMsIGRpc3QsIHN0YXJ0VmFsdWUsIGNoZWNrU25hcCkge1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMudGhyb3R0bGVSb3RhdGUsIHRocm90dGxlUm90YXRlID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYTtcclxuICAgIHZhciBwcmV2U25hcERlZyA9IGRhdGFzLnByZXZTbmFwRGVnO1xyXG4gICAgdmFyIHNuYXBSb3RhdGlvbiA9IDA7XHJcbiAgICB2YXIgaXNTbmFwID0gZmFsc2U7XHJcbiAgICBpZiAoY2hlY2tTbmFwKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNoZWNrU25hcFJvdGF0ZShtb3ZlYWJsZSwgbW92ZWFibGVSZWN0LCBkaXN0LCBzdGFydFZhbHVlICsgZGlzdCk7XHJcbiAgICAgICAgaXNTbmFwID0gcmVzdWx0LmlzU25hcDtcclxuICAgICAgICBzbmFwUm90YXRpb24gPSBzdGFydFZhbHVlICsgcmVzdWx0LmRpc3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzU25hcCkge1xyXG4gICAgICAgIHNuYXBSb3RhdGlvbiA9IHRocm90dGxlKHN0YXJ0VmFsdWUgKyBkaXN0LCB0aHJvdHRsZVJvdGF0ZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc25hcERlZyA9IHNuYXBSb3RhdGlvbiAtIHN0YXJ0VmFsdWU7XHJcbiAgICBkYXRhcy5wcmV2U25hcERlZyA9IHNuYXBEZWc7XHJcbiAgICByZXR1cm4gW3NuYXBEZWcgLSBwcmV2U25hcERlZywgc25hcERlZywgc25hcFJvdGF0aW9uXTtcclxufVxyXG5mdW5jdGlvbiBnZXRSb3RhdGlvblBvc2l0aW9ucyhyb3RhdGlvblBvc2l0aW9uLCBfYSwgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDQpLCBwb3MxID0gX2JbMF0sIHBvczIgPSBfYlsxXSwgcG9zMyA9IF9iWzJdLCBwb3M0ID0gX2JbM107XHJcbiAgICBpZiAocm90YXRpb25Qb3NpdGlvbiA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShyb3RhdGlvblBvc2l0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiByb3RhdGlvblBvc2l0aW9uLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGdldFJvdGF0aW9uUG9zaXRpb25zKGNoaWxkLCBbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0sIGRpcmVjdGlvbilbMF07IH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gX19yZWFkKChyb3RhdGlvblBvc2l0aW9uIHx8IFwidG9wXCIpLnNwbGl0KFwiLVwiKSwgMiksIGRpcjEgPSBfY1swXSwgZGlyMiA9IF9jWzFdO1xyXG4gICAgdmFyIHJhZFBvc2VzID0gW3BvczEsIHBvczJdO1xyXG4gICAgaWYgKGRpcjEgPT09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgcmFkUG9zZXMgPSBbcG9zMywgcG9zMV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkaXIxID09PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICByYWRQb3NlcyA9IFtwb3MyLCBwb3M0XTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRpcjEgPT09IFwiYm90dG9tXCIpIHtcclxuICAgICAgICByYWRQb3NlcyA9IFtwb3M0LCBwb3MzXTtcclxuICAgIH1cclxuICAgIHZhciBwb3MgPSBbXHJcbiAgICAgICAgKHJhZFBvc2VzWzBdWzBdICsgcmFkUG9zZXNbMV1bMF0pIC8gMixcclxuICAgICAgICAocmFkUG9zZXNbMF1bMV0gKyByYWRQb3Nlc1sxXVsxXSkgLyAyLFxyXG4gICAgXTtcclxuICAgIHZhciByYWQgPSBnZXRSb3RhdGlvblJhZChyYWRQb3NlcywgZGlyZWN0aW9uKTtcclxuICAgIGlmIChkaXIyKSB7XHJcbiAgICAgICAgdmFyIGlzU3RhcnQgPSBkaXIyID09PSBcInRvcFwiIHx8IGRpcjIgPT09IFwibGVmdFwiO1xyXG4gICAgICAgIHZhciBpc1JldmVyc2UgPSBkaXIxID09PSBcImJvdHRvbVwiIHx8IGRpcjEgPT09IFwibGVmdFwiO1xyXG4gICAgICAgIHBvcyA9IHJhZFBvc2VzWyhpc1N0YXJ0ICYmICFpc1JldmVyc2UpIHx8ICghaXNTdGFydCAmJiBpc1JldmVyc2UpID8gMCA6IDFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtbcG9zLCByYWRdXTtcclxufVxyXG5mdW5jdGlvbiBkcmFnQ29udHJvbENvbmRpdGlvbihtb3ZlYWJsZSwgZSkge1xyXG4gICAgaWYgKGUuaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGUucmVxdWVzdEFibGUgPT09IFwicm90YXRhYmxlXCI7XHJcbiAgICB9XHJcbiAgICB2YXIgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldDtcclxuICAgIGlmIChoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcInJvdGF0aW9uLWNvbnRyb2xcIikpXHJcbiAgICAgICAgfHwgKG1vdmVhYmxlLnByb3BzLnJvdGF0ZUFyb3VuZENvbnRyb2xzICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiYXJvdW5kLWNvbnRyb2xcIikpKVxyXG4gICAgICAgIHx8IChoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImNvbnRyb2xcIikpICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwicm90YXRhYmxlXCIpKSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHZhciByb3RhdGlvblRhcmdldCA9IG1vdmVhYmxlLnByb3BzLnJvdGF0aW9uVGFyZ2V0O1xyXG4gICAgaWYgKHJvdGF0aW9uVGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFJlZlRhcmdldHMocm90YXRpb25UYXJnZXQsIHRydWUpLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gZWxlbWVudCB8fCB0YXJnZXQuY29udGFpbnMoZWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxudmFyIGNzcyA9IFwiLnJvdGF0aW9uIHtcXG5wb3NpdGlvbjogYWJzb2x1dGU7XFxuaGVpZ2h0OiA0MHB4O1xcbndpZHRoOiAxcHg7XFxudHJhbnNmb3JtLW9yaWdpbjogNTAlIDEwMCU7XFxuaGVpZ2h0OiBjYWxjKDQwcHggKiB2YXIoLS16b29tKSk7XFxudG9wOiBhdXRvO1xcbmxlZnQ6IDA7XFxuYm90dG9tOiAxMDAlO1xcbndpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxufVxcbi5yb3RhdGlvbiAucm90YXRpb24tbGluZSB7XFxuZGlzcGxheTogYmxvY2s7XFxud2lkdGg6IDEwMCU7XFxuaGVpZ2h0OiAxMDAlO1xcbnRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XFxufVxcbi5yb3RhdGlvbiAucm90YXRpb24tY29udHJvbCB7XFxuYm9yZGVyLWNvbG9yOiAjNGFmO1xcbmJvcmRlci1jb2xvcjogdmFyKC0tbW92ZWFibGUtY29sb3IpO1xcbmJhY2tncm91bmQ6I2ZmZjtcXG5jdXJzb3I6IGFsaWFzO1xcbn1cXG46Z2xvYmFsIC52aWV3LXJvdGF0aW9uLWRyYWdnaW5nLCAucm90YXRhYmxlLmRpcmVjdGlvbi5jb250cm9sIHtcXG5jdXJzb3I6IGFsaWFzO1xcbn1cXG4ucm90YXRhYmxlLmRpcmVjdGlvbi5jb250cm9sLm1vdmUge1xcbmN1cnNvcjogbW92ZTtcXG59XFxuXCI7XHJcbnZhciBSb3RhdGFibGUgPSB7XHJcbiAgICBuYW1lOiBcInJvdGF0YWJsZVwiLFxyXG4gICAgY2FuUGluY2g6IHRydWUsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwicm90YXRhYmxlXCIsXHJcbiAgICAgICAgXCJyb3RhdGlvblBvc2l0aW9uXCIsXHJcbiAgICAgICAgXCJ0aHJvdHRsZVJvdGF0ZVwiLFxyXG4gICAgICAgIFwicmVuZGVyRGlyZWN0aW9uc1wiLFxyXG4gICAgICAgIFwicm90YXRpb25UYXJnZXRcIixcclxuICAgICAgICBcInJvdGF0ZUFyb3VuZENvbnRyb2xzXCIsXHJcbiAgICAgICAgXCJlZGdlXCIsXHJcbiAgICAgICAgXCJyZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlXCIsXHJcbiAgICAgICAgXCJkaXNwbGF5QXJvdW5kQ29udHJvbHNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInJvdGF0ZVN0YXJ0XCIsXHJcbiAgICAgICAgXCJiZWZvcmVSb3RhdGVcIixcclxuICAgICAgICBcInJvdGF0ZVwiLFxyXG4gICAgICAgIFwicm90YXRlRW5kXCIsXHJcbiAgICAgICAgXCJyb3RhdGVHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJiZWZvcmVSb3RhdGVHcm91cFwiLFxyXG4gICAgICAgIFwicm90YXRlR3JvdXBcIixcclxuICAgICAgICBcInJvdGF0ZUdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgY3NzOiBbY3NzXSxcclxuICAgIHZpZXdDbGFzc05hbWU6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIGlmICghbW92ZWFibGUuaXNEcmFnZ2luZyhcInJvdGF0YWJsZVwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByZWZpeChcInZpZXctcm90YXRpb24tZHJhZ2dpbmdcIik7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIF9hID0gZ2V0UHJvcHMobW92ZWFibGUucHJvcHMsIFwicm90YXRhYmxlXCIpLCByb3RhdGFibGUgPSBfYS5yb3RhdGFibGUsIHJvdGF0aW9uUG9zaXRpb24gPSBfYS5yb3RhdGlvblBvc2l0aW9uLCB6b29tID0gX2Euem9vbSwgcmVuZGVyRGlyZWN0aW9ucyA9IF9hLnJlbmRlckRpcmVjdGlvbnMsIHJvdGF0ZUFyb3VuZENvbnRyb2xzID0gX2Eucm90YXRlQXJvdW5kQ29udHJvbHMsIHJlc29sdmVBYmxlc1dpdGhSb3RhdGFibGUgPSBfYS5yZXNvbHZlQWJsZXNXaXRoUm90YXRhYmxlO1xyXG4gICAgICAgIHZhciBfYiA9IG1vdmVhYmxlLmdldFN0YXRlKCksIHJlbmRlclBvc2VzID0gX2IucmVuZGVyUG9zZXMsIGRpcmVjdGlvbiA9IF9iLmRpcmVjdGlvbjtcclxuICAgICAgICBpZiAoIXJvdGF0YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdldFJvdGF0aW9uUG9zaXRpb25zKHJvdGF0aW9uUG9zaXRpb24sIHJlbmRlclBvc2VzLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIHZhciBqc3hzID0gW107XHJcbiAgICAgICAgcG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKF9hLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHBvcyA9IF9iWzBdLCByYWQgPSBfYlsxXTtcclxuICAgICAgICAgICAganN4cy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwicm90YXRpb25cIi5jb25jYXQoaSksIGNsYXNzTmFtZTogcHJlZml4KFwicm90YXRpb25cIiksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUpIHRyYW5zbGF0ZShcIi5jb25jYXQocG9zWzBdLCBcInB4LCBcIikuY29uY2F0KHBvc1sxXSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocmFkLCBcInJhZClcIiksXHJcbiAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lIHJvdGF0aW9uLWxpbmVcIiksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZVgoXCIuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgICAgICB9IH0pLFxyXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbCByb3RhdGlvbi1jb250cm9sXCIpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDAuNXB4KSBzY2FsZShcIi5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVuZGVyRGlyZWN0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgYWJsZXMgPSBnZXRLZXlzKHJlc29sdmVBYmxlc1dpdGhSb3RhdGFibGUgfHwge30pO1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZU1hcF8xID0ge307XHJcbiAgICAgICAgICAgIGFibGVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVBYmxlc1dpdGhSb3RhdGFibGVbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1hcF8xW2RpcmVjdGlvbl0gPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uQ29udHJvbEluZm9zID0gW107XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHJlbmRlckRpcmVjdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25Db250cm9sSW5mb3MgPSByZW5kZXJEaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFibGUgPSByZXNvbHZlTWFwXzFbZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBhYmxlID8geyByZXNvbHZlOiBhYmxlIH0gOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lczogYWJsZSA/IFtcIm1vdmVcIl0gOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiBkaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGpzeHMucHVzaC5hcHBseShqc3hzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocmVuZGVyRGlyZWN0aW9uQ29udHJvbHNCeUluZm9zKG1vdmVhYmxlLCBcInJvdGF0YWJsZVwiLCBkaXJlY3Rpb25Db250cm9sSW5mb3MsIFJlYWN0KSksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3RhdGVBcm91bmRDb250cm9scykge1xyXG4gICAgICAgICAgICBqc3hzLnB1c2guYXBwbHkoanN4cywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlbmRlckFyb3VuZENvbnRyb2xzKG1vdmVhYmxlLCBSZWFjdCkpLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ganN4cztcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZHJhZ0NvbnRyb2xDb25kaXRpb24sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF9iO1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIGNsaWVudFggPSBlLmNsaWVudFgsIGNsaWVudFkgPSBlLmNsaWVudFksIHBhcmVudFJvdGF0ZSA9IGUucGFyZW50Um90YXRlLCBwYXJlbnRGbGFnID0gZS5wYXJlbnRGbGFnLCBpc1BpbmNoID0gZS5pc1BpbmNoLCBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0LCBsZWZ0ID0gc3RhdGUubGVmdCwgdG9wID0gc3RhdGUudG9wLCBkaXJlY3Rpb24gPSBzdGF0ZS5kaXJlY3Rpb24sIGJlZm9yZURpcmVjdGlvbiA9IHN0YXRlLmJlZm9yZURpcmVjdGlvbiwgdGFyZ2V0VHJhbnNmb3JtID0gc3RhdGUudGFyZ2V0VHJhbnNmb3JtLCBtb3ZlYWJsZUNsaWVudFJlY3QgPSBzdGF0ZS5tb3ZlYWJsZUNsaWVudFJlY3QsIG9mZnNldE1hdHJpeCA9IHN0YXRlLm9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4ID0gc3RhdGUudGFyZ2V0TWF0cml4LCBhbGxNYXRyaXggPSBzdGF0ZS5hbGxNYXRyaXgsIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcclxuICAgICAgICBpZiAoIWlzUmVxdWVzdCAmJiAhdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlY3QgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XHJcbiAgICAgICAgZGF0YXMucmVjdCA9IHJlY3Q7XHJcbiAgICAgICAgZGF0YXMudHJhbnNmb3JtID0gdGFyZ2V0VHJhbnNmb3JtO1xyXG4gICAgICAgIGRhdGFzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIGRhdGFzLnRvcCA9IHRvcDtcclxuICAgICAgICB2YXIgc2V0Rml4ZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIChmaXhlZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRPZmZzZXRGaXhlZFBvc2l0aW9uSW5mbyhtb3ZlYWJsZS5zdGF0ZSwgZml4ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gcmVzdWx0LmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZE9mZnNldCA9IHJlc3VsdC5maXhlZE9mZnNldDtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRQb3NpdGlvbiA9IHJlc3VsdC5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBpZiAocmVzaXplU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZVN0YXJ0LnNldEZpeGVkUG9zaXRpb24oZml4ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzZXRGaXhlZERpcmVjdGlvbiA9IGZ1bmN0aW9uIChmaXhlZERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0T2Zmc2V0Rml4ZWREaXJlY3Rpb25JbmZvKG1vdmVhYmxlLnN0YXRlLCBmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkRGlyZWN0aW9uID0gcmVzdWx0LmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBkYXRhcy5maXhlZE9mZnNldCA9IHJlc3VsdC5maXhlZE9mZnNldDtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRQb3NpdGlvbiA9IHJlc3VsdC5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBpZiAocmVzaXplU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZVN0YXJ0LnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0YXJ0Q2xpZW50WCA9IGNsaWVudFg7XHJcbiAgICAgICAgdmFyIHN0YXJ0Q2xpZW50WSA9IGNsaWVudFk7XHJcbiAgICAgICAgaWYgKGlzUmVxdWVzdCB8fCBpc1BpbmNoIHx8IHBhcmVudEZsYWcpIHtcclxuICAgICAgICAgICAgdmFyIGV4dGVybmFsUm90YXRlID0gcGFyZW50Um90YXRlIHx8IDA7XHJcbiAgICAgICAgICAgIGRhdGFzLmJlZm9yZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW46IHJlY3QuYmVmb3JlT3JpZ2luLFxyXG4gICAgICAgICAgICAgICAgcHJldkRlZzogZXh0ZXJuYWxSb3RhdGUsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGVnOiBleHRlcm5hbFJvdGF0ZSxcclxuICAgICAgICAgICAgICAgIHByZXZTbmFwRGVnOiAwLFxyXG4gICAgICAgICAgICAgICAgc3RhcnREaXN0OiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkYXRhcy5hZnRlckluZm8gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YXMuYmVmb3JlSW5mbyksIHsgb3JpZ2luOiByZWN0Lm9yaWdpbiB9KTtcclxuICAgICAgICAgICAgZGF0YXMuYWJzb2x1dGVJbmZvID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGFzLmJlZm9yZUluZm8pLCB7IG9yaWdpbjogcmVjdC5vcmlnaW4sIHN0YXJ0VmFsdWU6IGV4dGVybmFsUm90YXRlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0VGFyZ2V0ID0gKF9iID0gZS5pbnB1dEV2ZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRUYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWdpb25EaXJlY3Rpb24gPSBpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpcmVjdGlvblwiKSB8fCBcIlwiO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xEaXJlY3Rpb24gPSBESVJFQ1RJT05fUkVHSU9OX1RPX0RJUkVDVElPTltyZWdpb25EaXJlY3Rpb25dO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xEaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhcy5pc0NvbnRyb2wgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzLmlzQXJvdW5kQ29udHJvbCA9IGhhc0NsYXNzKGlucHV0VGFyZ2V0LCBwcmVmaXgoXCJhcm91bmQtY29udHJvbFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXMuY29udHJvbERpcmVjdGlvbiA9IGNvbnRyb2xEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmUgPSBpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc29sdmVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXMucmVzb2x2ZUFibGUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpZW50UG9zZXMgPSBjYWxjdWxhdGVNb3ZlYWJsZUNsaWVudFBvc2l0aW9ucyhzdGF0ZS5yb290TWF0cml4LCBzdGF0ZS5yZW5kZXJQb3NlcywgbW92ZWFibGVDbGllbnRSZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9fcmVhZChnZXRQb3NCeURpcmVjdGlvbihjbGllbnRQb3NlcywgY29udHJvbERpcmVjdGlvbiksIDIpLCBzdGFydENsaWVudFggPSBfYVswXSwgc3RhcnRDbGllbnRZID0gX2FbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YXMuYmVmb3JlSW5mbyA9IHsgb3JpZ2luOiByZWN0LmJlZm9yZU9yaWdpbiB9O1xyXG4gICAgICAgICAgICBkYXRhcy5hZnRlckluZm8gPSB7IG9yaWdpbjogcmVjdC5vcmlnaW4gfTtcclxuICAgICAgICAgICAgZGF0YXMuYWJzb2x1dGVJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luOiByZWN0Lm9yaWdpbixcclxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHJlY3Qucm90YXRpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEZpeGVkUG9zaXRpb25fMSA9IHNldEZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgICAgIHNldEZpeGVkUG9zaXRpb24gPSBmdW5jdGlvbiAoZml4ZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGF0ZS5pczNkID8gNCA6IDM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQocGx1cyhnZXRPcmlnaW4odGFyZ2V0TWF0cml4LCBuKSwgZml4ZWRQb3NpdGlvbiksIDIpLCBvcmlnaW5YID0gX2FbMF0sIG9yaWdpblkgPSBfYVsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBmaXhlZEJlZm9yZU9yaWdpbiA9IGNhbGN1bGF0ZShvZmZzZXRNYXRyaXgsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChbb3JpZ2luWCwgb3JpZ2luWV0sIG4pKTtcclxuICAgICAgICAgICAgICAgIHZhciBmaXhlZEFmdGVyT3JpZ2luID0gY2FsY3VsYXRlKGFsbE1hdHJpeCwgY29udmVydFBvc2l0aW9uTWF0cml4KFtmaXhlZFBvc2l0aW9uWzBdLCBmaXhlZFBvc2l0aW9uWzFdXSwgbikpO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxGaXhlZFBvc2l0aW9uXzEoZml4ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zRGVsdGEgPSBzdGF0ZS5wb3NEZWx0YTtcclxuICAgICAgICAgICAgICAgIGRhdGFzLmJlZm9yZUluZm8ub3JpZ2luID0gbWludXMoZml4ZWRCZWZvcmVPcmlnaW4sIHBvc0RlbHRhKTtcclxuICAgICAgICAgICAgICAgIGRhdGFzLmFmdGVySW5mby5vcmlnaW4gPSBtaW51cyhmaXhlZEFmdGVyT3JpZ2luLCBwb3NEZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5hYnNvbHV0ZUluZm8ub3JpZ2luID0gbWludXMoZml4ZWRBZnRlck9yaWdpbiwgcG9zRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgc2V0Um90YXRlU3RhcnRJbmZvKG1vdmVhYmxlLCBkYXRhcy5iZWZvcmVJbmZvLCBzdGFydENsaWVudFgsIHN0YXJ0Q2xpZW50WSwgbW92ZWFibGVDbGllbnRSZWN0KTtcclxuICAgICAgICAgICAgICAgIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMuYWZ0ZXJJbmZvLCBzdGFydENsaWVudFgsIHN0YXJ0Q2xpZW50WSwgbW92ZWFibGVDbGllbnRSZWN0KTtcclxuICAgICAgICAgICAgICAgIHNldFJvdGF0ZVN0YXJ0SW5mbyhtb3ZlYWJsZSwgZGF0YXMuYWJzb2x1dGVJbmZvLCBzdGFydENsaWVudFgsIHN0YXJ0Q2xpZW50WSwgbW92ZWFibGVDbGllbnRSZWN0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2V0Rml4ZWREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZml4ZWREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gZ2V0UG9zQnlEaXJlY3Rpb24oW1xyXG4gICAgICAgICAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICBbd2lkdGgsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFswLCBoZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgIF0sIGZpeGVkRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHNldEZpeGVkUG9zaXRpb24oZml4ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLnN0YXJ0Q2xpZW50WCA9IHN0YXJ0Q2xpZW50WDtcclxuICAgICAgICBkYXRhcy5zdGFydENsaWVudFkgPSBzdGFydENsaWVudFk7XHJcbiAgICAgICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIGRhdGFzLmJlZm9yZURpcmVjdGlvbiA9IGJlZm9yZURpcmVjdGlvbjtcclxuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gMDtcclxuICAgICAgICBkYXRhcy5kYXRhcyA9IHt9O1xyXG4gICAgICAgIHNldERlZmF1bHRUcmFuc2Zvcm1JbmRleChtb3ZlYWJsZSwgZSwgXCJyb3RhdGVcIik7XHJcbiAgICAgICAgdmFyIGRyYWdTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciByZXNpemVTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChkYXRhcy5pc0NvbnRyb2wgJiYgZGF0YXMucmVzb2x2ZUFibGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVBYmxlID0gZGF0YXMucmVzb2x2ZUFibGU7XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlQWJsZSA9PT0gXCJyZXNpemFibGVcIikge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplU3RhcnQgPSBSZXNpemFibGUuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIChuZXcgQ3VzdG9tR2VzdG8oXCJyZXNpemFibGVcIikuZHJhZ1N0YXJ0KFswLCAwXSwgZSkpKSwgeyBwYXJlbnRQb3NpdGlvbjogZGF0YXMuY29udHJvbFBvc2l0aW9uLCBwYXJlbnRGaXhlZFBvc2l0aW9uOiBkYXRhcy5maXhlZFBvc2l0aW9uIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlc2l6ZVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGRyYWdTdGFydCA9IERyYWdnYWJsZS5kcmFnU3RhcnQobW92ZWFibGUsIG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChbMCwgMF0sIGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0Rml4ZWRQb3NpdGlvbihnZXRUb3RhbE9yaWdpbihtb3ZlYWJsZSkpO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7IHNldDogZnVuY3Rpb24gKHJvdGF0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGRhdGFzLnN0YXJ0VmFsdWUgPSByb3RhdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgfSwgc2V0Rml4ZWREaXJlY3Rpb246IHNldEZpeGVkRGlyZWN0aW9uLCBzZXRGaXhlZFBvc2l0aW9uOiBzZXRGaXhlZFBvc2l0aW9uIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KG1vdmVhYmxlLCBlKSksIHsgZHJhZ1N0YXJ0OiBkcmFnU3RhcnQsIHJlc2l6ZVN0YXJ0OiByZXNpemVTdGFydCB9KSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZVN0YXJ0XCIsIHBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuaXNSb3RhdGUgPSByZXN1bHQgIT09IGZhbHNlO1xyXG4gICAgICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0ge1xyXG4gICAgICAgICAgICByZXF1ZXN0OiBlLmlzUmVxdWVzdCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBkYXRhcy5pc1JvdGF0ZSA/IHBhcmFtcyA6IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBjbGllbnREaXN0WCA9IGUuY2xpZW50RGlzdFgsIGNsaWVudERpc3RZID0gZS5jbGllbnREaXN0WSwgcGFyZW50Um90YXRlID0gZS5wYXJlbnRSb3RhdGUsIHBhcmVudEZsYWcgPSBlLnBhcmVudEZsYWcsIGlzUGluY2ggPSBlLmlzUGluY2gsIGdyb3VwRGVsdGEgPSBlLmdyb3VwRGVsdGEsIHJlc29sdmVNYXRyaXggPSBlLnJlc29sdmVNYXRyaXg7XHJcbiAgICAgICAgdmFyIGJlZm9yZURpcmVjdGlvbiA9IGRhdGFzLmJlZm9yZURpcmVjdGlvbiwgYmVmb3JlSW5mbyA9IGRhdGFzLmJlZm9yZUluZm8sIGFmdGVySW5mbyA9IGRhdGFzLmFmdGVySW5mbywgYWJzb2x1dGVJbmZvID0gZGF0YXMuYWJzb2x1dGVJbmZvLCBpc1JvdGF0ZSA9IGRhdGFzLmlzUm90YXRlLCBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZSwgcmVjdCA9IGRhdGFzLnJlY3QsIHN0YXJ0Q2xpZW50WCA9IGRhdGFzLnN0YXJ0Q2xpZW50WCwgc3RhcnRDbGllbnRZID0gZGF0YXMuc3RhcnRDbGllbnRZO1xyXG4gICAgICAgIGlmICghaXNSb3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNvbHZlVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIGUsIFwicm90YXRlXCIpO1xyXG4gICAgICAgIHZhciB0YXJnZXREaXJlY3Rpb24gPSBnZXRUcmFuc2Zvcm1EaXJlY3Rpb24oZSk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGJlZm9yZURpcmVjdGlvbiAqIHRhcmdldERpcmVjdGlvbjtcclxuICAgICAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBtb3ZlYWJsZS5wcm9wcy5wYXJlbnRNb3ZlYWJsZTtcclxuICAgICAgICB2YXIgYmVmb3JlRGVsdGEgPSAwO1xyXG4gICAgICAgIHZhciBiZWZvcmVEaXN0O1xyXG4gICAgICAgIHZhciBiZWZvcmVSb3RhdGlvbjtcclxuICAgICAgICB2YXIgZGVsdGEgPSAwO1xyXG4gICAgICAgIHZhciBkaXN0O1xyXG4gICAgICAgIHZhciByb3RhdGlvbjtcclxuICAgICAgICB2YXIgYWJzb2x1dGVEZWx0YSA9IDA7XHJcbiAgICAgICAgdmFyIGFic29sdXRlRGlzdDtcclxuICAgICAgICB2YXIgYWJzb2x1dGVSb3RhdGlvbjtcclxuICAgICAgICB2YXIgc3RhcnRSb3RhdGlvbiA9IDE4MCAvIE1hdGguUEkgKiBzdGFydFZhbHVlO1xyXG4gICAgICAgIHZhciBhYnNvbHV0ZVN0YXJ0Um90YXRpb24gPSBhYnNvbHV0ZUluZm8uc3RhcnRWYWx1ZTtcclxuICAgICAgICB2YXIgaXNTbmFwID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG5leHRDbGllbnRYID0gc3RhcnRDbGllbnRYICsgY2xpZW50RGlzdFg7XHJcbiAgICAgICAgdmFyIG5leHRDbGllbnRZID0gc3RhcnRDbGllbnRZICsgY2xpZW50RGlzdFk7XHJcbiAgICAgICAgaWYgKCFwYXJlbnRGbGFnICYmIFwicGFyZW50RGlzdFwiIGluIGUpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudERpc3QgPSBlLnBhcmVudERpc3Q7XHJcbiAgICAgICAgICAgIGJlZm9yZURpc3QgPSBwYXJlbnREaXN0O1xyXG4gICAgICAgICAgICBkaXN0ID0gcGFyZW50RGlzdDtcclxuICAgICAgICAgICAgYWJzb2x1dGVEaXN0ID0gcGFyZW50RGlzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNQaW5jaCB8fCBwYXJlbnRGbGFnKSB7XHJcbiAgICAgICAgICAgIGJlZm9yZURpc3QgPSBnZXRBYnNvbHV0ZURpc3QocGFyZW50Um90YXRlLCBiZWZvcmVEaXJlY3Rpb24sIGJlZm9yZUluZm8pO1xyXG4gICAgICAgICAgICBkaXN0ID0gZ2V0QWJzb2x1dGVEaXN0KHBhcmVudFJvdGF0ZSwgZGlyZWN0aW9uLCBhZnRlckluZm8pO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZURpc3QgPSBnZXRBYnNvbHV0ZURpc3QocGFyZW50Um90YXRlLCBkaXJlY3Rpb24sIGFic29sdXRlSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBiZWZvcmVEaXN0ID0gZ2V0QWJzb2x1dGVEaXN0QnlDbGllbnQobmV4dENsaWVudFgsIG5leHRDbGllbnRZLCBiZWZvcmVEaXJlY3Rpb24sIGJlZm9yZUluZm8pO1xyXG4gICAgICAgICAgICBkaXN0ID0gZ2V0QWJzb2x1dGVEaXN0QnlDbGllbnQobmV4dENsaWVudFgsIG5leHRDbGllbnRZLCBkaXJlY3Rpb24sIGFmdGVySW5mbyk7XHJcbiAgICAgICAgICAgIGFic29sdXRlRGlzdCA9IGdldEFic29sdXRlRGlzdEJ5Q2xpZW50KG5leHRDbGllbnRYLCBuZXh0Q2xpZW50WSwgZGlyZWN0aW9uLCBhYnNvbHV0ZUluZm8pO1xyXG4gICAgICAgICAgICBpc1NuYXAgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiZWZvcmVSb3RhdGlvbiA9IHN0YXJ0Um90YXRpb24gKyBiZWZvcmVEaXN0O1xyXG4gICAgICAgIHJvdGF0aW9uID0gc3RhcnRSb3RhdGlvbiArIGRpc3Q7XHJcbiAgICAgICAgYWJzb2x1dGVSb3RhdGlvbiA9IGFic29sdXRlU3RhcnRSb3RhdGlvbiArIGFic29sdXRlRGlzdDtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSb3RhdGVcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBiZWZvcmVSb3RhdGlvbjogYmVmb3JlUm90YXRpb24sXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcclxuICAgICAgICAgICAgYWJzb2x1dGVSb3RhdGlvbjogYWJzb2x1dGVSb3RhdGlvbixcclxuICAgICAgICAgICAgc2V0Um90YXRpb246IGZ1bmN0aW9uIChuZXh0Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGRpc3QgPSBuZXh0Um90YXRpb24gLSBzdGFydFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlRGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZURpc3QgPSBkaXN0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sIHRydWUpKTtcclxuICAgICAgICBfYSA9IF9fcmVhZChnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBiZWZvcmVJbmZvLCBiZWZvcmVEaXN0LCBzdGFydFJvdGF0aW9uLCBpc1NuYXApLCAzKSwgYmVmb3JlRGVsdGEgPSBfYVswXSwgYmVmb3JlRGlzdCA9IF9hWzFdLCBiZWZvcmVSb3RhdGlvbiA9IF9hWzJdO1xyXG4gICAgICAgIF9iID0gX19yZWFkKGdldFJvdGF0ZUluZm8obW92ZWFibGUsIHJlY3QsIGFmdGVySW5mbywgZGlzdCwgc3RhcnRSb3RhdGlvbiwgaXNTbmFwKSwgMyksIGRlbHRhID0gX2JbMF0sIGRpc3QgPSBfYlsxXSwgcm90YXRpb24gPSBfYlsyXTtcclxuICAgICAgICBfYyA9IF9fcmVhZChnZXRSb3RhdGVJbmZvKG1vdmVhYmxlLCByZWN0LCBhYnNvbHV0ZUluZm8sIGFic29sdXRlRGlzdCwgYWJzb2x1dGVTdGFydFJvdGF0aW9uLCBpc1NuYXApLCAzKSwgYWJzb2x1dGVEZWx0YSA9IF9jWzBdLCBhYnNvbHV0ZURpc3QgPSBfY1sxXSwgYWJzb2x1dGVSb3RhdGlvbiA9IF9jWzJdO1xyXG4gICAgICAgIGlmICghYWJzb2x1dGVEZWx0YSAmJiAhZGVsdGEgJiYgIWJlZm9yZURlbHRhICYmICFwYXJlbnRNb3ZlYWJsZSAmJiAhcmVzb2x2ZU1hdHJpeCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0VHJhbnNmb3JtID0gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0aW9uLCBcImRlZylcIiksIFwicm90YXRlKFwiLmNvbmNhdChkaXN0LCBcImRlZylcIikpO1xyXG4gICAgICAgIGlmIChyZXNvbHZlTWF0cml4KSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSBnZXRUcmFuc2xhdGVGaXhlZFBvc2l0aW9uKG1vdmVhYmxlLCBkYXRhcy50YXJnZXRBbGxUcmFuc2Zvcm0sIGRhdGFzLmZpeGVkRGlyZWN0aW9uLCBkYXRhcy5maXhlZE9mZnNldCwgZGF0YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW52ZXJzZURpc3QgPSBnZXRSb3RhdGVEaXN0KG1vdmVhYmxlLCBkaXN0LCBkYXRhcyk7XHJcbiAgICAgICAgdmFyIGludmVyc2VEZWx0YSA9IG1pbnVzKHBsdXMoZ3JvdXBEZWx0YSB8fCBbMCwgMF0sIGludmVyc2VEaXN0KSwgZGF0YXMucHJldkludmVyc2VEaXN0IHx8IFswLCAwXSk7XHJcbiAgICAgICAgZGF0YXMucHJldkludmVyc2VEaXN0ID0gaW52ZXJzZURpc3Q7XHJcbiAgICAgICAgZGF0YXMucmVxdWVzdFZhbHVlID0gbnVsbDtcclxuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gZmlsbFRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBuZXh0VHJhbnNmb3JtLCBpbnZlcnNlRGVsdGEsIGlzUGluY2gsIGUpO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1FdmVudCA9IGRyYWdFdmVudDtcclxuICAgICAgICB2YXIgcGFyZW50RGlzdGFuY2UgPSBnZXREaXN0JDEoW25leHRDbGllbnRYLCBuZXh0Q2xpZW50WV0sIGFic29sdXRlSW5mby5zdGFydEFic29sdXRlT3JpZ2luKSAtIGFic29sdXRlSW5mby5zdGFydERpc3Q7XHJcbiAgICAgICAgdmFyIHJlc2l6ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoZGF0YXMucmVzb2x2ZUFibGUgPT09IFwicmVzaXphYmxlXCIpIHtcclxuICAgICAgICAgICAgdmFyIHJlc2l6ZUV2ZW50ID0gUmVzaXphYmxlLmRyYWdDb250cm9sKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2V0Q3VzdG9tRHJhZyhlLCBtb3ZlYWJsZS5zdGF0ZSwgW2UuZGVsdGFYLCBlLmRlbHRhWV0sICEhaXNQaW5jaCwgZmFsc2UsIFwicmVzaXphYmxlXCIpKSwgeyByZXNvbHZlTWF0cml4OiB0cnVlLCBwYXJlbnREaXN0YW5jZTogcGFyZW50RGlzdGFuY2UgfSkpO1xyXG4gICAgICAgICAgICBpZiAocmVzaXplRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZSA9IHJlc2l6ZUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtRXZlbnQgPSBmaWxsQWZ0ZXJUcmFuc2Zvcm0odHJhbnNmb3JtRXZlbnQsIHJlc2l6ZUV2ZW50LCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oeyBkZWx0YTogZGVsdGEsIGRpc3Q6IGRpc3QsIHJvdGF0ZTogcm90YXRpb24sIHJvdGF0aW9uOiByb3RhdGlvbiwgYmVmb3JlRGlzdDogYmVmb3JlRGlzdCwgYmVmb3JlRGVsdGE6IGJlZm9yZURlbHRhLCBiZWZvcmVSb3RhdGU6IGJlZm9yZVJvdGF0aW9uLCBiZWZvcmVSb3RhdGlvbjogYmVmb3JlUm90YXRpb24sIGFic29sdXRlRGlzdDogYWJzb2x1dGVEaXN0LCBhYnNvbHV0ZURlbHRhOiBhYnNvbHV0ZURlbHRhLCBhYnNvbHV0ZVJvdGF0ZTogYWJzb2x1dGVSb3RhdGlvbiwgYWJzb2x1dGVSb3RhdGlvbjogYWJzb2x1dGVSb3RhdGlvbiwgaXNQaW5jaDogISFpc1BpbmNoLCByZXNpemU6IHJlc2l6ZSB9LCBkcmFnRXZlbnQpLCB0cmFuc2Zvcm1FdmVudCkpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZVwiLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1JvdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLmlzUm90YXRlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3RhdGVFbmRcIiwgcGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRyYWdDb250cm9sQ29uZGl0aW9uLFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCBwYXJlbnRMZWZ0ID0gX2EubGVmdCwgcGFyZW50VG9wID0gX2EudG9wLCBwYXJlbnRCZWZvcmVPcmlnaW4gPSBfYS5iZWZvcmVPcmlnaW47XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJhbXMuc2V0KGRhdGFzLmJlZm9yZURpcmVjdGlvbiAqIG1vdmVhYmxlLnJvdGF0aW9uKTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xTdGFydFwiLCBlLCBmdW5jdGlvbiAoY2hpbGQsIGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGNoaWxkLnN0YXRlLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCBiZWZvcmVPcmlnaW4gPSBfYS5iZWZvcmVPcmlnaW47XHJcbiAgICAgICAgICAgIHZhciBjaGlsZENsaWVudCA9IHBsdXMobWludXMoW2xlZnQsIHRvcF0sIFtwYXJlbnRMZWZ0LCBwYXJlbnRUb3BdKSwgbWludXMoYmVmb3JlT3JpZ2luLCBwYXJlbnRCZWZvcmVPcmlnaW4pKTtcclxuICAgICAgICAgICAgZXYuZGF0YXMuc3RhcnRHcm91cENsaWVudCA9IGNoaWxkQ2xpZW50O1xyXG4gICAgICAgICAgICBldi5kYXRhcy5ncm91cENsaWVudCA9IGNoaWxkQ2xpZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwgeyBwYXJlbnRSb3RhdGU6IDAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1zKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cyB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm90YXRlR3JvdXBTdGFydFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICBkYXRhcy5pc1JvdGF0ZSA9IHJlc3VsdCAhPT0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFzLmlzUm90YXRlID8gcGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWRhdGFzLmlzUm90YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2hFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJvdGF0ZVwiLCBmdW5jdGlvbiAocGFyZW50RXZlbnQpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUm90YXRlR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmVudEV2ZW50KSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pLCB0cnVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2wobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRhdGFzLmJlZm9yZURpcmVjdGlvbjtcclxuICAgICAgICB2YXIgcGFyZW50Um90YXRlID0gcGFyYW1zLmJlZm9yZURpc3Q7XHJcbiAgICAgICAgdmFyIHJhZCA9IHBhcmVudFJvdGF0ZSAvIDE4MCAqIE1hdGguUEk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sXCIsIGUsIGZ1bmN0aW9uIChfLCBldikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRHcm91cENsaWVudCA9IGV2LmRhdGFzLnN0YXJ0R3JvdXBDbGllbnQ7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChldi5kYXRhcy5ncm91cENsaWVudCwgMiksIHByZXZDbGllbnRYID0gX2FbMF0sIHByZXZDbGllbnRZID0gX2FbMV07XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyb3RhdGUoc3RhcnRHcm91cENsaWVudCwgcmFkICogZGlyZWN0aW9uKSwgMiksIGNsaWVudFggPSBfYlswXSwgY2xpZW50WSA9IF9iWzFdO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBbY2xpZW50WCAtIHByZXZDbGllbnRYLCBjbGllbnRZIC0gcHJldkNsaWVudFldO1xyXG4gICAgICAgICAgICBldi5kYXRhcy5ncm91cENsaWVudCA9IFtjbGllbnRYLCBjbGllbnRZXTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgcGFyZW50Um90YXRlOiBwYXJlbnRSb3RhdGUsIGdyb3VwRGVsdGE6IGRlbHRhIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vdmVhYmxlLnJvdGF0aW9uID0gZGlyZWN0aW9uICogcGFyYW1zLmJlZm9yZVJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cywgc2V0OiBmdW5jdGlvbiAocm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIG1vdmVhYmxlLnJvdGF0aW9uID0gcm90YXRpb247XHJcbiAgICAgICAgICAgIH0sIHNldEdyb3VwUm90YXRpb246IGZ1bmN0aW9uIChyb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbW92ZWFibGUucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgfSB9LCBwYXJhbXMpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZUdyb3VwXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0UGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBpc0RyYWcgPSBlLmlzRHJhZywgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNSb3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xFbmRcIiwgZSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXHJcbiAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdGF0ZUdyb3VwRW5kXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBpc0RyYWc7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlLlJvdGF0YWJsZSNyZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2VdIC0gdGhlIFJlc2l6YWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFSb3RhdGU9MF0gLSAgZGVsdGEgbnVtYmVyIG9mIHJvdGF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Uucm90YXRlPTBdIC0gYWJzb2x1dGUgbnVtYmVyIG9mIG1vdmVhYmxlJ3Mgcm90YXRpb25cclxuICAgICAqIEByZXR1cm4ge01vdmVhYmxlLlJlcXVlc3Rlcn0gTW92ZWFibGUgUmVxdWVzdGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG5cbiAgICAgKiAvLyBJbnN0YW50bHkgUmVxdWVzdCAocmVxdWVzdFN0YXJ0IC0gcmVxdWVzdCAtIHJlcXVlc3RFbmQpXHJcbiAgICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwicm90YXRhYmxlXCIsIHsgZGVsdGFSb3RhdGU6IDEwIH0sIHRydWUpO1xyXG4gICAgICpcclxuICAgICAqICogbW92ZWFibGUucmVxdWVzdChcInJvdGF0YWJsZVwiLCB7IHJvdGF0ZTogMTAgfSwgdHJ1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdFN0YXJ0XHJcbiAgICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwicm90YXRhYmxlXCIpO1xyXG4gICAgICpcclxuICAgICAqIC8vIHJlcXVlc3RcclxuICAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFSb3RhdGU6IDEwIH0pO1xyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVJvdGF0ZTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhUm90YXRlOiAxMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IHJvdGF0ZTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IHJvdGF0ZTogMjAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IHJvdGF0ZTogMzAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdEVuZFxyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcclxuICAgICAqL1xyXG4gICAgcmVxdWVzdDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0ge307XHJcbiAgICAgICAgdmFyIGRpc3RSb3RhdGUgPSAwO1xyXG4gICAgICAgIHZhciBzdGFydFJvdGF0aW9uID0gbW92ZWFibGUuZ2V0Um90YXRpb24oKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0NvbnRyb2w6IHRydWUsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJkZWx0YVJvdGF0ZVwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0Um90YXRlICs9IGUuZGVsdGFSb3RhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInJvdGF0ZVwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0Um90YXRlID0gZS5yb3RhdGUgLSBzdGFydFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCBwYXJlbnREaXN0OiBkaXN0Um90YXRlIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcywgaXNEcmFnOiB0cnVlIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHJvdGF0ZWQuIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuUm90YXRhYmxlI3JvdGF0YWJsZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5yb3RhdGFibGUgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIHJvdGF0aW9uLiAoZGVmYXVsdDogXCJ0b3BcIilcclxuICogQG5hbWUgTW92ZWFibGUuUm90YXRhYmxlI3JvdGF0aW9uUG9zaXRpb25cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgcm90YXRpb25Qb3NpdGlvbjogXCJ0b3BcIixcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnJvdGF0aW9uUG9zaXRpb24gPSBcImJvdHRvbVwiXHJcbiAqL1xyXG4vKipcclxuICogdGhyb3R0bGUgb2YgYW5nbGUoZGVncmVlKSB3aGVuIHJvdGF0ZS5cclxuICogQG5hbWUgTW92ZWFibGUuUm90YXRhYmxlI3Rocm90dGxlUm90YXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnRocm90dGxlUm90YXRlID0gMTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSByb3RhdGUgc3RhcnRzLCB0aGUgcm90YXRlU3RhcnQgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm90YXRhYmxlXHJcbiAqIEBldmVudCByb3RhdGVTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZVN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGVTdGFydCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgcm90YXRhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZVN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4qIFdoZW4gcm90YXRpbmcsIHRoZSByb3RhdGUgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcclxuKiBAZXZlbnQgcm90YXRlXHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHJvdGF0ZSBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyByb3RhdGFibGU6IHRydWUgfSk7XHJcbiogbW92ZWFibGUub24oXCJyb3RhdGVcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpc3QgfSkgPT4ge1xyXG4qICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogV2hlbiB0aGUgcm90YXRlIGZpbmlzaGVzLCB0aGUgcm90YXRlRW5kIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxyXG4gKiBAZXZlbnQgcm90YXRlRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm90YXRhYmxlLk9uUm90YXRlRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSByb3RhdGVFbmQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHJvdGF0YWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3RhdGVFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBncm91cCByb3RhdGUgc3RhcnRzLCB0aGUgYHJvdGF0ZUdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxyXG4gKiBAZXZlbnQgcm90YXRlR3JvdXBTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3RhdGVHcm91cFN0YXJ0YCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICByb3RhdGFibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25Sb3RhdGVHcm91cFN0YXJ0XCIsIHRhcmdldHMpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIHJvdGF0ZSwgdGhlIGByb3RhdGVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3RhdGFibGVcclxuKiBAZXZlbnQgcm90YXRlR3JvdXBcclxuKiBAcGFyYW0ge01vdmVhYmxlLlJvdGF0YWJsZS5PblJvdGF0ZUdyb3VwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm90YXRlR3JvdXBgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiogICAgIHJvdGF0YWJsZTogdHJ1ZVxyXG4qIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwicm90YXRlR3JvdXBcIiwgKHsgdGFyZ2V0cywgZXZlbnRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvblJvdGF0ZUdyb3VwXCIsIHRhcmdldHMpO1xyXG4qICAgICBldmVudHMuZm9yRWFjaChldiA9PiB7XHJcbiogICAgICAgICBjb25zdCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiogICAgICAgICAvLyBldi5kcmFnIGlzIGEgZHJhZyBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBncm91cCByb3RhdGUuXHJcbiogICAgICAgICBjb25zdCBsZWZ0ID0gZXYuZHJhZy5iZWZvcmVEaXN0WzBdO1xyXG4qICAgICAgICAgY29uc3QgdG9wID0gZXYuZHJhZy5iZWZvcmVEaXN0WzFdO1xyXG4qICAgICAgICAgY29uc3QgZGVnID0gZXYuYmVmb3JlRGlzdDtcclxuKiAgICAgfSk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBncm91cCByb3RhdGUgZmluaXNoZXMsIHRoZSBgcm90YXRlR3JvdXBFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdGF0YWJsZVxyXG4gKiBAZXZlbnQgcm90YXRlR3JvdXBFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3RhdGFibGUuT25Sb3RhdGVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdGF0ZUdyb3VwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICByb3RhdGFibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm90YXRlR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25Sb3RhdGVHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXG5cbmZ1bmN0aW9uIHJlbmRlckd1aWRlbGluZShpbmZvLCBSZWFjdCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIGRpcmVjdGlvbiA9IGluZm8uZGlyZWN0aW9uLCBjbGFzc05hbWVzID0gaW5mby5jbGFzc05hbWVzLCBzaXplID0gaW5mby5zaXplLCBwb3MgPSBpbmZvLnBvcywgem9vbSA9IGluZm8uem9vbSwga2V5ID0gaW5mby5rZXk7XHJcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcclxuICAgIHZhciBzY2FsZVR5cGUgPSBpc0hvcml6b250YWwgPyBcIllcIiA6IFwiWFwiO1xyXG4gICAgLy8gY29uc3Qgc2NhbGVUeXBlMiA9IGlzSG9yaXpvbnRhbCA/IFwiWVwiIDogXCJYXCI7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XHJcbiAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oXCIgXCIpLFxyXG4gICAgICAgIHN0eWxlOiAoX2EgPSB7fSxcclxuICAgICAgICAgICAgX2FbaXNIb3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBcIlwiLmNvbmNhdChzaXplKSxcclxuICAgICAgICAgICAgX2EudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHBvc1swXSwgXCIsIFwiKS5jb25jYXQocG9zWzFdLCBcIikgdHJhbnNsYXRlXCIpLmNvbmNhdChzY2FsZVR5cGUsIFwiKC01MCUpIHNjYWxlXCIpLmNvbmNhdChzY2FsZVR5cGUsIFwiKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgICAgICBfYSksXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJJbm5lckd1aWRlbGluZShpbmZvLCBSZWFjdCkge1xyXG4gICAgcmV0dXJuIHJlbmRlckd1aWRlbGluZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHsgY2xhc3NOYW1lczogX19zcHJlYWRBcnJheShbXHJcbiAgICAgICAgICAgIHByZWZpeChcImxpbmVcIiwgXCJndWlkZWxpbmVcIiwgaW5mby5kaXJlY3Rpb24pXHJcbiAgICAgICAgXSwgX19yZWFkKGluZm8uY2xhc3NOYW1lcyksIGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY2xhc3NOYW1lOyB9KSwgc2l6ZTogaW5mby5zaXplIHx8IFwiXCIuY29uY2F0KGluZm8uc2l6ZVZhbHVlLCBcInB4XCIpLCBwb3M6IGluZm8ucG9zIHx8IGluZm8ucG9zVmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIlwiLmNvbmNhdCh0aHJvdHRsZSh2LCAwLjEpLCBcInB4XCIpOyB9KSB9KSwgUmVhY3QpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlclNuYXBQb3Nlcyhtb3ZlYWJsZSwgZGlyZWN0aW9uLCBzbmFwUG9zZXMsIG1pblBvcywgdGFyZ2V0UG9zLCBzaXplLCBpbmRleCwgUmVhY3QpIHtcclxuICAgIHZhciB6b29tID0gbW92ZWFibGUucHJvcHMuem9vbTtcclxuICAgIHJldHVybiBzbmFwUG9zZXMubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgcG9zID0gX2EucG9zO1xyXG4gICAgICAgIHZhciByZW5kZXJQb3MgPSBbMCwgMF07XHJcbiAgICAgICAgcmVuZGVyUG9zW2luZGV4XSA9IG1pblBvcztcclxuICAgICAgICByZW5kZXJQb3NbaW5kZXggPyAwIDogMV0gPSAtdGFyZ2V0UG9zICsgcG9zO1xyXG4gICAgICAgIHJldHVybiByZW5kZXJJbm5lckd1aWRlbGluZSh7XHJcbiAgICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoZGlyZWN0aW9uLCBcIlRhcmdldEd1aWRlbGluZVwiKS5jb25jYXQoaSksXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtwcmVmaXgoXCJ0YXJnZXRcIiwgXCJib2xkXCIsIHR5cGUpXSxcclxuICAgICAgICAgICAgcG9zVmFsdWU6IHJlbmRlclBvcyxcclxuICAgICAgICAgICAgc2l6ZVZhbHVlOiBzaXplLFxyXG4gICAgICAgICAgICB6b29tOiB6b29tLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICB9LCBSZWFjdCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJHdWlkZWxpbmVzKG1vdmVhYmxlLCB0eXBlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgem9vbSA9IF9hLnpvb20sIGlzRGlzcGxheUlubmVyU25hcERpZ2l0ID0gX2EuaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQ7XHJcbiAgICB2YXIgbWFpbk5hbWVzID0gdHlwZSA9PT0gXCJob3Jpem9udGFsXCIgPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcclxuICAgIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcclxuICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5lbmRdO1xyXG4gICAgcmV0dXJuIGd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoaWRlID0gX2EuaGlkZSwgZWxlbWVudFJlY3QgPSBfYS5lbGVtZW50UmVjdDtcclxuICAgICAgICBpZiAoaGlkZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCAmJiBlbGVtZW50UmVjdCkge1xyXG4gICAgICAgICAgICAvLyBpbm5lclxyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnRSZWN0LnJlY3Q7XHJcbiAgICAgICAgICAgIGlmIChyZWN0W21haW5OYW1lcy5zdGFydF0gPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3RbbWFpbk5hbWVzLmVuZF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pLm1hcChmdW5jdGlvbiAoZ3VpZGVsaW5lLCBpKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IGd1aWRlbGluZS5wb3MsIHNpemUgPSBndWlkZWxpbmUuc2l6ZSwgZWxlbWVudCA9IGd1aWRlbGluZS5lbGVtZW50LCBjbGFzc05hbWUgPSBndWlkZWxpbmUuY2xhc3NOYW1lO1xyXG4gICAgICAgIHZhciByZW5kZXJQb3MgPSBbXHJcbiAgICAgICAgICAgIC10YXJnZXRQb3NbMF0gKyBwb3NbMF0sXHJcbiAgICAgICAgICAgIC10YXJnZXRQb3NbMV0gKyBwb3NbMV0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gcmVuZGVySW5uZXJHdWlkZWxpbmUoe1xyXG4gICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KHR5cGUsIFwiLWRlZmF1bHQtZ3VpZGVsaW5lLVwiKS5jb25jYXQoaSksXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IGVsZW1lbnQgPyBbcHJlZml4KFwiYm9sZFwiKSwgY2xhc3NOYW1lXSA6IFtwcmVmaXgoXCJub3JtYWxcIiksIGNsYXNzTmFtZV0sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdHlwZSxcclxuICAgICAgICAgICAgcG9zVmFsdWU6IHJlbmRlclBvcyxcclxuICAgICAgICAgICAgc2l6ZVZhbHVlOiBzaXplLFxyXG4gICAgICAgICAgICB6b29tOiB6b29tLFxyXG4gICAgICAgIH0sIFJlYWN0KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgbGluZVR5cGUsIGluZGV4LCBnYXAsIHJlbmRlclBvcywgY2xhc3NOYW1lLCBSZWFjdCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMsIF9jID0gX2Iuc25hcERpZ2l0LCBzbmFwRGlnaXQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLCBfZCA9IF9iLmlzRGlzcGxheVNuYXBEaWdpdCwgaXNEaXNwbGF5U25hcERpZ2l0ID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBfYi5zbmFwRGlzdEZvcm1hdCwgc25hcERpc3RGb3JtYXQgPSBfZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHYsIHR5cGUpIHtcclxuICAgICAgICAvLyBUeXBlIGNhbiBiZSB1c2VkIHJlbmRlciBkaWZmZXJlbnQgdmFsdWVzLlxyXG4gICAgICAgIGlmICh0eXBlID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0gOiBfZSwgem9vbSA9IF9iLnpvb207XHJcbiAgICB2YXIgc2NhbGVUeXBlID0gdHlwZSA9PT0gXCJob3Jpem9udGFsXCIgPyBcIlhcIiA6IFwiWVwiO1xyXG4gICAgdmFyIHNpemVOYW1lID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcclxuICAgIHZhciBhYnNHYXAgPSBNYXRoLmFicyhnYXApO1xyXG4gICAgdmFyIHNuYXBTaXplID0gaXNEaXNwbGF5U25hcERpZ2l0XHJcbiAgICAgICAgPyBwYXJzZUZsb2F0KGFic0dhcC50b0ZpeGVkKHNuYXBEaWdpdCkpXHJcbiAgICAgICAgOiAwO1xyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiXCIuY29uY2F0KHR5cGUsIFwiLVwiKS5jb25jYXQobGluZVR5cGUsIFwiLWd1aWRlbGluZS1cIikuY29uY2F0KGluZGV4KSwgY2xhc3NOYW1lOiBwcmVmaXgoXCJndWlkZWxpbmUtZ3JvdXBcIiwgdHlwZSksIHN0eWxlOiAoX2EgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChyZW5kZXJQb3NbMF0sIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KHJlbmRlclBvc1sxXSwgXCJweFwiKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfYVtzaXplTmFtZV0gPSBcIlwiLmNvbmNhdChhYnNHYXAsIFwicHhcIiksXHJcbiAgICAgICAgICAgIF9hKSB9LFxyXG4gICAgICAgIHJlbmRlcklubmVyR3VpZGVsaW5lKHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0eXBlLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbcHJlZml4KGxpbmVUeXBlKSwgY2xhc3NOYW1lXSxcclxuICAgICAgICAgICAgc2l6ZTogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIHBvc1ZhbHVlOiBbMCwgMF0sXHJcbiAgICAgICAgICAgIHNpemVWYWx1ZTogYWJzR2FwLFxyXG4gICAgICAgICAgICB6b29tOiB6b29tLFxyXG4gICAgICAgIH0sIFJlYWN0KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXgoXCJzaXplLXZhbHVlXCIsIFwiZ2FwXCIpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVwiLmNvbmNhdChzY2FsZVR5cGUsIFwiKC01MCUpIHNjYWxlKFwiKS5jb25jYXQoem9vbSwgXCIpXCIpLFxyXG4gICAgICAgICAgICB9IH0sIHNuYXBTaXplID4gMCA/IHNuYXBEaXN0Rm9ybWF0KHNuYXBTaXplLCB0eXBlKSA6IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBncm91cEJ5RWxlbWVudEd1aWRlbGluZXModHlwZSwgZ3VpZGVsaW5lcywgdGFyZ2V0UmVjdCwgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQpIHtcclxuICAgIHZhciBpbmRleCA9IHR5cGUgPT09IFwidmVydGljYWxcIiA/IDAgOiAxO1xyXG4gICAgdmFyIG90aGVySW5kZXggPSB0eXBlID09PSBcInZlcnRpY2FsXCIgPyAxIDogMDtcclxuICAgIHZhciBuYW1lcyA9IGluZGV4ID8gVkVSVElDQUxfTkFNRVNfTUFQIDogSE9SSVpPTlRBTF9OQU1FU19NQVA7XHJcbiAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W25hbWVzLnN0YXJ0XTtcclxuICAgIHZhciB0YXJnZXRFbmQgPSB0YXJnZXRSZWN0W25hbWVzLmVuZF07XHJcbiAgICByZXR1cm4gZ3JvdXBCeShndWlkZWxpbmVzLCBmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7XHJcbiAgICAgICAgcmV0dXJuIGd1aWRlbGluZS5wb3NbaW5kZXhdO1xyXG4gICAgfSkubWFwKGZ1bmN0aW9uIChuZXh0R3VpZGVsaW5lcykge1xyXG4gICAgICAgIHZhciBzdGFydCA9IFtdO1xyXG4gICAgICAgIHZhciBlbmQgPSBbXTtcclxuICAgICAgICB2YXIgaW5uZXIgPSBbXTtcclxuICAgICAgICBuZXh0R3VpZGVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBndWlkZWxpbmUuZWxlbWVudDtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBndWlkZWxpbmUuZWxlbWVudFJlY3QucmVjdDtcclxuICAgICAgICAgICAgaWYgKHJlY3RbbmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKGd1aWRlbGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RW5kIDwgcmVjdFtuYW1lcy5zdGFydF0pIHtcclxuICAgICAgICAgICAgICAgIGVuZC5wdXNoKGd1aWRlbGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdFtuYW1lcy5zdGFydF0gPD0gdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0RW5kIDw9IHJlY3RbbmFtZXMuZW5kXSAmJiBpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGd1aWRlbGluZS5wb3M7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFJlY3QxID0geyBlbGVtZW50OiBlbGVtZW50LCByZWN0OiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVjdCksIChfYSA9IHt9LCBfYVtuYW1lcy5lbmRdID0gcmVjdFtuYW1lcy5zdGFydF0sIF9hKSkgfTtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50UmVjdDIgPSB7IGVsZW1lbnQ6IGVsZW1lbnQsIHJlY3Q6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWN0KSwgKF9iID0ge30sIF9iW25hbWVzLnN0YXJ0XSA9IHJlY3RbbmFtZXMuZW5kXSwgX2IpKSB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRQb3MxID0gWzAsIDBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRQb3MyID0gWzAsIDBdO1xyXG4gICAgICAgICAgICAgICAgbmV4dFBvczFbaW5kZXhdID0gcG9zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIG5leHRQb3MxW290aGVySW5kZXhdID0gcG9zW290aGVySW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbmV4dFBvczJbaW5kZXhdID0gcG9zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIG5leHRQb3MyW290aGVySW5kZXhdID0gcG9zW290aGVySW5kZXhdICsgZ3VpZGVsaW5lLnNpemU7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvczogbmV4dFBvczEsXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMCxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50UmVjdDogZWxlbWVudFJlY3QxLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50RGlyZWN0aW9uOiBcImVuZFwiLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbmQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBwb3M6IG5leHRQb3MyLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFJlY3Q6IGVsZW1lbnRSZWN0MixcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudERpcmVjdGlvbjogXCJzdGFydFwiLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbm5lci5wdXNoKGd1aWRlbGluZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdGFydC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLnBvc1tvdGhlckluZGV4XSAtIGEucG9zW290aGVySW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVuZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnBvc1tvdGhlckluZGV4XSAtIGIucG9zW290aGVySW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvdGFsOiBuZXh0R3VpZGVsaW5lcyxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgaW5uZXI6IGlubmVyLFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJEYXNoZWRHdWlkZWxpbmVzKG1vdmVhYmxlLCBndWlkZWxpbmVzLCB0YXJnZXRQb3MsIHRhcmdldFJlY3QsIFJlYWN0KSB7XHJcbiAgICB2YXIgaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXQgPSBtb3ZlYWJsZS5wcm9wcy5pc0Rpc3BsYXlJbm5lclNuYXBEaWdpdDtcclxuICAgIHZhciByZW5kZXJlZCA9IFtdO1xyXG4gICAgW1widmVydGljYWxcIiwgXCJob3Jpem9udGFsXCJdLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgbmV4dEd1aWRlbGluZXMgPSBndWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7IHJldHVybiBndWlkZWxpbmUudHlwZSA9PT0gdHlwZTsgfSk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMSA6IDA7XHJcbiAgICAgICAgdmFyIG90aGVySW5kZXggPSBpbmRleCA/IDAgOiAxO1xyXG4gICAgICAgIHZhciBncm91cHMgPSBncm91cEJ5RWxlbWVudEd1aWRlbGluZXModHlwZSwgbmV4dEd1aWRlbGluZXMsIHRhcmdldFJlY3QsIGlzRGlzcGxheUlubmVyU25hcERpZ2l0KTtcclxuICAgICAgICB2YXIgbWFpbk5hbWVzID0gaW5kZXggPyBIT1JJWk9OVEFMX05BTUVTX01BUCA6IFZFUlRJQ0FMX05BTUVTX01BUDtcclxuICAgICAgICB2YXIgc2lkZU5hbWVzID0gaW5kZXggPyBWRVJUSUNBTF9OQU1FU19NQVAgOiBIT1JJWk9OVEFMX05BTUVTX01BUDtcclxuICAgICAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XHJcbiAgICAgICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XHJcbiAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IF9hLnRvdGFsLCBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQsIGlubmVyID0gX2EuaW5uZXI7XHJcbiAgICAgICAgICAgIHZhciBzaWRlUG9zID0gdGFyZ2V0UG9zW290aGVySW5kZXhdICsgdG90YWxbMF0ucG9zW290aGVySW5kZXhdIC0gdGFyZ2V0UmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICB2YXIgcHJldlJlY3QgPSB0YXJnZXRSZWN0O1xyXG4gICAgICAgICAgICBzdGFydC5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjdCA9IGd1aWRlbGluZS5lbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBwcmV2UmVjdFttYWluTmFtZXMuc3RhcnRdIC0gbmV4dFJlY3RbbWFpbk5hbWVzLmVuZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdICsgcHJldlJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHRhcmdldFN0YXJ0IC0gc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJQb3Nbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUsIHJlbmRlclBvcywgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZSZWN0ID0gbmV4dFJlY3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwcmV2UmVjdCA9IHRhcmdldFJlY3Q7XHJcbiAgICAgICAgICAgIGVuZC5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjdCA9IGd1aWRlbGluZS5lbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBuZXh0UmVjdFttYWluTmFtZXMuc3RhcnRdIC0gcHJldlJlY3RbbWFpbk5hbWVzLmVuZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUG9zID0gWzAsIDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclBvc1tpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdICsgcHJldlJlY3RbbWFpbk5hbWVzLmVuZF0gLSB0YXJnZXRTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJQb3Nbb3RoZXJJbmRleF0gPSBzaWRlUG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUsIHJlbmRlclBvcywgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZSZWN0ID0gbmV4dFJlY3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpbm5lci5mb3JFYWNoKGZ1bmN0aW9uIChndWlkZWxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjdCA9IGd1aWRlbGluZS5lbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUxID0gdGFyZ2V0U3RhcnQgLSBuZXh0UmVjdFttYWluTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUyID0gbmV4dFJlY3RbbWFpbk5hbWVzLmVuZF0gLSB0YXJnZXRFbmQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyUG9zMSA9IFswLCAwXTtcclxuICAgICAgICAgICAgICAgIHZhciByZW5kZXJQb3MyID0gWzAsIDBdO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyUG9zMVtpbmRleF0gPSB0YXJnZXRQb3NbaW5kZXhdIC0gc2l6ZTE7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJQb3MxW290aGVySW5kZXhdID0gc2lkZVBvcztcclxuICAgICAgICAgICAgICAgIHJlbmRlclBvczJbaW5kZXhdID0gdGFyZ2V0UG9zW2luZGV4XSArIHRhcmdldEVuZCAtIHRhcmdldFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyUG9zMltvdGhlckluZGV4XSA9IHNpZGVQb3M7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgdHlwZSwgXCJkYXNoZWRcIiwgcmVuZGVyZWQubGVuZ3RoLCBzaXplMSwgcmVuZGVyUG9zMSwgZ3VpZGVsaW5lLmNsYXNzTmFtZSwgUmVhY3QpKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkLnB1c2gocmVuZGVyRGlnaXRMaW5lKG1vdmVhYmxlLCB0eXBlLCBcImRhc2hlZFwiLCByZW5kZXJlZC5sZW5ndGgsIHNpemUyLCByZW5kZXJQb3MyLCBndWlkZWxpbmUuY2xhc3NOYW1lLCBSZWFjdCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVkO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckdhcEd1aWRlbGluZXMobW92ZWFibGUsIGd1aWRlbGluZXMsIHRhcmdldFBvcywgdGFyZ2V0UmVjdCwgUmVhY3QpIHtcclxuICAgIHZhciByZW5kZXJlZCA9IFtdO1xyXG4gICAgW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgbmV4dEd1aWRlbGluZXMgPSBndWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7IHJldHVybiBndWlkZWxpbmUudHlwZSA9PT0gdHlwZTsgfSkuc2xpY2UoMCwgMSk7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiID8gMCA6IDE7XHJcbiAgICAgICAgdmFyIG90aGVySW5kZXggPSBpbmRleCA/IDAgOiAxO1xyXG4gICAgICAgIHZhciBtYWluTmFtZXMgPSBpbmRleCA/IEhPUklaT05UQUxfTkFNRVNfTUFQIDogVkVSVElDQUxfTkFNRVNfTUFQO1xyXG4gICAgICAgIHZhciBzaWRlTmFtZXMgPSBpbmRleCA/IFZFUlRJQ0FMX05BTUVTX01BUCA6IEhPUklaT05UQUxfTkFNRVNfTUFQO1xyXG4gICAgICAgIHZhciB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLnN0YXJ0XTtcclxuICAgICAgICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFttYWluTmFtZXMuZW5kXTtcclxuICAgICAgICB2YXIgdGFyZ2V0U2lkZVN0YXJ0ID0gdGFyZ2V0UmVjdFtzaWRlTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgIHZhciB0YXJnZXRTaWRlRW5kID0gdGFyZ2V0UmVjdFtzaWRlTmFtZXMuZW5kXTtcclxuICAgICAgICBuZXh0R3VpZGVsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZ2FwID0gX2EuZ2FwLCBnYXBSZWN0cyA9IF9hLmdhcFJlY3RzO1xyXG4gICAgICAgICAgICB2YXIgc2lkZVN0YXJ0UG9zID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbdGFyZ2V0U2lkZVN0YXJ0XSwgX19yZWFkKGdhcFJlY3RzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gX2EucmVjdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0W3NpZGVOYW1lcy5zdGFydF07XHJcbiAgICAgICAgICAgIH0pKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgdmFyIHNpZGVFbmRQb3MgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfX3NwcmVhZEFycmF5KFt0YXJnZXRTaWRlRW5kXSwgX19yZWFkKGdhcFJlY3RzLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gX2EucmVjdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0W3NpZGVOYW1lcy5lbmRdO1xyXG4gICAgICAgICAgICB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHZhciBzaWRlQ2VudGVyUG9zID0gKHNpZGVTdGFydFBvcyArIHNpZGVFbmRQb3MpIC8gMjtcclxuICAgICAgICAgICAgaWYgKHNpZGVTdGFydFBvcyA9PT0gc2lkZUVuZFBvcyB8fCBzaWRlQ2VudGVyUG9zID09PSAodGFyZ2V0U2lkZVN0YXJ0ICsgdGFyZ2V0U2lkZUVuZCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2FwUmVjdHMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gX2EucmVjdCwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlclBvcyA9IFt0YXJnZXRQb3NbMF0sIHRhcmdldFBvc1sxXV07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjdFttYWluTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyUG9zW2luZGV4XSArPSByZWN0W21haW5OYW1lcy5lbmRdIC0gdGFyZ2V0U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRFbmQgPCByZWN0W21haW5OYW1lcy5zdGFydF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJQb3NbaW5kZXhdICs9IHJlY3RbbWFpbk5hbWVzLnN0YXJ0XSAtIHRhcmdldFN0YXJ0IC0gZ2FwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVuZGVyUG9zW290aGVySW5kZXhdICs9IHNpZGVDZW50ZXJQb3MgLSB0YXJnZXRTaWRlU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZC5wdXNoKHJlbmRlckRpZ2l0TGluZShtb3ZlYWJsZSwgaW5kZXggPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIiwgXCJnYXBcIiwgcmVuZGVyZWQubGVuZ3RoLCBnYXAsIHJlbmRlclBvcywgY2xhc3NOYW1lLCBSZWFjdCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVkO1xyXG59XG5cbmZ1bmN0aW9uIGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBzdGF0ZS5jb250YWluZXJDbGllbnRSZWN0LCBoYXNGaXhlZCA9IHN0YXRlLmhhc0ZpeGVkO1xyXG4gICAgdmFyIG92ZXJmbG93ID0gY29udGFpbmVyQ2xpZW50UmVjdC5vdmVyZmxvdywgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyQ2xpZW50UmVjdC5zY3JvbGxIZWlnaHQsIGNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyQ2xpZW50UmVjdC5zY3JvbGxXaWR0aCwgY29udGFpbmVyQ2xpZW50SGVpZ2h0ID0gY29udGFpbmVyQ2xpZW50UmVjdC5jbGllbnRIZWlnaHQsIGNvbnRhaW5lckNsaWVudFdpZHRoID0gY29udGFpbmVyQ2xpZW50UmVjdC5jbGllbnRXaWR0aCwgY2xpZW50TGVmdCA9IGNvbnRhaW5lckNsaWVudFJlY3QuY2xpZW50TGVmdCwgY2xpZW50VG9wID0gY29udGFpbmVyQ2xpZW50UmVjdC5jbGllbnRUb3A7XHJcbiAgICB2YXIgX2MgPSBtb3ZlYWJsZS5wcm9wcywgX2QgPSBfYy5zbmFwR2FwLCBzbmFwR2FwID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgdmVydGljYWxHdWlkZWxpbmVzID0gX2MudmVydGljYWxHdWlkZWxpbmVzLCBob3Jpem9udGFsR3VpZGVsaW5lcyA9IF9jLmhvcml6b250YWxHdWlkZWxpbmVzLCBfZSA9IF9jLnNuYXBUaHJlc2hvbGQsIHNuYXBUaHJlc2hvbGQgPSBfZSA9PT0gdm9pZCAwID8gNSA6IF9lLCBfZiA9IF9jLm1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2UsIG1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2UgPSBfZiA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfZiwgaXNEaXNwbGF5R3JpZEd1aWRlbGluZXMgPSBfYy5pc0Rpc3BsYXlHcmlkR3VpZGVsaW5lcztcclxuICAgIHZhciBfZyA9IGdldFJlY3QoZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUobW92ZWFibGUuc3RhdGUpKSwgdG9wID0gX2cudG9wLCBsZWZ0ID0gX2cubGVmdCwgYm90dG9tID0gX2cuYm90dG9tLCByaWdodCA9IF9nLnJpZ2h0O1xyXG4gICAgdmFyIHRhcmdldFJlY3QgPSB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBib3R0b206IGJvdHRvbSwgcmlnaHQ6IHJpZ2h0LCBjZW50ZXI6IChsZWZ0ICsgcmlnaHQpIC8gMiwgbWlkZGxlOiAodG9wICsgYm90dG9tKSAvIDIgfTtcclxuICAgIHZhciBlbGVtZW50R3VpZGVsaW5lcyA9IGdldEVsZW1lbnRHdWlkZWxpbmVzKG1vdmVhYmxlKTtcclxuICAgIHZhciB0b3RhbEd1aWRlbGluZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZWxlbWVudEd1aWRlbGluZXMpLCBmYWxzZSk7XHJcbiAgICB2YXIgc25hcFRocmVzaG9sZE11bHRpcGxlcyA9ICgoX2IgPSAoX2EgPSBzdGF0ZS5zbmFwVGhyZXNob2xkSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11bHRpcGxlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogWzEsIDFdKS5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gKiBzbmFwVGhyZXNob2xkOyB9KTtcclxuICAgIGlmIChzbmFwR2FwKSB7XHJcbiAgICAgICAgdG90YWxHdWlkZWxpbmVzLnB1c2guYXBwbHkodG90YWxHdWlkZWxpbmVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0R2FwR3VpZGVsaW5lcyhtb3ZlYWJsZSwgdGFyZ2V0UmVjdCwgc25hcFRocmVzaG9sZE11bHRpcGxlcykpLCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHNuYXBPZmZzZXQgPSBfX2Fzc2lnbih7fSwgKHN0YXRlLnNuYXBPZmZzZXQgfHwge1xyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgIH0pKTtcclxuICAgIHRvdGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KHRvdGFsR3VpZGVsaW5lcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldEdyaWRHdWlkZWxpbmVzKG1vdmVhYmxlLCBvdmVyZmxvdyA/IGNvbnRhaW5lcldpZHRoIDogY29udGFpbmVyQ2xpZW50V2lkdGgsIG92ZXJmbG93ID8gY29udGFpbmVySGVpZ2h0IDogY29udGFpbmVyQ2xpZW50SGVpZ2h0LCBjbGllbnRMZWZ0LCBjbGllbnRUb3AsIHNuYXBPZmZzZXQsIGlzRGlzcGxheUdyaWRHdWlkZWxpbmVzKSksIGZhbHNlKSk7XHJcbiAgICBpZiAoaGFzRml4ZWQpIHtcclxuICAgICAgICB2YXIgbGVmdF8xID0gY29udGFpbmVyQ2xpZW50UmVjdC5sZWZ0LCB0b3BfMSA9IGNvbnRhaW5lckNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIHNuYXBPZmZzZXQubGVmdCArPSBsZWZ0XzE7XHJcbiAgICAgICAgc25hcE9mZnNldC50b3AgKz0gdG9wXzE7XHJcbiAgICAgICAgc25hcE9mZnNldC5yaWdodCArPSBsZWZ0XzE7XHJcbiAgICAgICAgc25hcE9mZnNldC5ib3R0b20gKz0gdG9wXzE7XHJcbiAgICB9XHJcbiAgICB0b3RhbEd1aWRlbGluZXMucHVzaC5hcHBseSh0b3RhbEd1aWRlbGluZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChnZXREZWZhdWx0R3VpZGVsaW5lcyhob3Jpem9udGFsR3VpZGVsaW5lcyB8fCBmYWxzZSwgdmVydGljYWxHdWlkZWxpbmVzIHx8IGZhbHNlLCBvdmVyZmxvdyA/IGNvbnRhaW5lcldpZHRoIDogY29udGFpbmVyQ2xpZW50V2lkdGgsIG92ZXJmbG93ID8gY29udGFpbmVySGVpZ2h0IDogY29udGFpbmVyQ2xpZW50SGVpZ2h0LCBjbGllbnRMZWZ0LCBjbGllbnRUb3AsIHNuYXBPZmZzZXQpKSwgZmFsc2UpKTtcclxuICAgIHRvdGFsR3VpZGVsaW5lcyA9IHRvdGFsR3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50LCBlbGVtZW50UmVjdCA9IF9hLmVsZW1lbnRSZWN0LCB0eXBlID0gX2EudHlwZTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnRSZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnRSZWN0LnJlY3Q7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrQmV0d2VlblJlY3RzKHRhcmdldFJlY3QsIHJlY3QsIHR5cGUsIG1heFNuYXBFbGVtZW50R3VpZGVsaW5lRGlzdGFuY2UpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdG90YWxHdWlkZWxpbmVzO1xyXG59XHJcbmZ1bmN0aW9uIGdldEdhcEd1aWRlbGluZXMobW92ZWFibGUsIHRhcmdldFJlY3QsIHNuYXBUaHJlc2hvbGRzKSB7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgX2IgPSBfYS5tYXhTbmFwRWxlbWVudEd1aWRlbGluZURpc3RhbmNlLCBtYXhTbmFwRWxlbWVudEd1aWRlbGluZURpc3RhbmNlID0gX2IgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2IsIF9jID0gX2EubWF4U25hcEVsZW1lbnRHYXBEaXN0YW5jZSwgbWF4U25hcEVsZW1lbnRHYXBEaXN0YW5jZSA9IF9jID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9jO1xyXG4gICAgdmFyIGVsZW1lbnRSZWN0cyA9IG1vdmVhYmxlLnN0YXRlLmVsZW1lbnRSZWN0cztcclxuICAgIHZhciBnYXBHdWlkZWxpbmVzID0gW107XHJcbiAgICBbXHJcbiAgICAgICAgW1widmVydGljYWxcIiwgVkVSVElDQUxfTkFNRVNfTUFQLCBIT1JJWk9OVEFMX05BTUVTX01BUF0sXHJcbiAgICAgICAgW1wiaG9yaXpvbnRhbFwiLCBIT1JJWk9OVEFMX05BTUVTX01BUCwgVkVSVElDQUxfTkFNRVNfTUFQXSxcclxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCB0eXBlID0gX2JbMF0sIG1haW5OYW1lcyA9IF9iWzFdLCBzaWRlTmFtZXMgPSBfYlsyXTtcclxuICAgICAgICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W21haW5OYW1lcy5zdGFydF07XHJcbiAgICAgICAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmVuZF07XHJcbiAgICAgICAgdmFyIHRhcmdldENlbnRlciA9IHRhcmdldFJlY3RbbWFpbk5hbWVzLmNlbnRlcl07XHJcbiAgICAgICAgdmFyIHRhcmdldFN0YXJ0MiA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLnN0YXJ0XTtcclxuICAgICAgICB2YXIgdGFyZ2V0RW5kMiA9IHRhcmdldFJlY3Rbc2lkZU5hbWVzLmVuZF07XHJcbiAgICAgICAgLy8gZWxlbWVudCA6IG1vdmVhYmxlXHJcbiAgICAgICAgdmFyIHNuYXBUaHJlc2hvbGRNYXAgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IHNuYXBUaHJlc2hvbGRzWzBdLFxyXG4gICAgICAgICAgICB0b3A6IHNuYXBUaHJlc2hvbGRzWzFdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlzdChlbGVtZW50UmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsZW1lbnRSZWN0LnJlY3Q7XHJcbiAgICAgICAgICAgIHZhciBzbmFwVGhyZXNob2xkID0gc25hcFRocmVzaG9sZE1hcFttYWluTmFtZXMuc3RhcnRdO1xyXG4gICAgICAgICAgICBpZiAocmVjdFttYWluTmFtZXMuZW5kXSA8IHRhcmdldFN0YXJ0ICsgc25hcFRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IC0gcmVjdFttYWluTmFtZXMuZW5kXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRFbmQgLSBzbmFwVGhyZXNob2xkIDwgcmVjdFttYWluTmFtZXMuc3RhcnRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFttYWluTmFtZXMuc3RhcnRdIC0gdGFyZ2V0RW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0RWxlbWVudFJlY3RzID0gZWxlbWVudFJlY3RzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudFJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50UmVjdC5yZWN0O1xyXG4gICAgICAgICAgICBpZiAocmVjdFtzaWRlTmFtZXMuc3RhcnRdID4gdGFyZ2V0RW5kMiB8fCByZWN0W3NpZGVOYW1lcy5lbmRdIDwgdGFyZ2V0U3RhcnQyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGdldERpc3QoZWxlbWVudFJlY3QpID4gMDtcclxuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXREaXN0KGEpIC0gZ2V0RGlzdChiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gW107XHJcbiAgICAgICAgbmV4dEVsZW1lbnRSZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzbmFwUmVjdDEpIHtcclxuICAgICAgICAgICAgbmV4dEVsZW1lbnRSZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChzbmFwUmVjdDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwUmVjdDEgPT09IHNuYXBSZWN0Mikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZWN0MSA9IHNuYXBSZWN0MS5yZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QyID0gc25hcFJlY3QyLnJlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDFTdGFydCA9IHJlY3QxW3NpZGVOYW1lcy5zdGFydF07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDFFbmQgPSByZWN0MVtzaWRlTmFtZXMuZW5kXTtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0MlN0YXJ0ID0gcmVjdDJbc2lkZU5hbWVzLnN0YXJ0XTtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0MkVuZCA9IHJlY3QyW3NpZGVOYW1lcy5lbmRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY3QxU3RhcnQgPiByZWN0MkVuZCB8fCByZWN0MlN0YXJ0ID4gcmVjdDFFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaChbc25hcFJlY3QxLCBzbmFwUmVjdDJdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHNuYXBSZWN0MSA9IF9iWzBdLCBzbmFwUmVjdDIgPSBfYlsxXTtcclxuICAgICAgICAgICAgdmFyIHJlY3QxID0gc25hcFJlY3QxLnJlY3Q7XHJcbiAgICAgICAgICAgIHZhciByZWN0MiA9IHNuYXBSZWN0Mi5yZWN0O1xyXG4gICAgICAgICAgICB2YXIgcmVjdDFTdGFydCA9IHJlY3QxW21haW5OYW1lcy5zdGFydF07XHJcbiAgICAgICAgICAgIHZhciByZWN0MUVuZCA9IHJlY3QxW21haW5OYW1lcy5lbmRdO1xyXG4gICAgICAgICAgICB2YXIgcmVjdDJTdGFydCA9IHJlY3QyW21haW5OYW1lcy5zdGFydF07XHJcbiAgICAgICAgICAgIHZhciByZWN0MkVuZCA9IHJlY3QyW21haW5OYW1lcy5lbmRdO1xyXG4gICAgICAgICAgICB2YXIgc25hcFRocmVzaG9sZCA9IHNuYXBUaHJlc2hvbGRNYXBbbWFpbk5hbWVzLnN0YXJ0XTtcclxuICAgICAgICAgICAgdmFyIGdhcCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSAwO1xyXG4gICAgICAgICAgICB2YXIgaXNTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgaXNDZW50ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGlzRW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChyZWN0MUVuZCA8PSB0YXJnZXRTdGFydCAmJiB0YXJnZXRFbmQgPD0gcmVjdDJTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gKGwpZWxlbWVudDEocikgOiAobCl0YXJnZXQocikgOiAobCllbGVtZW50MihyKVxyXG4gICAgICAgICAgICAgICAgaXNDZW50ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZ2FwID0gKChyZWN0MlN0YXJ0IC0gcmVjdDFFbmQpIC0gKHRhcmdldEVuZCAtIHRhcmdldFN0YXJ0KSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgcG9zID0gcmVjdDFFbmQgKyBnYXAgKyAodGFyZ2V0RW5kIC0gdGFyZ2V0U3RhcnQpIC8gMjtcclxuICAgICAgICAgICAgICAgIGlmIChhYnMocG9zIC0gdGFyZ2V0Q2VudGVyKSA+IHNuYXBUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdDFFbmQgPCByZWN0MlN0YXJ0ICYmIHJlY3QyRW5kIDwgdGFyZ2V0U3RhcnQgKyBzbmFwVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAobCllbGVtZW50MShyKSA6IChsKWVsZW1lbnQyKHIpIDogKGwpdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICBpc1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGdhcCA9IHJlY3QyU3RhcnQgLSByZWN0MUVuZDtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHJlY3QyRW5kICsgZ2FwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFicyhwb3MgLSB0YXJnZXRTdGFydCkgPiBzbmFwVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QxRW5kIDwgcmVjdDJTdGFydCAmJiB0YXJnZXRFbmQgLSBzbmFwVGhyZXNob2xkIDwgcmVjdDFTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0KHIpIDogKGwpZWxlbWVudDEocikgOiAobCllbGVtZW50MihyKVxyXG4gICAgICAgICAgICAgICAgaXNFbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZ2FwID0gcmVjdDJTdGFydCAtIHJlY3QxRW5kO1xyXG4gICAgICAgICAgICAgICAgcG9zID0gcmVjdDFTdGFydCAtIGdhcDtcclxuICAgICAgICAgICAgICAgIGlmIChhYnMocG9zIC0gdGFyZ2V0RW5kKSA+IHNuYXBUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFnYXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNoZWNrQmV0d2VlblJlY3RzKHRhcmdldFJlY3QsIHJlY3QyLCB0eXBlLCBtYXhTbmFwRWxlbWVudEd1aWRlbGluZURpc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChnYXAgPiBtYXhTbmFwRWxlbWVudEdhcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2FwR3VpZGVsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBwb3M6IHR5cGUgPT09IFwidmVydGljYWxcIiA/IFtwb3MsIDBdIDogWzAsIHBvc10sXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBzbmFwUmVjdDIuZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHNpemU6IDAsXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHNuYXBSZWN0Mi5jbGFzc05hbWUsXHJcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBpc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgaXNDZW50ZXI6IGlzQ2VudGVyLFxyXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGlzRW5kLFxyXG4gICAgICAgICAgICAgICAgZ2FwOiBnYXAsXHJcbiAgICAgICAgICAgICAgICBoaWRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2FwUmVjdHM6IFtzbmFwUmVjdDEsIHNuYXBSZWN0Ml0sXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50RGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGdhcEd1aWRlbGluZXM7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRHcmlkR3JvdXBHdWlkZWxpbmVzKG1vdmVhYmxlLCBjbGllbnRMZWZ0LCBjbGllbnRUb3AsIHNuYXBPZmZzZXQpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIHNuYXBHcmlkQWxsID0gcHJvcHMuc25hcEdyaWRBbGw7XHJcbiAgICB2YXIgX2MgPSBwcm9wcy5zbmFwR3JpZFdpZHRoLCBzbmFwR3JpZFdpZHRoID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBwcm9wcy5zbmFwR3JpZEhlaWdodCwgc25hcEdyaWRIZWlnaHQgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kO1xyXG4gICAgdmFyIHNuYXBSZW5kZXJJbmZvID0gc3RhdGUuc25hcFJlbmRlckluZm87XHJcbiAgICB2YXIgaGFzRGlyZWN0aW9uID0gc25hcFJlbmRlckluZm8gJiYgKCgoX2EgPSBzbmFwUmVuZGVySW5mby5kaXJlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgfHwgKChfYiA9IHNuYXBSZW5kZXJJbmZvLmRpcmVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzFdKSk7XHJcbiAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgLy8gc25hcCBncm91cCdzIGFsbCBjaGlsZCB0byBncmlkLlxyXG4gICAgaWYgKHNuYXBHcmlkQWxsXHJcbiAgICAgICAgJiYgbW92ZWFibGVzXHJcbiAgICAgICAgJiYgaGFzRGlyZWN0aW9uXHJcbiAgICAgICAgJiYgKHNuYXBHcmlkV2lkdGggfHwgc25hcEdyaWRIZWlnaHQpKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuc25hcFRocmVzaG9sZEluZm8gPSB7XHJcbiAgICAgICAgICAgIG11bHRpcGxlczogWzEsIDFdLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWN0XzEgPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuXzEgPSByZWN0XzEuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHNuYXBSZW5kZXJJbmZvLmRpcmVjdGlvbjtcclxuICAgICAgICBpZiAoY2hpbGRyZW5fMSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGlyZWN0aW9uLm1hcChmdW5jdGlvbiAoZGlyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBpID09PSAwID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBTaXplOiBzbmFwR3JpZFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc05hbWU6IFwibGVmdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemVOYW1lOiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50T2Zmc2V0OiBzbmFwT2Zmc2V0LmxlZnQgLSBjbGllbnRMZWZ0LFxyXG4gICAgICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICAgICAgICBzbmFwU2l6ZTogc25hcEdyaWRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zTmFtZTogXCJ0b3BcIixcclxuICAgICAgICAgICAgICAgICAgICBzaXplTmFtZTogXCJoZWlnaHRcIixcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IHNuYXBPZmZzZXQudG9wIC0gY2xpZW50VG9wLFxyXG4gICAgICAgICAgICAgICAgfSwgc25hcFNpemUgPSBfYS5zbmFwU2l6ZSwgcG9zTmFtZSA9IF9hLnBvc05hbWUsIHNpemVOYW1lID0gX2Euc2l6ZU5hbWUsIGNsaWVudE9mZnNldCA9IF9hLmNsaWVudE9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmICghc25hcFNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXI6IGRpcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBTaXplOiBzbmFwU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcE9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RTaXplID0gcmVjdF8xW3NpemVOYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0UG9zID0gcmVjdF8xW3Bvc05hbWVdO1xyXG4gICAgICAgICAgICAgICAgLy8g7IKs7J207KaI67O064ukIOunjOyVvSDsnpHri6TrqbQg7Ja065a76rKMIO2VtOyVvOuQmOyjoD9cclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFNpemVzID0gZmxhdCQxKGNoaWxkcmVuXzEubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZFtwb3NOYW1lXSAtIHJlY3RQb3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGRbc2l6ZU5hbWVdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlY3RTaXplIC0gY2hpbGRbc2l6ZU5hbWVdIC0gY2hpbGRbcG9zTmFtZV0gKyByZWN0UG9zKSxcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfSkpLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGRTaXplID0gY2hpbGRTaXplc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFNuYXBTaXplcyA9IGNoaWxkU2l6ZXMubWFwKGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiB0aHJvdHRsZShzaXplIC8gZmlyc3RDaGlsZFNpemUsIDAuMSkgKiBzbmFwU2l6ZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFJhdGlvID0gdGhyb3R0bGUocmVjdFNpemUgLyBmaXJzdENoaWxkU2l6ZSwgMC4xKTtcclxuICAgICAgICAgICAgICAgIGZvciAobiA9IDE7IG4gPD0gMTA7ICsrbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFNuYXBTaXplcy5ldmVyeShmdW5jdGlvbiAoY2hpbGRTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFNpemUgKiBuICUgMSA9PT0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkaXIgMSAoZml4ZWQgLTEpXHJcbiAgICAgICAgICAgICAgICAvLyBkaXIgMCAoZml4ZWQgMClcclxuICAgICAgICAgICAgICAgIC8vIGRpciAtMSAoZml4ZWQgMSlcclxuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9ICgtZGlyICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldFBvcyA9IGRvdChyZWN0UG9zIC0gY2xpZW50T2Zmc2V0LCByZWN0UG9zIC0gY2xpZW50T2Zmc2V0ICsgcmVjdFNpemUsIHJhdGlvLCAxIC0gcmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZTogcmVjdFJhdGlvICogbixcclxuICAgICAgICAgICAgICAgICAgICBkaXI6IGRpcixcclxuICAgICAgICAgICAgICAgICAgICBzbmFwU2l6ZTogc25hcFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcE9mZnNldDogTWF0aC5yb3VuZChvZmZzZXRQb3MgLyBzbmFwU2l6ZSksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIG11bHRpcGxlcyA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIubXVsdGlwbGUgfHwgMTsgfSk7XHJcbiAgICAgICAgICAgIHN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvLm11bHRpcGxlcyA9IG11bHRpcGxlcztcclxuICAgICAgICAgICAgc3RhdGUuc25hcFRocmVzaG9sZEluZm8ub2Zmc2V0ID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gci5zbmFwT2Zmc2V0OyB9KTtcclxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyLnNuYXBTaXplKSA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN0YXRlLnNuYXBUaHJlc2hvbGRJbmZvID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRHcmlkR3VpZGVsaW5lcyhtb3ZlYWJsZSwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodCwgY2xpZW50TGVmdCwgY2xpZW50VG9wLCBzbmFwT2Zmc2V0LCBpc0Rpc3BsYXlHcmlkR3VpZGVsaW5lcykge1xyXG4gICAgaWYgKGNsaWVudExlZnQgPT09IHZvaWQgMCkgeyBjbGllbnRMZWZ0ID0gMDsgfVxyXG4gICAgaWYgKGNsaWVudFRvcCA9PT0gdm9pZCAwKSB7IGNsaWVudFRvcCA9IDA7IH1cclxuICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICB2YXIgX2EgPSBwcm9wcy5zbmFwR3JpZFdpZHRoLCBzbmFwR3JpZFdpZHRoID0gX2EgPT09IHZvaWQgMCA/IDAgOiBfYSwgX2IgPSBwcm9wcy5zbmFwR3JpZEhlaWdodCwgc25hcEdyaWRIZWlnaHQgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xyXG4gICAgdmFyIGd1aWRlbGluZXMgPSBbXTtcclxuICAgIHZhciBzbmFwT2Zmc2V0TGVmdCA9IHNuYXBPZmZzZXQubGVmdCwgc25hcE9mZnNldFRvcCA9IHNuYXBPZmZzZXQudG9wO1xyXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgc3RhcnRHcmlkR3JvdXBHdWlkZWxpbmVzKG1vdmVhYmxlLCBjbGllbnRMZWZ0LCBjbGllbnRUb3AsIHNuYXBPZmZzZXQpO1xyXG4gICAgdmFyIHNuYXBUaHJlc2hvbGRJbmZvID0gc3RhdGUuc25hcFRocmVzaG9sZEluZm87XHJcbiAgICB2YXIgZGVmYXVsdFNuYXBHcmlkV2lkdGggPSBzbmFwR3JpZFdpZHRoO1xyXG4gICAgdmFyIGRlZmF1bHRTbmFwR3JpZEhlaWdodCA9IHNuYXBHcmlkSGVpZ2h0O1xyXG4gICAgaWYgKHNuYXBUaHJlc2hvbGRJbmZvKSB7XHJcbiAgICAgICAgc25hcEdyaWRXaWR0aCAqPSBzbmFwVGhyZXNob2xkSW5mby5tdWx0aXBsZXNbMF0gfHwgMTtcclxuICAgICAgICBzbmFwR3JpZEhlaWdodCAqPSBzbmFwVGhyZXNob2xkSW5mby5tdWx0aXBsZXNbMV0gfHwgMTtcclxuICAgICAgICBzdGFydE9mZnNldCA9IHNuYXBUaHJlc2hvbGRJbmZvLm9mZnNldDtcclxuICAgIH1cclxuICAgIGlmIChzbmFwR3JpZEhlaWdodCkge1xyXG4gICAgICAgIHZhciBwdXNoR3VpZGVsaW5lID0gZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICBndWlkZWxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICBwb3M6IFtcclxuICAgICAgICAgICAgICAgICAgICBzbmFwT2Zmc2V0TGVmdCxcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZShzdGFydE9mZnNldFsxXSAqIGRlZmF1bHRTbmFwR3JpZEhlaWdodCArIHBvcyAtIGNsaWVudFRvcCArIHNuYXBPZmZzZXRUb3AsIDAuMSksXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBwcmVmaXgoXCJncmlkLWd1aWRlbGluZVwiKSxcclxuICAgICAgICAgICAgICAgIHNpemU6IGNvbnRhaW5lcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGlkZTogIWlzRGlzcGxheUdyaWRHdWlkZWxpbmVzLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgZ3JpZDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPD0gY29udGFpbmVySGVpZ2h0ICogMjsgcG9zICs9IHNuYXBHcmlkSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHB1c2hHdWlkZWxpbmUocG9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgcG9zID0gLXNuYXBHcmlkSGVpZ2h0OyBwb3MgPj0gLWNvbnRhaW5lckhlaWdodDsgcG9zIC09IHNuYXBHcmlkSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHB1c2hHdWlkZWxpbmUocG9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc25hcEdyaWRXaWR0aCkge1xyXG4gICAgICAgIHZhciBwdXNoR3VpZGVsaW5lID0gZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICBndWlkZWxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoc3RhcnRPZmZzZXRbMF0gKiBkZWZhdWx0U25hcEdyaWRXaWR0aCArIHBvcyAtIGNsaWVudExlZnQgKyBzbmFwT2Zmc2V0TGVmdCwgMC4xKSxcclxuICAgICAgICAgICAgICAgICAgICBzbmFwT2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogcHJlZml4KFwiZ3JpZC1ndWlkZWxpbmVcIiksXHJcbiAgICAgICAgICAgICAgICBzaXplOiBjb250YWluZXJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBoaWRlOiAhaXNEaXNwbGF5R3JpZEd1aWRlbGluZXMsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBncmlkOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8PSBjb250YWluZXJXaWR0aCAqIDI7IHBvcyArPSBzbmFwR3JpZFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHB1c2hHdWlkZWxpbmUocG9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgcG9zID0gLXNuYXBHcmlkV2lkdGg7IHBvcyA+PSAtY29udGFpbmVyV2lkdGg7IHBvcyAtPSBzbmFwR3JpZFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHB1c2hHdWlkZWxpbmUocG9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3VpZGVsaW5lcztcclxufVxyXG5mdW5jdGlvbiBjaGVja0JldHdlZW5SZWN0cyhyZWN0MSwgcmVjdDIsIHR5cGUsIGRpc3RhbmNlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gXCJob3Jpem9udGFsXCIpIHtcclxuICAgICAgICByZXR1cm4gYWJzKHJlY3QxLnJpZ2h0IC0gcmVjdDIubGVmdCkgPD0gZGlzdGFuY2VcclxuICAgICAgICAgICAgfHwgYWJzKHJlY3QxLmxlZnQgLSByZWN0Mi5yaWdodCkgPD0gZGlzdGFuY2VcclxuICAgICAgICAgICAgfHwgcmVjdDEubGVmdCA8PSByZWN0Mi5yaWdodCAmJiByZWN0Mi5sZWZ0IDw9IHJlY3QxLnJpZ2h0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGFicyhyZWN0MS5ib3R0b20gLSByZWN0Mi50b3ApIDw9IGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHx8IGFicyhyZWN0MS50b3AgLSByZWN0Mi5ib3R0b20pIDw9IGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHx8IHJlY3QxLnRvcCA8PSByZWN0Mi5ib3R0b20gJiYgcmVjdDIudG9wIDw9IHJlY3QxLmJvdHRvbTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVsZW1lbnRHdWlkZWxpbmVzKG1vdmVhYmxlKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLmVsZW1lbnRHdWlkZWxpbmVzLCBlbGVtZW50R3VpZGVsaW5lcyA9IF9hID09PSB2b2lkIDAgPyBbXSA6IF9hO1xyXG4gICAgaWYgKCFlbGVtZW50R3VpZGVsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICBzdGF0ZS5lbGVtZW50UmVjdHMgPSBbXTtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgcHJldlZhbHVlcyA9IChzdGF0ZS5lbGVtZW50UmVjdHMgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoc25hcFJlY3QpIHsgcmV0dXJuICFzbmFwUmVjdC5yZWZyZXNoOyB9KTtcclxuICAgIHZhciBuZXh0RWxlbWVudEd1aWRlbGluZXMgPSBlbGVtZW50R3VpZGVsaW5lcy5tYXAoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KGVsKSAmJiBcImVsZW1lbnRcIiBpbiBlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGVsKSwgeyBlbGVtZW50OiBnZXRSZWZUYXJnZXQoZWwuZWxlbWVudCwgdHJ1ZSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IGdldFJlZlRhcmdldChlbCwgdHJ1ZSksXHJcbiAgICAgICAgfTtcclxuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZWxlbWVudDtcclxuICAgIH0pO1xyXG4gICAgdmFyIF9iID0gZGlmZihwcmV2VmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5lbGVtZW50OyB9KSwgbmV4dEVsZW1lbnRHdWlkZWxpbmVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5lbGVtZW50OyB9KSksIG1haW50YWluZWQgPSBfYi5tYWludGFpbmVkLCBhZGRlZCA9IF9iLmFkZGVkO1xyXG4gICAgdmFyIG5leHRWYWx1ZXMgPSBbXTtcclxuICAgIG1haW50YWluZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBwcmV2SW5kZXggPSBfYlswXSwgbmV4dEluZGV4ID0gX2JbMV07XHJcbiAgICAgICAgbmV4dFZhbHVlc1tuZXh0SW5kZXhdID0gcHJldlZhbHVlc1twcmV2SW5kZXhdO1xyXG4gICAgfSk7XHJcbiAgICBnZXRTbmFwRWxlbWVudFJlY3RzKG1vdmVhYmxlLCBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBuZXh0RWxlbWVudEd1aWRlbGluZXNbaW5kZXhdOyB9KSkubWFwKGZ1bmN0aW9uIChyZWN0LCBpKSB7XHJcbiAgICAgICAgbmV4dFZhbHVlc1thZGRlZFtpXV0gPSByZWN0O1xyXG4gICAgfSk7XHJcbiAgICBzdGF0ZS5lbGVtZW50UmVjdHMgPSBuZXh0VmFsdWVzO1xyXG4gICAgdmFyIGVsZW1lbnRTbmFwRGlyZWN0aW9ucyA9IGdldFNuYXBEaXJlY3Rpb25zKG1vdmVhYmxlLnByb3BzLmVsZW1lbnRTbmFwRGlyZWN0aW9ucyk7XHJcbiAgICB2YXIgbmV4dEd1aWRlbGluZXMgPSBbXTtcclxuICAgIG5leHRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoc25hcFJlY3QpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHNuYXBSZWN0LmVsZW1lbnQsIF9hID0gc25hcFJlY3QudG9wLCB0b3BWYWx1ZSA9IF9hID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMudG9wIDogX2EsIF9iID0gc25hcFJlY3QubGVmdCwgbGVmdFZhbHVlID0gX2IgPT09IHZvaWQgMCA/IGVsZW1lbnRTbmFwRGlyZWN0aW9ucy5sZWZ0IDogX2IsIF9jID0gc25hcFJlY3QucmlnaHQsIHJpZ2h0VmFsdWUgPSBfYyA9PT0gdm9pZCAwID8gZWxlbWVudFNuYXBEaXJlY3Rpb25zLnJpZ2h0IDogX2MsIF9kID0gc25hcFJlY3QuYm90dG9tLCBib3R0b21WYWx1ZSA9IF9kID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMuYm90dG9tIDogX2QsIF9lID0gc25hcFJlY3QuY2VudGVyLCBjZW50ZXJWYWx1ZSA9IF9lID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMuY2VudGVyIDogX2UsIF9mID0gc25hcFJlY3QubWlkZGxlLCBtaWRkbGVWYWx1ZSA9IF9mID09PSB2b2lkIDAgPyBlbGVtZW50U25hcERpcmVjdGlvbnMubWlkZGxlIDogX2YsIGNsYXNzTmFtZSA9IHNuYXBSZWN0LmNsYXNzTmFtZSwgcmVjdCA9IHNuYXBSZWN0LnJlY3Q7XHJcbiAgICAgICAgdmFyIF9nID0gc3BsaXRTbmFwRGlyZWN0aW9uUG9zZXMoe1xyXG4gICAgICAgICAgICB0b3A6IHRvcFZhbHVlLFxyXG4gICAgICAgICAgICByaWdodDogcmlnaHRWYWx1ZSxcclxuICAgICAgICAgICAgbGVmdDogbGVmdFZhbHVlLFxyXG4gICAgICAgICAgICBib3R0b206IGJvdHRvbVZhbHVlLFxyXG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlclZhbHVlLFxyXG4gICAgICAgICAgICBtaWRkbGU6IG1pZGRsZVZhbHVlLFxyXG4gICAgICAgIH0sIHJlY3QpLCBob3Jpem9udGFsID0gX2cuaG9yaXpvbnRhbCwgdmVydGljYWwgPSBfZy52ZXJ0aWNhbCwgaG9yaXpvbnRhbE5hbWVzID0gX2cuaG9yaXpvbnRhbE5hbWVzLCB2ZXJ0aWNhbE5hbWVzID0gX2cudmVydGljYWxOYW1lcztcclxuICAgICAgICB2YXIgcmVjdFRvcCA9IHJlY3QudG9wO1xyXG4gICAgICAgIHZhciByZWN0TGVmdCA9IHJlY3QubGVmdDtcclxuICAgICAgICB2YXIgd2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdExlZnQ7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdFRvcDtcclxuICAgICAgICB2YXIgc2l6ZXMgPSBbd2lkdGgsIGhlaWdodF07XHJcbiAgICAgICAgdmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAocG9zLCBpKSB7XHJcbiAgICAgICAgICAgIG5leHRHdWlkZWxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHBvczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKHBvcywgMC4xKSxcclxuICAgICAgICAgICAgICAgICAgICByZWN0VG9wLFxyXG4gICAgICAgICAgICAgICAgXSwgc2l6ZTogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgc2l6ZXM6IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50UmVjdDogc25hcFJlY3QsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50RGlyZWN0aW9uOiBTTkFQX1NLSVBfTkFNRVNfTUFQW3ZlcnRpY2FsTmFtZXNbaV1dIHx8IHZlcnRpY2FsTmFtZXNbaV0sXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IFwiXCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAocG9zLCBpKSB7XHJcbiAgICAgICAgICAgIG5leHRHdWlkZWxpbmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdExlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUocG9zLCAwLjEpLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIHNpemU6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgc2l6ZXM6IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50UmVjdDogc25hcFJlY3QsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50RGlyZWN0aW9uOiBTTkFQX1NLSVBfTkFNRVNfTUFQW2hvcml6b250YWxOYW1lc1tpXV0gfHwgaG9yaXpvbnRhbE5hbWVzW2ldLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5leHRHdWlkZWxpbmVzO1xyXG59XHJcbmZ1bmN0aW9uIGdldE9iamVjdEd1aWRlbGluZXMoZ3VpZGVsaW5lcywgY29udGFpbmVyU2l6ZSkge1xyXG4gICAgcmV0dXJuIGd1aWRlbGluZXMgPyBndWlkZWxpbmVzLm1hcChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIHZhciBwb3NHdWlkZWxpbmUgPSBpc09iamVjdChpbmZvKSA/IGluZm8gOiB7IHBvczogaW5mbyB9O1xyXG4gICAgICAgIHZhciBwb3MgPSBwb3NHdWlkZWxpbmUucG9zO1xyXG4gICAgICAgIGlmIChpc051bWJlcihwb3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NHdWlkZWxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHBvc0d1aWRlbGluZSksIHsgcG9zOiBjb252ZXJ0VW5pdFNpemUocG9zLCBjb250YWluZXJTaXplKSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KSA6IFtdO1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRHdWlkZWxpbmVzKGhvcml6b250YWxHdWlkZWxpbmVzLCB2ZXJ0aWNhbEd1aWRlbGluZXMsIHdpZHRoLCBoZWlnaHQsIGNsaWVudExlZnQsIGNsaWVudFRvcCwgc25hcE9mZnNldCkge1xyXG4gICAgaWYgKGNsaWVudExlZnQgPT09IHZvaWQgMCkgeyBjbGllbnRMZWZ0ID0gMDsgfVxyXG4gICAgaWYgKGNsaWVudFRvcCA9PT0gdm9pZCAwKSB7IGNsaWVudFRvcCA9IDA7IH1cclxuICAgIGlmIChzbmFwT2Zmc2V0ID09PSB2b2lkIDApIHsgc25hcE9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07IH1cclxuICAgIHZhciBndWlkZWxpbmVzID0gW107XHJcbiAgICB2YXIgc25hcE9mZnNldExlZnQgPSBzbmFwT2Zmc2V0LmxlZnQsIHNuYXBPZmZzZXRUb3AgPSBzbmFwT2Zmc2V0LnRvcCwgc25hcE9mZnNldEJvdHRvbSA9IHNuYXBPZmZzZXQuYm90dG9tLCBzbmFwT2Zmc2V0UmlnaHQgPSBzbmFwT2Zmc2V0LnJpZ2h0O1xyXG4gICAgdmFyIHNuYXBXaWR0aCA9IHdpZHRoICsgc25hcE9mZnNldFJpZ2h0IC0gc25hcE9mZnNldExlZnQ7XHJcbiAgICB2YXIgc25hcEhlaWdodCA9IGhlaWdodCArIHNuYXBPZmZzZXRCb3R0b20gLSBzbmFwT2Zmc2V0VG9wO1xyXG4gICAgZ2V0T2JqZWN0R3VpZGVsaW5lcyhob3Jpem9udGFsR3VpZGVsaW5lcywgc25hcEhlaWdodCkuZm9yRWFjaChmdW5jdGlvbiAocG9zSW5mbykge1xyXG4gICAgICAgIGd1aWRlbGluZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICBwb3M6IFtcclxuICAgICAgICAgICAgICAgIHNuYXBPZmZzZXRMZWZ0LFxyXG4gICAgICAgICAgICAgICAgdGhyb3R0bGUocG9zSW5mby5wb3MgLSBjbGllbnRUb3AgKyBzbmFwT2Zmc2V0VG9wLCAwLjEpLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBzaXplOiBzbmFwV2lkdGgsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcG9zSW5mby5jbGFzc05hbWUsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgZ2V0T2JqZWN0R3VpZGVsaW5lcyh2ZXJ0aWNhbEd1aWRlbGluZXMsIHNuYXBXaWR0aCkuZm9yRWFjaChmdW5jdGlvbiAocG9zSW5mbykge1xyXG4gICAgICAgIGd1aWRlbGluZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwidmVydGljYWxcIixcclxuICAgICAgICAgICAgcG9zOiBbXHJcbiAgICAgICAgICAgICAgICB0aHJvdHRsZShwb3NJbmZvLnBvcyAtIGNsaWVudExlZnQgKyBzbmFwT2Zmc2V0TGVmdCwgMC4xKSxcclxuICAgICAgICAgICAgICAgIHNuYXBPZmZzZXRUb3AsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHNpemU6IHNuYXBIZWlnaHQsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogcG9zSW5mby5jbGFzc05hbWUsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJcIixcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGd1aWRlbGluZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U25hcEVsZW1lbnRSZWN0cyhtb3ZlYWJsZSwgdmFsdWVzKSB7XHJcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgZ3JvdXBhYmxlID0gbW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlO1xyXG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICB2YXIgY29udGFpbmVyQ2xpZW50UmVjdCA9IHN0YXRlLmNvbnRhaW5lckNsaWVudFJlY3QsIFxyXG4gICAgLy8gdGFyZ2V0Q2xpZW50UmVjdDoge1xyXG4gICAgLy8gICAgIHRvcDogY2xpZW50VG9wLFxyXG4gICAgLy8gICAgIGxlZnQ6IGNsaWVudExlZnQsXHJcbiAgICAvLyB9LFxyXG4gICAgcm9vdE1hdHJpeCA9IHN0YXRlLnJvb3RNYXRyaXgsIGlzM2QgPSBzdGF0ZS5pczNkLCBvZmZzZXREZWx0YSA9IHN0YXRlLm9mZnNldERlbHRhO1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgX2EgPSBfX3JlYWQoY2FsY3VsYXRlQ29udGFpbmVyUG9zKHJvb3RNYXRyaXgsIGNvbnRhaW5lckNsaWVudFJlY3QsIG4pLCAyKSwgY29udGFpbmVyTGVmdCA9IF9hWzBdLCBjb250YWluZXJUb3AgPSBfYVsxXTtcclxuICAgIC8vIGNvbnN0IHBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoc3RhdGUpO1xyXG4gICAgLy8gY29uc3Qge1xyXG4gICAgLy8gICAgIG1pblg6IHRhcmdldExlZnQsXHJcbiAgICAvLyAgICAgbWluWTogdGFyZ2V0VG9wLFxyXG4gICAgLy8gfSA9IGdldE1pbk1heHMocG9zZXMpO1xyXG4gICAgLy8gY29uc3QgW2Rpc3RMZWZ0LCBkaXN0VG9wXSA9IG1pbnVzKFt0YXJnZXRMZWZ0LCB0YXJnZXRUb3BdLCBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW1xyXG4gICAgLy8gICAgIGNsaWVudExlZnQgLSBjb250YWluZXJMZWZ0LFxyXG4gICAgLy8gICAgIGNsaWVudFRvcCAtIGNvbnRhaW5lclRvcCxcclxuICAgIC8vIF0sIG4pKS5tYXAocG9zID0+IHJvdW5kU2lnbihwb3MpKTtcclxuICAgIHZhciBvZmZzZXRMZWZ0ID0gZ3JvdXBhYmxlID8gMCA6IG9mZnNldERlbHRhWzBdO1xyXG4gICAgdmFyIG9mZnNldFRvcCA9IGdyb3VwYWJsZSA/IDAgOiBvZmZzZXREZWx0YVsxXTtcclxuICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdmFsdWUuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCAtIGNvbnRhaW5lckxlZnQgLSBvZmZzZXRMZWZ0O1xyXG4gICAgICAgIHZhciB0b3AgPSByZWN0LnRvcCAtIGNvbnRhaW5lclRvcCAtIG9mZnNldFRvcDtcclxuICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbbGVmdCwgdG9wXSwgbiksIDIpLCBlbGVtZW50TGVmdCA9IF9hWzBdLCBlbGVtZW50VG9wID0gX2FbMV07XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbcmlnaHQsIGJvdHRvbV0sIG4pLCAyKSwgZWxlbWVudFJpZ2h0ID0gX2JbMF0sIGVsZW1lbnRCb3R0b20gPSBfYlsxXTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHZhbHVlKSwgeyByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtZW50TGVmdCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiBlbGVtZW50UmlnaHQsXHJcbiAgICAgICAgICAgICAgICB0b3A6IGVsZW1lbnRUb3AsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IGVsZW1lbnRCb3R0b20sXHJcbiAgICAgICAgICAgICAgICBjZW50ZXI6IChlbGVtZW50TGVmdCArIGVsZW1lbnRSaWdodCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgbWlkZGxlOiAoZWxlbWVudFRvcCArIGVsZW1lbnRCb3R0b20pIC8gMixcclxuICAgICAgICAgICAgfSB9KTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIGNoZWNrU25hcEluZm8obW92ZWFibGUpIHtcclxuICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgdmFyIGNvbnRhaW5lciA9IHN0YXRlLmNvbnRhaW5lcjtcclxuICAgIHZhciBzbmFwQ29udGFpbmVyID0gbW92ZWFibGUucHJvcHMuc25hcENvbnRhaW5lciB8fCBjb250YWluZXI7XHJcbiAgICBpZiAoc3RhdGUuc25hcENvbnRhaW5lciA9PT0gc25hcENvbnRhaW5lciAmJiBzdGF0ZS5ndWlkZWxpbmVzICYmIHN0YXRlLmd1aWRlbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBzdGF0ZS5jb250YWluZXJDbGllbnRSZWN0O1xyXG4gICAgdmFyIHNuYXBPZmZzZXQgPSB7XHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgfTtcclxuICAgIGlmIChjb250YWluZXIgIT09IHNuYXBDb250YWluZXIpIHtcclxuICAgICAgICB2YXIgc25hcENvbnRhaW5lclRhcmdldCA9IGdldFJlZlRhcmdldChzbmFwQ29udGFpbmVyLCB0cnVlKTtcclxuICAgICAgICBpZiAoc25hcENvbnRhaW5lclRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgc25hcENvbnRhaW5lclJlY3QgPSBnZXRDbGllbnRSZWN0KHNuYXBDb250YWluZXJUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IGdldERyYWdEaXN0QnlTdGF0ZShzdGF0ZSwgW1xyXG4gICAgICAgICAgICAgICAgc25hcENvbnRhaW5lclJlY3QubGVmdCAtIGNvbnRhaW5lckNsaWVudFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHNuYXBDb250YWluZXJSZWN0LnRvcCAtIGNvbnRhaW5lckNsaWVudFJlY3QudG9wLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldDIgPSBnZXREcmFnRGlzdEJ5U3RhdGUoc3RhdGUsIFtcclxuICAgICAgICAgICAgICAgIHNuYXBDb250YWluZXJSZWN0LnJpZ2h0IC0gY29udGFpbmVyQ2xpZW50UmVjdC5yaWdodCxcclxuICAgICAgICAgICAgICAgIHNuYXBDb250YWluZXJSZWN0LmJvdHRvbSAtIGNvbnRhaW5lckNsaWVudFJlY3QuYm90dG9tLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgc25hcE9mZnNldC5sZWZ0ID0gdGhyb3R0bGUob2Zmc2V0MVswXSwgMC4wMDAwMSk7XHJcbiAgICAgICAgICAgIHNuYXBPZmZzZXQudG9wID0gdGhyb3R0bGUob2Zmc2V0MVsxXSwgMC4wMDAwMSk7XHJcbiAgICAgICAgICAgIHNuYXBPZmZzZXQucmlnaHQgPSB0aHJvdHRsZShvZmZzZXQyWzBdLCAwLjAwMDAxKTtcclxuICAgICAgICAgICAgc25hcE9mZnNldC5ib3R0b20gPSB0aHJvdHRsZShvZmZzZXQyWzFdLCAwLjAwMDAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0ZS5zbmFwQ29udGFpbmVyID0gc25hcENvbnRhaW5lcjtcclxuICAgIHN0YXRlLnNuYXBPZmZzZXQgPSBzbmFwT2Zmc2V0O1xyXG4gICAgc3RhdGUuZ3VpZGVsaW5lcyA9IGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSk7XHJcbiAgICBzdGF0ZS5lbmFibGVTbmFwID0gdHJ1ZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5leHRGaXhlZFBvc2VzKG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zLCBpczNkKSB7XHJcbiAgICB2YXIgbmV4dFBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBpczNkID8gNCA6IDMpO1xyXG4gICAgdmFyIG5leHRGaXhlZFBvcyA9IGdldFBvc0J5RGlyZWN0aW9uKG5leHRQb3NlcywgZml4ZWREaXJlY3Rpb24pO1xyXG4gICAgcmV0dXJuIGdldEFic29sdXRlUG9zZXMobmV4dFBvc2VzLCBtaW51cyhmaXhlZFBvcywgbmV4dEZpeGVkUG9zKSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUgLyBhYnModmFsdWUpIDogMDtcclxufVxyXG5mdW5jdGlvbiBnZXRTaXplT2Zmc2V0SW5mbyhtb3ZlYWJsZSwgcG9zZXMsIGRpcmVjdGlvbiwga2VlcFJhdGlvLCBpc1JlcXVlc3QsIGRhdGFzKSB7XHJcbiAgICB2YXIgZml4ZWREaXJlY3Rpb24gPSBkYXRhcy5maXhlZERpcmVjdGlvbjtcclxuICAgIHZhciBkaXJlY3Rpb25zID0gZ2V0Q2hlY2tTbmFwRGlyZWN0aW9ucyhkaXJlY3Rpb24sIGZpeGVkRGlyZWN0aW9uLCBrZWVwUmF0aW8pO1xyXG4gICAgdmFyIGlubmVyQm91bmRMaW5lSW5mb3MgPSBnZXRDaGVja0lubmVyQm91bmRMaW5lSW5mb3MobW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb24sIGtlZXBSYXRpbyk7XHJcbiAgICB2YXIgb2Zmc2V0cyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldFNuYXBCb3VuZEluZm8obW92ZWFibGUsIHBvc2VzLCBkaXJlY3Rpb25zLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpKSwgZmFsc2UpLCBfX3JlYWQoZ2V0SW5uZXJCb3VuZEluZm8obW92ZWFibGUsIGlubmVyQm91bmRMaW5lSW5mb3MsIGRhdGFzKSksIGZhbHNlKTtcclxuICAgIHZhciB3aWR0aE9mZnNldEluZm8gPSBnZXROZWFyT2Zmc2V0SW5mbyhvZmZzZXRzLCAwKTtcclxuICAgIHZhciBoZWlnaHRPZmZzZXRJbmZvID0gZ2V0TmVhck9mZnNldEluZm8ob2Zmc2V0cywgMSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICAgIGlzQm91bmQ6IHdpZHRoT2Zmc2V0SW5mby5pc0JvdW5kLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHdpZHRoT2Zmc2V0SW5mby5vZmZzZXRbMF0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWlnaHQ6IHtcclxuICAgICAgICAgICAgaXNCb3VuZDogaGVpZ2h0T2Zmc2V0SW5mby5pc0JvdW5kLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGhlaWdodE9mZnNldEluZm8ub2Zmc2V0WzFdLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlY2hlY2tTaXplQnlUd29EaXJlY3Rpb24obW92ZWFibGUsIHBvc2VzLCB3aWR0aCwgaGVpZ2h0LCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBkaXJlY3Rpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcclxuICAgIHZhciBzbmFwUG9zID0gZ2V0UG9zQnlEaXJlY3Rpb24ocG9zZXMsIGRpcmVjdGlvbik7XHJcbiAgICB2YXIgX2EgPSBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XHJcbiAgICAgICAgdmVydGljYWw6IFtzbmFwUG9zWzBdXSxcclxuICAgICAgICBob3Jpem9udGFsOiBbc25hcFBvc1sxXV0sXHJcbiAgICB9KSwgaG9yaXpvbnRhbE9mZnNldCA9IF9hLmhvcml6b250YWwub2Zmc2V0LCB2ZXJ0aWNhbE9mZnNldCA9IF9hLnZlcnRpY2FsLm9mZnNldDtcclxuICAgIGlmICh0aHJvdHRsZSh2ZXJ0aWNhbE9mZnNldCwgRkxPQVRfUE9JTlRfTlVNKSB8fCB0aHJvdHRsZShob3Jpem9udGFsT2Zmc2V0LCBGTE9BVF9QT0lOVF9OVU0pKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKGdldERyYWdEaXN0KHtcclxuICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICBkaXN0WDogLXZlcnRpY2FsT2Zmc2V0LFxyXG4gICAgICAgICAgICBkaXN0WTogLWhvcml6b250YWxPZmZzZXQsXHJcbiAgICAgICAgfSksIDIpLCBuZXh0V2lkdGhPZmZzZXQgPSBfYlswXSwgbmV4dEhlaWdodE9mZnNldCA9IF9iWzFdO1xyXG4gICAgICAgIHZhciBuZXh0V2lkdGggPSBNYXRoLm1pbihtYXhXaWR0aCB8fCBJbmZpbml0eSwgd2lkdGggKyBkaXJlY3Rpb25bMF0gKiBuZXh0V2lkdGhPZmZzZXQpO1xyXG4gICAgICAgIHZhciBuZXh0SGVpZ2h0ID0gTWF0aC5taW4obWF4SGVpZ2h0IHx8IEluZmluaXR5LCBoZWlnaHQgKyBkaXJlY3Rpb25bMV0gKiBuZXh0SGVpZ2h0T2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gW25leHRXaWR0aCAtIHdpZHRoLCBuZXh0SGVpZ2h0IC0gaGVpZ2h0XTtcclxuICAgIH1cclxuICAgIHJldHVybiBbMCwgMF07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTaXplRGlzdChtb3ZlYWJsZSwgZ2V0TmV4dFBvc2VzLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcclxuICAgIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcclxuICAgIHZhciBrZWVwUmF0aW8gPSBtb3ZlYWJsZS5wcm9wcy5rZWVwUmF0aW87XHJcbiAgICB2YXIgd2lkdGhPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGhlaWdodE9mZnNldCA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xyXG4gICAgICAgIHZhciBuZXh0UG9zZXMgPSBnZXROZXh0UG9zZXMod2lkdGhPZmZzZXQsIGhlaWdodE9mZnNldCk7XHJcbiAgICAgICAgdmFyIF9hID0gZ2V0U2l6ZU9mZnNldEluZm8obW92ZWFibGUsIG5leHRQb3NlcywgZGlyZWN0aW9uLCBrZWVwUmF0aW8sIGlzUmVxdWVzdCwgZGF0YXMpLCB3aWR0aE9mZnNldEluZm8gPSBfYS53aWR0aCwgaGVpZ2h0T2Zmc2V0SW5mbyA9IF9hLmhlaWdodDtcclxuICAgICAgICB2YXIgaXNXaWR0aEJvdW5kID0gd2lkdGhPZmZzZXRJbmZvLmlzQm91bmQ7XHJcbiAgICAgICAgdmFyIGlzSGVpZ2h0Qm91bmQgPSBoZWlnaHRPZmZzZXRJbmZvLmlzQm91bmQ7XHJcbiAgICAgICAgdmFyIG5leHRXaWR0aE9mZnNldCA9IHdpZHRoT2Zmc2V0SW5mby5vZmZzZXQ7XHJcbiAgICAgICAgdmFyIG5leHRIZWlnaHRPZmZzZXQgPSBoZWlnaHRPZmZzZXRJbmZvLm9mZnNldDtcclxuICAgICAgICBpZiAoaSA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzV2lkdGhCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzSGVpZ2h0Qm91bmQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRIZWlnaHRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID09PSAwICYmIGlzUmVxdWVzdCAmJiAhaXNXaWR0aEJvdW5kICYmICFpc0hlaWdodEJvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZWVwUmF0aW8pIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoRGlzdCA9IGFicyhuZXh0V2lkdGhPZmZzZXQpICogKHdpZHRoID8gMSAvIHdpZHRoIDogMSk7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHREaXN0ID0gYWJzKG5leHRIZWlnaHRPZmZzZXQpICogKGhlaWdodCA/IDEgLyBoZWlnaHQgOiAxKTtcclxuICAgICAgICAgICAgdmFyIGlzR2V0V2lkdGhPZmZzZXQgPSBpc1dpZHRoQm91bmQgJiYgaXNIZWlnaHRCb3VuZFxyXG4gICAgICAgICAgICAgICAgPyB3aWR0aERpc3QgPCBoZWlnaHREaXN0XHJcbiAgICAgICAgICAgICAgICA6IGlzSGVpZ2h0Qm91bmQgfHxcclxuICAgICAgICAgICAgICAgICAgICAoIWlzV2lkdGhCb3VuZCAmJiB3aWR0aERpc3QgPCBoZWlnaHREaXN0KTtcclxuICAgICAgICAgICAgaWYgKGlzR2V0V2lkdGhPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoIDogaGVpZ2h0ID0gPyA6IGhlaWdodE9mZnNldFxyXG4gICAgICAgICAgICAgICAgbmV4dFdpZHRoT2Zmc2V0ID0gKHdpZHRoICogbmV4dEhlaWdodE9mZnNldCkgLyBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aWR0aCA6IGhlaWdodCA9IHdpZHRoT2Zmc2V0IDogP1xyXG4gICAgICAgICAgICAgICAgbmV4dEhlaWdodE9mZnNldCA9IChoZWlnaHQgKiBuZXh0V2lkdGhPZmZzZXQpIC8gd2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2lkdGhPZmZzZXQgKz0gbmV4dFdpZHRoT2Zmc2V0O1xyXG4gICAgICAgIGhlaWdodE9mZnNldCArPSBuZXh0SGVpZ2h0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZWVwUmF0aW8gJiYgZGlyZWN0aW9uWzBdICYmIGRpcmVjdGlvblsxXSkge1xyXG4gICAgICAgIHZhciBfYiA9IGNoZWNrTWF4Qm91bmRzKG1vdmVhYmxlLCBwb3NlcywgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBkYXRhcyksIG1heFdpZHRoID0gX2IubWF4V2lkdGgsIG1heEhlaWdodCA9IF9iLm1heEhlaWdodDtcclxuICAgICAgICB2YXIgX2MgPSBfX3JlYWQocmVjaGVja1NpemVCeVR3b0RpcmVjdGlvbihtb3ZlYWJsZSwgZ2V0TmV4dFBvc2VzKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiB0aHJvdHRsZShwLCBGTE9BVF9QT0lOVF9OVU0pOyB9KTsgfSksIHdpZHRoICsgd2lkdGhPZmZzZXQsIGhlaWdodCArIGhlaWdodE9mZnNldCwgbWF4V2lkdGgsIG1heEhlaWdodCwgZGlyZWN0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKSwgMiksIG5leHRXaWR0aE9mZnNldCA9IF9jWzBdLCBuZXh0SGVpZ2h0T2Zmc2V0ID0gX2NbMV07XHJcbiAgICAgICAgd2lkdGhPZmZzZXQgKz0gbmV4dFdpZHRoT2Zmc2V0O1xyXG4gICAgICAgIGhlaWdodE9mZnNldCArPSBuZXh0SGVpZ2h0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFt3aWR0aE9mZnNldCwgaGVpZ2h0T2Zmc2V0XTtcclxufVxyXG5mdW5jdGlvbiBhYnNEZWdyZWUoZGVnKSB7XHJcbiAgICBpZiAoZGVnIDwgMCkge1xyXG4gICAgICAgIGRlZyA9IGRlZyAlIDM2MCArIDM2MDtcclxuICAgIH1cclxuICAgIGRlZyAlPSAzNjA7XHJcbiAgICByZXR1cm4gZGVnO1xyXG59XHJcbmZ1bmN0aW9uIGJ1bXBEZWdyZWUoYmFzZURlZywgc25hcERlZykge1xyXG4gICAgLy8gYmFzZURlZyAtODBcclxuICAgIC8vIHNuYXBEZWcgMjcwXHJcbiAgICAvLyByZXR1cm4gLTkwXHJcbiAgICBzbmFwRGVnID0gYWJzRGVncmVlKHNuYXBEZWcpO1xyXG4gICAgdmFyIGNvdW50ID0gTWF0aC5mbG9vcihiYXNlRGVnIC8gMzYwKTtcclxuICAgIHZhciBkZWcxID0gY291bnQgKiAzNjAgKyAzNjAgLSBzbmFwRGVnO1xyXG4gICAgdmFyIGRlZzIgPSBjb3VudCAqIDM2MCArIHNuYXBEZWc7XHJcbiAgICByZXR1cm4gYWJzKGJhc2VEZWcgLSBkZWcxKSA8IGFicyhiYXNlRGVnIC0gZGVnMikgPyBkZWcxIDogZGVnMjtcclxufVxyXG5mdW5jdGlvbiBnZXRNaW5EZWdyZWVEaXN0YW5jZShkZWcxLCBkZWcyKSB7XHJcbiAgICBkZWcxID0gYWJzRGVncmVlKGRlZzEpO1xyXG4gICAgZGVnMiA9IGFic0RlZ3JlZShkZWcyKTtcclxuICAgIHZhciBkZWczID0gYWJzRGVncmVlKGRlZzEgLSBkZWcyKTtcclxuICAgIHJldHVybiBNYXRoLm1pbihkZWczLCAzNjAgLSBkZWczKTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBSb3RhdGUobW92ZWFibGUsIHJlY3QsIGRpc3QsIHJvdGF0aW9uKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgIHZhciBzbmFwUm90YXRpb25UaHJlc2hvbGQgPSAoX2EgPSBwcm9wc1tOQU1FX3NuYXBSb3RhdGlvblRocmVzaG9sZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDU7XHJcbiAgICB2YXIgc25hcFJvdGF0aW9uRGVncmVlcyA9IHByb3BzW05BTUVfc25hcFJvdGF0aW9uRGVncmVlc107XHJcbiAgICBpZiAoaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJyb3RhdGFibGVcIikpIHtcclxuICAgICAgICB2YXIgcG9zMSA9IHJlY3QucG9zMSwgcG9zMiA9IHJlY3QucG9zMiwgcG9zMyA9IHJlY3QucG9zMywgcG9zNCA9IHJlY3QucG9zNCwgb3JpZ2luMl8xID0gcmVjdC5vcmlnaW47XHJcbiAgICAgICAgdmFyIHJhZF8xID0gKGRpc3QgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgICAgICB2YXIgcHJldlBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBtaW51cyhwb3MsIG9yaWdpbjJfMSk7IH0pO1xyXG4gICAgICAgIHZhciBuZXh0UG9zZXMgPSBwcmV2UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHJvdGF0ZShwb3MsIHJhZF8xKTsgfSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cobW92ZWFibGUuc3RhdGUubGVmdCwgbW92ZWFibGUuc3RhdGUudG9wLCBtb3ZlYWJsZS5zdGF0ZS5vcmlnaW4pO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHBvczEsIHBvczIsIHBvczMsIHBvczQsIG9yaWdpbiwgcmFkLCBwcmV2UG9zZXMsIG5leHRQb3Nlcyk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGNoZWNrUm90YXRlQm91bmRzKG1vdmVhYmxlLCBwcmV2UG9zZXMsIG5leHRQb3Nlcywgb3JpZ2luMl8xLCBkaXN0KSksIGZhbHNlKSwgX19yZWFkKGNoZWNrUm90YXRlSW5uZXJCb3VuZHMobW92ZWFibGUsIHByZXZQb3NlcywgbmV4dFBvc2VzLCBvcmlnaW4yXzEsIGRpc3QpKSwgZmFsc2UpO1xyXG4gICAgICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhYnMoYSAtIGRpc3QpIC0gYWJzKGIgLSBkaXN0KTsgfSk7XHJcbiAgICAgICAgdmFyIGlzU25hcCA9IHJlc3VsdC5sZW5ndGggPiAwO1xyXG4gICAgICAgIGlmIChpc1NuYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzU25hcDogaXNTbmFwLFxyXG4gICAgICAgICAgICAgICAgZGlzdDogaXNTbmFwID8gcmVzdWx0WzBdIDogZGlzdCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHNuYXBSb3RhdGlvbkRlZ3JlZXMgPT09IG51bGwgfHwgc25hcFJvdGF0aW9uRGVncmVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcFJvdGF0aW9uRGVncmVlcy5sZW5ndGgpICYmIHNuYXBSb3RhdGlvblRocmVzaG9sZCkge1xyXG4gICAgICAgIHZhciBzb3J0ZWQgPSBzbmFwUm90YXRpb25EZWdyZWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TWluRGVncmVlRGlzdGFuY2UoYSwgcm90YXRpb24pIC0gZ2V0TWluRGVncmVlRGlzdGFuY2UoYiwgcm90YXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBmaXJzdERlZ3JlZSA9IHNvcnRlZFswXTtcclxuICAgICAgICBpZiAoZ2V0TWluRGVncmVlRGlzdGFuY2UoZmlyc3REZWdyZWUsIHJvdGF0aW9uKSA8PSBzbmFwUm90YXRpb25UaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzU25hcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRpc3Q6IGRpc3QgKyBidW1wRGVncmVlKHJvdGF0aW9uLCBmaXJzdERlZ3JlZSkgLSByb3RhdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzU25hcDogZmFsc2UsXHJcbiAgICAgICAgZGlzdDogZGlzdCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tTbmFwUmVzaXplKG1vdmVhYmxlLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzUmVxdWVzdCwgZGF0YXMpIHtcclxuICAgIGlmICghaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIikpIHtcclxuICAgICAgICByZXR1cm4gWzAsIDBdO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb24sIG5leHRBbGxNYXRyaXggPSBkYXRhcy5uZXh0QWxsTWF0cml4O1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIGFsbE1hdHJpeCA9IF9hLmFsbE1hdHJpeCwgaXMzZCA9IF9hLmlzM2Q7XHJcbiAgICByZXR1cm4gY2hlY2tTaXplRGlzdChtb3ZlYWJsZSwgZnVuY3Rpb24gKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmV4dEZpeGVkUG9zZXMobmV4dEFsbE1hdHJpeCB8fCBhbGxNYXRyaXgsIHdpZHRoICsgd2lkdGhPZmZzZXQsIGhlaWdodCArIGhlaWdodE9mZnNldCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzM2QpO1xyXG4gICAgfSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBmaXhlZFBvc2l0aW9uLCBpc1JlcXVlc3QsIGRhdGFzKTtcclxufVxyXG5mdW5jdGlvbiBjaGVja1NuYXBTY2FsZShtb3ZlYWJsZSwgc2NhbGUsIGRpcmVjdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcykge1xyXG4gICAgaWYgKCFoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcInNjYWxhYmxlXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcclxuICAgIH1cclxuICAgIHZhciBzdGFydE9mZnNldFdpZHRoID0gZGF0YXMuc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQgPSBkYXRhcy5zdGFydE9mZnNldEhlaWdodCwgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb24sIGZpeGVkRGlyZWN0aW9uID0gZGF0YXMuZml4ZWREaXJlY3Rpb24sIGlzM2QgPSBkYXRhcy5pczNkO1xyXG4gICAgdmFyIHNpemVEaXN0ID0gY2hlY2tTaXplRGlzdChtb3ZlYWJsZSwgZnVuY3Rpb24gKHdpZHRoT2Zmc2V0LCBoZWlnaHRPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmV4dEZpeGVkUG9zZXMoc2NhbGVNYXRyaXgoZGF0YXMsIHBsdXMoc2NhbGUsIFt3aWR0aE9mZnNldCAvIHN0YXJ0T2Zmc2V0V2lkdGgsIGhlaWdodE9mZnNldCAvIHN0YXJ0T2Zmc2V0SGVpZ2h0XSkpLCBzdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodCwgZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGlzM2QpO1xyXG4gICAgfSwgc3RhcnRPZmZzZXRXaWR0aCwgc3RhcnRPZmZzZXRIZWlnaHQsIGRpcmVjdGlvbiwgZml4ZWRQb3NpdGlvbiwgaXNSZXF1ZXN0LCBkYXRhcyk7XHJcbiAgICByZXR1cm4gW3NpemVEaXN0WzBdIC8gc3RhcnRPZmZzZXRXaWR0aCwgc2l6ZURpc3RbMV0gLyBzdGFydE9mZnNldEhlaWdodF07XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRDaGVja1NuYXBEcmFnKG1vdmVhYmxlLCBkYXRhcykge1xyXG4gICAgZGF0YXMuYWJzb2x1dGVQb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTbmFwR3VpZGVsaW5lcyhwb3NJbmZvcykge1xyXG4gICAgdmFyIGd1aWRlbGluZXMgPSBbXTtcclxuICAgIHBvc0luZm9zLmZvckVhY2goZnVuY3Rpb24gKHBvc0luZm8pIHtcclxuICAgICAgICBwb3NJbmZvLmd1aWRlbGluZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmU7XHJcbiAgICAgICAgICAgIGlmIChmaW5kKGd1aWRlbGluZXMsIGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLmd1aWRlbGluZSA9PT0gZ3VpZGVsaW5lOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1aWRlbGluZS5kaXJlY3Rpb24gPSBcIlwiO1xyXG4gICAgICAgICAgICBndWlkZWxpbmVzLnB1c2goeyBndWlkZWxpbmU6IGd1aWRlbGluZSwgcG9zSW5mbzogcG9zSW5mbyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGd1aWRlbGluZXMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmUsIHBvc0luZm8gPSBfYS5wb3NJbmZvO1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZ3VpZGVsaW5lKSwgeyBkaXJlY3Rpb246IHBvc0luZm8uZGlyZWN0aW9uIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkQm91bmRHdWlkZWxpbmVzKG1vdmVhYmxlLCB2ZXJ0aWNhbFBvc2VzLCBob3Jpem9udGFsUG9zZXMsIHZlcnRpY2FsU25hcFBvc2VzLCBob3Jpem9udGFsU25hcFBvc2VzLCBleHRlcm5hbEJvdW5kcykge1xyXG4gICAgdmFyIF9hID0gY2hlY2tCb3VuZFBvc2VzKGdldEJvdW5kcyhtb3ZlYWJsZSwgZXh0ZXJuYWxCb3VuZHMpLCB2ZXJ0aWNhbFBvc2VzLCBob3Jpem9udGFsUG9zZXMpLCB2ZXJ0aWNhbEJvdW5kSW5mb3MgPSBfYS52ZXJ0aWNhbCwgaG9yaXpvbnRhbEJvdW5kSW5mb3MgPSBfYS5ob3Jpem9udGFsO1xyXG4gICAgdmFyIGJvdW5kTWFwID0gZ2V0SW5pdGlhbEJvdW5kcygpO1xyXG4gICAgdmVydGljYWxCb3VuZEluZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICBpZiAoaW5mby5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmZvLmRpcmVjdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZE1hcC5sZWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5mby5kaXJlY3Rpb24gPT09IFwiZW5kXCIpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kTWFwLnJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZXJ0aWNhbFNuYXBQb3Nlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm91bmRzXCIsXHJcbiAgICAgICAgICAgICAgICBwb3M6IGluZm8ucG9zLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGhvcml6b250YWxCb3VuZEluZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICBpZiAoaW5mby5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmZvLmRpcmVjdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZE1hcC50b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpbmZvLmRpcmVjdGlvbiA9PT0gXCJlbmRcIikge1xyXG4gICAgICAgICAgICAgICAgYm91bmRNYXAuYm90dG9tID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3Jpem9udGFsU25hcFBvc2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJib3VuZHNcIixcclxuICAgICAgICAgICAgICAgIHBvczogaW5mby5wb3MsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIF9iID0gY2hlY2tJbm5lckJvdW5kUG9zZXMobW92ZWFibGUpLCBpbm5lckJvdW5kTWFwID0gX2IuYm91bmRNYXAsIHZlcnRpY2FsSW5uZXJCb3VuZFBvc2VzID0gX2IudmVydGljYWwsIGhvcml6b250YWxJbm5lckJvdW5kUG9zZXMgPSBfYi5ob3Jpem9udGFsO1xyXG4gICAgdmVydGljYWxJbm5lckJvdW5kUG9zZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5uZXJQb3MpIHtcclxuICAgICAgICBpZiAoZmluZEluZGV4KHZlcnRpY2FsU25hcFBvc2VzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBwb3MgPSBfYS5wb3M7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSBcImJvdW5kc1wiICYmIHBvcyA9PT0gaW5uZXJQb3M7XHJcbiAgICAgICAgfSkgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlcnRpY2FsU25hcFBvc2VzLnB1c2goe1xyXG4gICAgICAgICAgICB0eXBlOiBcImJvdW5kc1wiLFxyXG4gICAgICAgICAgICBwb3M6IGlubmVyUG9zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBob3Jpem9udGFsSW5uZXJCb3VuZFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGlubmVyUG9zKSB7XHJcbiAgICAgICAgaWYgKGZpbmRJbmRleChob3Jpem9udGFsU25hcFBvc2VzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBwb3MgPSBfYS5wb3M7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSBcImJvdW5kc1wiICYmIHBvcyA9PT0gaW5uZXJQb3M7XHJcbiAgICAgICAgfSkgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvcml6b250YWxTbmFwUG9zZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYm91bmRzXCIsXHJcbiAgICAgICAgICAgIHBvczogaW5uZXJQb3MsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYm91bmRNYXA6IGJvdW5kTWFwLFxyXG4gICAgICAgIGlubmVyQm91bmRNYXA6IGlubmVyQm91bmRNYXAsXHJcbiAgICB9O1xyXG59XHJcbnZhciBkaXJlY3Rpb25Db25kaXRpb24kMSA9IGdldERpcmVjdGlvbkNvbmRpdGlvbihcIlwiLCBbXCJyZXNpemFibGVcIiwgXCJzY2FsYWJsZVwiXSk7XHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlNuYXBwYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBzbmFwcGVkIHRvIHRoZSBndWlkZWxpbmUuIChkZWZhdWx0OiBmYWxzZSlcclxuICogQHNvcnQgMlxyXG4gKi9cclxudmFyIFNuYXBwYWJsZSA9IHtcclxuICAgIG5hbWU6IFwic25hcHBhYmxlXCIsXHJcbiAgICBkcmFnUmVsYXRpb246IFwic3Ryb25nXCIsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwic25hcHBhYmxlXCIsXHJcbiAgICAgICAgXCJzbmFwQ29udGFpbmVyXCIsXHJcbiAgICAgICAgXCJzbmFwRGlyZWN0aW9uc1wiLFxyXG4gICAgICAgIFwiZWxlbWVudFNuYXBEaXJlY3Rpb25zXCIsXHJcbiAgICAgICAgXCJzbmFwR2FwXCIsXHJcbiAgICAgICAgXCJzbmFwR3JpZFdpZHRoXCIsXHJcbiAgICAgICAgXCJzbmFwR3JpZEhlaWdodFwiLFxyXG4gICAgICAgIFwiaXNEaXNwbGF5U25hcERpZ2l0XCIsXHJcbiAgICAgICAgXCJpc0Rpc3BsYXlJbm5lclNuYXBEaWdpdFwiLFxyXG4gICAgICAgIFwiaXNEaXNwbGF5R3JpZEd1aWRlbGluZXNcIixcclxuICAgICAgICBcInNuYXBEaWdpdFwiLFxyXG4gICAgICAgIFwic25hcFRocmVzaG9sZFwiLFxyXG4gICAgICAgIFwic25hcFJlbmRlclRocmVzaG9sZFwiLFxyXG4gICAgICAgIFwic25hcEdyaWRBbGxcIixcclxuICAgICAgICBOQU1FX3NuYXBSb3RhdGlvblRocmVzaG9sZCxcclxuICAgICAgICBOQU1FX3NuYXBSb3RhdGlvbkRlZ3JlZXMsXHJcbiAgICAgICAgTkFNRV9zbmFwSG9yaXpvbnRhbFRocmVzaG9sZCxcclxuICAgICAgICBOQU1FX3NuYXBWZXJ0aWNhbFRocmVzaG9sZCxcclxuICAgICAgICBcImhvcml6b250YWxHdWlkZWxpbmVzXCIsXHJcbiAgICAgICAgXCJ2ZXJ0aWNhbEd1aWRlbGluZXNcIixcclxuICAgICAgICBcImVsZW1lbnRHdWlkZWxpbmVzXCIsXHJcbiAgICAgICAgXCJib3VuZHNcIixcclxuICAgICAgICBcImlubmVyQm91bmRzXCIsXHJcbiAgICAgICAgXCJzbmFwRGlzdEZvcm1hdFwiLFxyXG4gICAgICAgIFwibWF4U25hcEVsZW1lbnRHdWlkZWxpbmVEaXN0YW5jZVwiLFxyXG4gICAgICAgIFwibWF4U25hcEVsZW1lbnRHYXBEaXN0YW5jZVwiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1wic25hcFwiLCBcImJvdW5kXCJdLFxyXG4gICAgY3NzOiBbXHJcbiAgICAgICAgXCI6aG9zdCB7XFxuLS1ib3VuZHMtY29sb3I6ICNkNjY7XFxufVxcbi5ndWlkZWxpbmUge1xcbnBvaW50ZXItZXZlbnRzOiBub25lO1xcbnotaW5kZXg6IDI7XFxufVxcbi5ndWlkZWxpbmUuYm91bmRzIHtcXG5iYWNrZ3JvdW5kOiAjZDY2O1xcbmJhY2tncm91bmQ6IHZhcigtLWJvdW5kcy1jb2xvcik7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG50b3A6IDA7XFxubGVmdDogMDtcXG59XFxuLmd1aWRlbGluZS1ncm91cCAuc2l6ZS12YWx1ZSB7XFxucG9zaXRpb246IGFic29sdXRlO1xcbmNvbG9yOiAjZjU1O1xcbmZvbnQtc2l6ZTogMTJweDtcXG5mb250LXNpemU6IGNhbGMoMTJweCAqIHZhcigtLXpvb20pKTtcXG5mb250LXdlaWdodDogYm9sZDtcXG59XFxuLmd1aWRlbGluZS1ncm91cC5ob3Jpem9udGFsIC5zaXplLXZhbHVlIHtcXG50cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTAwJTtcXG50cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XFxubGVmdDogNTAlO1xcbmJvdHRvbTogNXB4O1xcbmJvdHRvbTogY2FsYygycHggKyAzcHggKiB2YXIoLS16b29tKSk7XFxufVxcbi5ndWlkZWxpbmUtZ3JvdXAudmVydGljYWwgLnNpemUtdmFsdWUge1xcbnRyYW5zZm9ybS1vcmlnaW46IDAlIDUwJTtcXG50b3A6IDUwJTtcXG50cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxubGVmdDogNXB4O1xcbmxlZnQ6IGNhbGMoMnB4ICsgM3B4ICogdmFyKC0tem9vbSkpO1xcbn1cXG4uZ3VpZGVsaW5lLmdhcCB7XFxuYmFja2dyb3VuZDogI2Y1NTtcXG59XFxuLnNpemUtdmFsdWUuZ2FwIHtcXG5jb2xvcjogI2Y1NTtcXG59XFxuXCIsXHJcbiAgICBdLFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHRhcmdldFRvcCA9IHN0YXRlLnRvcCwgdGFyZ2V0TGVmdCA9IHN0YXRlLmxlZnQsIHBvczEgPSBzdGF0ZS5wb3MxLCBwb3MyID0gc3RhdGUucG9zMiwgcG9zMyA9IHN0YXRlLnBvczMsIHBvczQgPSBzdGF0ZS5wb3M0LCBzbmFwUmVuZGVySW5mbyA9IHN0YXRlLnNuYXBSZW5kZXJJbmZvO1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLnNuYXBSZW5kZXJUaHJlc2hvbGQsIHNuYXBSZW5kZXJUaHJlc2hvbGQgPSBfYSA9PT0gdm9pZCAwID8gMSA6IF9hO1xyXG4gICAgICAgIGlmICghc25hcFJlbmRlckluZm8gfHwgIXNuYXBSZW5kZXJJbmZvLnJlbmRlciB8fCAhaGFzR3VpZGVsaW5lcyhtb3ZlYWJsZSwgXCJcIikpIHtcclxuICAgICAgICAgICAgLy8gcmVzZXQgc3RvcmVcclxuICAgICAgICAgICAgd2F0Y2hWYWx1ZShtb3ZlYWJsZSwgXCJib3VuZE1hcFwiLCBnZXRJbml0aWFsQm91bmRzKCksIGZ1bmN0aW9uICh2KSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsgfSk7XHJcbiAgICAgICAgICAgIHdhdGNoVmFsdWUobW92ZWFibGUsIFwiaW5uZXJCb3VuZE1hcFwiLCBnZXRJbml0aWFsQm91bmRzKCksIGZ1bmN0aW9uICh2KSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZ3VpZGVsaW5lcyA9IGdldFRvdGFsR3VpZGVsaW5lcyhtb3ZlYWJsZSk7XHJcbiAgICAgICAgdmFyIG1pbkxlZnQgPSBNYXRoLm1pbihwb3MxWzBdLCBwb3MyWzBdLCBwb3MzWzBdLCBwb3M0WzBdKTtcclxuICAgICAgICB2YXIgbWluVG9wID0gTWF0aC5taW4ocG9zMVsxXSwgcG9zMlsxXSwgcG9zM1sxXSwgcG9zNFsxXSk7XHJcbiAgICAgICAgdmFyIGV4dGVybmFsUG9zZXMgPSBzbmFwUmVuZGVySW5mby5leHRlcm5hbFBvc2VzIHx8IFtdO1xyXG4gICAgICAgIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKG1vdmVhYmxlLnN0YXRlKTtcclxuICAgICAgICB2YXIgdmVydGljYWxTbmFwUG9zZXMgPSBbXTtcclxuICAgICAgICB2YXIgaG9yaXpvbnRhbFNuYXBQb3NlcyA9IFtdO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNhbEd1aWRlbGluZXMgPSBbXTtcclxuICAgICAgICB2YXIgaG9yaXpvbnRhbEd1aWRlbGluZXMgPSBbXTtcclxuICAgICAgICB2YXIgc25hcEluZm9zID0gW107XHJcbiAgICAgICAgdmFyIF9iID0gZ2V0UmVjdChwb3NlcyksIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodCwgdG9wID0gX2IudG9wLCBsZWZ0ID0gX2IubGVmdCwgYm90dG9tID0gX2IuYm90dG9tLCByaWdodCA9IF9iLnJpZ2h0O1xyXG4gICAgICAgIHZhciB0YXJnZXRSZWN0ID0geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQsIHRvcDogdG9wLCBib3R0b206IGJvdHRvbSwgY2VudGVyOiAobGVmdCArIHJpZ2h0KSAvIDIsIG1pZGRsZTogKHRvcCArIGJvdHRvbSkgLyAyIH07XHJcbiAgICAgICAgdmFyIGhhc0V4dGVybmFsUG9zZXMgPSBleHRlcm5hbFBvc2VzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgdmFyIGV4dGVybmFsUmVjdCA9IGhhc0V4dGVybmFsUG9zZXNcclxuICAgICAgICAgICAgPyBnZXRSZWN0KGV4dGVybmFsUG9zZXMpXHJcbiAgICAgICAgICAgIDoge307XHJcbiAgICAgICAgaWYgKCFzbmFwUmVuZGVySW5mby5yZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChzbmFwUmVuZGVySW5mby5kaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHNuYXBJbmZvcy5wdXNoKGdldFNuYXBJbmZvc0J5RGlyZWN0aW9uKG1vdmVhYmxlLCBwb3Nlcywgc25hcFJlbmRlckluZm8uZGlyZWN0aW9uLCBzbmFwUmVuZGVyVGhyZXNob2xkLCBzbmFwUmVuZGVyVGhyZXNob2xkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLnNuYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZ2V0UmVjdChwb3Nlcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc25hcFJlbmRlckluZm8uY2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5taWRkbGUgPSAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3QuY2VudGVyID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNuYXBJbmZvcy5wdXNoKGNoZWNrU25hcHMobW92ZWFibGUsIHJlY3QsIHNuYXBSZW5kZXJUaHJlc2hvbGQsIHNuYXBSZW5kZXJUaHJlc2hvbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzRXh0ZXJuYWxQb3Nlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuYXBSZW5kZXJJbmZvLmNlbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsUmVjdC5taWRkbGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXh0ZXJuYWxSZWN0LnRvcCArIGV4dGVybmFsUmVjdC5ib3R0b20pIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbFJlY3QuY2VudGVyID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKGV4dGVybmFsUmVjdC5sZWZ0ICsgZXh0ZXJuYWxSZWN0LnJpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbmFwSW5mb3MucHVzaChjaGVja1NuYXBzKG1vdmVhYmxlLCBleHRlcm5hbFJlY3QsIHNuYXBSZW5kZXJUaHJlc2hvbGQsIHNuYXBSZW5kZXJUaHJlc2hvbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbmFwSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoc25hcEluZm8pIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNhbFBvc0luZm9zID0gc25hcEluZm8udmVydGljYWwucG9zSW5mb3MsIGhvcml6b250YWxQb3NJbmZvcyA9IHNuYXBJbmZvLmhvcml6b250YWwucG9zSW5mb3M7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNuYXBQb3Nlcy5wdXNoLmFwcGx5KHZlcnRpY2FsU25hcFBvc2VzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmVydGljYWxQb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1aWRlbGluZUluZm9zID0gX2EuZ3VpZGVsaW5lSW5mb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1aWRlbGluZUluZm9zLnNvbWUoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZ3VpZGVsaW5lLmhpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvc0luZm8pIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzbmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3NJbmZvLnBvcyxcclxuICAgICAgICAgICAgICAgIH0pOyB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsU25hcFBvc2VzLnB1c2guYXBwbHkoaG9yaXpvbnRhbFNuYXBQb3NlcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGhvcml6b250YWxQb3NJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1aWRlbGluZUluZm9zID0gX2EuZ3VpZGVsaW5lSW5mb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1aWRlbGluZUluZm9zLnNvbWUoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWlkZWxpbmUgPSBfYS5ndWlkZWxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZ3VpZGVsaW5lLmhpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvc0luZm8pIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzbmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3NJbmZvLnBvcyxcclxuICAgICAgICAgICAgICAgIH0pOyB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEd1aWRlbGluZXMucHVzaC5hcHBseSh2ZXJ0aWNhbEd1aWRlbGluZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChnZXRTbmFwR3VpZGVsaW5lcyh2ZXJ0aWNhbFBvc0luZm9zKSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsR3VpZGVsaW5lcy5wdXNoLmFwcGx5KGhvcml6b250YWxHdWlkZWxpbmVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0U25hcEd1aWRlbGluZXMoaG9yaXpvbnRhbFBvc0luZm9zKSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2MgPSBhZGRCb3VuZEd1aWRlbGluZXMobW92ZWFibGUsIFtsZWZ0LCByaWdodF0sIFt0b3AsIGJvdHRvbV0sIHZlcnRpY2FsU25hcFBvc2VzLCBob3Jpem9udGFsU25hcFBvc2VzKSwgYm91bmRNYXAgPSBfYy5ib3VuZE1hcCwgaW5uZXJCb3VuZE1hcCA9IF9jLmlubmVyQm91bmRNYXA7XHJcbiAgICAgICAgaWYgKGhhc0V4dGVybmFsUG9zZXMpIHtcclxuICAgICAgICAgICAgYWRkQm91bmRHdWlkZWxpbmVzKG1vdmVhYmxlLCBbZXh0ZXJuYWxSZWN0LmxlZnQsIGV4dGVybmFsUmVjdC5yaWdodF0sIFtleHRlcm5hbFJlY3QudG9wLCBleHRlcm5hbFJlY3QuYm90dG9tXSwgdmVydGljYWxTbmFwUG9zZXMsIGhvcml6b250YWxTbmFwUG9zZXMsIHNuYXBSZW5kZXJJbmZvLmV4dGVybmFsQm91bmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbEd1aWRlbGluZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh2ZXJ0aWNhbEd1aWRlbGluZXMpLCBmYWxzZSksIF9fcmVhZChob3Jpem9udGFsR3VpZGVsaW5lcyksIGZhbHNlKTtcclxuICAgICAgICB2YXIgZWxlbWVudEd1aWRlbGluZXMgPSBhbGxHdWlkZWxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZ3VpZGVsaW5lKSB7IHJldHVybiBndWlkZWxpbmUuZWxlbWVudCAmJiAhZ3VpZGVsaW5lLmdhcFJlY3RzOyB9KTtcclxuICAgICAgICB2YXIgZ2FwR3VpZGVsaW5lcyA9IGFsbEd1aWRlbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChndWlkZWxpbmUpIHsgcmV0dXJuIGd1aWRlbGluZS5nYXBSZWN0czsgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5nYXAgLSBiLmdhcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TbmFwXCIsIHtcclxuICAgICAgICAgICAgZ3VpZGVsaW5lczogYWxsR3VpZGVsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudEd1aWRlbGluZXMsXHJcbiAgICAgICAgICAgIGdhcHM6IGdhcEd1aWRlbGluZXMsXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIG5leHRCb3VuZE1hcCA9IHdhdGNoVmFsdWUobW92ZWFibGUsIFwiYm91bmRNYXBcIiwgYm91bmRNYXAsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsgfSwgZ2V0SW5pdGlhbEJvdW5kcygpKTtcclxuICAgICAgICB2YXIgbmV4dElubmVyQm91bmRNYXAgPSB3YXRjaFZhbHVlKG1vdmVhYmxlLCBcImlubmVyQm91bmRNYXBcIiwgaW5uZXJCb3VuZE1hcCwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpOyB9LCBnZXRJbml0aWFsQm91bmRzKCkpO1xyXG4gICAgICAgIGlmIChib3VuZE1hcCA9PT0gbmV4dEJvdW5kTWFwIHx8IGlubmVyQm91bmRNYXAgPT09IG5leHRJbm5lckJvdW5kTWFwKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJvdW5kXCIsIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kczogYm91bmRNYXAsXHJcbiAgICAgICAgICAgICAgICBpbm5lckJvdW5kczogaW5uZXJCb3VuZE1hcCxcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHZlcnRpY2FsU25hcFBvc2VzLlxyXG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlbmRlckRhc2hlZEd1aWRlbGluZXMobW92ZWFibGUsIGVsZW1lbnRHdWlkZWxpbmVzLCBbbWluTGVmdCwgbWluVG9wXSwgdGFyZ2V0UmVjdCwgUmVhY3QpKSwgZmFsc2UpLCBfX3JlYWQocmVuZGVyR2FwR3VpZGVsaW5lcyhtb3ZlYWJsZSwgZ2FwR3VpZGVsaW5lcywgW21pbkxlZnQsIG1pblRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSksIGZhbHNlKSwgX19yZWFkKHJlbmRlckd1aWRlbGluZXMobW92ZWFibGUsIFwiaG9yaXpvbnRhbFwiLCBob3Jpem9udGFsR3VpZGVsaW5lcywgW3RhcmdldExlZnQsIHRhcmdldFRvcF0sIHRhcmdldFJlY3QsIFJlYWN0KSksIGZhbHNlKSwgX19yZWFkKHJlbmRlckd1aWRlbGluZXMobW92ZWFibGUsIFwidmVydGljYWxcIiwgdmVydGljYWxHdWlkZWxpbmVzLCBbdGFyZ2V0TGVmdCwgdGFyZ2V0VG9wXSwgdGFyZ2V0UmVjdCwgUmVhY3QpKSwgZmFsc2UpLCBfX3JlYWQocmVuZGVyU25hcFBvc2VzKG1vdmVhYmxlLCBcImhvcml6b250YWxcIiwgaG9yaXpvbnRhbFNuYXBQb3NlcywgbWluTGVmdCwgdGFyZ2V0VG9wLCB3aWR0aCwgMCwgUmVhY3QpKSwgZmFsc2UpLCBfX3JlYWQocmVuZGVyU25hcFBvc2VzKG1vdmVhYmxlLCBcInZlcnRpY2FsXCIsIHZlcnRpY2FsU25hcFBvc2VzLCBtaW5Ub3AsIHRhcmdldExlZnQsIGhlaWdodCwgMSwgUmVhY3QpKSwgZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxyXG4gICAgICAgICAgICBzbmFwOiB0cnVlLFxyXG4gICAgICAgICAgICBjZW50ZXI6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGVja1NuYXBJbmZvKG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICBpZiAoIWNoZWNrU25hcEluZm8obW92ZWFibGUpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmd1aWRlbGluZXMgPSBnZXRUb3RhbEd1aWRlbGluZXMobW92ZWFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuc25hcFJlbmRlckluZm8pIHtcclxuICAgICAgICAgICAgc3RhdGUuc25hcFJlbmRlckluZm8ucmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcGluY2hTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25Db25kaXRpb24kMShtb3ZlYWJsZSwgZSkgfHwgZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWUuaXNSZXF1ZXN0ICYmIGUuaW5wdXRFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZS5pbnB1dEV2ZW50LnRhcmdldCwgcHJlZml4KFwic25hcC1jb250cm9sXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsO1xyXG4gICAgICAgIGNoZWNrU25hcEluZm8obW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB0aGlzLmRyYWcobW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnKG1vdmVhYmxlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHRoaXMudW5zZXQobW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsO1xyXG4gICAgICAgIGNoZWNrU25hcEluZm8obW92ZWFibGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHRoaXMuZHJhZyhtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG4gICAgdW5zZXQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHN0YXRlLmVuYWJsZVNuYXAgPSBmYWxzZTtcclxuICAgICAgICBzdGF0ZS5ndWlkZWxpbmVzID0gW107XHJcbiAgICAgICAgc3RhdGUuc25hcFJlbmRlckluZm8gPSBudWxsO1xyXG4gICAgICAgIHN0YXRlLmVsZW1lbnRSZWN0cyA9IFtdO1xyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRhcmdldCBjYW4gYmUgc25hcHBlZCB0byB0aGUgZ3VpZGVsaW5lLiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwcGFibGVcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5zbmFwcGFibGUgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqICBBIHNuYXAgY29udGFpbmVyIHRoYXQgaXMgdGhlIGJhc2lzIGZvciBzbmFwLCBib3VuZHMsIGFuZCBpbm5lckJvdW5kcy4gKGRlZmF1bHQ6IG51bGwgPSBjb250YWluZXIpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwQ29udGFpbmVyXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmNvbnRhaW5lclwiKSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnNuYXBDb250YWluZXIgPSBkb2N1bWVudC5ib2R5O1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgZGlyZWN0aW9ucyB0byBzbmFwIHRvIHRoZSB0YXJnZXQuIChkZWZhdWx0OiB7IGxlZnQ6IHRydWUsIHRvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSB9KVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcERpcmVjdGlvbnNcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICBzbmFwcGFibGU6IHRydWUsXHJcbiAqICAgc25hcERpcmVjdGlvbnM6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiAvLyBzbmFwIGNlbnRlclxyXG4gKiBtb3ZlYWJsZS5zbmFwRGlyZWN0aW9ucyA9IHsgbGVmdDogdHJ1ZSwgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBjZW50ZXI6IHRydWUsIG1pZGRsZTogdHJ1ZSB9O1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgc25hcCBkaXJlY3Rpb25zIG9mIGVsZW1lbnRzLiAoZGVmYXVsdDogeyBsZWZ0OiB0cnVlLCBmdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSB9KVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjZWxlbWVudFNuYXBEaXJlY3Rpb25zXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgc25hcHBhYmxlOiB0cnVlLFxyXG4gKiAgIGVsZW1lbnRTbmFwRGlyZWN0aW9uczogdHJ1ZSxcclxuICogfSk7XHJcbiAqIC8vIHNuYXAgY2VudGVyXHJcbiAqIG1vdmVhYmxlLmVsZW1lbnRTbmFwRGlyZWN0aW9ucyA9IHsgbGVmdDogdHJ1ZSwgdG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBjZW50ZXI6IHRydWUsIG1pZGRsZTogdHJ1ZSB9O1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4geW91IGRyYWcsIG1ha2UgdGhlIGdhcCBzbmFwIGluIHRoZSBlbGVtZW50IGd1aWRlbGluZXMuIChkZWZhdWx0OiB0cnVlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcEdhcFxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIHNuYXBwYWJsZTogdHJ1ZSxcclxuICogICBzbmFwRWxlbWVudDogdHJ1ZSxcclxuICogICBzbmFwR2FwOiB0cnVlLFxyXG4gKiB9KTtcclxuICpcclxuICogbW92ZWFibGUuc25hcEdhcCA9IGZhbHNlO1xyXG4gKi9cclxuLyoqXHJcbiAqIERpc3RhbmNlIHZhbHVlIHRoYXQgY2FuIHNuYXAgdG8gZ3VpZGVsaW5lcy4gKGRlZmF1bHQ6IDUpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwVGhyZXNob2xkXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuc25hcFRocmVzaG9sZCA9IDU7XHJcbiAqL1xyXG4vKipcclxuICogQWRkIGd1aWRlbGluZXMgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLiAoZGVmYXVsdDogW10pXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNob3Jpem9udGFsR3VpZGVsaW5lc1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmhvcml6b250YWxHdWlkZWxpbmVzID0gWzEwMCwgMjAwLCA1MDBdO1xyXG4gKi9cclxuLyoqXHJcbiAqIEFkZCBndWlkZWxpbmVzIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uIChkZWZhdWx0OiBbXSlcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3ZlcnRpY2FsR3VpZGVsaW5lc1xyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnZlcnRpY2FsR3VpZGVsaW5lcyA9IFsxMDAsIDIwMCwgNTAwXTtcclxuICovXHJcbi8qKlxyXG4gKiBBZGQgZ3VpZGVsaW5lcyBmb3IgdGhlIGVsZW1lbnQuIChkZWZhdWx0OiBbXSlcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI2VsZW1lbnRHdWlkZWxpbmVzXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5TbmFwcGFibGUuaHRtbCMuU25hcHBhYmxlT3B0aW9uc31cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuZWxlbWVudEd1aWRlbGluZXMgPSBbXHJcbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5lbGVtZW50XCIpLFxyXG4gKiBdO1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gc2V0IHVwIGJvdW5kYXJpZXMuXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNib3VuZHNcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZGVmYXVsdCBudWxsXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmJvdW5kcyA9IHsgbGVmdDogMCwgcmlnaHQ6IDEwMDAsIHRvcDogMCwgYm90dG9tOiAxMDAwfTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIHNldCB1cCBpbm5lciBib3VuZGFyaWVzLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjaW5uZXJCb3VuZHNcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZGVmYXVsdCBudWxsXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmlubmVyQm91bmRzID0geyBsZWZ0OiA1MDAsIHRvcDogNTAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH07XHJcbiAqL1xyXG4vKipcclxuICogc25hcCBkaXN0YW5jZSBkaWdpdHMgKGRlZmF1bHQ6IDApXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwRGlnaXRcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5zbmFwRGlnaXQgPSAwXHJcbiAqL1xyXG4vKipcclxuICogSWYgd2lkdGggc2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgeW91IGNhbiB2ZXJ0aWNhbCBzbmFwIHRvIHRoZSBncmlkLiAoZGVmYXVsdDogMClcclxuICogQG5hbWUgTW92ZWFibGUuU25hcHBhYmxlI3NuYXBHcmlkV2lkdGhcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5zbmFwR3JpZFdpZHRoID0gNTtcclxuICovXHJcbi8qKlxyXG4gKiBJZiBoZWlnaHQgc2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgeW91IGNhbiBob3Jpem9udGFsIHNuYXAgdG8gdGhlIGdyaWQuIChkZWZhdWx0OiAwKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjc25hcEdyaWRIZWlnaHRcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5zbmFwR3JpZEhlaWdodCA9IDU7XHJcbiAqL1xyXG4vKipcclxuICogV2hldGhlciB0byBzaG93IHNuYXAgZGlzdGFuY2UgKGRlZmF1bHQ6IHRydWUpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNpc0Rpc3BsYXlTbmFwRGlnaXRcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5pc0Rpc3BsYXlTbmFwRGlnaXQgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gc2hvdyBlbGVtZW50IGlubmVyIHNuYXAgZGlzdGFuY2UgKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TbmFwcGFibGUjaXNEaXNwbGF5SW5uZXJTbmFwRGlnaXRcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLlNuYXBwYWJsZS5odG1sIy5TbmFwcGFibGVPcHRpb25zfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS5pc0Rpc3BsYXlJbm5lclNuYXBEaWdpdCA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogWW91IGNhbiBzZXQgdGhlIHRleHQgZm9ybWF0IG9mIHRoZSBkaXN0YW5jZSBzaG93biBpbiB0aGUgZ3VpZGVsaW5lcy4gKGRlZmF1bHQ6IHNlbGYpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNuYXBwYWJsZSNzbmFwRGlzdEZvcm1hdFxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU25hcHBhYmxlLmh0bWwjLlNuYXBwYWJsZU9wdGlvbnN9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgc25hcHBhYmxlOiB0cnVlLFxyXG4gKiAgc25hcERpc3RGb3JtYXQ6ICh2LCB0eXBlKSA9PiB2LFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUuc25hcERpc3RGb3JtYXQgPSAodiwgdHlwZSkgPT4gYCR7dn1weGA7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB5b3UgZHJhZyBvciBkcmFnQ29udHJvbCwgdGhlIGBzbmFwYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TbmFwcGFibGVcclxuICogQGV2ZW50IHNuYXBcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TbmFwcGFibGUuT25TbmFwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc25hcGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBzbmFwcGFibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic25hcFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25TbmFwXCIsIGUpO1xyXG4gKiB9KTtcclxuICovXG5cbmZ1bmN0aW9uIG11bHRpcGx5Mihwb3MxLCBwb3MyKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHBvczFbMF0gKiBwb3MyWzBdLFxyXG4gICAgICAgIHBvczFbMV0gKiBwb3MyWzFdLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBwcmVmaXgoKSB7XHJcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBjbGFzc05hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJlZml4TmFtZXMuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtQUkVGSVhdLCBfX3JlYWQoY2xhc3NOYW1lcyksIGZhbHNlKSk7XHJcbn1cclxuZnVuY3Rpb24gZGVmYXVsdFN5bmMoZm4pIHtcclxuICAgIGZuKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtTWF0cml4KHRyYW5zZm9ybSkge1xyXG4gICAgaWYgKCF0cmFuc2Zvcm0gfHwgdHJhbnNmb3JtID09PSBcIm5vbmVcIikge1xyXG4gICAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMF07XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYmplY3QodHJhbnNmb3JtKSkge1xyXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyc2VNYXQodHJhbnNmb3JtKTtcclxufVxyXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZU1hdHJpeChtYXRyaXgsIG4sIG9yaWdpbikge1xyXG4gICAgcmV0dXJuIG11bHRpcGxpZXMobiwgY3JlYXRlT3JpZ2luTWF0cml4KG9yaWdpbiwgbiksIG1hdHJpeCwgY3JlYXRlT3JpZ2luTWF0cml4KG9yaWdpbi5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC1hOyB9KSwgbikpO1xyXG59XHJcbmZ1bmN0aW9uIG1lYXN1cmVTVkdTaXplKGVsLCB1bml0LCBpc0hvcml6b250YWwpIHtcclxuICAgIGlmICh1bml0ID09PSBcIiVcIikge1xyXG4gICAgICAgIHZhciB2aWV3Qm94ID0gZ2V0U1ZHVmlld0JveChlbC5vd25lclNWR0VsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB2aWV3Qm94W2lzSG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIC8gMTAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDE7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmVmb3JlVHJhbnNmb3JtT3JpZ2luKGVsKSB7XHJcbiAgICB2YXIgcmVsYXRpdmVPcmlnaW4gPSBnZXRUcmFuc2Zvcm1PcmlnaW4oZ2V0Q29tcHV0ZWRTdHlsZShlbCwgXCI6YmVmb3JlXCIpKTtcclxuICAgIHJldHVybiByZWxhdGl2ZU9yaWdpbi5tYXAoZnVuY3Rpb24gKG8sIGkpIHtcclxuICAgICAgICB2YXIgX2EgPSBzcGxpdFVuaXQobyksIHZhbHVlID0gX2EudmFsdWUsIHVuaXQgPSBfYS51bml0O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAqIG1lYXN1cmVTVkdTaXplKGVsLCB1bml0LCBpID09PSAwKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zZm9ybU9yaWdpbkFycmF5KHRyYW5zZm9ybU9yaWdpbikge1xyXG4gICAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpbiA/IHRyYW5zZm9ybU9yaWdpbi5zcGxpdChcIiBcIikgOiBbXCIwXCIsIFwiMFwiXTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PcmlnaW4oc3R5bGUpIHtcclxuICAgIHJldHVybiBnZXRUcmFuc2Zvcm1PcmlnaW5BcnJheShzdHlsZS50cmFuc2Zvcm1PcmlnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVsZW1lbnRUcmFuc2Zvcm0odGFyZ2V0KSB7XHJcbiAgICB2YXIgZ2V0U3R5bGUgPSBnZXRDYWNoZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIGNvbXB1dGVkVHJhbnNmb3JtID0gZ2V0U3R5bGUoXCJ0cmFuc2Zvcm1cIik7XHJcbiAgICBpZiAoY29tcHV0ZWRUcmFuc2Zvcm0gJiYgY29tcHV0ZWRUcmFuc2Zvcm0gIT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkVHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgaWYgKFwidHJhbnNmb3JtXCIgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGxpc3QgPSB0YXJnZXQudHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBiYXNlVmFsID0gbGlzdC5iYXNlVmFsO1xyXG4gICAgICAgIGlmICghYmFzZVZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gYmFzZVZhbC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFsZW5ndGhfMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdHJpeGVzID0gW107XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gYmFzZVZhbFtpXS5tYXRyaXg7XHJcbiAgICAgICAgICAgIG1hdHJpeGVzLnB1c2goXCJtYXRyaXgoXCIuY29uY2F0KFtcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJlXCIsIFwiZlwiXS5tYXAoZnVuY3Rpb24gKGNocikgeyByZXR1cm4gbWF0cml4W2Nocl07IH0pLmpvaW4oXCIsIFwiKSwgXCIpXCIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7ICsraSkge1xyXG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0cml4ZXMuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJcIjtcclxufVxyXG5mdW5jdGlvbiBnZXRPZmZzZXRJbmZvKGVsLCBsYXN0UGFyZW50LCBpc1BhcmVudCwgY2hlY2tab29tLCBnZXRUYXJnZXRTdHlsZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQoZWwpIHx8IGdldERvY3VtZW50Qm9keShlbCk7XHJcbiAgICB2YXIgaGFzU2xvdCA9IGZhbHNlO1xyXG4gICAgdmFyIHRhcmdldDtcclxuICAgIHZhciBwYXJlbnRTbG90RWxlbWVudDtcclxuICAgIGlmICghZWwgfHwgaXNQYXJlbnQpIHtcclxuICAgICAgICB0YXJnZXQgPSBlbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBhc3NpZ25lZFNsb3RQYXJlbnRFbGVtZW50ID0gKF9hID0gZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLmFzc2lnbmVkU2xvdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmIChhc3NpZ25lZFNsb3RQYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGhhc1Nsb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBwYXJlbnRTbG90RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IGFzc2lnbmVkU2xvdFBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBwYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBpc0N1c3RvbUVsZW1lbnQgPSBmYWxzZTtcclxuICAgIHZhciBpc0VuZCA9IGVsID09PSBsYXN0UGFyZW50IHx8IHRhcmdldCA9PT0gbGFzdFBhcmVudDtcclxuICAgIHZhciBwb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuICAgIHZhciBvZmZzZXRab29tID0gMTtcclxuICAgIHZhciB0YXJnZXRab29tID0gcGFyc2VGbG9hdChnZXRUYXJnZXRTdHlsZSA9PT0gbnVsbCB8fCBnZXRUYXJnZXRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0VGFyZ2V0U3R5bGUoXCJ6b29tXCIpKSB8fCAxO1xyXG4gICAgdmFyIHRhcmdldFBvc2l0aW9uID0gZ2V0VGFyZ2V0U3R5bGUgPT09IG51bGwgfHwgZ2V0VGFyZ2V0U3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldFRhcmdldFN0eWxlKFwicG9zaXRpb25cIik7XHJcbiAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGxhc3RQYXJlbnQgPT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICBpc0VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBnZXRTdHlsZSA9IGdldENhY2hlZFN0eWxlKHRhcmdldCk7XHJcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRFbGVtZW50VHJhbnNmb3JtKHRhcmdldCk7XHJcbiAgICAgICAgdmFyIHdpbGxDaGFuZ2UgPSBnZXRTdHlsZShcIndpbGxDaGFuZ2VcIik7XHJcbiAgICAgICAgdmFyIHpvb20gPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwiem9vbVwiKSkgfHwgMTtcclxuICAgICAgICBwb3NpdGlvbiA9IGdldFN0eWxlKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgaWYgKGNoZWNrWm9vbSAmJiB6b29tICE9PSAxKSB7XHJcbiAgICAgICAgICAgIG9mZnNldFpvb20gPSB6b29tO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgIC8vIG9mZnNldFBhcmVudCBpcyB0aGUgcGFyZW50RWxlbWVudCBpZiB0aGUgdGFyZ2V0J3Mgem9vbSBpcyBub3QgMSBhbmQgbm90IGFic29sdXRlLlxyXG4gICAgICAgICFpc1BhcmVudCAmJiBjaGVja1pvb20gJiYgdGFyZ2V0Wm9vbSAhPT0gMSAmJiB0YXJnZXRQb3NpdGlvbiAmJiB0YXJnZXRQb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiXHJcbiAgICAgICAgICAgIHx8IHRhZ05hbWUgPT09IFwic3ZnXCJcclxuICAgICAgICAgICAgfHwgdGFnTmFtZSA9PT0gXCJmb3JlaWdub2JqZWN0XCJcclxuICAgICAgICAgICAgfHwgcG9zaXRpb24gIT09IFwic3RhdGljXCJcclxuICAgICAgICAgICAgfHwgKHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0gIT09IFwibm9uZVwiKVxyXG4gICAgICAgICAgICB8fCB3aWxsQ2hhbmdlID09PSBcInRyYW5zZm9ybVwiKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2xvdFBhcmVudE5vZGUgPSAoX2IgPSBlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwuYXNzaWduZWRTbG90KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFyZW50Tm9kZTtcclxuICAgICAgICB2YXIgdGFyZ2V0UGFyZW50Tm9kZSA9IHRhcmdldC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChzbG90UGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBoYXNTbG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcGFyZW50U2xvdEVsZW1lbnQgPSB0YXJnZXRQYXJlbnROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRhcmdldFBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTEpIHtcclxuICAgICAgICAgICAgLy8gU2hhZG93IFJvb3RcclxuICAgICAgICAgICAgdGFyZ2V0ID0gcGFyZW50Tm9kZS5ob3N0O1xyXG4gICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGdldENhY2hlZFN0eWxlKHRhcmdldCkoXCJwb3NpdGlvblwiKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldCA9IHBhcmVudE5vZGU7XHJcbiAgICAgICAgcG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG9mZnNldFpvb206IG9mZnNldFpvb20sXHJcbiAgICAgICAgaGFzU2xvdDogaGFzU2xvdCxcclxuICAgICAgICBwYXJlbnRTbG90RWxlbWVudDogcGFyZW50U2xvdEVsZW1lbnQsXHJcbiAgICAgICAgaXNDdXN0b21FbGVtZW50OiBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgaXNTdGF0aWM6IHBvc2l0aW9uID09PSBcInN0YXRpY1wiLFxyXG4gICAgICAgIGlzRW5kOiBpc0VuZCB8fCAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgIG9mZnNldFBhcmVudDogdGFyZ2V0IHx8IGRvY3VtZW50RWxlbWVudCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0T2Zmc2V0UG9zSW5mbyhlbCwgdGFyZ2V0KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHZhciBvZmZzZXRMZWZ0ID0gZWwub2Zmc2V0TGVmdDtcclxuICAgIHZhciBvZmZzZXRUb3AgPSBlbC5vZmZzZXRUb3A7XHJcbiAgICB2YXIgZ2V0U3R5bGUgPSBnZXRDYWNoZWRTdHlsZShlbCk7XHJcbiAgICAvLyBzdmdcclxuICAgIHZhciBpc1NWRyA9IGlzVW5kZWZpbmVkKG9mZnNldExlZnQpO1xyXG4gICAgdmFyIGhhc09mZnNldCA9ICFpc1NWRztcclxuICAgIHZhciBvcmlnaW47XHJcbiAgICB2YXIgdGFyZ2V0T3JpZ2luO1xyXG4gICAgLy8gaW5uZXIgc3ZnIGVsZW1lbnRcclxuICAgIGlmICghaGFzT2Zmc2V0ICYmICh0YWdOYW1lICE9PSBcInN2Z1wiIHx8IGVsLm93bmVyU1ZHRWxlbWVudCkpIHtcclxuICAgICAgICBvcmlnaW4gPSBJU19XRUJLSVQ2MDVcclxuICAgICAgICAgICAgPyBnZXRCZWZvcmVUcmFuc2Zvcm1PcmlnaW4oZWwpXHJcbiAgICAgICAgICAgIDogZ2V0VHJhbnNmb3JtT3JpZ2luQXJyYXkoZ2V0U3R5bGUoXCJ0cmFuc2Zvcm1PcmlnaW5cIikpLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwYXJzZUZsb2F0KHBvcyk7IH0pO1xyXG4gICAgICAgIHRhcmdldE9yaWdpbiA9IG9yaWdpbi5zbGljZSgpO1xyXG4gICAgICAgIGhhc09mZnNldCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09IFwic3ZnXCIpIHtcclxuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XHJcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfYSA9IF9fcmVhZChnZXRTVkdHcmFwaGljc09mZnNldChlbCwgb3JpZ2luLCBlbCA9PT0gdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSwgNCksIG9mZnNldExlZnQgPSBfYVswXSwgb2Zmc2V0VG9wID0gX2FbMV0sIG9yaWdpblswXSA9IF9hWzJdLCBvcmlnaW5bMV0gPSBfYVszXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvcmlnaW4gPSBnZXRUcmFuc2Zvcm1PcmlnaW5BcnJheShnZXRTdHlsZShcInRyYW5zZm9ybU9yaWdpblwiKSkubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBhcnNlRmxvYXQocG9zKTsgfSk7XHJcbiAgICAgICAgdGFyZ2V0T3JpZ2luID0gb3JpZ2luLnNsaWNlKCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZ2V0U3R5bGUoXCJ0cmFuc2Zvcm1PcmlnaW5cIiksIHRhcmdldE9yaWdpbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXHJcbiAgICAgICAgaXNTVkc6IGlzU1ZHLFxyXG4gICAgICAgIGhhc09mZnNldDogaGFzT2Zmc2V0LFxyXG4gICAgICAgIG9mZnNldDogW29mZnNldExlZnQgfHwgMCwgb2Zmc2V0VG9wIHx8IDBdLFxyXG4gICAgICAgIG9yaWdpbjogb3JpZ2luLFxyXG4gICAgICAgIHRhcmdldE9yaWdpbjogdGFyZ2V0T3JpZ2luLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRCb2R5T2Zmc2V0KGVsLCBpc1NWRykge1xyXG4gICAgdmFyIGdldFN0eWxlID0gZ2V0Q2FjaGVkU3R5bGUoZWwpO1xyXG4gICAgdmFyIGdldEJvZHlTdHlsZSA9IGdldENhY2hlZFN0eWxlKGdldERvY3VtZW50Qm9keShlbCkpO1xyXG4gICAgdmFyIGJvZHlQb3NpdGlvbiA9IGdldEJvZHlTdHlsZShcInBvc2l0aW9uXCIpO1xyXG4gICAgaWYgKCFpc1NWRyAmJiAoIWJvZHlQb3NpdGlvbiB8fCBib2R5UG9zaXRpb24gPT09IFwic3RhdGljXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcclxuICAgIH1cclxuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VJbnQoZ2V0Qm9keVN0eWxlKFwibWFyZ2luTGVmdFwiKSwgMTApO1xyXG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlSW50KGdldEJvZHlTdHlsZShcIm1hcmdpblRvcFwiKSwgMTApO1xyXG4gICAgaWYgKGdldFN0eWxlKFwicG9zaXRpb25cIikgPT09IFwiYWJzb2x1dGVcIikge1xyXG4gICAgICAgIGlmIChnZXRTdHlsZShcInRvcFwiKSAhPT0gXCJhdXRvXCIgfHwgZ2V0U3R5bGUoXCJib3R0b21cIikgIT09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgIG1hcmdpblRvcCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRTdHlsZShcImxlZnRcIikgIT09IFwiYXV0b1wiIHx8IGdldFN0eWxlKFwicmlnaHRcIikgIT09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbbWFyZ2luTGVmdCwgbWFyZ2luVG9wXTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0M0RNYXRyaXhlcyhtYXRyaXhlcykge1xyXG4gICAgbWF0cml4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBpbmZvLm1hdHJpeDtcclxuICAgICAgICBpZiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgIGluZm8ubWF0cml4ID0gY29udmVydERpbWVuc2lvbihtYXRyaXgsIDMsIDQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uRml4ZWRJbmZvKGVsKSB7XHJcbiAgICB2YXIgZml4ZWRDb250YWluZXIgPSBlbC5wYXJlbnRFbGVtZW50O1xyXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xyXG4gICAgdmFyIGJvZHkgPSBnZXREb2N1bWVudEJvZHkoZWwpO1xyXG4gICAgd2hpbGUgKGZpeGVkQ29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldENvbXB1dGVkU3R5bGUoZml4ZWRDb250YWluZXIpLnRyYW5zZm9ybTtcclxuICAgICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybSAhPT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgaGFzVHJhbnNmb3JtID0gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXhlZENvbnRhaW5lciA9PT0gYm9keSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZml4ZWRDb250YWluZXIgPSBmaXhlZENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaXhlZENvbnRhaW5lcjogZml4ZWRDb250YWluZXIgfHwgYm9keSxcclxuICAgICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWFrZU1hdHJpeENTUyhtYXRyaXgsIGlzM2QpIHtcclxuICAgIGlmIChpczNkID09PSB2b2lkIDApIHsgaXMzZCA9IG1hdHJpeC5sZW5ndGggPiA5OyB9XHJcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoaXMzZCA/IFwibWF0cml4M2RcIiA6IFwibWF0cml4XCIsIFwiKFwiKS5jb25jYXQoY29udmVydE1hdHJpeHRvQ1NTKG1hdHJpeCwgIWlzM2QpLmpvaW4oXCIsXCIpLCBcIilcIik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U1ZHVmlld0JveChlbCkge1xyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gZWwuY2xpZW50V2lkdGg7XHJcbiAgICB2YXIgY2xpZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xyXG4gICAgaWYgKCFlbCkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGNsaWVudFdpZHRoOiBjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjbGllbnRIZWlnaHQgfTtcclxuICAgIH1cclxuICAgIHZhciB2aWV3Qm94ID0gZWwudmlld0JveDtcclxuICAgIHZhciBiYXNlVmFsID0gKHZpZXdCb3ggJiYgdmlld0JveC5iYXNlVmFsKSB8fCB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogYmFzZVZhbC54LFxyXG4gICAgICAgIHk6IGJhc2VWYWwueSxcclxuICAgICAgICB3aWR0aDogYmFzZVZhbC53aWR0aCB8fCBjbGllbnRXaWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGJhc2VWYWwuaGVpZ2h0IHx8IGNsaWVudEhlaWdodCxcclxuICAgICAgICBjbGllbnRXaWR0aDogY2xpZW50V2lkdGgsXHJcbiAgICAgICAgY2xpZW50SGVpZ2h0OiBjbGllbnRIZWlnaHQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNWR01hdHJpeChlbCwgbikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIF9iID0gZ2V0U1ZHVmlld0JveChlbCksIHZpZXdCb3hXaWR0aCA9IF9iLndpZHRoLCB2aWV3Qm94SGVpZ2h0ID0gX2IuaGVpZ2h0LCBjbGllbnRXaWR0aCA9IF9iLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSBfYi5jbGllbnRIZWlnaHQ7XHJcbiAgICB2YXIgc2NhbGVYID0gY2xpZW50V2lkdGggLyB2aWV3Qm94V2lkdGg7XHJcbiAgICB2YXIgc2NhbGVZID0gY2xpZW50SGVpZ2h0IC8gdmlld0JveEhlaWdodDtcclxuICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZWwucHJlc2VydmVBc3BlY3RSYXRpby5iYXNlVmFsO1xyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9wcmVzZXJ2ZUFzcGVjdFJhdGlvXHJcbiAgICB2YXIgYWxpZ24gPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduO1xyXG4gICAgLy8gMSA6IG1lZXQgMjogc2xpY2VcclxuICAgIHZhciBtZWV0T3JTbGljZSA9IHByZXNlcnZlQXNwZWN0UmF0aW8ubWVldE9yU2xpY2U7XHJcbiAgICB2YXIgc3ZnT3JpZ2luID0gWzAsIDBdO1xyXG4gICAgdmFyIHNjYWxlID0gW3NjYWxlWCwgc2NhbGVZXTtcclxuICAgIHZhciB0cmFuc2xhdGUgPSBbMCwgMF07XHJcbiAgICBpZiAoYWxpZ24gIT09IDEpIHtcclxuICAgICAgICB2YXIgeEFsaWduID0gKGFsaWduIC0gMikgJSAzO1xyXG4gICAgICAgIHZhciB5QWxpZ24gPSBNYXRoLmZsb29yKChhbGlnbiAtIDIpIC8gMyk7XHJcbiAgICAgICAgc3ZnT3JpZ2luWzBdID0gdmlld0JveFdpZHRoICogeEFsaWduIC8gMjtcclxuICAgICAgICBzdmdPcmlnaW5bMV0gPSB2aWV3Qm94SGVpZ2h0ICogeUFsaWduIC8gMjtcclxuICAgICAgICB2YXIgc2NhbGVEaW1lbnNpb24gPSBtZWV0T3JTbGljZSA9PT0gMiA/IE1hdGgubWF4KHNjYWxlWSwgc2NhbGVYKSA6IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTtcclxuICAgICAgICBzY2FsZVswXSA9IHNjYWxlRGltZW5zaW9uO1xyXG4gICAgICAgIHNjYWxlWzFdID0gc2NhbGVEaW1lbnNpb247XHJcbiAgICAgICAgdHJhbnNsYXRlWzBdID0gKGNsaWVudFdpZHRoIC0gdmlld0JveFdpZHRoKSAvIDIgKiB4QWxpZ247XHJcbiAgICAgICAgdHJhbnNsYXRlWzFdID0gKGNsaWVudEhlaWdodCAtIHZpZXdCb3hIZWlnaHQpIC8gMiAqIHlBbGlnbjtcclxuICAgIH1cclxuICAgIHZhciBzY2FsZU1hdHJpeCA9IGNyZWF0ZVNjYWxlTWF0cml4KHNjYWxlLCBuKTtcclxuICAgIF9hID0gX19yZWFkKHRyYW5zbGF0ZSwgMiksIHNjYWxlTWF0cml4W24gKiAobiAtIDEpXSA9IF9hWzBdLCBzY2FsZU1hdHJpeFtuICogKG4gLSAxKSArIDFdID0gX2FbMV07XHJcbiAgICByZXR1cm4gZ2V0QWJzb2x1dGVNYXRyaXgoc2NhbGVNYXRyaXgsIG4sIHN2Z09yaWdpbik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U1ZHR3JhcGhpY3NPZmZzZXQoZWwsIG9yaWdpbiwgaXNHVGFyZ2V0KSB7XHJcbiAgICB2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmICghZWwuZ2V0QkJveCB8fCAhaXNHVGFyZ2V0ICYmIHRhZ05hbWUgPT09IFwiZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcclxuICAgIH1cclxuICAgIHZhciBnZXRTdHlsZSA9IGdldENhY2hlZFN0eWxlKGVsKTtcclxuICAgIHZhciBpc0ZpbGxCb3ggPSBnZXRTdHlsZShcInRyYW5zZm9ybS1ib3hcIikgPT09IFwiZmlsbC1ib3hcIjtcclxuICAgIHZhciBiYm94ID0gZWwuZ2V0QkJveCgpO1xyXG4gICAgdmFyIHZpZXdCb3ggPSBnZXRTVkdWaWV3Qm94KGVsLm93bmVyU1ZHRWxlbWVudCk7XHJcbiAgICB2YXIgeCA9IGJib3gueDtcclxuICAgIHZhciB5ID0gYmJveC55O1xyXG4gICAgLy8geCwgeeqwgCAw7Jy866GcIOuCmO2DgOuCmOuKlCDrsoTqt7hcclxuICAgIGlmICh0YWdOYW1lID09PSBcImZvcmVpZ25vYmplY3RcIiAmJiAoIXggJiYgIXkpKSB7XHJcbiAgICAgICAgeCA9IHBhcnNlRmxvYXQoZWwuZ2V0QXR0cmlidXRlKFwieFwiKSkgfHwgMDtcclxuICAgICAgICB5ID0gcGFyc2VGbG9hdChlbC5nZXRBdHRyaWJ1dGUoXCJ5XCIpKSB8fCAwO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlZnQgPSB4IC0gdmlld0JveC54O1xyXG4gICAgdmFyIHRvcCA9IHkgLSB2aWV3Qm94Lnk7XHJcbiAgICB2YXIgb3JpZ2luWCA9IGlzRmlsbEJveCA/IG9yaWdpblswXSA6IG9yaWdpblswXSAtIGxlZnQ7XHJcbiAgICB2YXIgb3JpZ2luWSA9IGlzRmlsbEJveCA/IG9yaWdpblsxXSA6IG9yaWdpblsxXSAtIHRvcDtcclxuICAgIC8vIGlmIChpc0ZpbGxCb3gpIHtcclxuICAgIC8vICAgICBjb25zdCBiYm94ID0gKGVsIGFzIFNWR0dyYXBoaWNzRWxlbWVudCkuZ2V0QkJveCgpO1xyXG4gICAgLy8gICAgIGNvbnN0IHggPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwieFwiKSkgfHwgYmJveC54O1xyXG4gICAgLy8gICAgIGNvbnN0IHkgPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwieVwiKSkgfHwgYmJveC55O1xyXG4gICAgLy8gICAgIGNvbnN0IHhTY2FsZSA9IGJib3gueCAvIHg7XHJcbiAgICAvLyAgICAgY29uc3QgeVNjYWxlID0gYmJveC55IC8geTtcclxuICAgIC8vICAgICBjb25zb2xlLmxvZyh4LCB5KTtcclxuICAgIC8vICAgICBvcmlnaW5YICo9IHhTY2FsZTtcclxuICAgIC8vICAgICBvcmlnaW5ZICo9IHlTY2FsZTtcclxuICAgIC8vIH1cclxuICAgIHJldHVybiBbbGVmdCwgdG9wLCBvcmlnaW5YLCBvcmlnaW5ZXTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIHBvcywgbikge1xyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZShtYXRyaXgsIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChwb3MsIG4pLCBuKTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NlcyhtYXRyaXgsIHdpZHRoLCBoZWlnaHQsIG4pIHtcclxuICAgIHJldHVybiBbWzAsIDBdLCBbd2lkdGgsIDBdLCBbMCwgaGVpZ2h0XSwgW3dpZHRoLCBoZWlnaHRdXS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBwb3MsIG4pOyB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRSZWN0KHBvc2VzKSB7XHJcbiAgICB2YXIgcG9zZXNYID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1swXTsgfSk7XHJcbiAgICB2YXIgcG9zZXNZID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1sxXTsgfSk7XHJcbiAgICB2YXIgbGVmdCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlc1gpLCBmYWxzZSkpO1xyXG4gICAgdmFyIHRvcCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlc1kpLCBmYWxzZSkpO1xyXG4gICAgdmFyIHJpZ2h0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBvc2VzWCksIGZhbHNlKSk7XHJcbiAgICB2YXIgYm90dG9tID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBvc2VzWSksIGZhbHNlKSk7XHJcbiAgICB2YXIgcmVjdFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xyXG4gICAgdmFyIHJlY3RIZWlnaHQgPSBib3R0b20gLSB0b3A7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxyXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgICAgIHdpZHRoOiByZWN0V2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiByZWN0SGVpZ2h0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVSZWN0KG1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbikge1xyXG4gICAgdmFyIHBvc2VzID0gY2FsY3VsYXRlUG9zZXMobWF0cml4LCB3aWR0aCwgaGVpZ2h0LCBuKTtcclxuICAgIHJldHVybiBnZXRSZWN0KHBvc2VzKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTVkdPZmZzZXQob2Zmc2V0SW5mbywgdGFyZ2V0SW5mbywgY29udGFpbmVyLCBuLCBiZWZvcmVNYXRyaXgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciB0YXJnZXQgPSBvZmZzZXRJbmZvLnRhcmdldDtcclxuICAgIHZhciBvcmlnaW4gPSBvZmZzZXRJbmZvLm9yaWdpbjtcclxuICAgIHZhciB0YXJnZXRNYXRyaXggPSB0YXJnZXRJbmZvLm1hdHJpeDtcclxuICAgIHZhciBfYiA9IGdldFNpemUodGFyZ2V0KSwgd2lkdGggPSBfYi5vZmZzZXRXaWR0aCwgaGVpZ2h0ID0gX2Iub2Zmc2V0SGVpZ2h0O1xyXG4gICAgdmFyIGNvbnRhaW5lckNsaWVudFJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgbWFyZ2luID0gWzAsIDBdO1xyXG4gICAgaWYgKGNvbnRhaW5lciA9PT0gZ2V0RG9jdW1lbnRCb2R5KGNvbnRhaW5lcikpIHtcclxuICAgICAgICBtYXJnaW4gPSBnZXRCb2R5T2Zmc2V0KHRhcmdldCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciByZWN0TGVmdCA9IHJlY3QubGVmdCAtIGNvbnRhaW5lckNsaWVudFJlY3QubGVmdCArIGNvbnRhaW5lci5zY3JvbGxMZWZ0XHJcbiAgICAgICAgLSAoY29udGFpbmVyLmNsaWVudExlZnQgfHwgMCkgKyBtYXJnaW5bMF07XHJcbiAgICB2YXIgcmVjdFRvcCA9IHJlY3QudG9wIC0gY29udGFpbmVyQ2xpZW50UmVjdC50b3AgKyBjb250YWluZXIuc2Nyb2xsVG9wXHJcbiAgICAgICAgLSAoY29udGFpbmVyLmNsaWVudFRvcCB8fCAwKSArIG1hcmdpblsxXTtcclxuICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgIHZhciBtYXQgPSBtdWx0aXBsaWVzKG4sIGJlZm9yZU1hdHJpeCwgdGFyZ2V0TWF0cml4KTtcclxuICAgIHZhciBfYyA9IGNhbGN1bGF0ZVJlY3QobWF0LCB3aWR0aCwgaGVpZ2h0LCBuKSwgcHJldkxlZnQgPSBfYy5sZWZ0LCBwcmV2VG9wID0gX2MudG9wLCBwcmV2V2lkdGggPSBfYy53aWR0aCwgcHJldkhlaWdodCA9IF9jLmhlaWdodDtcclxuICAgIHZhciBwb3NPcmlnaW4gPSBjYWxjdWxhdGVQb3NpdGlvbihtYXQsIG9yaWdpbiwgbik7XHJcbiAgICB2YXIgcHJldk9yaWdpbiA9IG1pbnVzKHBvc09yaWdpbiwgW3ByZXZMZWZ0LCBwcmV2VG9wXSk7XHJcbiAgICB2YXIgcmVjdE9yaWdpbiA9IFtcclxuICAgICAgICByZWN0TGVmdCArIHByZXZPcmlnaW5bMF0gKiByZWN0V2lkdGggLyBwcmV2V2lkdGgsXHJcbiAgICAgICAgcmVjdFRvcCArIHByZXZPcmlnaW5bMV0gKiByZWN0SGVpZ2h0IC8gcHJldkhlaWdodCxcclxuICAgIF07XHJcbiAgICB2YXIgb2Zmc2V0ID0gWzAsIDBdO1xyXG4gICAgdmFyIGNvdW50ID0gMDtcclxuICAgIHdoaWxlICgrK2NvdW50IDwgMTApIHtcclxuICAgICAgICB2YXIgaW52ZXJzZUJlZm9yZU1hdHJpeCA9IGludmVydChiZWZvcmVNYXRyaXgsIG4pO1xyXG4gICAgICAgIF9hID0gX19yZWFkKG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGludmVyc2VCZWZvcmVNYXRyaXgsIHJlY3RPcmlnaW4sIG4pLCBjYWxjdWxhdGVQb3NpdGlvbihpbnZlcnNlQmVmb3JlTWF0cml4LCBwb3NPcmlnaW4sIG4pKSwgMiksIG9mZnNldFswXSA9IF9hWzBdLCBvZmZzZXRbMV0gPSBfYVsxXTtcclxuICAgICAgICB2YXIgbWF0MiA9IG11bHRpcGxpZXMobiwgYmVmb3JlTWF0cml4LCBjcmVhdGVPcmlnaW5NYXRyaXgob2Zmc2V0LCBuKSwgdGFyZ2V0TWF0cml4KTtcclxuICAgICAgICB2YXIgX2QgPSBjYWxjdWxhdGVSZWN0KG1hdDIsIHdpZHRoLCBoZWlnaHQsIG4pLCBuZXh0TGVmdCA9IF9kLmxlZnQsIG5leHRUb3AgPSBfZC50b3A7XHJcbiAgICAgICAgdmFyIGRpc3RMZWZ0ID0gbmV4dExlZnQgLSByZWN0TGVmdDtcclxuICAgICAgICB2YXIgZGlzdFRvcCA9IG5leHRUb3AgLSByZWN0VG9wO1xyXG4gICAgICAgIGlmIChhYnMoZGlzdExlZnQpIDwgMiAmJiBhYnMoZGlzdFRvcCkgPCAyKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWN0T3JpZ2luWzBdIC09IGRpc3RMZWZ0O1xyXG4gICAgICAgIHJlY3RPcmlnaW5bMV0gLT0gZGlzdFRvcDtcclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBNYXRoLnJvdW5kKHApOyB9KTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVNb3ZlYWJsZUNsaWVudFBvc2l0aW9ucyhyb290TWF0cml4LCBwb3Nlcywgcm9vdENsaWVudFJlY3QpIHtcclxuICAgIHZhciBpczNkID0gcm9vdE1hdHJpeC5sZW5ndGggPT09IDE2O1xyXG4gICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICB2YXIgcm9vdFBvc2VzID0gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIGNhbGN1bGF0ZVBvc2l0aW9uKHJvb3RNYXRyaXgsIHBvcywgbik7IH0pO1xyXG4gICAgdmFyIGxlZnQgPSByb290Q2xpZW50UmVjdC5sZWZ0LCB0b3AgPSByb290Q2xpZW50UmVjdC50b3A7XHJcbiAgICByZXR1cm4gcm9vdFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIFtwb3NbMF0gKyBsZWZ0LCBwb3NbMV0gKyB0b3BdO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlzdFNpemUodmVjKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY1swXSAqIHZlY1swXSArIHZlY1sxXSAqIHZlY1sxXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlhZ29uYWxTaXplKHBvczEsIHBvczIpIHtcclxuICAgIHJldHVybiBnZXREaXN0U2l6ZShbXHJcbiAgICAgICAgcG9zMlswXSAtIHBvczFbMF0sXHJcbiAgICAgICAgcG9zMlsxXSAtIHBvczFbMV0sXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBnZXRMaW5lU3R5bGUocG9zMSwgcG9zMiwgem9vbSwgcmFkKSB7XHJcbiAgICBpZiAoem9vbSA9PT0gdm9pZCAwKSB7IHpvb20gPSAxOyB9XHJcbiAgICBpZiAocmFkID09PSB2b2lkIDApIHsgcmFkID0gZ2V0UmFkKHBvczEsIHBvczIpOyB9XHJcbiAgICB2YXIgd2lkdGggPSBnZXREaWFnb25hbFNpemUocG9zMSwgcG9zMik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC01MCUpIHRyYW5zbGF0ZShcIi5jb25jYXQocG9zMVswXSwgXCJweCwgXCIpLmNvbmNhdChwb3MxWzFdLCBcInB4KSByb3RhdGUoXCIpLmNvbmNhdChyYWQsIFwicmFkKSBzY2FsZVkoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250cm9sVHJhbnNmb3JtKHJvdGF0aW9uLCB6b29tKSB7XHJcbiAgICB2YXIgcG9zZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgcG9zZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgbGVuZ3RoID0gcG9zZXMubGVuZ3RoO1xyXG4gICAgdmFyIHggPSBwb3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHBvcykgeyByZXR1cm4gcHJldiArIHBvc1swXTsgfSwgMCkgLyBsZW5ndGg7XHJcbiAgICB2YXIgeSA9IHBvc2VzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcG9zKSB7IHJldHVybiBwcmV2ICsgcG9zWzFdOyB9LCAwKSAvIGxlbmd0aDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVooMHB4KSB0cmFuc2xhdGUoXCIuY29uY2F0KHgsIFwicHgsIFwiKS5jb25jYXQoeSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocm90YXRpb24sIFwicmFkKSBzY2FsZShcIikuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UHJvcHMocHJvcHMsIGFibGVOYW1lKSB7XHJcbiAgICB2YXIgc2VsZiA9IHByb3BzW2FibGVOYW1lXTtcclxuICAgIGlmIChpc09iamVjdChzZWxmKSkge1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCBzZWxmKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBnZXRTaXplKHRhcmdldCkge1xyXG4gICAgdmFyIGhhc09mZnNldCA9IHRhcmdldCAmJiAhaXNVbmRlZmluZWQodGFyZ2V0Lm9mZnNldFdpZHRoKTtcclxuICAgIHZhciBvZmZzZXRXaWR0aCA9IDA7XHJcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gMDtcclxuICAgIHZhciBjbGllbnRXaWR0aCA9IDA7XHJcbiAgICB2YXIgY2xpZW50SGVpZ2h0ID0gMDtcclxuICAgIHZhciBjc3NXaWR0aCA9IDA7XHJcbiAgICB2YXIgY3NzSGVpZ2h0ID0gMDtcclxuICAgIHZhciBjb250ZW50V2lkdGggPSAwO1xyXG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSAwO1xyXG4gICAgdmFyIG1pbldpZHRoID0gMDtcclxuICAgIHZhciBtaW5IZWlnaHQgPSAwO1xyXG4gICAgdmFyIG1pbk9mZnNldFdpZHRoID0gMDtcclxuICAgIHZhciBtaW5PZmZzZXRIZWlnaHQgPSAwO1xyXG4gICAgdmFyIG1heFdpZHRoID0gSW5maW5pdHk7XHJcbiAgICB2YXIgbWF4SGVpZ2h0ID0gSW5maW5pdHk7XHJcbiAgICB2YXIgbWF4T2Zmc2V0V2lkdGggPSBJbmZpbml0eTtcclxuICAgIHZhciBtYXhPZmZzZXRIZWlnaHQgPSBJbmZpbml0eTtcclxuICAgIHZhciBpbmxpbmVDU1NXaWR0aCA9IDA7XHJcbiAgICB2YXIgaW5saW5lQ1NTSGVpZ2h0ID0gMDtcclxuICAgIHZhciBzdmcgPSBmYWxzZTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIWhhc09mZnNldCAmJiB0YXJnZXQub3duZXJTVkdFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIHN2ZyBlbGVtZW50c1xyXG4gICAgICAgICAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICAgICAgICAgIHN2ZyA9IHRydWU7XHJcbiAgICAgICAgICAgIG9mZnNldFdpZHRoID0gYmJveC53aWR0aDtcclxuICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gYmJveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNzc1dpZHRoID0gb2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGNzc0hlaWdodCA9IG9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgY29udGVudFdpZHRoID0gb2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gb2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGNsaWVudEhlaWdodCA9IG9mZnNldEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGh0bWwgZWxlbWVudHNcclxuICAgICAgICAgICAgdmFyIGdldFN0eWxlID0gZ2V0Q2FjaGVkU3R5bGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldFN0eWxlID0gdGFyZ2V0LnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgYm94U2l6aW5nID0gZ2V0U3R5bGUoXCJib3hTaXppbmdcIikgPT09IFwiYm9yZGVyLWJveFwiO1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyTGVmdCA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJib3JkZXJMZWZ0V2lkdGhcIikpIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBib3JkZXJSaWdodCA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJib3JkZXJSaWdodFdpZHRoXCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyVG9wID0gcGFyc2VGbG9hdChnZXRTdHlsZShcImJvcmRlclRvcFdpZHRoXCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyQm90dG9tID0gcGFyc2VGbG9hdChnZXRTdHlsZShcImJvcmRlckJvdHRvbVdpZHRoXCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwicGFkZGluZ0xlZnRcIikpIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGdldFN0eWxlKFwicGFkZGluZ1JpZ2h0XCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJwYWRkaW5nVG9wXCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJwYWRkaW5nQm90dG9tXCIpKSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodDtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nQm90dG9tO1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEJvcmRlciA9IGJvcmRlckxlZnQgKyBib3JkZXJSaWdodDtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQm9yZGVyID0gYm9yZGVyVG9wICsgYm9yZGVyQm90dG9tO1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlcjtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxQYWRkaW5nICsgdmVydGljYWxCb3JkZXI7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFN0eWxlKFwicG9zaXRpb25cIik7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAvLyBTVkdTVkdFbGVtZW50LCBIVE1MRWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoXCJjbGllbnRMZWZ0XCIgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRJbmZvID0gZ2V0T2Zmc2V0SW5mbyh0YXJnZXQsIGdldERvY3VtZW50Qm9keSh0YXJnZXQpKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gb2Zmc2V0SW5mby5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRQYXJlbnRTdHlsZSA9IGdldENhY2hlZFN0eWxlKHBhcmVudEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gcGFyc2VGbG9hdChnZXRQYXJlbnRTdHlsZShcIndpZHRoXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJIZWlnaHQgPSBwYXJzZUZsb2F0KGdldFBhcmVudFN0eWxlKFwiaGVpZ2h0XCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaW5XaWR0aCA9IE1hdGgubWF4KGhvcml6b250YWxQYWRkaW5nLCBjb252ZXJ0VW5pdFNpemUoZ2V0U3R5bGUoXCJtaW5XaWR0aFwiKSwgY29udGFpbmVyV2lkdGgpIHx8IDApO1xyXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoLm1heCh2ZXJ0aWNhbFBhZGRpbmcsIGNvbnZlcnRVbml0U2l6ZShnZXRTdHlsZShcIm1pbkhlaWdodFwiKSwgY29udGFpbmVySGVpZ2h0KSB8fCAwKTtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBjb252ZXJ0VW5pdFNpemUoZ2V0U3R5bGUoXCJtYXhXaWR0aFwiKSwgY29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBjb252ZXJ0VW5pdFNpemUoZ2V0U3R5bGUoXCJtYXhIZWlnaHRcIiksIGNvbnRhaW5lckhlaWdodCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihtYXhXaWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTmFOKG1heEhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlubGluZUNTU1dpZHRoID0gY29udmVydFVuaXRTaXplKHRhcmdldFN0eWxlLndpZHRoLCAwKSB8fCAwO1xyXG4gICAgICAgICAgICBpbmxpbmVDU1NIZWlnaHQgPSBjb252ZXJ0VW5pdFNpemUodGFyZ2V0U3R5bGUuaGVpZ2h0LCAwKSB8fCAwO1xyXG4gICAgICAgICAgICBjc3NXaWR0aCA9IHBhcnNlRmxvYXQoZ2V0U3R5bGUoXCJ3aWR0aFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgY3NzSGVpZ2h0ID0gcGFyc2VGbG9hdChnZXRTdHlsZShcImhlaWdodFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgY29udGVudFdpZHRoID0gYWJzKGNzc1dpZHRoIC0gaW5saW5lQ1NTV2lkdGgpIDwgMVxyXG4gICAgICAgICAgICAgICAgPyBiZXR3ZWVuKG1pbldpZHRoLCBpbmxpbmVDU1NXaWR0aCB8fCBjc3NXaWR0aCwgbWF4V2lkdGgpXHJcbiAgICAgICAgICAgICAgICA6IGNzc1dpZHRoO1xyXG4gICAgICAgICAgICBjb250ZW50SGVpZ2h0ID0gYWJzKGNzc0hlaWdodCAtIGlubGluZUNTU0hlaWdodCkgPCAxXHJcbiAgICAgICAgICAgICAgICA/IGJldHdlZW4obWluSGVpZ2h0LCBpbmxpbmVDU1NIZWlnaHQgfHwgY3NzSGVpZ2h0LCBtYXhIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICA6IGNzc0hlaWdodDtcclxuICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBjb250ZW50V2lkdGg7XHJcbiAgICAgICAgICAgIG9mZnNldEhlaWdodCA9IGNvbnRlbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gY29udGVudFdpZHRoO1xyXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBjb250ZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoYm94U2l6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhPZmZzZXRXaWR0aCA9IG1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0SGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbWluT2Zmc2V0V2lkdGggPSBtaW5XaWR0aDtcclxuICAgICAgICAgICAgICAgIG1pbk9mZnNldEhlaWdodCA9IG1pbkhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRXaWR0aCA9IG9mZnNldFdpZHRoIC0gaG9yaXpvbnRhbE9mZnNldDtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRIZWlnaHQgPSBvZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbE9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1heE9mZnNldFdpZHRoID0gbWF4V2lkdGggKyBob3Jpem9udGFsT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgbWF4T2Zmc2V0SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgdmVydGljYWxPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBtaW5PZmZzZXRXaWR0aCA9IG1pbldpZHRoICsgaG9yaXpvbnRhbE9mZnNldDtcclxuICAgICAgICAgICAgICAgIG1pbk9mZnNldEhlaWdodCA9IG1pbkhlaWdodCArIHZlcnRpY2FsT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBjb250ZW50V2lkdGggKyBob3Jpem9udGFsT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29udGVudEhlaWdodCArIHZlcnRpY2FsT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gY29udGVudFdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmc7XHJcbiAgICAgICAgICAgIGNsaWVudEhlaWdodCA9IGNvbnRlbnRIZWlnaHQgKyB2ZXJ0aWNhbFBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdmc6IHN2ZyxcclxuICAgICAgICBvZmZzZXRXaWR0aDogb2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgb2Zmc2V0SGVpZ2h0OiBvZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLFxyXG4gICAgICAgIGNsaWVudEhlaWdodDogY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIGNvbnRlbnRXaWR0aDogY29udGVudFdpZHRoLFxyXG4gICAgICAgIGNvbnRlbnRIZWlnaHQ6IGNvbnRlbnRIZWlnaHQsXHJcbiAgICAgICAgaW5saW5lQ1NTV2lkdGg6IGlubGluZUNTU1dpZHRoLFxyXG4gICAgICAgIGlubGluZUNTU0hlaWdodDogaW5saW5lQ1NTSGVpZ2h0LFxyXG4gICAgICAgIGNzc1dpZHRoOiBjc3NXaWR0aCxcclxuICAgICAgICBjc3NIZWlnaHQ6IGNzc0hlaWdodCxcclxuICAgICAgICBtaW5XaWR0aDogbWluV2lkdGgsXHJcbiAgICAgICAgbWluSGVpZ2h0OiBtaW5IZWlnaHQsXHJcbiAgICAgICAgbWF4V2lkdGg6IG1heFdpZHRoLFxyXG4gICAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0LFxyXG4gICAgICAgIG1pbk9mZnNldFdpZHRoOiBtaW5PZmZzZXRXaWR0aCxcclxuICAgICAgICBtaW5PZmZzZXRIZWlnaHQ6IG1pbk9mZnNldEhlaWdodCxcclxuICAgICAgICBtYXhPZmZzZXRXaWR0aDogbWF4T2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgbWF4T2Zmc2V0SGVpZ2h0OiBtYXhPZmZzZXRIZWlnaHQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFJvdGF0aW9uUmFkKHBvc2VzLCBkaXJlY3Rpb24pIHtcclxuICAgIHJldHVybiBnZXRSYWQoZGlyZWN0aW9uID4gMCA/IHBvc2VzWzBdIDogcG9zZXNbMV0sIGRpcmVjdGlvbiA+IDAgPyBwb3Nlc1sxXSA6IHBvc2VzWzBdKTtcclxufVxyXG5mdW5jdGlvbiByZXNldENsaWVudFJlY3QoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IDAsIHRvcDogMCxcclxuICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICBjbGllbnRMZWZ0OiAwLCBjbGllbnRUb3A6IDAsXHJcbiAgICAgICAgY2xpZW50V2lkdGg6IDAsIGNsaWVudEhlaWdodDogMCxcclxuICAgICAgICBzY3JvbGxXaWR0aDogMCwgc2Nyb2xsSGVpZ2h0OiAwLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRFeHRlbmRzUmVjdChlbCwgcmVjdCkge1xyXG4gICAgdmFyIGlzUm9vdCA9IGVsID09PSBnZXREb2N1bWVudEJvZHkoZWwpIHx8IGVsID09PSBnZXREb2N1bWVudEVsZW1lbnQoZWwpO1xyXG4gICAgdmFyIGV4dGVuZHNSZWN0ID0ge1xyXG4gICAgICAgIGNsaWVudExlZnQ6IGVsLmNsaWVudExlZnQsXHJcbiAgICAgICAgY2xpZW50VG9wOiBlbC5jbGllbnRUb3AsXHJcbiAgICAgICAgY2xpZW50V2lkdGg6IGVsLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGNsaWVudEhlaWdodDogZWwuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIHNjcm9sbFdpZHRoOiBlbC5zY3JvbGxXaWR0aCxcclxuICAgICAgICBzY3JvbGxIZWlnaHQ6IGVsLnNjcm9sbEhlaWdodCxcclxuICAgICAgICBvdmVyZmxvdzogZmFsc2UsXHJcbiAgICB9O1xyXG4gICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICAgIGV4dGVuZHNSZWN0LmNsaWVudEhlaWdodCA9IE1hdGgubWF4KHJlY3QuaGVpZ2h0LCBleHRlbmRzUmVjdC5jbGllbnRIZWlnaHQpO1xyXG4gICAgICAgIGV4dGVuZHNSZWN0LnNjcm9sbEhlaWdodCA9IE1hdGgubWF4KHJlY3QuaGVpZ2h0LCBleHRlbmRzUmVjdC5zY3JvbGxIZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kc1JlY3Qub3ZlcmZsb3cgPSBnZXRDYWNoZWRTdHlsZShlbCkoXCJvdmVyZmxvd1wiKSAhPT0gXCJ2aXNpYmxlXCI7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY3QpLCBleHRlbmRzUmVjdCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEJ5UG9zaXRpb24ocG9zaXRpb24sIGJhc2UsIGVsLCBpc0V4dGVuZHMpIHtcclxuICAgIHZhciBsZWZ0ID0gcG9zaXRpb24ubGVmdCwgcmlnaHQgPSBwb3NpdGlvbi5yaWdodCwgdG9wID0gcG9zaXRpb24udG9wLCBib3R0b20gPSBwb3NpdGlvbi5ib3R0b207XHJcbiAgICB2YXIgYmFzZVRvcCA9IGJhc2UudG9wO1xyXG4gICAgdmFyIGJhc2VMZWZ0ID0gYmFzZS5sZWZ0O1xyXG4gICAgdmFyIHJlY3QgPSB7XHJcbiAgICAgICAgbGVmdDogYmFzZUxlZnQgKyBsZWZ0LFxyXG4gICAgICAgIHRvcDogYmFzZVRvcCArIHRvcCxcclxuICAgICAgICByaWdodDogYmFzZUxlZnQgKyByaWdodCxcclxuICAgICAgICBib3R0b206IGJhc2VUb3AgKyBib3R0b20sXHJcbiAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcclxuICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcCxcclxuICAgIH07XHJcbiAgICBpZiAoZWwgJiYgaXNFeHRlbmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEV4dGVuZHNSZWN0KGVsLCByZWN0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIGlzRXh0ZW5kcykge1xyXG4gICAgdmFyIGxlZnQgPSAwO1xyXG4gICAgdmFyIHRvcCA9IDA7XHJcbiAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgdmFyIGhlaWdodCA9IDA7XHJcbiAgICAvLyBsZXQgaXNSb290ID0gZmFsc2U7XHJcbiAgICBpZiAoZWwpIHtcclxuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxlZnQgPSBjbGllbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgdG9wID0gY2xpZW50UmVjdC50b3A7XHJcbiAgICAgICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xyXG4gICAgICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgdmFyIHJlY3QgPSB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aCxcclxuICAgICAgICBib3R0b206IHRvcCArIGhlaWdodCxcclxuICAgIH07XHJcbiAgICBpZiAoZWwgJiYgaXNFeHRlbmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEV4dGVuZHNSZWN0KGVsLCByZWN0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGdldFRvdGFsT3JpZ2luKG1vdmVhYmxlKSB7XHJcbiAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgZ3JvdXBhYmxlID0gX2EuZ3JvdXBhYmxlLCBzdmdPcmlnaW4gPSBfYS5zdmdPcmlnaW47XHJcbiAgICB2YXIgX2IgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCBvZmZzZXRXaWR0aCA9IF9iLm9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgPSBfYi5vZmZzZXRIZWlnaHQsIHN2ZyA9IF9iLnN2ZywgdHJhbnNmb3JtT3JpZ2luID0gX2IudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgaWYgKCFncm91cGFibGUgJiYgc3ZnICYmIHN2Z09yaWdpbikge1xyXG4gICAgICAgIHJldHVybiBjb252ZXJ0VHJhbnNmb3JtT3JpZ2luQXJyYXkoc3ZnT3JpZ2luLCBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2Zvcm1PcmlnaW47XHJcbn1cclxuZnVuY3Rpb24gZ2V0VG90YWxEaXJlY3Rpb24ocGFyZW50RGlyZWN0aW9uLCBpc1BpbmNoLCBpbnB1dEV2ZW50LCBkYXRhcykge1xyXG4gICAgdmFyIGRpcmVjdGlvbjtcclxuICAgIGlmIChwYXJlbnREaXJlY3Rpb24pIHtcclxuICAgICAgICBkaXJlY3Rpb24gPSBwYXJlbnREaXJlY3Rpb247XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1BpbmNoKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uID0gWzAsIDBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGlucHV0RXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbih0YXJnZXQsIGRhdGFzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaXJlY3Rpb247XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHRhcmdldCwgZGF0YXMpIHtcclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGRlZyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJvdGF0aW9uXCIpIHx8IFwiXCI7XHJcbiAgICB2YXIgZGlyZWNpdG9uID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtZGlyZWN0aW9uXCIpO1xyXG4gICAgZGF0YXMuZGVnID0gZGVnO1xyXG4gICAgaWYgKCFkaXJlY2l0b24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgZGlyID0gWzAsIDBdO1xyXG4gICAgKGRpcmVjaXRvbi5pbmRleE9mKFwid1wiKSA+IC0xKSAmJiAoZGlyWzBdID0gLTEpO1xyXG4gICAgKGRpcmVjaXRvbi5pbmRleE9mKFwiZVwiKSA+IC0xKSAmJiAoZGlyWzBdID0gMSk7XHJcbiAgICAoZGlyZWNpdG9uLmluZGV4T2YoXCJuXCIpID4gLTEpICYmIChkaXJbMV0gPSAtMSk7XHJcbiAgICAoZGlyZWNpdG9uLmluZGV4T2YoXCJzXCIpID4gLTEpICYmIChkaXJbMV0gPSAxKTtcclxuICAgIHJldHVybiBkaXI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVQb3Nlcyhwb3NlcywgZGlzdCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBwbHVzKGRpc3QsIHBvc2VzWzBdKSxcclxuICAgICAgICBwbHVzKGRpc3QsIHBvc2VzWzFdKSxcclxuICAgICAgICBwbHVzKGRpc3QsIHBvc2VzWzJdKSxcclxuICAgICAgICBwbHVzKGRpc3QsIHBvc2VzWzNdKSxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoX2EpIHtcclxuICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCBwb3MxID0gX2EucG9zMSwgcG9zMiA9IF9hLnBvczIsIHBvczMgPSBfYS5wb3MzLCBwb3M0ID0gX2EucG9zNDtcclxuICAgIHJldHVybiBnZXRBYnNvbHV0ZVBvc2VzKFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XSwgW2xlZnQsIHRvcF0pO1xyXG59XHJcbmZ1bmN0aW9uIHVuc2V0QWJsZXMoc2VsZiwgaXNDb250cm9sKSB7XHJcbiAgICBzZWxmW2lzQ29udHJvbCA/IFwiY29udHJvbEFibGVzXCIgOiBcInRhcmdldEFibGVzXCJdLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICBhYmxlLnVuc2V0ICYmIGFibGUudW5zZXQoc2VsZik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1bnNldEdlc3RvKHNlbGYsIGlzQ29udHJvbCkge1xyXG4gICAgdmFyIGdlc3RvTmFtZSA9IGlzQ29udHJvbCA/IFwiY29udHJvbEdlc3RvXCIgOiBcInRhcmdldEdlc3RvXCI7XHJcbiAgICB2YXIgZ2VzdG8gPSBzZWxmW2dlc3RvTmFtZV07XHJcbiAgICBpZiAoKGdlc3RvID09PSBudWxsIHx8IGdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXN0by5pc0lkbGUoKSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgdW5zZXRBYmxlcyhzZWxmLCBpc0NvbnRyb2wpO1xyXG4gICAgfVxyXG4gICAgZ2VzdG8gPT09IG51bGwgfHwgZ2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlc3RvLnVuc2V0KCk7XHJcbiAgICBzZWxmW2dlc3RvTmFtZV0gPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGxDU1NPYmplY3Qoc3R5bGUsIHJlc29sdmVkRXZlbnQpIHtcclxuICAgIGlmIChyZXNvbHZlZEV2ZW50KSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsRGF0YXMgPSBnZXRCZWZvcmVSZW5kZXJhYmxlRGF0YXMocmVzb2x2ZWRFdmVudCk7XHJcbiAgICAgICAgb3JpZ2luYWxEYXRhcy5uZXh0U3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3JpZ2luYWxEYXRhcy5uZXh0U3R5bGUpLCBzdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcclxuICAgICAgICBjc3NUZXh0OiBnZXRLZXlzKHN0eWxlKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFwiXCIuY29uY2F0KGRlY2FtZWxpemUobmFtZSwgXCItXCIpLCBcIjogXCIpLmNvbmNhdChzdHlsZVtuYW1lXSwgXCI7XCIpOyB9KS5qb2luKFwiXCIpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmaWxsQWZ0ZXJUcmFuc2Zvcm0ocHJldkV2ZW50LCBuZXh0RXZlbnQsIHJlc29sdmVkRXZlbnQpIHtcclxuICAgIHZhciBhZnRlclRyYW5zZm9ybSA9IG5leHRFdmVudC5hZnRlclRyYW5zZm9ybSB8fCBuZXh0RXZlbnQudHJhbnNmb3JtO1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmaWxsQ1NTT2JqZWN0KF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2RXZlbnQuc3R5bGUpLCBuZXh0RXZlbnQuc3R5bGUpLCB7IHRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0gfSksIHJlc29sdmVkRXZlbnQpKSwgeyBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0sIHRyYW5zZm9ybTogcHJldkV2ZW50LnRyYW5zZm9ybSB9KTtcclxufVxyXG5mdW5jdGlvbiBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBwYXJhbXMsIGlzQmVmb3JlRXZlbnQpIHtcclxuICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICBpZiAoIWRhdGFzLmRhdGFzKSB7XHJcbiAgICAgICAgZGF0YXMuZGF0YXMgPSB7fTtcclxuICAgIH1cclxuICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtcyksIHsgdGFyZ2V0OiBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQsIGNsaWVudFg6IGUuY2xpZW50WCwgY2xpZW50WTogZS5jbGllbnRZLCBpbnB1dEV2ZW50OiBlLmlucHV0RXZlbnQsIGN1cnJlbnRUYXJnZXQ6IG1vdmVhYmxlLCBtb3ZlYWJsZTogbW92ZWFibGUsIGRhdGFzOiBkYXRhcy5kYXRhcywgaXNSZXF1ZXN0OiBlLmlzUmVxdWVzdCwgaXNSZXF1ZXN0Q2hpbGQ6IGUuaXNSZXF1ZXN0Q2hpbGQsIGlzRmlyc3REcmFnOiAhIWUuaXNGaXJzdERyYWcsIGlzVHJ1c3RlZDogZS5pc1RydXN0ZWQgIT09IGZhbHNlLCBzdG9wQWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc0V2ZW50U3RhcnQgPSBmYWxzZTtcclxuICAgICAgICB9LCBzdG9wRHJhZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIChfYSA9IGUuc3RvcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZSk7XHJcbiAgICAgICAgfSB9KTtcclxuICAgIGlmICghZGF0YXMuaXNTdGFydEV2ZW50KSB7XHJcbiAgICAgICAgZGF0YXMuaXNTdGFydEV2ZW50ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFpc0JlZm9yZUV2ZW50KSB7XHJcbiAgICAgICAgZGF0YXMubGFzdEV2ZW50ID0gbmV4dFBhcmFtcztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0UGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHBhcmFtcykge1xyXG4gICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgIHZhciBpc0RyYWcgPSBcImlzRHJhZ1wiIGluIHBhcmFtcyA/IHBhcmFtcy5pc0RyYWcgOiBlLmlzRHJhZztcclxuICAgIGlmICghZGF0YXMuZGF0YXMpIHtcclxuICAgICAgICBkYXRhcy5kYXRhcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHsgaXNEcmFnOiBpc0RyYWcgfSwgcGFyYW1zKSwgeyBtb3ZlYWJsZTogbW92ZWFibGUsIHRhcmdldDogbW92ZWFibGUuc3RhdGUudGFyZ2V0LCBjbGllbnRYOiBlLmNsaWVudFgsIGNsaWVudFk6IGUuY2xpZW50WSwgaW5wdXRFdmVudDogZS5pbnB1dEV2ZW50LCBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZSwgbGFzdEV2ZW50OiBkYXRhcy5sYXN0RXZlbnQsIGlzRG91YmxlOiBlLmlzRG91YmxlLCBkYXRhczogZGF0YXMuZGF0YXMsIGlzRmlyc3REcmFnOiAhIWUuaXNGaXJzdERyYWcgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2F0Y2hFdmVudChtb3ZlYWJsZSwgbmFtZSwgY2FsbGJhY2spIHtcclxuICAgIG1vdmVhYmxlLl9lbWl0dGVyLm9uKG5hbWUsIGNhbGxiYWNrKTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIG5hbWUsIHBhcmFtcywgaXNNYW5hZ2VyLCBpc1JlcXVlc3QpIHtcclxuICAgIHJldHVybiBtb3ZlYWJsZS50cmlnZ2VyRXZlbnQobmFtZSwgcGFyYW1zLCBpc01hbmFnZXIsIGlzUmVxdWVzdCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgcHNldWRvRWx0KSB7XHJcbiAgICByZXR1cm4gZ2V0V2luZG93KGVsKS5nZXRDb21wdXRlZFN0eWxlKGVsLCBwc2V1ZG9FbHQpO1xyXG59XHJcbmZ1bmN0aW9uIGZpbHRlckFibGVzKGFibGVzLCBtZXRob2RzLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSkge1xyXG4gICAgdmFyIGVuYWJsZWRBYmxlcyA9IHt9O1xyXG4gICAgdmFyIGFibGVHcm91cHMgPSB7fTtcclxuICAgIHJldHVybiBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IGFibGUubmFtZTtcclxuICAgICAgICBpZiAoZW5hYmxlZEFibGVzW25hbWVdIHx8ICFtZXRob2RzLnNvbWUoZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gYWJsZVttZXRob2RdOyB9KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHkgJiYgYWJsZS5hYmxlR3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKGFibGVHcm91cHNbYWJsZS5hYmxlR3JvdXBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWJsZUdyb3Vwc1thYmxlLmFibGVHcm91cF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmFibGVkQWJsZXNbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZXF1YWxzKGExLCBhMikge1xyXG4gICAgcmV0dXJuIGExID09PSBhMiB8fCAoYTEgPT0gbnVsbCAmJiBhMiA9PSBudWxsKTtcclxufVxyXG5mdW5jdGlvbiBzZWxlY3RWYWx1ZSgpIHtcclxuICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCAtIDE7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzW2xlbmd0aF07XHJcbn1cclxuZnVuY3Rpb24gZ3JvdXBCeShhcnIsIGZ1bmMpIHtcclxuICAgIHZhciBncm91cHMgPSBbXTtcclxuICAgIHZhciBncm91cEtleXMgPSBbXTtcclxuICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgZ3JvdXBLZXkgPSBmdW5jKGVsLCBpbmRleCwgYXJyKTtcclxuICAgICAgICB2YXIga2V5SW5kZXggPSBncm91cEtleXMuaW5kZXhPZihncm91cEtleSk7XHJcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2tleUluZGV4XSB8fCBbXTtcclxuICAgICAgICBpZiAoa2V5SW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGdyb3VwS2V5cy5wdXNoKGdyb3VwS2V5KTtcclxuICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncm91cC5wdXNoKGVsKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGdyb3VwcztcclxufVxyXG5mdW5jdGlvbiBncm91cEJ5TWFwKGFyciwgZnVuYykge1xyXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xyXG4gICAgdmFyIGdyb3VwS2V5cyA9IHt9O1xyXG4gICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBncm91cEtleSA9IGZ1bmMoZWwsIGluZGV4LCBhcnIpO1xyXG4gICAgICAgIHZhciBncm91cCA9IGdyb3VwS2V5c1tncm91cEtleV07XHJcbiAgICAgICAgaWYgKCFncm91cCkge1xyXG4gICAgICAgICAgICBncm91cCA9IFtdO1xyXG4gICAgICAgICAgICBncm91cEtleXNbZ3JvdXBLZXldID0gZ3JvdXA7XHJcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXAucHVzaChlbCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBncm91cHM7XHJcbn1cclxuZnVuY3Rpb24gZmxhdChhcnIpIHtcclxuICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcclxuICAgICAgICByZXR1cm4gcHJldi5jb25jYXQoY3VyKTtcclxuICAgIH0sIFtdKTtcclxufVxyXG5mdW5jdGlvbiBtYXhPZmZzZXQoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBhcmdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFicyhiKSAtIGFicyhhKTsgfSk7XHJcbiAgICByZXR1cm4gYXJnc1swXTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24obWF0cml4LCBwb3MsIG4pIHtcclxuICAgIHJldHVybiBjYWxjdWxhdGUoaW52ZXJ0KG1hdHJpeCwgbiksIGNvbnZlcnRQb3NpdGlvbk1hdHJpeChwb3MsIG4pLCBuKTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0RHJhZ0Rpc3Qoc3RhdGUsIGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBpczNkID0gc3RhdGUuaXMzZCwgcm9vdE1hdHJpeCA9IHN0YXRlLnJvb3RNYXRyaXg7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIF9hID0gX19yZWFkKGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyb290TWF0cml4LCBbZS5kaXN0WCwgZS5kaXN0WV0sIG4pLCAyKSwgZS5kaXN0WCA9IF9hWzBdLCBlLmRpc3RZID0gX2FbMV07XHJcbiAgICByZXR1cm4gZTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVQYWRkaW5nKG1hdHJpeCwgcG9zLCBhZGRlZCwgbikge1xyXG4gICAgaWYgKCFhZGRlZFswXSAmJiAhYWRkZWRbMV0pIHtcclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG4gICAgdmFyIHhBZGRlZCA9IGNhbGN1bGF0ZVBvc2l0aW9uKG1hdHJpeCwgW25vcm1hbGl6ZWQoYWRkZWRbMF0gfHwgMSksIDBdLCBuKTtcclxuICAgIHZhciB5QWRkZWQgPSBjYWxjdWxhdGVQb3NpdGlvbihtYXRyaXgsIFswLCBub3JtYWxpemVkKGFkZGVkWzFdIHx8IDEpXSwgbik7XHJcbiAgICB2YXIgbmV4dEFkZGVkID0gY2FsY3VsYXRlUG9zaXRpb24obWF0cml4LCBbXHJcbiAgICAgICAgYWRkZWRbMF0gLyBnZXREaXN0U2l6ZSh4QWRkZWQpLFxyXG4gICAgICAgIGFkZGVkWzFdIC8gZ2V0RGlzdFNpemUoeUFkZGVkKSxcclxuICAgIF0sIG4pO1xyXG4gICAgcmV0dXJuIHBsdXMocG9zLCBuZXh0QWRkZWQpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRDU1NTaXplKHZhbHVlLCBzaXplLCBpc1JlbGF0aXZlKSB7XHJcbiAgICByZXR1cm4gaXNSZWxhdGl2ZSA/IFwiXCIuY29uY2F0KHZhbHVlIC8gc2l6ZSAqIDEwMCwgXCIlXCIpIDogXCJcIi5jb25jYXQodmFsdWUsIFwicHhcIik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGlueURpc3Qodikge1xyXG4gICAgcmV0dXJuIGFicyh2KSA8PSBUSU5ZX05VTSA/IDAgOiB2O1xyXG59XHJcbmZ1bmN0aW9uIGdldERpcmVjdGlvblZpZXdDbGFzc05hbWUoYWJsZU5hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICBpZiAoIW1vdmVhYmxlLmlzRHJhZ2dpbmcoYWJsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YSA9IGdldEdlc3RvRGF0YShtb3ZlYWJsZSwgYWJsZU5hbWUpO1xyXG4gICAgICAgIHZhciBkZWcgPSBkYXRhLmRlZztcclxuICAgICAgICBpZiAoIWRlZykge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByZWZpeChcInZpZXctY29udHJvbC1yb3RhdGlvblwiLmNvbmNhdChkZWcpKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uQ29uZGl0aW9uKGFibGVOYW1lLCBjaGVja0FibGVzKSB7XHJcbiAgICBpZiAoY2hlY2tBYmxlcyA9PT0gdm9pZCAwKSB7IGNoZWNrQWJsZXMgPSBbYWJsZU5hbWVdOyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgaWYgKGUuaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVja0FibGVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGUucmVxdWVzdEFibGUgPT09IG5hbWU7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5wYXJlbnREaXJlY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKSAmJiAoIWFibGVOYW1lIHx8IGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KGFibGVOYW1lKSkpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtSW5mbyh0cmFuc2Zvcm1zLCBzdGF0ZSwgaW5kZXgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBtYXRyaXhJbmZvcyA9IHBhcnNlKHRyYW5zZm9ybXMsIHtcclxuICAgICAgICBcInglXCI6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IC8gMTAwICogc3RhdGUub2Zmc2V0V2lkdGg7IH0sXHJcbiAgICAgICAgXCJ5JVwiOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAvIDEwMCAqIHN0YXRlLm9mZnNldEhlaWdodDsgfSxcclxuICAgIH0pO1xyXG4gICAgdmFyIGJlZm9yZUZ1bmN0aW9uVGV4dHMgPSB0cmFuc2Zvcm1zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4KTtcclxuICAgIHZhciBiZWZvcmVGdW5jdGlvblRleHRzMiA9IHRyYW5zZm9ybXMuc2xpY2UoMCwgaW5kZXggPCAwID8gdW5kZWZpbmVkIDogaW5kZXggKyAxKTtcclxuICAgIHZhciB0YXJnZXRGdW5jdGlvblRleHQgPSB0cmFuc2Zvcm1zW2luZGV4XSB8fCBcIlwiO1xyXG4gICAgdmFyIGFmdGVyRnVuY3Rpb25UZXh0cyA9IGluZGV4IDwgMCA/IFtdIDogdHJhbnNmb3Jtcy5zbGljZShpbmRleCk7XHJcbiAgICB2YXIgYWZ0ZXJGdW5jdGlvblRleHRzMiA9IGluZGV4IDwgMCA/IFtdIDogdHJhbnNmb3Jtcy5zbGljZShpbmRleCArIDEpO1xyXG4gICAgdmFyIGJlZm9yZUZ1bmN0aW9ucyA9IG1hdHJpeEluZm9zLnNsaWNlKDAsIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4KTtcclxuICAgIHZhciBiZWZvcmVGdW5jdGlvbnMyID0gbWF0cml4SW5mb3Muc2xpY2UoMCwgaW5kZXggPCAwID8gdW5kZWZpbmVkIDogaW5kZXggKyAxKTtcclxuICAgIHZhciB0YXJnZXRGdW5jdGlvbiA9IChfYSA9IG1hdHJpeEluZm9zW2luZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcGFyc2UoW1wiXCJdKVswXTtcclxuICAgIHZhciBhZnRlckZ1bmN0aW9ucyA9IGluZGV4IDwgMCA/IFtdIDogbWF0cml4SW5mb3Muc2xpY2UoaW5kZXgpO1xyXG4gICAgdmFyIGFmdGVyRnVuY3Rpb25zMiA9IGluZGV4IDwgMCA/IFtdIDogbWF0cml4SW5mb3Muc2xpY2UoaW5kZXggKyAxKTtcclxuICAgIHZhciB0YXJnZXRGdW5jdGlvbnMgPSB0YXJnZXRGdW5jdGlvbiA/IFt0YXJnZXRGdW5jdGlvbl0gOiBbXTtcclxuICAgIHZhciBiZWZvcmVGdW5jdGlvbk1hdHJpeCA9IHRvTWF0KGJlZm9yZUZ1bmN0aW9ucyk7XHJcbiAgICB2YXIgYmVmb3JlRnVuY3Rpb25NYXRyaXgyID0gdG9NYXQoYmVmb3JlRnVuY3Rpb25zMik7XHJcbiAgICB2YXIgYWZ0ZXJGdW5jdGlvbk1hdHJpeCA9IHRvTWF0KGFmdGVyRnVuY3Rpb25zKTtcclxuICAgIHZhciBhZnRlckZ1bmN0aW9uTWF0cml4MiA9IHRvTWF0KGFmdGVyRnVuY3Rpb25zMik7XHJcbiAgICB2YXIgYWxsRnVuY3Rpb25NYXRyaXggPSBtdWx0aXBseShiZWZvcmVGdW5jdGlvbk1hdHJpeCwgYWZ0ZXJGdW5jdGlvbk1hdHJpeCwgNCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXMsXHJcbiAgICAgICAgYmVmb3JlRnVuY3Rpb25NYXRyaXg6IGJlZm9yZUZ1bmN0aW9uTWF0cml4LFxyXG4gICAgICAgIGJlZm9yZUZ1bmN0aW9uTWF0cml4MjogYmVmb3JlRnVuY3Rpb25NYXRyaXgyLFxyXG4gICAgICAgIHRhcmdldEZ1bmN0aW9uTWF0cml4OiB0b01hdCh0YXJnZXRGdW5jdGlvbnMpLFxyXG4gICAgICAgIGFmdGVyRnVuY3Rpb25NYXRyaXg6IGFmdGVyRnVuY3Rpb25NYXRyaXgsXHJcbiAgICAgICAgYWZ0ZXJGdW5jdGlvbk1hdHJpeDI6IGFmdGVyRnVuY3Rpb25NYXRyaXgyLFxyXG4gICAgICAgIGFsbEZ1bmN0aW9uTWF0cml4OiBhbGxGdW5jdGlvbk1hdHJpeCxcclxuICAgICAgICBiZWZvcmVGdW5jdGlvbnM6IGJlZm9yZUZ1bmN0aW9ucyxcclxuICAgICAgICBiZWZvcmVGdW5jdGlvbnMyOiBiZWZvcmVGdW5jdGlvbnMyLFxyXG4gICAgICAgIHRhcmdldEZ1bmN0aW9uOiB0YXJnZXRGdW5jdGlvbnNbMF0sXHJcbiAgICAgICAgYWZ0ZXJGdW5jdGlvbnM6IGFmdGVyRnVuY3Rpb25zLFxyXG4gICAgICAgIGFmdGVyRnVuY3Rpb25zMjogYWZ0ZXJGdW5jdGlvbnMyLFxyXG4gICAgICAgIGJlZm9yZUZ1bmN0aW9uVGV4dHM6IGJlZm9yZUZ1bmN0aW9uVGV4dHMsXHJcbiAgICAgICAgYmVmb3JlRnVuY3Rpb25UZXh0czI6IGJlZm9yZUZ1bmN0aW9uVGV4dHMyLFxyXG4gICAgICAgIHRhcmdldEZ1bmN0aW9uVGV4dDogdGFyZ2V0RnVuY3Rpb25UZXh0LFxyXG4gICAgICAgIGFmdGVyRnVuY3Rpb25UZXh0czogYWZ0ZXJGdW5jdGlvblRleHRzLFxyXG4gICAgICAgIGFmdGVyRnVuY3Rpb25UZXh0czI6IGFmdGVyRnVuY3Rpb25UZXh0czIsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQXJyYXlGb3JtYXQoYXJyKSB7XHJcbiAgICBpZiAoIWFyciB8fCAhaXNPYmplY3QoYXJyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc05vZGUoYXJyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0FycmF5KGFycikgfHwgXCJsZW5ndGhcIiBpbiBhcnI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVmVGFyZ2V0KHRhcmdldCwgaXNTZWxlY3Rvcikge1xyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChpc05vZGUodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmIChpc1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNGdW5jdGlvbih0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzV2luZG93KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKFwiY3VycmVudFwiIGluIHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuY3VycmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVmVGFyZ2V0cyh0YXJnZXRzLCBpc1NlbGVjdG9yKSB7XHJcbiAgICBpZiAoIXRhcmdldHMpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB2YXIgdXNlclRhcmdldHMgPSBpc0FycmF5Rm9ybWF0KHRhcmdldHMpID8gW10uc2xpY2UuY2FsbCh0YXJnZXRzKSA6IFt0YXJnZXRzXTtcclxuICAgIHJldHVybiB1c2VyVGFyZ2V0cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHRhcmdldCkge1xyXG4gICAgICAgIGlmIChpc1N0cmluZyh0YXJnZXQpICYmIGlzU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHByZXYpLCBmYWxzZSksIF9fcmVhZChbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KSkpLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcHJldi5wdXNoKGdldFJlZlRhcmdldHModGFyZ2V0LCBpc1NlbGVjdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2LnB1c2goZ2V0UmVmVGFyZ2V0KHRhcmdldCwgaXNTZWxlY3RvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgIH0sIFtdKTtcclxufVxyXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVJvdGF0aW9uKHBvczEsIHBvczIsIGRpcmVjdGlvbikge1xyXG4gICAgdmFyIGRlZyA9IGdldFJhZChwb3MxLCBwb3MyKSAvIE1hdGguUEkgKiAxODA7XHJcbiAgICBkZWcgPSBkaXJlY3Rpb24gPj0gMCA/IGRlZyA6IDE4MCAtIGRlZztcclxuICAgIGRlZyA9IGRlZyA+PSAwID8gZGVnIDogMzYwICsgZGVnO1xyXG4gICAgcmV0dXJuIGRlZztcclxufVxyXG5mdW5jdGlvbiBnZXREcmFnRGlzdEJ5U3RhdGUoc3RhdGUsIGRpc3QpIHtcclxuICAgIHZhciByb290TWF0cml4ID0gc3RhdGUucm9vdE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2Q7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHZhciBpbnZlcnNlTWF0cml4ID0gaW52ZXJ0KHJvb3RNYXRyaXgsIG4pO1xyXG4gICAgaWYgKCFpczNkKSB7XHJcbiAgICAgICAgaW52ZXJzZU1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24oaW52ZXJzZU1hdHJpeCwgMywgNCk7XHJcbiAgICB9XHJcbiAgICBpbnZlcnNlTWF0cml4WzEyXSA9IDA7XHJcbiAgICBpbnZlcnNlTWF0cml4WzEzXSA9IDA7XHJcbiAgICBpbnZlcnNlTWF0cml4WzE0XSA9IDA7XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlTWF0cml4RGlzdChpbnZlcnNlTWF0cml4LCBkaXN0KTtcclxufVxyXG5mdW5jdGlvbiBnZXRTaXplRGlzdEJ5RGlzdChzdGFydFNpemUsIGRpc3QsIHJhdGlvLCBkaXJlY3Rpb24sIGtlZXBSYXRpbykge1xyXG4gICAgdmFyIF9hID0gX19yZWFkKHN0YXJ0U2l6ZSwgMiksIHN0YXJ0T2Zmc2V0V2lkdGggPSBfYVswXSwgc3RhcnRPZmZzZXRIZWlnaHQgPSBfYVsxXTtcclxuICAgIHZhciBkaXN0V2lkdGggPSAwO1xyXG4gICAgdmFyIGRpc3RIZWlnaHQgPSAwO1xyXG4gICAgaWYgKGtlZXBSYXRpbyAmJiBzdGFydE9mZnNldFdpZHRoICYmIHN0YXJ0T2Zmc2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHJhZCA9IGdldFJhZChbMCwgMF0sIGRpc3QpO1xyXG4gICAgICAgIHZhciBzdGFuZGFyZFJhZCA9IGdldFJhZChbMCwgMF0sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgdmFyIHNpemUgPSBnZXREaXN0U2l6ZShkaXN0KTtcclxuICAgICAgICB2YXIgc2lnblNpemUgPSBNYXRoLmNvcyhyYWQgLSBzdGFuZGFyZFJhZCkgKiBzaXplO1xyXG4gICAgICAgIGlmICghZGlyZWN0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgIC8vIHRvcCwgYm90dG9tXHJcbiAgICAgICAgICAgIGRpc3RIZWlnaHQgPSBzaWduU2l6ZTtcclxuICAgICAgICAgICAgZGlzdFdpZHRoID0gZGlzdEhlaWdodCAqIHJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghZGlyZWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgIC8vIGxlZnQsIHJpZ2h0XHJcbiAgICAgICAgICAgIGRpc3RXaWR0aCA9IHNpZ25TaXplO1xyXG4gICAgICAgICAgICBkaXN0SGVpZ2h0ID0gZGlzdFdpZHRoIC8gcmF0aW87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0d28td2F5XHJcbiAgICAgICAgICAgIHZhciBzdGFydFdpZHRoU2l6ZSA9IGRpcmVjdGlvblswXSAqIHN0YXJ0T2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEhlaWdodFNpemUgPSBkaXJlY3Rpb25bMV0gKiBzdGFydE9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgdmFyIHNlY29uZFJhZCA9IE1hdGguYXRhbjIoc3RhcnRXaWR0aFNpemUgKyBkaXN0WzBdLCBzdGFydEhlaWdodFNpemUgKyBkaXN0WzFdKTtcclxuICAgICAgICAgICAgdmFyIGZpcnN0UmFkID0gTWF0aC5hdGFuMihzdGFydFdpZHRoU2l6ZSwgc3RhcnRIZWlnaHRTaXplKTtcclxuICAgICAgICAgICAgaWYgKHNlY29uZFJhZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHNlY29uZFJhZCArPSBNYXRoLlBJICogMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3RSYWQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFJhZCArPSBNYXRoLlBJICogMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmFkXzEgPSAwO1xyXG4gICAgICAgICAgICBpZiAoYWJzKHNlY29uZFJhZCAtIGZpcnN0UmFkKSA8IE1hdGguUEkgLyAyIHx8IGFicyhzZWNvbmRSYWQgLSBmaXJzdFJhZCkgPiBNYXRoLlBJIC8gMiAqIDMpIHtcclxuICAgICAgICAgICAgICAgIHJhZF8xID0gc2Vjb25kUmFkIC0gZmlyc3RSYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFJhZCArPSBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgcmFkXzEgPSBzZWNvbmRSYWQgLSBmaXJzdFJhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmFkXzEgPiBNYXRoLlBJICogMikge1xyXG4gICAgICAgICAgICAgICAgcmFkXzEgLT0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmFkXzEgPiBNYXRoLlBJKSB7XHJcbiAgICAgICAgICAgICAgICByYWRfMSA9IDIgKiBNYXRoLlBJIC0gcmFkXzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmFkXzEgPCAtTWF0aC5QSSkge1xyXG4gICAgICAgICAgICAgICAgcmFkXzEgPSAtMiAqIE1hdGguUEkgLSByYWRfMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgICAxODBcclxuICAgICAgICAgICAgLy8gLTEsIC0xLCAgLy8gMSwgLTFcclxuICAgICAgICAgICAgLy8gMjcwICAgICAgICAgICAgOTBcclxuICAgICAgICAgICAgLy8gLTEsIDEgICAgLy8gMSwgMVxyXG4gICAgICAgICAgICAvLyAgICAgICAwXHJcbiAgICAgICAgICAgIHZhciBkaXN0U2l6ZSA9IGdldERpc3RTaXplKFtzdGFydFdpZHRoU2l6ZSArIGRpc3RbMF0sIHN0YXJ0SGVpZ2h0U2l6ZSArIGRpc3RbMV1dKSAqIE1hdGguY29zKHJhZF8xKTtcclxuICAgICAgICAgICAgZGlzdFdpZHRoID0gZGlzdFNpemUgKiBNYXRoLnNpbihmaXJzdFJhZCkgLSBzdGFydFdpZHRoU2l6ZTtcclxuICAgICAgICAgICAgZGlzdEhlaWdodCA9IGRpc3RTaXplICogTWF0aC5jb3MoZmlyc3RSYWQpIC0gc3RhcnRIZWlnaHRTaXplO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZGlzdFdpZHRoICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMV0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0SGVpZ2h0ICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGlzdFdpZHRoID0gZGlyZWN0aW9uWzBdICogZGlzdFswXTtcclxuICAgICAgICBkaXN0SGVpZ2h0ID0gZGlyZWN0aW9uWzFdICogZGlzdFsxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbZGlzdFdpZHRoLCBkaXN0SGVpZ2h0XTtcclxufVxyXG5mdW5jdGlvbiBnZXRPZmZzZXRTaXplRGlzdChzaXplRGlyZWN0aW9uLCBrZWVwUmF0aW8sIGRhdGFzLCBlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgcmF0aW8gPSBkYXRhcy5yYXRpbywgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQ7XHJcbiAgICB2YXIgZGlzdFdpZHRoID0gMDtcclxuICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcclxuICAgIHZhciBkaXN0WCA9IGUuZGlzdFgsIGRpc3RZID0gZS5kaXN0WSwgcGluY2hTY2FsZSA9IGUucGluY2hTY2FsZSwgcGFyZW50RGlzdGFuY2UgPSBlLnBhcmVudERpc3RhbmNlLCBwYXJlbnREaXN0ID0gZS5wYXJlbnREaXN0LCBwYXJlbnRTY2FsZSA9IGUucGFyZW50U2NhbGU7XHJcbiAgICB2YXIgc3RhcnRGaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgdmFyIGRpcmVjdGlvbnNEaXN0cyA9IFswLCAxXS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGFicyhzaXplRGlyZWN0aW9uW2luZGV4XSAtIHN0YXJ0Rml4ZWREaXJlY3Rpb25baW5kZXhdKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGRpcmVjdGlvblJhdGlvcyA9IFswLCAxXS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBkaXJlY3Rpb25zRGlzdHNbaW5kZXhdO1xyXG4gICAgICAgIGlmIChkaXN0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGRpc3QgPSAyIC8gZGlzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3Q7XHJcbiAgICB9KTtcclxuICAgIGlmIChwYXJlbnREaXN0KSB7XHJcbiAgICAgICAgZGlzdFdpZHRoID0gcGFyZW50RGlzdFswXTtcclxuICAgICAgICBkaXN0SGVpZ2h0ID0gcGFyZW50RGlzdFsxXTtcclxuICAgICAgICBpZiAoa2VlcFJhdGlvKSB7XHJcbiAgICAgICAgICAgIGlmICghZGlzdFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0V2lkdGggPSBkaXN0SGVpZ2h0ICogcmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWRpc3RIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGRpc3RIZWlnaHQgPSBkaXN0V2lkdGggLyByYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTnVtYmVyKHBpbmNoU2NhbGUpKSB7XHJcbiAgICAgICAgZGlzdFdpZHRoID0gKHBpbmNoU2NhbGUgLSAxKSAqIHN0YXJ0T2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgZGlzdEhlaWdodCA9IChwaW5jaFNjYWxlIC0gMSkgKiBzdGFydE9mZnNldEhlaWdodDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmVudFNjYWxlKSB7XHJcbiAgICAgICAgZGlzdFdpZHRoID0gKHBhcmVudFNjYWxlWzBdIC0gMSkgKiBzdGFydE9mZnNldFdpZHRoO1xyXG4gICAgICAgIGRpc3RIZWlnaHQgPSAocGFyZW50U2NhbGVbMV0gLSAxKSAqIHN0YXJ0T2Zmc2V0SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyZW50RGlzdGFuY2UpIHtcclxuICAgICAgICB2YXIgc2NhbGVYID0gc3RhcnRPZmZzZXRXaWR0aCAqIGRpcmVjdGlvbnNEaXN0c1swXTtcclxuICAgICAgICB2YXIgc2NhbGVZID0gc3RhcnRPZmZzZXRIZWlnaHQgKiBkaXJlY3Rpb25zRGlzdHNbMV07XHJcbiAgICAgICAgdmFyIHJhdGlvRGlzdGFuY2UgPSBnZXREaXN0U2l6ZShbc2NhbGVYLCBzY2FsZVldKTtcclxuICAgICAgICBkaXN0V2lkdGggPSBwYXJlbnREaXN0YW5jZSAvIHJhdGlvRGlzdGFuY2UgKiBzY2FsZVggKiBkaXJlY3Rpb25SYXRpb3NbMF07XHJcbiAgICAgICAgZGlzdEhlaWdodCA9IHBhcmVudERpc3RhbmNlIC8gcmF0aW9EaXN0YW5jZSAqIHNjYWxlWSAqIGRpcmVjdGlvblJhdGlvc1sxXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBkaXN0XzEgPSBnZXREcmFnRGlzdCh7IGRhdGFzOiBkYXRhcywgZGlzdFg6IGRpc3RYLCBkaXN0WTogZGlzdFkgfSk7XHJcbiAgICAgICAgZGlzdF8xID0gZGlyZWN0aW9uUmF0aW9zLm1hcChmdW5jdGlvbiAocmF0aW8sIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RfMVtpXSAqIHJhdGlvO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9hID0gX19yZWFkKGdldFNpemVEaXN0QnlEaXN0KFtzdGFydE9mZnNldFdpZHRoLCBzdGFydE9mZnNldEhlaWdodF0sIGRpc3RfMSwgcmF0aW8sIHNpemVEaXJlY3Rpb24sIGtlZXBSYXRpbyksIDIpLCBkaXN0V2lkdGggPSBfYVswXSwgZGlzdEhlaWdodCA9IF9hWzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvLyBkaXJlY3Rpb24sXHJcbiAgICAgICAgLy8gc2l6ZURpcmVjdGlvbixcclxuICAgICAgICBkaXN0V2lkdGg6IGRpc3RXaWR0aCxcclxuICAgICAgICBkaXN0SGVpZ2h0OiBkaXN0SGVpZ2h0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtVW5pdChvcmlnaW4sIHh5KSB7XHJcbiAgICBpZiAoeHkpIHtcclxuICAgICAgICBpZiAob3JpZ2luID09PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBcIjAlXCIsIHk6IFwiNTAlXCIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luID09PSBcInRvcFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFwiNTAlXCIsIHk6IFwiNTAlXCIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luID09PSBcImNlbnRlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFwiNTAlXCIsIHk6IFwiNTAlXCIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luID09PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeDogXCIxMDAlXCIsIHk6IFwiNTAlXCIgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luID09PSBcImJvdHRvbVwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFwiNTAlXCIsIHk6IFwiMTAwJVwiIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChvcmlnaW4uc3BsaXQoXCIgXCIpLCAyKSwgbGVmdCA9IF9hWzBdLCByaWdodCA9IF9hWzFdO1xyXG4gICAgICAgIHZhciBsZWZ0T3JpZ2luID0gY29udmVydFRyYW5zZm9ybVVuaXQobGVmdCB8fCBcIlwiKTtcclxuICAgICAgICB2YXIgcmlnaHRPcmlnaW4gPSBjb252ZXJ0VHJhbnNmb3JtVW5pdChyaWdodCB8fCBcIlwiKTtcclxuICAgICAgICB2YXIgb3JpZ2luT2JqZWN0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxlZnRPcmlnaW4pLCByaWdodE9yaWdpbik7XHJcbiAgICAgICAgdmFyIG5leHRPcmlnaW5PYmplY3QgPSB7XHJcbiAgICAgICAgICAgIHg6IFwiNTAlXCIsXHJcbiAgICAgICAgICAgIHk6IFwiNTAlXCIsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3JpZ2luT2JqZWN0LngpIHtcclxuICAgICAgICAgICAgbmV4dE9yaWdpbk9iamVjdC54ID0gb3JpZ2luT2JqZWN0Lng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmlnaW5PYmplY3QueSkge1xyXG4gICAgICAgICAgICBuZXh0T3JpZ2luT2JqZWN0LnkgPSBvcmlnaW5PYmplY3QueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdpbk9iamVjdC52YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luT2JqZWN0LnggJiYgIW9yaWdpbk9iamVjdC55KSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0T3JpZ2luT2JqZWN0LnkgPSBvcmlnaW5PYmplY3QudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvcmlnaW5PYmplY3QueCAmJiBvcmlnaW5PYmplY3QueSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dE9yaWdpbk9iamVjdC54ID0gb3JpZ2luT2JqZWN0LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0T3JpZ2luT2JqZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKG9yaWdpbiA9PT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICByZXR1cm4geyB4OiBcIjAlXCIgfTtcclxuICAgIH1cclxuICAgIGlmIChvcmlnaW4gPT09IFwicmlnaHRcIikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IFwiMTAwJVwiIH07XHJcbiAgICB9XHJcbiAgICBpZiAob3JpZ2luID09PSBcInRvcFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeTogXCIwJVwiIH07XHJcbiAgICB9XHJcbiAgICBpZiAob3JpZ2luID09PSBcImJvdHRvbVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeTogXCIxMDAlXCIgfTtcclxuICAgIH1cclxuICAgIGlmICghb3JpZ2luKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKG9yaWdpbiA9PT0gXCJjZW50ZXJcIikge1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBcIjUwJVwiIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB2YWx1ZTogb3JpZ2luIH07XHJcbn1cclxuZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybU9yaWdpbkFycmF5KHRyYW5zZm9ybU9yaWdpbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIF9hID0gY29udmVydFRyYW5zZm9ybVVuaXQodHJhbnNmb3JtT3JpZ2luLCB0cnVlKSwgeCA9IF9hLngsIHkgPSBfYS55O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBjb252ZXJ0VW5pdFNpemUoeCwgd2lkdGgpIHx8IDAsXHJcbiAgICAgICAgY29udmVydFVuaXRTaXplKHksIGhlaWdodCkgfHwgMCxcclxuICAgIF07XHJcbn1cclxuZnVuY3Rpb24gcm90YXRlUG9zZXNJbmZvKHBvc2VzLCBvcmlnaW4sIHJhZCkge1xyXG4gICAgdmFyIHByZXZQb3NlcyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBtaW51cyhwb3MsIG9yaWdpbik7IH0pO1xyXG4gICAgdmFyIG5leHRQb3NlcyA9IHByZXZQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcm90YXRlKHBvcywgcmFkKTsgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByZXY6IHByZXZQb3NlcyxcclxuICAgICAgICBuZXh0OiBuZXh0UG9zZXMsXHJcbiAgICAgICAgcmVzdWx0OiBuZXh0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBsdXMocG9zLCBvcmlnaW4pOyB9KSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNEZWVwQXJyYXlFcXVhbHMoYXJyMSwgYXJyMikge1xyXG4gICAgcmV0dXJuIGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZTEsIGkpIHtcclxuICAgICAgICB2YXIgdmFsdWUyID0gYXJyMltpXTtcclxuICAgICAgICB2YXIgaXNBcnJheTEgPSBpc0FycmF5KHZhbHVlMSk7XHJcbiAgICAgICAgdmFyIGlzQXJyYXkyID0gaXNBcnJheSh2YWx1ZTIpO1xyXG4gICAgICAgIGlmIChpc0FycmF5MSAmJiBpc0FycmF5Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNEZWVwQXJyYXlFcXVhbHModmFsdWUxLCB2YWx1ZTIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaXNBcnJheTEgJiYgIWlzQXJyYXkyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gd2F0Y2hWYWx1ZShtb3ZlYWJsZSwgcHJvcGVydHksIG5leHRWYWx1ZSwgdmFsdWVLZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgdmFyIHN0b3JlID0gbW92ZWFibGUuX3N0b3JlO1xyXG4gICAgdmFyIHByZXZWYWx1ZSA9IHN0b3JlW3Byb3BlcnR5XTtcclxuICAgIGlmICghKHByb3BlcnR5IGluIHN0b3JlKSkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdG9yZVtwcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0b3JlW3Byb3BlcnR5XSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJldlZhbHVlID09PSBuZXh0VmFsdWUgfHwgdmFsdWVLZXkocHJldlZhbHVlKSA9PT0gdmFsdWVLZXkobmV4dFZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBwcmV2VmFsdWU7XHJcbiAgICB9XHJcbiAgICBzdG9yZVtwcm9wZXJ0eV0gPSBuZXh0VmFsdWU7XHJcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHNpZ24odmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA+PSAwID8gMSA6IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGFicyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBjb3VudEVhY2goY291bnQsIGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gY291bnRlcihjb3VudCkubWFwKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gY2FsbGJhY2soaW5kZXgpOyB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRQYWRkaW5nQm94KHBhZGRpbmcpIHtcclxuICAgIGlmIChpc051bWJlcihwYWRkaW5nKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvcDogcGFkZGluZyxcclxuICAgICAgICAgICAgbGVmdDogcGFkZGluZyxcclxuICAgICAgICAgICAgcmlnaHQ6IHBhZGRpbmcsXHJcbiAgICAgICAgICAgIGJvdHRvbTogcGFkZGluZyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBwYWRkaW5nLmxlZnQgfHwgMCxcclxuICAgICAgICB0b3A6IHBhZGRpbmcudG9wIHx8IDAsXHJcbiAgICAgICAgcmlnaHQ6IHBhZGRpbmcucmlnaHQgfHwgMCxcclxuICAgICAgICBib3R0b206IHBhZGRpbmcuYm90dG9tIHx8IDAsXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlBpbmNoYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBwaW5jaGVkIHdpdGggZHJhZ2dhYmxlLCByZXNpemFibGUsIHNjYWxhYmxlLCByb3RhdGFibGUgKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKi9cclxudmFyIFBpbmNoYWJsZSA9IG1ha2VBYmxlKFwicGluY2hhYmxlXCIsIHtcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJwaW5jaGFibGVcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInBpbmNoU3RhcnRcIixcclxuICAgICAgICBcInBpbmNoXCIsXHJcbiAgICAgICAgXCJwaW5jaEVuZFwiLFxyXG4gICAgICAgIFwicGluY2hHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJwaW5jaEdyb3VwXCIsXHJcbiAgICAgICAgXCJwaW5jaEdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgcGluY2hTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgdGFyZ2V0cyA9IGUudGFyZ2V0cywgYW5nbGUgPSBlLmFuZ2xlLCBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzO1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCBwaW5jaGFibGUgPSBfYS5waW5jaGFibGUsIGFibGVzID0gX2EuYWJsZXM7XHJcbiAgICAgICAgaWYgKCFwaW5jaGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXZlbnROYW1lID0gXCJvblBpbmNoXCIuY29uY2F0KHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiLCBcIlN0YXJ0XCIpO1xyXG4gICAgICAgIHZhciBjb250cm9sRXZlbnROYW1lID0gXCJkcmFnXCIuY29uY2F0KHRhcmdldHMgPyBcIkdyb3VwXCIgOiBcIlwiLCBcIkNvbnRyb2xTdGFydFwiKTtcclxuICAgICAgICB2YXIgcGluY2hBYmxlcyA9IChwaW5jaGFibGUgPT09IHRydWUgPyBtb3ZlYWJsZS5jb250cm9sQWJsZXMgOiBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBpbmNoYWJsZS5pbmRleE9mKGFibGUubmFtZSkgPiAtMTtcclxuICAgICAgICB9KSkuZmlsdGVyKGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlLmNhblBpbmNoICYmIGFibGVbY29udHJvbEV2ZW50TmFtZV07IH0pO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7fSk7XHJcbiAgICAgICAgaWYgKHRhcmdldHMpIHtcclxuICAgICAgICAgICAgcGFyYW1zLnRhcmdldHMgPSB0YXJnZXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuaXNQaW5jaCA9IHJlc3VsdCAhPT0gZmFsc2U7XHJcbiAgICAgICAgZGF0YXMuYWJsZXMgPSBwaW5jaEFibGVzO1xyXG4gICAgICAgIHZhciBpc1BpbmNoID0gZGF0YXMuaXNQaW5jaDtcclxuICAgICAgICBpZiAoIWlzUGluY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwaW5jaEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdID0gb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWFibGVbY29udHJvbEV2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWJsZUV2ZW50ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGRhdGFzOiBvcmlnaW5hbERhdGFzW2FibGUubmFtZV0sIHBhcmVudFJvdGF0ZTogYW5nbGUsIGlzUGluY2g6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIGFibGVbY29udHJvbEV2ZW50TmFtZV0obW92ZWFibGUsIGFibGVFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcFJlbmRlckluZm8gPSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFswLCAwXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBpc1BpbmNoO1xyXG4gICAgfSxcclxuICAgIHBpbmNoOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBwaW5jaFNjYWxlID0gZS5zY2FsZSwgZGlzdGFuY2UgPSBlLmRpc3RhbmNlLCBvcmlnaW5hbERhdGFzID0gZS5vcmlnaW5hbERhdGFzLCBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50LCB0YXJnZXRzID0gZS50YXJnZXRzLCBhbmdsZSA9IGUuYW5nbGU7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1BpbmNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmVudERpc3RhbmNlID0gZGlzdGFuY2UgKiAoMSAtIDEgLyBwaW5jaFNjYWxlKTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xyXG4gICAgICAgIGlmICh0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IFwib25QaW5jaFwiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIik7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgdmFyIGFibGVzID0gZGF0YXMuYWJsZXM7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xFdmVudE5hbWUgPSBcImRyYWdcIi5jb25jYXQodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIsIFwiQ29udHJvbFwiKTtcclxuICAgICAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmICghYWJsZVtjb250cm9sRXZlbnROYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFibGVbY29udHJvbEV2ZW50TmFtZV0obW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBkYXRhczogb3JpZ2luYWxEYXRhc1thYmxlLm5hbWVdLCBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LCByZXNvbHZlTWF0cml4OiB0cnVlLCBwaW5jaFNjYWxlOiBwaW5jaFNjYWxlLCBwYXJlbnREaXN0YW5jZTogcGFyZW50RGlzdGFuY2UsIHBhcmVudFJvdGF0ZTogYW5nbGUsIGlzUGluY2g6IHRydWUgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgcGluY2hFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIGlzUGluY2ggPSBlLmlzUGluY2gsIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsIHRhcmdldHMgPSBlLnRhcmdldHMsIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1BpbmNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IFwib25QaW5jaFwiLmNvbmNhdCh0YXJnZXRzID8gXCJHcm91cFwiIDogXCJcIiwgXCJFbmRcIik7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHsgaXNEcmFnOiBpc1BpbmNoIH0pO1xyXG4gICAgICAgIGlmICh0YXJnZXRzKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXRzID0gdGFyZ2V0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBldmVudE5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgdmFyIGFibGVzID0gZGF0YXMuYWJsZXM7XHJcbiAgICAgICAgdmFyIGNvbnRyb2xFdmVudE5hbWUgPSBcImRyYWdcIi5jb25jYXQodGFyZ2V0cyA/IFwiR3JvdXBcIiA6IFwiXCIsIFwiQ29udHJvbEVuZFwiKTtcclxuICAgICAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmICghYWJsZVtjb250cm9sRXZlbnROYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFibGVbY29udHJvbEV2ZW50TmFtZV0obW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBpc0RyYWc6IGlzUGluY2gsIGRhdGFzOiBvcmlnaW5hbERhdGFzW2FibGUubmFtZV0sIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsIGlzUGluY2g6IHRydWUgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpc1BpbmNoO1xyXG4gICAgfSxcclxuICAgIHBpbmNoR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGluY2hTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMgfSkpO1xyXG4gICAgfSxcclxuICAgIHBpbmNoR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpbmNoKG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyB9KSk7XHJcbiAgICB9LFxyXG4gICAgcGluY2hHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGluY2hFbmQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbn0pO1xyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGFyZ2V0IGNhbiBiZSBwaW5jaGVkIHdpdGggZHJhZ2dhYmxlLCByZXNpemFibGUsIHNjYWxhYmxlLCByb3RhdGFibGUgKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5QaW5jaGFibGUjcGluY2hhYmxlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnBpbmNoYWJsZSA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgcGluY2ggc3RhcnRzLCB0aGUgcGluY2hTdGFydCBldmVudCBpcyBjYWxsZWQgd2l0aCBwYXJ0IG9mIHNjYWxlU3RhcnQsIHJvdGF0ZVN0YXJ0LCByZXNpemVTdGFydFxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXHJcbiAqIEBldmVudCBwaW5jaFN0YXJ0XHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcGluY2hTdGFydCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHJvdGF0YWJsZTogdHJ1ZSxcclxuICogICAgIHNjYWxhYmxlOiB0cnVlLFxyXG4gKiAgICAgcGluY2hhYmxlOiB0cnVlLCAvLyBbXCJyb3RhdGFibGVcIiwgXCJzY2FsYWJsZVwiXVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJwaW5jaFN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3RhdGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBwaW5jaGluZywgdGhlIHBpbmNoIGV2ZW50IGlzIGNhbGxlZCB3aXRoIHBhcnQgb2Ygc2NhbGUsIHJvdGF0ZSwgcmVzaXplXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5QaW5jaGFibGVcclxuICogQGV2ZW50IHBpbmNoXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2h9IC0gUGFyYW1ldGVycyBmb3IgdGhlIHBpbmNoIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm90YXRhYmxlOiB0cnVlLFxyXG4gKiAgICAgc2NhbGFibGU6IHRydWUsXHJcbiAqICAgICBwaW5jaGFibGU6IHRydWUsIC8vIFtcInJvdGF0YWJsZVwiLCBcInNjYWxhYmxlXCJdXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInBpbmNoXCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3RhdGVcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlXCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBwaW5jaCBmaW5pc2hlcywgdGhlIHBpbmNoRW5kIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxyXG4gKiBAZXZlbnQgcGluY2hFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5QaW5jaGFibGUuT25QaW5jaEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgcGluY2hFbmQgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3RhdGFibGU6IHRydWUsXHJcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcclxuICogICAgIHBpbmNoYWJsZTogdHJ1ZSwgLy8gW1wicm90YXRhYmxlXCIsIFwic2NhbGFibGVcIl1cclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdGF0ZUVuZFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVFbmRcIiwgKHsgdGFyZ2V0IH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIGdyb3VwIHBpbmNoIHN0YXJ0cywgdGhlIGBwaW5jaEdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlBpbmNoYWJsZVxyXG4gKiBAZXZlbnQgcGluY2hHcm91cFN0YXJ0XHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hHcm91cFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcGluY2hHcm91cFN0YXJ0YCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqICAgICBwaW5jaGFibGU6IHRydWVcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicGluY2hHcm91cFN0YXJ0XCIsICh7IHRhcmdldHMgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblBpbmNoR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgcGluY2gsIHRoZSBgcGluY2hHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXHJcbiAqIEBldmVudCBwaW5jaEdyb3VwXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHBpbmNoR3JvdXBgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogICAgIHBpbmNoYWJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJwaW5jaEdyb3VwXCIsICh7IHRhcmdldHMsIGV2ZW50cyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUGluY2hHcm91cFwiLCB0YXJnZXRzKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgZ3JvdXAgcGluY2ggZmluaXNoZXMsIHRoZSBgcGluY2hHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUGluY2hhYmxlXHJcbiAqIEBldmVudCBwaW5jaEdyb3VwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUGluY2hhYmxlLk9uUGluY2hHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHBpbmNoR3JvdXBFbmRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogICAgIHBpbmNoYWJsZTogdHJ1ZVxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJwaW5jaEdyb3VwRW5kXCIsICh7IHRhcmdldHMsIGlzRHJhZyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUGluY2hHcm91cEVuZFwiLCB0YXJnZXRzLCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXG5cbnZhciBkaXJlY3Rpb25Db25kaXRpb24gPSBnZXREaXJlY3Rpb25Db25kaXRpb24oXCJzY2FsYWJsZVwiKTtcclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgU2NhbGFibGVcclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBTY2FsYWJsZSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdGFyZ2V0J3MgeCBhbmQgeSBjYW4gYmUgc2NhbGUgb2YgdHJhbnNmb3JtLlxyXG4gKi9cclxudmFyIFNjYWxhYmxlID0ge1xyXG4gICAgbmFtZTogXCJzY2FsYWJsZVwiLFxyXG4gICAgYWJsZUdyb3VwOiBcInNpemVcIixcclxuICAgIGNhblBpbmNoOiB0cnVlLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcInNjYWxhYmxlXCIsXHJcbiAgICAgICAgXCJ0aHJvdHRsZVNjYWxlXCIsXHJcbiAgICAgICAgXCJyZW5kZXJEaXJlY3Rpb25zXCIsXHJcbiAgICAgICAgXCJrZWVwUmF0aW9cIixcclxuICAgICAgICBcImVkZ2VcIixcclxuICAgICAgICBcImRpc3BsYXlBcm91bmRDb250cm9sc1wiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwic2NhbGVTdGFydFwiLFxyXG4gICAgICAgIFwiYmVmb3JlU2NhbGVcIixcclxuICAgICAgICBcInNjYWxlXCIsXHJcbiAgICAgICAgXCJzY2FsZUVuZFwiLFxyXG4gICAgICAgIFwic2NhbGVHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJiZWZvcmVTY2FsZUdyb3VwXCIsXHJcbiAgICAgICAgXCJzY2FsZUdyb3VwXCIsXHJcbiAgICAgICAgXCJzY2FsZUdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgcmVuZGVyOiBnZXRSZW5kZXJEaXJlY3Rpb25zKFwic2NhbGFibGVcIiksXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZGlyZWN0aW9uQ29uZGl0aW9uLFxyXG4gICAgdmlld0NsYXNzTmFtZTogZ2V0RGlyZWN0aW9uVmlld0NsYXNzTmFtZShcInNjYWxhYmxlXCIpLFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgaXNQaW5jaCA9IGUuaXNQaW5jaCwgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCwgcGFyZW50RGlyZWN0aW9uID0gZS5wYXJlbnREaXJlY3Rpb247XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGdldFRvdGFsRGlyZWN0aW9uKHBhcmVudERpcmVjdGlvbiwgaXNQaW5jaCwgaW5wdXRFdmVudCwgZGF0YXMpO1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQsIHRhcmdldFRyYW5zZm9ybSA9IF9hLnRhcmdldFRyYW5zZm9ybSwgdGFyZ2V0ID0gX2EudGFyZ2V0LCBwb3MxID0gX2EucG9zMSwgcG9zMiA9IF9hLnBvczIsIHBvczQgPSBfYS5wb3M0O1xyXG4gICAgICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUGluY2gpIHtcclxuICAgICAgICAgICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuZGF0YXMgPSB7fTtcclxuICAgICAgICBkYXRhcy50cmFuc2Zvcm0gPSB0YXJnZXRUcmFuc2Zvcm07XHJcbiAgICAgICAgZGF0YXMucHJldkRpc3QgPSBbMSwgMV07XHJcbiAgICAgICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGggPSB3aWR0aDtcclxuICAgICAgICBkYXRhcy5zdGFydE9mZnNldEhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gWzEsIDFdO1xyXG4gICAgICAgIC8vIGNvbnN0IHNjYWxlV2lkdGggPSBnZXREaXN0KHBvczEsIHBvczIpO1xyXG4gICAgICAgIC8vIGNvbnN0IHNjYWxlSGVpZ2h0ID0gZ2V0RGlzdChwb3MyLCBwb3M0KTtcclxuICAgICAgICB2YXIgaXNXaWR0aCA9ICghZGlyZWN0aW9uWzBdICYmICFkaXJlY3Rpb25bMV0pIHx8IGRpcmVjdGlvblswXSB8fCAhZGlyZWN0aW9uWzFdO1xyXG4gICAgICAgIC8vIGRhdGFzLnNjYWxlV2lkdGggPSBzY2FsZVdpZHRoO1xyXG4gICAgICAgIC8vIGRhdGFzLnNjYWxlSGVpZ2h0ID0gc2NhbGVIZWlnaHQ7XHJcbiAgICAgICAgLy8gZGF0YXMuc2NhbGVYUmF0aW8gPSBzY2FsZVdpZHRoIC8gd2lkdGg7XHJcbiAgICAgICAgLy8gZGF0YXMuc2NhbGVZUmF0aW8gPSBzY2FsZUhlaWdodCAvIGhlaWdodDtcclxuICAgICAgICBzZXREZWZhdWx0VHJhbnNmb3JtSW5kZXgobW92ZWFibGUsIGUsIFwic2NhbGVcIik7XHJcbiAgICAgICAgZGF0YXMuaXNXaWR0aCA9IGlzV2lkdGg7XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0UmF0aW8ocmF0aW8pIHtcclxuICAgICAgICAgICAgZGF0YXMucmF0aW8gPSByYXRpbyAmJiBpc0Zpbml0ZShyYXRpbykgPyByYXRpbyA6IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLnN0YXJ0UG9zaXRpb25zID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUobW92ZWFibGUuc3RhdGUpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRGaXhlZERpcmVjdGlvbkluZm8oZGF0YXMuc3RhcnRQb3NpdGlvbnMsIGZpeGVkRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWREaXJlY3Rpb24gPSByZXN1bHQuZml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGRhdGFzLmZpeGVkUG9zaXRpb24gPSByZXN1bHQuZml4ZWRQb3NpdGlvbjtcclxuICAgICAgICAgICAgZGF0YXMuZml4ZWRPZmZzZXQgPSByZXN1bHQuZml4ZWRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uID0gc2V0Rml4ZWREaXJlY3Rpb247XHJcbiAgICAgICAgc2V0UmF0aW8oZ2V0RGlzdCQxKHBvczEsIHBvczIpIC8gZ2V0RGlzdCQxKHBvczIsIHBvczQpKTtcclxuICAgICAgICBzZXRGaXhlZERpcmVjdGlvbihbLWRpcmVjdGlvblswXSwgLWRpcmVjdGlvblsxXV0pO1xyXG4gICAgICAgIHZhciBzZXRNaW5TY2FsZVNpemUgPSBmdW5jdGlvbiAobWluKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLm1pblNjYWxlU2l6ZSA9IG1pbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzZXRNYXhTY2FsZVNpemUgPSBmdW5jdGlvbiAobWF4KSB7XHJcbiAgICAgICAgICAgIGRhdGFzLm1heFNjYWxlU2l6ZSA9IG1heDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNvbnN0IHNldE1pblNjYWxlID0gKG1pbjogbnVtYmVyW10pID0+IHtcclxuICAgICAgICAvLyB9O1xyXG4gICAgICAgIC8vIGNvbnN0IHNldE1heFNjYWxlID0gKG1heDogbnVtYmVyW10pID0+IHtcclxuICAgICAgICAvLyB9O1xyXG4gICAgICAgIHNldE1pblNjYWxlU2l6ZShbLUluZmluaXR5LCAtSW5maW5pdHldKTtcclxuICAgICAgICBzZXRNYXhTY2FsZVNpemUoW0luZmluaXR5LCBJbmZpbml0eV0pO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7IGRpcmVjdGlvbjogZGlyZWN0aW9uLCBzZXQ6IGZ1bmN0aW9uIChzY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICB9LCBzZXRSYXRpbzogc2V0UmF0aW8sIHNldEZpeGVkRGlyZWN0aW9uOiBzZXRGaXhlZERpcmVjdGlvbiwgc2V0TWluU2NhbGVTaXplOiBzZXRNaW5TY2FsZVNpemUsIHNldE1heFNjYWxlU2l6ZTogc2V0TWF4U2NhbGVTaXplIH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KG1vdmVhYmxlLCBlKSksIHsgZHJhZ1N0YXJ0OiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBuZXcgQ3VzdG9tR2VzdG8oKS5kcmFnU3RhcnQoWzAsIDBdLCBlKSkgfSkpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZVN0YXJ0XCIsIHBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRGaXhlZERpcmVjdGlvbiA9IGRhdGFzLmZpeGVkRGlyZWN0aW9uO1xyXG4gICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmlzU2NhbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGUuaXNSZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhcy5pc1NjYWxlID8gcGFyYW1zIDogZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJlc29sdmVUcmFuc2Zvcm1FdmVudChtb3ZlYWJsZSwgZSwgXCJzY2FsZVwiKTtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBwYXJlbnRLZWVwUmF0aW8gPSBlLnBhcmVudEtlZXBSYXRpbywgcGFyZW50RmxhZyA9IGUucGFyZW50RmxhZywgaXNQaW5jaCA9IGUuaXNQaW5jaCwgZHJhZ0NsaWVudCA9IGUuZHJhZ0NsaWVudCwgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3QsIHVzZVNuYXAgPSBlLnVzZVNuYXAsIHJlc29sdmVNYXRyaXggPSBlLnJlc29sdmVNYXRyaXg7XHJcbiAgICAgICAgdmFyIHByZXZEaXN0ID0gZGF0YXMucHJldkRpc3QsIGRpcmVjdGlvbiA9IGRhdGFzLmRpcmVjdGlvbiwgc3RhcnRPZmZzZXRXaWR0aCA9IGRhdGFzLnN0YXJ0T2Zmc2V0V2lkdGgsIHN0YXJ0T2Zmc2V0SGVpZ2h0ID0gZGF0YXMuc3RhcnRPZmZzZXRIZWlnaHQsIGlzU2NhbGUgPSBkYXRhcy5pc1NjYWxlLCBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZSwgaXNXaWR0aCA9IGRhdGFzLmlzV2lkdGgsIHJhdGlvID0gZGF0YXMucmF0aW87XHJcbiAgICAgICAgaWYgKCFpc1NjYWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgdmFyIHRocm90dGxlU2NhbGUgPSBwcm9wcy50aHJvdHRsZVNjYWxlLCBwYXJlbnRNb3ZlYWJsZSA9IHByb3BzLnBhcmVudE1vdmVhYmxlO1xyXG4gICAgICAgIHZhciBzaXplRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIGlmICghZGlyZWN0aW9uWzBdICYmICFkaXJlY3Rpb25bMV0pIHtcclxuICAgICAgICAgICAgc2l6ZURpcmVjdGlvbiA9IFsxLCAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtlZXBSYXRpbyA9IChyYXRpbyAmJiAocGFyZW50S2VlcFJhdGlvICE9IG51bGwgPyBwYXJlbnRLZWVwUmF0aW8gOiBwcm9wcy5rZWVwUmF0aW8pKSB8fCBmYWxzZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgdGVtcFNjYWxlVmFsdWUgPSBbXHJcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVbMF0sXHJcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVbMV0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U2NhbGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGdldE9mZnNldFNpemVEaXN0KHNpemVEaXJlY3Rpb24sIGtlZXBSYXRpbywgZGF0YXMsIGUpLCBkaXN0V2lkdGggPSBfYS5kaXN0V2lkdGgsIGRpc3RIZWlnaHQgPSBfYS5kaXN0SGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZGlzdFggPSBzdGFydE9mZnNldFdpZHRoID8gKHN0YXJ0T2Zmc2V0V2lkdGggKyBkaXN0V2lkdGgpIC8gc3RhcnRPZmZzZXRXaWR0aCA6IDE7XHJcbiAgICAgICAgICAgIHZhciBkaXN0WSA9IHN0YXJ0T2Zmc2V0SGVpZ2h0ID8gKHN0YXJ0T2Zmc2V0SGVpZ2h0ICsgZGlzdEhlaWdodCkgLyBzdGFydE9mZnNldEhlaWdodCA6IDE7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnRWYWx1ZVswXSkge1xyXG4gICAgICAgICAgICAgICAgdGVtcFNjYWxlVmFsdWVbMF0gPSBkaXN0V2lkdGggLyBzdGFydE9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc3RhcnRWYWx1ZVsxXSkge1xyXG4gICAgICAgICAgICAgICAgdGVtcFNjYWxlVmFsdWVbMV0gPSBkaXN0SGVpZ2h0IC8gc3RhcnRPZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IChzaXplRGlyZWN0aW9uWzBdIHx8IGtlZXBSYXRpbyA/IGRpc3RYIDogMSkgKiB0ZW1wU2NhbGVWYWx1ZVswXTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlWSA9IChzaXplRGlyZWN0aW9uWzFdIHx8IGtlZXBSYXRpbyA/IGRpc3RZIDogMSkgKiB0ZW1wU2NhbGVWYWx1ZVsxXTtcclxuICAgICAgICAgICAgaWYgKHNjYWxlWCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gc2lnbihwcmV2RGlzdFswXSkgKiBNSU5fU0NBTEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNjYWxlWSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVZID0gc2lnbihwcmV2RGlzdFsxXSkgKiBNSU5fU0NBTEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtzY2FsZVgsIHNjYWxlWV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzY2FsZSA9IGdldE5leHRTY2FsZSgpO1xyXG4gICAgICAgIGlmICghaXNQaW5jaCAmJiBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIHNuYXBSZW5kZXJJbmZvID0gc3RhdGUuc25hcFJlbmRlckluZm8gfHwge307XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZURpcmVjdGlvbiA9IHNuYXBSZW5kZXJJbmZvLmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3RhdGVEaXJlY3Rpb24pICYmIChzdGF0ZURpcmVjdGlvblswXSB8fCBzdGF0ZURpcmVjdGlvblsxXSkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnNuYXBSZW5kZXJJbmZvID0geyBkaXJlY3Rpb246IGRpcmVjdGlvbiwgcmVxdWVzdDogZS5pc1JlcXVlc3QgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVTY2FsZVwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICAgICAgc2V0Rml4ZWREaXJlY3Rpb246IGZ1bmN0aW9uIChuZXh0Rml4ZWREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGRhdGFzLnNldEZpeGVkRGlyZWN0aW9uKG5leHRGaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IGdldE5leHRTY2FsZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGFydEZpeGVkRGlyZWN0aW9uOiBkYXRhcy5zdGFydEZpeGVkRGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBzZXRTY2FsZTogZnVuY3Rpb24gKG5leHRTY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBuZXh0U2NhbGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgdHJ1ZSkpO1xyXG4gICAgICAgIHZhciBkaXN0ID0gW1xyXG4gICAgICAgICAgICBzY2FsZVswXSAvIHRlbXBTY2FsZVZhbHVlWzBdLFxyXG4gICAgICAgICAgICBzY2FsZVsxXSAvIHRlbXBTY2FsZVZhbHVlWzFdLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIGZpeGVkUG9zaXRpb24gPSBkcmFnQ2xpZW50O1xyXG4gICAgICAgIHZhciBzbmFwRGlzdCA9IFswLCAwXTtcclxuICAgICAgICB2YXIgZGlzdFNpZ24gPSBzaWduKGRpc3RbMF0gKiBkaXN0WzFdKTtcclxuICAgICAgICB2YXIgaXNTZWxmUGluY2ggPSAhZHJhZ0NsaWVudCAmJiAhcGFyZW50RmxhZyAmJiBpc1BpbmNoO1xyXG4gICAgICAgIGlmIChpc1NlbGZQaW5jaCB8fCByZXNvbHZlTWF0cml4KSB7XHJcbiAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBnZXRUcmFuc2xhdGVGaXhlZFBvc2l0aW9uKG1vdmVhYmxlLCBkYXRhcy50YXJnZXRBbGxUcmFuc2Zvcm0sIFswLCAwXSwgWzAsIDBdLCBkYXRhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFkcmFnQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIGZpeGVkUG9zaXRpb24gPSBkYXRhcy5maXhlZFBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUGluY2gpIHtcclxuICAgICAgICAgICAgc25hcERpc3QgPSBjaGVja1NuYXBTY2FsZShtb3ZlYWJsZSwgZGlzdCwgZGlyZWN0aW9uLCAhdXNlU25hcCAmJiBpc1JlcXVlc3QsIGRhdGFzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtlZXBSYXRpbykge1xyXG4gICAgICAgICAgICBpZiAoc2l6ZURpcmVjdGlvblswXSAmJiBzaXplRGlyZWN0aW9uWzFdICYmIHNuYXBEaXN0WzBdICYmIHNuYXBEaXN0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc25hcERpc3RbMF0gKiBzdGFydE9mZnNldFdpZHRoKSA+IE1hdGguYWJzKHNuYXBEaXN0WzFdICogc3RhcnRPZmZzZXRIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc25hcERpc3RbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc25hcERpc3RbMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc05vU25hcCA9ICFzbmFwRGlzdFswXSAmJiAhc25hcERpc3RbMV07XHJcbiAgICAgICAgICAgIGlmIChpc05vU25hcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhyb3R0bGUgc2NhbGUgdmFsdWUgKG5vdCBhYnNvbHV0ZSBzY2FsZSBzaXplKVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0WzBdID0gdGhyb3R0bGUoZGlzdFswXSAqIHRlbXBTY2FsZVZhbHVlWzBdLCB0aHJvdHRsZVNjYWxlKSAvIHRlbXBTY2FsZVZhbHVlWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdFsxXSA9IHRocm90dGxlKGRpc3RbMV0gKiB0ZW1wU2NhbGVWYWx1ZVsxXSwgdGhyb3R0bGVTY2FsZSkgLyB0ZW1wU2NhbGVWYWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHNpemVEaXJlY3Rpb25bMF0gJiYgIXNpemVEaXJlY3Rpb25bMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoc25hcERpc3RbMF0gJiYgIXNuYXBEaXN0WzFdKVxyXG4gICAgICAgICAgICAgICAgfHwgKGlzTm9TbmFwICYmIGlzV2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0WzBdICs9IHNuYXBEaXN0WzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBIZWlnaHQgPSBzdGFydE9mZnNldFdpZHRoICogZGlzdFswXSAqIHRlbXBTY2FsZVZhbHVlWzBdIC8gcmF0aW87XHJcbiAgICAgICAgICAgICAgICBkaXN0WzFdID0gc2lnbihkaXN0U2lnbiAqIGRpc3RbMF0pICogYWJzKHNuYXBIZWlnaHQgLyBzdGFydE9mZnNldEhlaWdodCAvIHRlbXBTY2FsZVZhbHVlWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoIXNpemVEaXJlY3Rpb25bMF0gJiYgc2l6ZURpcmVjdGlvblsxXSlcclxuICAgICAgICAgICAgICAgIHx8ICghc25hcERpc3RbMF0gJiYgc25hcERpc3RbMV0pXHJcbiAgICAgICAgICAgICAgICB8fCAoaXNOb1NuYXAgJiYgIWlzV2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0WzFdICs9IHNuYXBEaXN0WzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBXaWR0aCA9IHN0YXJ0T2Zmc2V0SGVpZ2h0ICogZGlzdFsxXSAqIHRlbXBTY2FsZVZhbHVlWzFdICogcmF0aW87XHJcbiAgICAgICAgICAgICAgICBkaXN0WzBdID0gc2lnbihkaXN0U2lnbiAqIGRpc3RbMV0pICogYWJzKHNuYXBXaWR0aCAvIHN0YXJ0T2Zmc2V0V2lkdGggLyB0ZW1wU2NhbGVWYWx1ZVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRpc3RbMF0gKz0gc25hcERpc3RbMF07XHJcbiAgICAgICAgICAgIGRpc3RbMV0gKz0gc25hcERpc3RbMV07XHJcbiAgICAgICAgICAgIGlmICghc25hcERpc3RbMF0pIHtcclxuICAgICAgICAgICAgICAgIGRpc3RbMF0gPSB0aHJvdHRsZShkaXN0WzBdICogdGVtcFNjYWxlVmFsdWVbMF0sIHRocm90dGxlU2NhbGUpIC8gdGVtcFNjYWxlVmFsdWVbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFzbmFwRGlzdFsxXSkge1xyXG4gICAgICAgICAgICAgICAgZGlzdFsxXSA9IHRocm90dGxlKGRpc3RbMV0gKiB0ZW1wU2NhbGVWYWx1ZVsxXSwgdGhyb3R0bGVTY2FsZSkgLyB0ZW1wU2NhbGVWYWx1ZVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzdFswXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaXN0WzBdID0gc2lnbihwcmV2RGlzdFswXSkgKiBNSU5fU0NBTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXN0WzFdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpc3RbMV0gPSBzaWduKHByZXZEaXN0WzFdKSAqIE1JTl9TQ0FMRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2NhbGUgPSBtdWx0aXBseTIoZGlzdCwgW3RlbXBTY2FsZVZhbHVlWzBdLCB0ZW1wU2NhbGVWYWx1ZVsxXV0pO1xyXG4gICAgICAgIHZhciBzdGFydE9mZnNldFNpemUgPSBbXHJcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0SGVpZ2h0LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIHNjYWxlU2l6ZSA9IFtcclxuICAgICAgICAgICAgc3RhcnRPZmZzZXRXaWR0aCAqIHNjYWxlWzBdLFxyXG4gICAgICAgICAgICBzdGFydE9mZnNldEhlaWdodCAqIHNjYWxlWzFdLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgc2NhbGVTaXplID0gY2FsY3VsYXRlQm91bmRTaXplKHNjYWxlU2l6ZSwgZGF0YXMubWluU2NhbGVTaXplLCBkYXRhcy5tYXhTY2FsZVNpemUsIGtlZXBSYXRpbyA/IHJhdGlvIDogZmFsc2UpO1xyXG4gICAgICAgIC8vIGlmIChrZWVwUmF0aW8gJiYgKGlzR3JvdXAgfHwga2VlcFJhdGlvRmluYWxseSkpIHtcclxuICAgICAgICAvLyAgICAgaWYgKGlzV2lkdGgpIHtcclxuICAgICAgICAvLyAgICAgICAgIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmdXaWR0aCAvIHJhdGlvO1xyXG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgYm91bmRpbmdXaWR0aCA9IGJvdW5kaW5nSGVpZ2h0ICogcmF0aW87XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgc2NhbGUgPSBjb3VudEVhY2goMiwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2Zmc2V0U2l6ZVtpXSA/IHNjYWxlU2l6ZVtpXSAvIHN0YXJ0T2Zmc2V0U2l6ZVtpXSA6IHNjYWxlU2l6ZVtpXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkaXN0ID0gY291bnRFYWNoKDIsIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVtpXSAvIHRlbXBTY2FsZVZhbHVlW2ldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IGNvdW50RWFjaCgyLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gcHJldkRpc3RbaV0gPyBkaXN0W2ldIC8gcHJldkRpc3RbaV0gOiBkaXN0W2ldOyB9KTtcclxuICAgICAgICB2YXIgZGlzdFRleHQgPSBcInNjYWxlKFwiLmNvbmNhdChkaXN0LmpvaW4oXCIsIFwiKSwgXCIpXCIpO1xyXG4gICAgICAgIHZhciBzY2FsZVRleHQgPSBcInNjYWxlKFwiLmNvbmNhdChzY2FsZS5qb2luKFwiLCBcIiksIFwiKVwiKTtcclxuICAgICAgICB2YXIgbmV4dFRyYW5zZm9ybSA9IGNvbnZlcnRUcmFuc2Zvcm1Gb3JtYXQoZGF0YXMsIHNjYWxlVGV4dCwgZGlzdFRleHQpO1xyXG4gICAgICAgIHZhciBpc1plcm9TY2FsZSA9ICFzdGFydFZhbHVlWzBdIHx8ICFzdGFydFZhbHVlWzFdO1xyXG4gICAgICAgIHZhciBpbnZlcnNlRGlzdCA9IGdldFNjYWxlRGlzdChtb3ZlYWJsZSwgaXNaZXJvU2NhbGUgPyBzY2FsZVRleHQgOiBkaXN0VGV4dCwgZGF0YXMuZml4ZWREaXJlY3Rpb24sIGZpeGVkUG9zaXRpb24sIGRhdGFzLmZpeGVkT2Zmc2V0LCBkYXRhcywgaXNaZXJvU2NhbGUpO1xyXG4gICAgICAgIHZhciBpbnZlcnNlRGVsdGEgPSBpc1NlbGZQaW5jaCA/IGludmVyc2VEaXN0IDogbWludXMoaW52ZXJzZURpc3QsIGRhdGFzLnByZXZJbnZlcnNlRGlzdCB8fCBbMCwgMF0pO1xyXG4gICAgICAgIGRhdGFzLnByZXZEaXN0ID0gZGlzdDtcclxuICAgICAgICBkYXRhcy5wcmV2SW52ZXJzZURpc3QgPSBpbnZlcnNlRGlzdDtcclxuICAgICAgICBpZiAoc2NhbGVbMF0gPT09IHByZXZEaXN0WzBdICYmIHNjYWxlWzFdID09PSBwcmV2RGlzdFsxXVxyXG4gICAgICAgICAgICAmJiBpbnZlcnNlRGVsdGEuZXZlcnkoZnVuY3Rpb24gKG51bSkgeyByZXR1cm4gIW51bTsgfSlcclxuICAgICAgICAgICAgJiYgIXBhcmVudE1vdmVhYmxlXHJcbiAgICAgICAgICAgICYmICFpc1NlbGZQaW5jaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJhbXMgPSBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IG9mZnNldFdpZHRoOiBzdGFydE9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQ6IHN0YXJ0T2Zmc2V0SGVpZ2h0LCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgc2NhbGU6IHNjYWxlLCBkaXN0OiBkaXN0LCBkZWx0YTogZGVsdGEsIGlzUGluY2g6ICEhaXNQaW5jaCB9LCBmaWxsVHJhbnNmb3JtRXZlbnQobW92ZWFibGUsIG5leHRUcmFuc2Zvcm0sIGludmVyc2VEZWx0YSwgaXNQaW5jaCwgZSkpKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25TY2FsZVwiLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1NjYWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuaXNTY2FsZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzY2FsZUVuZFBhcmFtID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlRW5kXCIsIHNjYWxlRW5kUGFyYW0pO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUVuZFBhcmFtO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGRpcmVjdGlvbkNvbmRpdGlvbixcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgICAgICBpZiAoIXBhcmFtcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbEV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJyZXNpemFibGVcIiwgZSk7XHJcbiAgICAgICAgZGF0YXMubW92ZWFibGVTY2FsZSA9IG1vdmVhYmxlLnNjYWxlO1xyXG4gICAgICAgIHZhciBldmVudHMgPSB0cmlnZ2VyQ2hpbGRBYmxlcyhtb3ZlYWJsZSwgdGhpcywgXCJkcmFnQ29udHJvbFN0YXJ0XCIsIGUsIGZ1bmN0aW9uIChjaGlsZCwgZXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Q2hpbGREaXN0KG1vdmVhYmxlLCBjaGlsZCwgZGF0YXMsIGV2KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgc2V0Rml4ZWREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZml4ZWREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgcGFyYW1zLnNldEZpeGVkRGlyZWN0aW9uKGZpeGVkRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBldi5zZXRGaXhlZERpcmVjdGlvbihmaXhlZERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdGFydENoaWxkRGlzdChtb3ZlYWJsZSwgZXYubW92ZWFibGUsIGRhdGFzLCBvcmlnaW5hbEV2ZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGF0YXMuc2V0Rml4ZWREaXJlY3Rpb24gPSBzZXRGaXhlZERpcmVjdGlvbjtcclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsIGV2ZW50czogZXZlbnRzLCBzZXRGaXhlZERpcmVjdGlvbjogc2V0Rml4ZWREaXJlY3Rpb24gfSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlR3JvdXBTdGFydFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICBkYXRhcy5pc1NjYWxlID0gcmVzdWx0ICE9PSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNTY2FsZSA/IG5leHRQYXJhbXMgOiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNTY2FsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVTY2FsZVwiLCBmdW5jdGlvbiAocGFyZW50RXZlbnQpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlU2NhbGVHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyZW50RXZlbnQpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMgfSksIHRydWUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlzdCA9IHBhcmFtcy5kaXN0O1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZVNjYWxlID0gZGF0YXMubW92ZWFibGVTY2FsZTtcclxuICAgICAgICBtb3ZlYWJsZS5zY2FsZSA9IFtcclxuICAgICAgICAgICAgZGlzdFswXSAqIG1vdmVhYmxlU2NhbGVbMF0sXHJcbiAgICAgICAgICAgIGRpc3RbMV0gKiBtb3ZlYWJsZVNjYWxlWzFdLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIGtlZXBSYXRpbyA9IG1vdmVhYmxlLnByb3BzLmtlZXBSYXRpbztcclxuICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGRhdGFzLmZpeGVkUG9zaXRpb247XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRyaWdnZXJDaGlsZEFibGVzKG1vdmVhYmxlLCB0aGlzLCBcImRyYWdDb250cm9sXCIsIGUsIGZ1bmN0aW9uIChfLCBldikge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoY2FsY3VsYXRlKGNyZWF0ZVJvdGF0ZU1hdHJpeChtb3ZlYWJsZS5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEksIDMpLCBbXHJcbiAgICAgICAgICAgICAgICBldi5kYXRhcy5vcmlnaW5hbFggKiBkaXN0WzBdLFxyXG4gICAgICAgICAgICAgICAgZXYuZGF0YXMub3JpZ2luYWxZICogZGlzdFsxXSxcclxuICAgICAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgIF0sIDMpLCAyKSwgY2xpZW50WCA9IF9hWzBdLCBjbGllbnRZID0gX2FbMV07XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXYpLCB7IHBhcmVudERpc3Q6IG51bGwsIHBhcmVudFNjYWxlOiBkaXN0LCBwYXJlbnRLZWVwUmF0aW86IGtlZXBSYXRpbywgXHJcbiAgICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBjaGlsZCBmaXhlZCBwb3NpdGlvbiBmb3IgcGFyZW50IGdyb3VwJ3MgZHJhZ2dpbmcuXHJcbiAgICAgICAgICAgICAgICBkcmFnQ2xpZW50OiBwbHVzKGZpeGVkUG9zaXRpb24sIFtjbGllbnRYLCBjbGllbnRZXSkgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBfX2Fzc2lnbih7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsIGV2ZW50czogZXZlbnRzIH0sIHBhcmFtcyk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uU2NhbGVHcm91cFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV4dFBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgaXNEcmFnID0gZS5pc0RyYWcsIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWRhdGFzLmlzU2NhbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdHJpZ2dlckNoaWxkQWJsZXMobW92ZWFibGUsIHRoaXMsIFwiZHJhZ0NvbnRyb2xFbmRcIiwgZSk7XHJcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBmaWxsRW5kUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsXHJcbiAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblNjYWxlR3JvdXBFbmRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIGlzRHJhZztcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUuU2NhbGFibGUjcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5TY2FsYWJsZVJlcXVlc3RQYXJhbX0gZSAtIHRoZSBTY2FsYWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXHJcbiAgICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxyXG4gICAgICogQGV4YW1wbGVcclxuXG4gICAgICogLy8gSW5zdGFudGx5IFJlcXVlc3QgKHJlcXVlc3RTdGFydCAtIHJlcXVlc3QgLSByZXF1ZXN0RW5kKVxyXG4gICAgICogbW92ZWFibGUucmVxdWVzdChcInNjYWxhYmxlXCIsIHsgZGVsdGFXaWR0aDogMTAsIGRlbHRhSGVpZ2h0OiAxMCB9LCB0cnVlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0U3RhcnRcclxuICAgICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJzY2FsYWJsZVwiKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZXF1ZXN0XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhV2lkdGg6IDEwLCBkZWx0YUhlaWdodDogMTAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVxdWVzdEVuZFxyXG4gICAgICogcmVxdWVzdGVyLnJlcXVlc3RFbmQoKTtcclxuICAgICAqL1xyXG4gICAgcmVxdWVzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IHt9O1xyXG4gICAgICAgIHZhciBkaXN0V2lkdGggPSAwO1xyXG4gICAgICAgIHZhciBkaXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICB2YXIgdXNlU25hcCA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzQ29udHJvbDogdHJ1ZSxcclxuICAgICAgICAgICAgcmVxdWVzdFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdXNlU25hcCA9IGUudXNlU25hcDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERpcmVjdGlvbjogZS5kaXJlY3Rpb24gfHwgWzEsIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZVNuYXA6IHVzZVNuYXAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZGlzdFdpZHRoICs9IGUuZGVsdGFXaWR0aDtcclxuICAgICAgICAgICAgICAgIGRpc3RIZWlnaHQgKz0gZS5kZWx0YUhlaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXM6IGRhdGFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERpc3Q6IFtkaXN0V2lkdGgsIGRpc3RIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEtlZXBSYXRpbzogZS5rZWVwUmF0aW8sXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlU25hcDogdXNlU25hcCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcywgaXNEcmFnOiB0cnVlLCB1c2VTbmFwOiB1c2VTbmFwIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIHNjYWxlZC5cclxuICpcclxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUjc2NhbGFibGVcclxuICogQGRlZmF1bHQgZmFsc2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUuc2NhbGFibGUgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIHRocm90dGxlIG9mIHNjYWxlWCwgc2NhbGVZIHdoZW4gc2NhbGUuXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlNjYWxhYmxlI3Rocm90dGxlU2NhbGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICpcclxuICogbW92ZWFibGUudGhyb3R0bGVTY2FsZSA9IDAuMTtcclxuICovXHJcbi8qKlxyXG4gKiBTZXQgZGlyZWN0aW9ucyB0byBzaG93IHRoZSBjb250cm9sIGJveC4gKGRlZmF1bHQ6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSlcclxuICogQG5hbWUgTW92ZWFibGUuU2NhbGFibGUjcmVuZGVyRGlyZWN0aW9uc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHNjYWxhYmxlOiB0cnVlLFxyXG4gKiAgIHJlbmRlckRpcmVjdGlvbnM6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSxcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLnJlbmRlckRpcmVjdGlvbnMgPSBbXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHJlc2l6ZSBvciBzY2FsZSwga2VlcHMgYSByYXRpbyBvZiB0aGUgd2lkdGgsIGhlaWdodC4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5TY2FsYWJsZSNrZWVwUmF0aW9cclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBzY2FsYWJsZTogdHJ1ZSxcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmtlZXBSYXRpbyA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB0aGUgc2NhbGUgc3RhcnRzLCB0aGUgc2NhbGVTdGFydCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxyXG4gKiBAZXZlbnQgc2NhbGVTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgc2NhbGVTdGFydCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgc2NhbGFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBzY2FsaW5nLCBgYmVmb3JlU2NhbGVgIGlzIGNhbGxlZCBiZWZvcmUgYHNjYWxlYCBvY2N1cnMuIEluIGBiZWZvcmVTY2FsZWAsIHlvdSBjYW4gZ2V0IGFuZCBzZXQgdGhlIHByZS12YWx1ZSBiZWZvcmUgc2NhbGluZy5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjYWxhYmxlXHJcbiAqIEBldmVudCBiZWZvcmVTY2FsZVxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uQmVmb3JlU2NhbGV9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBiZWZvcmVTY2FsZWAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHNjYWxhYmxlOiB0cnVlIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImJlZm9yZVNjYWxlXCIsICh7IHNldEZpeGVkRGlyZWN0aW9uIH0pID0+IHtcclxuICogICAgIGlmIChzaGlmdEtleSkge1xyXG4gKiAgICAgICAgc2V0Rml4ZWREaXJlY3Rpb24oWzAsIDBdKTtcclxuICogICAgIH1cclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVcIiwgKHsgdGFyZ2V0LCB0cmFuc2Zvcm0sIGRpc3QgfSkgPT4ge1xyXG4gKiAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBzY2FsaW5nLCB0aGUgYHNjYWxlYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxyXG4gKiBAZXZlbnQgc2NhbGVcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgc2NhbGVgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyBzY2FsYWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJzY2FsZVwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGlzdCB9KSA9PiB7XHJcbiAqICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBzY2FsZSBmaW5pc2hlcywgdGhlIGBzY2FsZUVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcclxuICogQGV2ZW50IHNjYWxlRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuU2NhbGFibGUuT25TY2FsZUVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgc2NhbGFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2NhbGVFbmRcIiwgKHsgdGFyZ2V0LCBpc0RyYWcgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2codGFyZ2V0LCBpc0RyYWcpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIGdyb3VwIHNjYWxlIHN0YXJ0cywgdGhlIGBzY2FsZUdyb3VwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuU2NhbGFibGVcclxuKiBAZXZlbnQgc2NhbGVHcm91cFN0YXJ0XHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlR3JvdXBTdGFydGAgZXZlbnRcclxuKiBAZXhhbXBsZVxyXG4qIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuKlxyXG4qIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuKiAgICAgc2NhbGFibGU6IHRydWVcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBTdGFydFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coXCJvblNjYWxlR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcclxuKiB9KTtcclxuKi9cclxuLyoqXHJcbiogV2hlbiB0aGUgZ3JvdXAgc2NhbGUsIHRoZSBgc2NhbGVHcm91cGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxyXG4qIEBldmVudCBzY2FsZUdyb3VwXHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5TY2FsYWJsZS5PblNjYWxlR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY2FsZUdyb3VwYCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4qICAgICBzY2FsYWJsZTogdHJ1ZVxyXG4qIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwic2NhbGVHcm91cFwiLCAoeyB0YXJnZXRzLCBldmVudHMgfSkgPT4ge1xyXG4qICAgICBjb25zb2xlLmxvZyhcIm9uU2NhbGVHcm91cFwiLCB0YXJnZXRzKTtcclxuKiAgICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xyXG4qICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4qICAgICAgICAgLy8gZXYuZHJhZyBpcyBhIGRyYWcgZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgZ3JvdXAgc2NhbGUuXHJcbiogICAgICAgICBjb25zdCBsZWZ0ID0gZXYuZHJhZy5iZWZvcmVEaXN0WzBdO1xyXG4qICAgICAgICAgY29uc3QgdG9wID0gZXYuZHJhZy5iZWZvcmVEaXN0WzFdO1xyXG4qICAgICAgICAgY29uc3Qgc2NhbGVYID0gZXYuc2NhbGVbMF07XHJcbiogICAgICAgICBjb25zdCBzY2FsZVkgPSBldi5zY2FsZVsxXTtcclxuKiAgICAgfSk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBncm91cCBzY2FsZSBmaW5pc2hlcywgdGhlIGBzY2FsZUdyb3VwRW5kYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5TY2FsYWJsZVxyXG4gKiBAZXZlbnQgc2NhbGVHcm91cEVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjYWxhYmxlLk9uU2NhbGVHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHNjYWxlR3JvdXBFbmRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogICAgIHNjYWxhYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInNjYWxlR3JvdXBFbmRcIiwgKHsgdGFyZ2V0cywgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25TY2FsZUdyb3VwRW5kXCIsIHRhcmdldHMsIGlzRHJhZyk7XHJcbiAqIH0pO1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWlkZGxlTGluZVBvcyhwb3MxLCBwb3MyKSB7XHJcbiAgICByZXR1cm4gcG9zMS5tYXAoZnVuY3Rpb24gKHBvcywgaSkgeyByZXR1cm4gZG90KHBvcywgcG9zMltpXSwgMSwgMik7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyaWFuZ2xlUmFkKHBvczEsIHBvczIsIHBvczMpIHtcclxuICAgIC8vIHBvczEgUmFkXHJcbiAgICB2YXIgcmFkMSA9IGdldFJhZChwb3MxLCBwb3MyKTtcclxuICAgIHZhciByYWQyID0gZ2V0UmFkKHBvczEsIHBvczMpO1xyXG4gICAgdmFyIHJhZCA9IHJhZDIgLSByYWQxO1xyXG4gICAgcmV0dXJuIHJhZCA+PSAwID8gcmFkIDogcmFkICsgMiAqIE1hdGguUEk7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZFBvcyhwb3NlczEsIHBvc2VzMikge1xyXG4gICAgdmFyIHJhZDEgPSBnZXRUcmlhbmdsZVJhZChwb3NlczFbMF0sIHBvc2VzMVsxXSwgcG9zZXMxWzJdKTtcclxuICAgIHZhciByYWQyID0gZ2V0VHJpYW5nbGVSYWQocG9zZXMyWzBdLCBwb3NlczJbMV0sIHBvc2VzMlsyXSk7XHJcbiAgICB2YXIgcGkgPSBNYXRoLlBJO1xyXG4gICAgaWYgKChyYWQxID49IHBpICYmIHJhZDIgPD0gcGkpIHx8IChyYWQxIDw9IHBpICYmIHJhZDIgPj0gcGkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuV2FycGFibGVcclxuICogQGRlc2NyaXB0aW9uIFdhcnBhYmxlIGluZGljYXRlcyB3aGV0aGVyIHRoZSB0YXJnZXQgY2FuIGJlIHdhcnBlZChkaXN0b3J0ZWQsIGJlbnRlZCkuXHJcbiAqL1xyXG52YXIgV2FycGFibGUgPSB7XHJcbiAgICBuYW1lOiBcIndhcnBhYmxlXCIsXHJcbiAgICBhYmxlR3JvdXA6IFwic2l6ZVwiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcIndhcnBhYmxlXCIsXHJcbiAgICAgICAgXCJyZW5kZXJEaXJlY3Rpb25zXCIsXHJcbiAgICAgICAgXCJlZGdlXCIsXHJcbiAgICAgICAgXCJkaXNwbGF5QXJvdW5kQ29udHJvbHNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcIndhcnBTdGFydFwiLFxyXG4gICAgICAgIFwid2FycFwiLFxyXG4gICAgICAgIFwid2FycEVuZFwiLFxyXG4gICAgXSxcclxuICAgIHZpZXdDbGFzc05hbWU6IGdldERpcmVjdGlvblZpZXdDbGFzc05hbWUoXCJ3YXJwYWJsZVwiKSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCByZXNpemFibGUgPSBfYS5yZXNpemFibGUsIHNjYWxhYmxlID0gX2Euc2NhbGFibGUsIHdhcnBhYmxlID0gX2Eud2FycGFibGUsIHpvb20gPSBfYS56b29tO1xyXG4gICAgICAgIGlmIChyZXNpemFibGUgfHwgc2NhbGFibGUgfHwgIXdhcnBhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuc3RhdGUsIHBvczEgPSBfYi5wb3MxLCBwb3MyID0gX2IucG9zMiwgcG9zMyA9IF9iLnBvczMsIHBvczQgPSBfYi5wb3M0O1xyXG4gICAgICAgIHZhciBsaW5lUG9zRnJvbTEgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczEsIHBvczIpO1xyXG4gICAgICAgIHZhciBsaW5lUG9zRnJvbTIgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczIsIHBvczEpO1xyXG4gICAgICAgIHZhciBsaW5lUG9zRnJvbTMgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczEsIHBvczMpO1xyXG4gICAgICAgIHZhciBsaW5lUG9zRnJvbTQgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczMsIHBvczEpO1xyXG4gICAgICAgIHZhciBsaW5lUG9zVG8xID0gZ2V0TWlkZGxlTGluZVBvcyhwb3MzLCBwb3M0KTtcclxuICAgICAgICB2YXIgbGluZVBvc1RvMiA9IGdldE1pZGRsZUxpbmVQb3MocG9zNCwgcG9zMyk7XHJcbiAgICAgICAgdmFyIGxpbmVQb3NUbzMgPSBnZXRNaWRkbGVMaW5lUG9zKHBvczIsIHBvczQpO1xyXG4gICAgICAgIHZhciBsaW5lUG9zVG80ID0gZ2V0TWlkZGxlTGluZVBvcyhwb3M0LCBwb3MyKTtcclxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShbXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksIGtleTogXCJtaWRkZUxpbmUxXCIsIHN0eWxlOiBnZXRMaW5lU3R5bGUobGluZVBvc0Zyb20xLCBsaW5lUG9zVG8xLCB6b29tKSB9KSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogcHJlZml4KFwibGluZVwiKSwga2V5OiBcIm1pZGRlTGluZTJcIiwgc3R5bGU6IGdldExpbmVTdHlsZShsaW5lUG9zRnJvbTIsIGxpbmVQb3NUbzIsIHpvb20pIH0pLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXgoXCJsaW5lXCIpLCBrZXk6IFwibWlkZGVMaW5lM1wiLCBzdHlsZTogZ2V0TGluZVN0eWxlKGxpbmVQb3NGcm9tMywgbGluZVBvc1RvMywgem9vbSkgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiksIGtleTogXCJtaWRkZUxpbmU0XCIsIHN0eWxlOiBnZXRMaW5lU3R5bGUobGluZVBvc0Zyb200LCBsaW5lUG9zVG80LCB6b29tKSB9KVxyXG4gICAgICAgIF0sIF9fcmVhZChyZW5kZXJBbGxEaXJlY3Rpb25zKG1vdmVhYmxlLCBcIndhcnBhYmxlXCIsIFJlYWN0KSksIGZhbHNlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgaWYgKGUuaXNSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKSAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcIndhcnBhYmxlXCIpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBtb3ZlYWJsZS5wcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgdmFyIGlucHV0VGFyZ2V0ID0gaW5wdXRFdmVudC50YXJnZXQ7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dFRhcmdldCwgZGF0YXMpO1xyXG4gICAgICAgIGlmICghZGlyZWN0aW9uIHx8ICF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luLCBpczNkID0gc3RhdGUuaXMzZCwgdGFyZ2V0VHJhbnNmb3JtID0gc3RhdGUudGFyZ2V0VHJhbnNmb3JtLCB0YXJnZXRNYXRyaXggPSBzdGF0ZS50YXJnZXRNYXRyaXgsIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodCwgbGVmdCA9IHN0YXRlLmxlZnQsIHRvcCA9IHN0YXRlLnRvcDtcclxuICAgICAgICBkYXRhcy5kYXRhcyA9IHt9O1xyXG4gICAgICAgIGRhdGFzLnRhcmdldFRyYW5zZm9ybSA9IHRhcmdldFRyYW5zZm9ybTtcclxuICAgICAgICBkYXRhcy53YXJwVGFyZ2V0TWF0cml4ID0gaXMzZCA/IHRhcmdldE1hdHJpeCA6IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCAzLCA0KTtcclxuICAgICAgICBkYXRhcy50YXJnZXRJbnZlcnNlTWF0cml4ID0gaWdub3JlRGltZW5zaW9uKGludmVydChkYXRhcy53YXJwVGFyZ2V0TWF0cml4LCA0KSwgMywgNCk7XHJcbiAgICAgICAgZGF0YXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG4gICAgICAgIGRhdGFzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIGRhdGFzLnRvcCA9IHRvcDtcclxuICAgICAgICBkYXRhcy5wb3NlcyA9IFtcclxuICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICBbd2lkdGgsIDBdLFxyXG4gICAgICAgICAgICBbMCwgaGVpZ2h0XSxcclxuICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxyXG4gICAgICAgIF0ubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBtaW51cyhwLCB0cmFuc2Zvcm1PcmlnaW4pOyB9KTtcclxuICAgICAgICBkYXRhcy5uZXh0UG9zZXMgPSBkYXRhcy5wb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIHggPSBfYlswXSwgeSA9IF9iWzFdO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlKGRhdGFzLndhcnBUYXJnZXRNYXRyaXgsIFt4LCB5LCAwLCAxXSwgNCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRWYWx1ZSA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KDQpO1xyXG4gICAgICAgIGRhdGFzLnByZXZNYXRyaXggPSBjcmVhdGVJZGVudGl0eU1hdHJpeCg0KTtcclxuICAgICAgICBkYXRhcy5hYnNvbHV0ZVBvc2VzID0gZ2V0QWJzb2x1dGVQb3Nlc0J5U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIGRhdGFzLnBvc0luZGV4ZXMgPSBnZXRQb3NJbmRleGVzQnlEaXJlY3Rpb24oZGlyZWN0aW9uKTtcclxuICAgICAgICBzZXREcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHNldERlZmF1bHRUcmFuc2Zvcm1JbmRleChtb3ZlYWJsZSwgZSwgXCJtYXRyaXgzZFwiKTtcclxuICAgICAgICBzdGF0ZS5zbmFwUmVuZGVySW5mbyA9IHtcclxuICAgICAgICAgICAgcmVxdWVzdDogZS5pc1JlcXVlc3QsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgc2V0OiBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhcy5zdGFydFZhbHVlID0gbWF0cml4O1xyXG4gICAgICAgICAgICB9IH0sIGZpbGxUcmFuc2Zvcm1TdGFydEV2ZW50KG1vdmVhYmxlLCBlKSkpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25XYXJwU3RhcnRcIiwgcGFyYW1zKTtcclxuICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc1dhcnAgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YXMuaXNXYXJwO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBpc1JlcXVlc3QgPSBlLmlzUmVxdWVzdDtcclxuICAgICAgICB2YXIgZGlzdFggPSBlLmRpc3RYLCBkaXN0WSA9IGUuZGlzdFk7XHJcbiAgICAgICAgdmFyIHRhcmdldEludmVyc2VNYXRyaXggPSBkYXRhcy50YXJnZXRJbnZlcnNlTWF0cml4LCBwcmV2TWF0cml4ID0gZGF0YXMucHJldk1hdHJpeCwgaXNXYXJwID0gZGF0YXMuaXNXYXJwLCBzdGFydFZhbHVlID0gZGF0YXMuc3RhcnRWYWx1ZSwgcG9zZXMgPSBkYXRhcy5wb3NlcywgcG9zSW5kZXhlcyA9IGRhdGFzLnBvc0luZGV4ZXMsIGFic29sdXRlUG9zZXMgPSBkYXRhcy5hYnNvbHV0ZVBvc2VzO1xyXG4gICAgICAgIGlmICghaXNXYXJwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZVRyYW5zZm9ybUV2ZW50KG1vdmVhYmxlLCBlLCBcIm1hdHJpeDNkXCIpO1xyXG4gICAgICAgIGlmIChoYXNHdWlkZWxpbmVzKG1vdmVhYmxlLCBcIndhcnBhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFBvc2VzID0gcG9zSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBhYnNvbHV0ZVBvc2VzW2luZGV4XTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFBvc2VzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkUG9zZXMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGVkUG9zZXNbMF1bMF0gKyBzZWxlY3RlZFBvc2VzWzFdWzBdKSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGVkUG9zZXNbMF1bMV0gKyBzZWxlY3RlZFBvc2VzWzFdWzFdKSAvIDIsXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX2EgPSBjaGVja01vdmVhYmxlU25hcEJvdW5kcyhtb3ZlYWJsZSwgaXNSZXF1ZXN0LCB7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBzZWxlY3RlZFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMV0gKyBkaXN0WTsgfSksXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogc2VsZWN0ZWRQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzBdICsgZGlzdFg7IH0pLFxyXG4gICAgICAgICAgICB9KSwgaG9yaXpvbnRhbFNuYXBJbmZvID0gX2EuaG9yaXpvbnRhbCwgdmVydGljYWxTbmFwSW5mbyA9IF9hLnZlcnRpY2FsO1xyXG4gICAgICAgICAgICBkaXN0WSAtPSBob3Jpem9udGFsU25hcEluZm8ub2Zmc2V0O1xyXG4gICAgICAgICAgICBkaXN0WCAtPSB2ZXJ0aWNhbFNuYXBJbmZvLm9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3QgPSBnZXREcmFnRGlzdCh7IGRhdGFzOiBkYXRhcywgZGlzdFg6IGRpc3RYLCBkaXN0WTogZGlzdFkgfSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIG5leHRQb3NlcyA9IGRhdGFzLm5leHRQb3Nlcy5zbGljZSgpO1xyXG4gICAgICAgIHBvc0luZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgbmV4dFBvc2VzW2luZGV4XSA9IHBsdXMobmV4dFBvc2VzW2luZGV4XSwgZGlzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFORUFSQllfUE9TLmV2ZXJ5KGZ1bmN0aW9uIChuZWFyQnlQb3NlcykgeyByZXR1cm4gaXNWYWxpZFBvcyhuZWFyQnlQb3Nlcy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHBvc2VzW2ldOyB9KSwgbmVhckJ5UG9zZXMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBuZXh0UG9zZXNbaV07IH0pKTsgfSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaCA9IGNyZWF0ZVdhcnBNYXRyaXgocG9zZXNbMF0sIHBvc2VzWzJdLCBwb3Nlc1sxXSwgcG9zZXNbM10sIG5leHRQb3Nlc1swXSwgbmV4dFBvc2VzWzJdLCBuZXh0UG9zZXNbMV0sIG5leHRQb3Nlc1szXSk7XHJcbiAgICAgICAgaWYgKCFoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEIgKiBBICogTVxyXG4gICAgICAgIHZhciBhZnRlck1hdHJpeCA9IG11bHRpcGx5KHRhcmdldEludmVyc2VNYXRyaXgsIGgsIDQpO1xyXG4gICAgICAgIC8vIEIgKiBNICogQVxyXG4gICAgICAgIHZhciBtYXRyaXggPSBnZXRUcmFuc2Zyb21NYXRyaXgoZGF0YXMsIGFmdGVyTWF0cml4LCB0cnVlKTtcclxuICAgICAgICB2YXIgZGVsdGEgPSBtdWx0aXBseShpbnZlcnQocHJldk1hdHJpeCwgNCksIG1hdHJpeCwgNCk7XHJcbiAgICAgICAgZGF0YXMucHJldk1hdHJpeCA9IG1hdHJpeDtcclxuICAgICAgICB2YXIgdG90YWxNYXRyaXggPSBtdWx0aXBseShzdGFydFZhbHVlLCBtYXRyaXgsIDQpO1xyXG4gICAgICAgIHZhciBuZXh0VHJhbnNmb3JtID0gY29udmVydFRyYW5zZm9ybUZvcm1hdChkYXRhcywgXCJtYXRyaXgzZChcIi5jb25jYXQodG90YWxNYXRyaXguam9pbihcIiwgXCIpLCBcIilcIiksIFwibWF0cml4M2QoXCIuY29uY2F0KG1hdHJpeC5qb2luKFwiLCBcIiksIFwiKVwiKSk7XHJcbiAgICAgICAgZmlsbE9yaWdpbmFsVHJhbnNmb3JtKGUsIG5leHRUcmFuc2Zvcm0pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbldhcnBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyBkZWx0YTogZGVsdGEsIG1hdHJpeDogdG90YWxNYXRyaXgsIGRpc3Q6IG1hdHJpeCwgbXVsdGlwbHk6IG11bHRpcGx5LCB0cmFuc2Zvcm06IG5leHRUcmFuc2Zvcm0gfSwgZmlsbENTU09iamVjdCh7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybTogbmV4dFRyYW5zZm9ybSxcclxuICAgICAgICB9LCBlKSkpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcywgaXNEcmFnID0gZS5pc0RyYWc7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1dhcnApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5pc1dhcnAgPSBmYWxzZTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25XYXJwRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XHJcbiAgICAgICAgcmV0dXJuIGlzRHJhZztcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHdhcnBlZC4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5XYXJwYWJsZSN3YXJwYWJsZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKlxyXG4gKiBtb3ZlYWJsZS53YXJwYWJsZSA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuKiBTZXQgZGlyZWN0aW9ucyB0byBzaG93IHRoZSBjb250cm9sIGJveC4gKGRlZmF1bHQ6IFtcIm5cIiwgXCJud1wiLCBcIm5lXCIsIFwic1wiLCBcInNlXCIsIFwic3dcIiwgXCJlXCIsIFwid1wiXSlcclxuKiBAbmFtZSBNb3ZlYWJsZS5XYXJwYWJsZSNyZW5kZXJEaXJlY3Rpb25zXHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIHdhcnBhYmxlOiB0cnVlLFxyXG4qICAgICByZW5kZXJEaXJlY3Rpb25zOiBbXCJuXCIsIFwibndcIiwgXCJuZVwiLCBcInNcIiwgXCJzZVwiLCBcInN3XCIsIFwiZVwiLCBcIndcIl0sXHJcbiogfSk7XHJcbipcclxuKiBtb3ZlYWJsZS5yZW5kZXJEaXJlY3Rpb25zID0gW1wibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl07XHJcbiovXHJcbi8qKlxyXG4qIFdoZW4gdGhlIHdhcnAgc3RhcnRzLCB0aGUgd2FycFN0YXJ0IGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuV2FycGFibGVcclxuKiBAZXZlbnQgd2FycFN0YXJ0XHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5XYXJwYWJsZS5PbldhcnBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgd2FycFN0YXJ0IGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7IHdhcnBhYmxlOiB0cnVlIH0pO1xyXG4qIG1vdmVhYmxlLm9uKFwid2FycFN0YXJ0XCIsICh7IHRhcmdldCB9KSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKHRhcmdldCk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4gKiBXaGVuIHdhcnBpbmcsIHRoZSB3YXJwIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLldhcnBhYmxlXHJcbiAqIEBldmVudCB3YXJwXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuV2FycGFibGUuT25XYXJwfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB3YXJwIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICogbGV0IG1hdHJpeCA9IFtcclxuICogIDEsIDAsIDAsIDAsXHJcbiAqICAwLCAxLCAwLCAwLFxyXG4gKiAgMCwgMCwgMSwgMCxcclxuICogIDAsIDAsIDAsIDEsXHJcbiAqIF07XHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHsgd2FycGFibGU6IHRydWUgfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwid2FycFwiLCAoeyB0YXJnZXQsIHRyYW5zZm9ybSwgZGVsdGEsIG11bHRpcGx5IH0pID0+IHtcclxuICogICAgLy8gdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICogICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCBkZWx0YSk7XHJcbiAqICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBgbWF0cml4M2QoJHttYXRyaXguam9pbihcIixcIil9KWA7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gdGhlIHdhcnAgZmluaXNoZXMsIHRoZSB3YXJwRW5kIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLldhcnBhYmxlXHJcbiAqIEBldmVudCB3YXJwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuV2FycGFibGUuT25XYXJwRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSB3YXJwRW5kIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwgeyB3YXJwYWJsZTogdHJ1ZSB9KTtcclxuICogbW92ZWFibGUub24oXCJ3YXJwRW5kXCIsICh7IHRhcmdldCwgaXNEcmFnIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKHRhcmdldCwgaXNEcmFnKTtcclxuICogfSk7XHJcbiAqL1xuXG52YXIgQVJFQV9QSUVDRVMgPSAvKiNfX1BVUkVfXyovIHByZWZpeChcImFyZWEtcGllY2VzXCIpO1xyXG52YXIgQVJFQV9QSUVDRSA9IC8qI19fUFVSRV9fKi8gcHJlZml4KFwiYXJlYS1waWVjZVwiKTtcclxudmFyIEFWT0lEID0gLyojX19QVVJFX18qLyBwcmVmaXgoXCJhdm9pZFwiKTtcclxudmFyIFZJRVdfRFJBR0dJTkcgPSBwcmVmaXgoXCJ2aWV3LWRyYWdnaW5nXCIpO1xuXG5mdW5jdGlvbiByZXN0b3JlU3R5bGUobW92ZWFibGUpIHtcclxuICAgIHZhciBlbCA9IG1vdmVhYmxlLmFyZWFFbGVtZW50O1xyXG4gICAgaWYgKCFlbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICByZW1vdmVDbGFzcyhlbCwgQVZPSUQpO1xyXG4gICAgZWwuc3R5bGUuY3NzVGV4dCArPSBcImxlZnQ6IDBweDsgdG9wOiAwcHg7IHdpZHRoOiBcIi5jb25jYXQod2lkdGgsIFwicHg7IGhlaWdodDogXCIpLmNvbmNhdChoZWlnaHQsIFwicHhcIik7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyUGllY2VzKFJlYWN0KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiYXJlYV9waWVjZXNcIiwgY2xhc3NOYW1lOiBBUkVBX1BJRUNFUyB9LFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IEFSRUFfUElFQ0UgfSksXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogQVJFQV9QSUVDRSB9KSxcclxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBBUkVBX1BJRUNFIH0pLFxyXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IEFSRUFfUElFQ0UgfSkpKTtcclxufVxyXG52YXIgRHJhZ0FyZWEgPSB7XHJcbiAgICBuYW1lOiBcImRyYWdBcmVhXCIsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwiZHJhZ0FyZWFcIixcclxuICAgICAgICBcInBhc3NEcmFnQXJlYVwiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwiY2xpY2tcIixcclxuICAgICAgICBcImNsaWNrR3JvdXBcIixcclxuICAgIF0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgdGFyZ2V0ID0gX2EudGFyZ2V0LCBkcmFnQXJlYSA9IF9hLmRyYWdBcmVhLCBncm91cGFibGUgPSBfYS5ncm91cGFibGUsIHBhc3NEcmFnQXJlYSA9IF9hLnBhc3NEcmFnQXJlYTtcclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCB3aWR0aCA9IF9iLndpZHRoLCBoZWlnaHQgPSBfYi5oZWlnaHQsIHJlbmRlclBvc2VzID0gX2IucmVuZGVyUG9zZXM7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHBhc3NEcmFnQXJlYSA/IHByZWZpeChcImFyZWFcIiwgXCJwYXNzXCIpIDogcHJlZml4KFwiYXJlYVwiKTtcclxuICAgICAgICBpZiAoZ3JvdXBhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImFyZWFcIiwgcmVmOiByZWYobW92ZWFibGUsIFwiYXJlYUVsZW1lbnRcIiksIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0pLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyUGllY2VzKFJlYWN0KSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIWRyYWdBcmVhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGggPSBjcmVhdGVXYXJwTWF0cml4KFswLCAwXSwgW3dpZHRoLCAwXSwgWzAsIGhlaWdodF0sIFt3aWR0aCwgaGVpZ2h0XSwgcmVuZGVyUG9zZXNbMF0sIHJlbmRlclBvc2VzWzFdLCByZW5kZXJQb3Nlc1syXSwgcmVuZGVyUG9zZXNbM10pO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBoLmxlbmd0aCA/IG1ha2VNYXRyaXhDU1MoaCwgdHJ1ZSkgOiBcIm5vbmVcIjtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImFyZWFcIiwgcmVmOiByZWYobW92ZWFibGUsIFwiYXJlYUVsZW1lbnRcIiksIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogXCIwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIjBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiMCAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgICAgICB9IH0pLFxyXG4gICAgICAgICAgICByZW5kZXJQaWVjZXMoUmVhY3QpLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIF9hKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WSwgaW5wdXRFdmVudCA9IF9hLmlucHV0RXZlbnQ7XHJcbiAgICAgICAgaWYgKCFpbnB1dEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMuaXNEcmFnQXJlYSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBhcmVhRWxlbWVudCA9IG1vdmVhYmxlLmFyZWFFbGVtZW50O1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZUNsaWVudFJlY3QgPSBzdGF0ZS5tb3ZlYWJsZUNsaWVudFJlY3QsIHJlbmRlclBvc2VzID0gc3RhdGUucmVuZGVyUG9zZXMsIHJvb3RNYXRyaXggPSBzdGF0ZS5yb290TWF0cml4LCBpczNkID0gc3RhdGUuaXMzZDtcclxuICAgICAgICB2YXIgbGVmdCA9IG1vdmVhYmxlQ2xpZW50UmVjdC5sZWZ0LCB0b3AgPSBtb3ZlYWJsZUNsaWVudFJlY3QudG9wO1xyXG4gICAgICAgIHZhciBfYiA9IGdldFJlY3QocmVuZGVyUG9zZXMpLCByZWxhdGl2ZUxlZnQgPSBfYi5sZWZ0LCByZWxhdGl2ZVRvcCA9IF9iLnRvcCwgd2lkdGggPSBfYi53aWR0aCwgaGVpZ2h0ID0gX2IuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgIHZhciBfYyA9IF9fcmVhZChjYWxjdWxhdGVJbnZlcnNlUG9zaXRpb24ocm9vdE1hdHJpeCwgW2NsaWVudFggLSBsZWZ0LCBjbGllbnRZIC0gdG9wXSwgbiksIDIpLCBwb3NYID0gX2NbMF0sIHBvc1kgPSBfY1sxXTtcclxuICAgICAgICBwb3NYIC09IHJlbGF0aXZlTGVmdDtcclxuICAgICAgICBwb3NZIC09IHJlbGF0aXZlVG9wO1xyXG4gICAgICAgIHZhciByZWN0cyA9IFtcclxuICAgICAgICAgICAgeyBsZWZ0OiByZWxhdGl2ZUxlZnQsIHRvcDogcmVsYXRpdmVUb3AsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBwb3NZIC0gMTAgfSxcclxuICAgICAgICAgICAgeyBsZWZ0OiByZWxhdGl2ZUxlZnQsIHRvcDogcmVsYXRpdmVUb3AsIHdpZHRoOiBwb3NYIC0gMTAsIGhlaWdodDogaGVpZ2h0IH0sXHJcbiAgICAgICAgICAgIHsgbGVmdDogcmVsYXRpdmVMZWZ0LCB0b3A6IHJlbGF0aXZlVG9wICsgcG9zWSArIDEwLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IC0gcG9zWSAtIDEwIH0sXHJcbiAgICAgICAgICAgIHsgbGVmdDogcmVsYXRpdmVMZWZ0ICsgcG9zWCArIDEwLCB0b3A6IHJlbGF0aXZlVG9wLCB3aWR0aDogd2lkdGggLSBwb3NYIC0gMTAsIGhlaWdodDogaGVpZ2h0IH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKGFyZWFFbGVtZW50Lm5leHRFbGVtZW50U2libGluZy5jaGlsZHJlbik7XHJcbiAgICAgICAgcmVjdHMuZm9yRWFjaChmdW5jdGlvbiAocmVjdCwgaSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5jc3NUZXh0XHJcbiAgICAgICAgICAgICAgICA9IFwibGVmdDogXCIuY29uY2F0KHJlY3QubGVmdCwgXCJweDt0b3A6IFwiKS5jb25jYXQocmVjdC50b3AsIFwicHg7IHdpZHRoOiBcIikuY29uY2F0KHJlY3Qud2lkdGgsIFwicHg7IGhlaWdodDogXCIpLmNvbmNhdChyZWN0LmhlaWdodCwgXCJweDtcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkQ2xhc3MoYXJlYUVsZW1lbnQsIEFWT0lEKTtcclxuICAgICAgICBzdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0sXHJcbiAgICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIF9hKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gX2EuZGF0YXMsIGlucHV0RXZlbnQgPSBfYS5pbnB1dEV2ZW50O1xyXG4gICAgICAgIHRoaXMuZW5hYmxlTmF0aXZlRXZlbnQobW92ZWFibGUpO1xyXG4gICAgICAgIGlmICghaW5wdXRFdmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGF0YXMuaXNEcmFnQXJlYSkge1xyXG4gICAgICAgICAgICBkYXRhcy5pc0RyYWdBcmVhID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVOYXRpdmVFdmVudChtb3ZlYWJsZSk7XHJcbiAgICAgICAgdmFyIGlucHV0RXZlbnQgPSBlLmlucHV0RXZlbnQsIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBpZiAoIWlucHV0RXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRhdGFzLmlzRHJhZ0FyZWEpIHtcclxuICAgICAgICAgICAgcmVzdG9yZVN0eWxlKG1vdmVhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICByZXN0b3JlU3R5bGUobW92ZWFibGUpO1xyXG4gICAgICAgIG1vdmVhYmxlLnN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCA9IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGVuYWJsZU5hdGl2ZUV2ZW50OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUuZGlzYWJsZU5hdGl2ZUV2ZW50KSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlTmF0aXZlRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiAqIEFkZCBhbiBldmVudCB0byB0aGUgbW92ZWFibGUgYXJlYSBpbnN0ZWFkIG9mIHRoZSB0YXJnZXQgZm9yIHN0b3BQcm9wYWdhdGlvbi4gKGRlZmF1bHQ6IGZhbHNlLCB0cnVlIGluIGdyb3VwKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZSNkcmFnQXJlYVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogIGRyYWdBcmVhOiBmYWxzZSxcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogU2V0IGBwb2ludGVyRXZlbnRzOiBub25lO2AgY3NzIHRvIHBhc3MgZXZlbnRzIGluIGRyYWdBcmVhLiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlI3Bhc3NEcmFnQXJlYVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogIGRyYWdBcmVhOiBmYWxzZSxcclxuICogfSk7XHJcbiAqL1xuXG52YXIgT3JpZ2luID0gbWFrZUFibGUoXCJvcmlnaW5cIiwge1xyXG4gICAgcHJvcHM6IFtcIm9yaWdpblwiLCBcInN2Z09yaWdpblwiXSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBSZWFjdCkge1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCB6b29tID0gX2Euem9vbSwgc3ZnT3JpZ2luID0gX2Euc3ZnT3JpZ2luLCBncm91cGFibGUgPSBfYS5ncm91cGFibGU7XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgYmVmb3JlT3JpZ2luID0gX2IuYmVmb3JlT3JpZ2luLCByb3RhdGlvbiA9IF9iLnJvdGF0aW9uLCBzdmcgPSBfYi5zdmcsIGFsbE1hdHJpeCA9IF9iLmFsbE1hdHJpeCwgaXMzZCA9IF9iLmlzM2QsIGxlZnQgPSBfYi5sZWZ0LCB0b3AgPSBfYi50b3AsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcclxuICAgICAgICB2YXIgb3JpZ2luU3R5bGU7XHJcbiAgICAgICAgaWYgKCFncm91cGFibGUgJiYgc3ZnICYmIHN2Z09yaWdpbikge1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfX3JlYWQoY29udmVydFRyYW5zZm9ybU9yaWdpbkFycmF5KHN2Z09yaWdpbiwgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCksIDIpLCBvcmlnaW5YID0gX2NbMF0sIG9yaWdpblkgPSBfY1sxXTtcclxuICAgICAgICAgICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIFtvcmlnaW5YLCBvcmlnaW5ZXSwgbik7XHJcbiAgICAgICAgICAgIG9yaWdpblN0eWxlID0gZ2V0Q29udHJvbFRyYW5zZm9ybShyb3RhdGlvbiwgem9vbSwgbWludXMocmVzdWx0LCBbbGVmdCwgdG9wXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3JpZ2luU3R5bGUgPSBnZXRDb250cm9sVHJhbnNmb3JtKHJvdGF0aW9uLCB6b29tLCBiZWZvcmVPcmlnaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sXCIsIFwib3JpZ2luXCIpLCBzdHlsZTogb3JpZ2luU3R5bGUsIGtleTogXCJiZWZvcmVPcmlnaW5cIiB9KSxcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3JpZ2luIGNvbnRyb2xib3ggd2lsbCBiZSB2aXNpYmxlIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcclxuICogQG5hbWUgTW92ZWFibGUjb3JpZ2luXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLm9yaWdpbiA9IHRydWU7XHJcbiAqL1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2Nyb2xsUG9zaXRpb24oZSkge1xyXG4gICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IGUuc2Nyb2xsQ29udGFpbmVyO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCxcclxuICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wLFxyXG4gICAgXTtcclxufVxyXG4vKipcclxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5TY3JvbGxhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIG9yIG5vdCB0YXJnZXQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZSBzY3JvbGwgY29udGFpbmVyIChkZWZhdWx0OiBmYWxzZSlcclxuICovXHJcbnZhciBTY3JvbGxhYmxlID0ge1xyXG4gICAgbmFtZTogXCJzY3JvbGxhYmxlXCIsXHJcbiAgICBjYW5QaW5jaDogdHJ1ZSxcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJzY3JvbGxhYmxlXCIsXHJcbiAgICAgICAgXCJzY3JvbGxDb250YWluZXJcIixcclxuICAgICAgICBcInNjcm9sbFRocmVzaG9sZFwiLFxyXG4gICAgICAgIFwic2Nyb2xsVGhyb3R0bGVUaW1lXCIsXHJcbiAgICAgICAgXCJnZXRTY3JvbGxQb3NpdGlvblwiLFxyXG4gICAgICAgIFwic2Nyb2xsT3B0aW9uc1wiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwic2Nyb2xsXCIsXHJcbiAgICAgICAgXCJzY3JvbGxHcm91cFwiLFxyXG4gICAgXSxcclxuICAgIGRyYWdSZWxhdGlvbjogXCJzdHJvbmdcIixcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgdmFyIF9hID0gcHJvcHMuc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxDb250YWluZXIgPSBfYSA9PT0gdm9pZCAwID8gbW92ZWFibGUuZ2V0Q29udGFpbmVyKCkgOiBfYSwgc2Nyb2xsT3B0aW9ucyA9IHByb3BzLnNjcm9sbE9wdGlvbnM7XHJcbiAgICAgICAgdmFyIGRyYWdTY3JvbGwgPSBuZXcgRHJhZ1Njcm9sbCgpO1xyXG4gICAgICAgIHZhciBzY3JvbGxDb250YWluZXJFbGVtZW50ID0gZ2V0UmVmVGFyZ2V0KHNjcm9sbENvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICAgICAgZS5kYXRhcy5kcmFnU2Nyb2xsID0gZHJhZ1Njcm9sbDtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5kcmFnU2Nyb2xsID0gZHJhZ1Njcm9sbDtcclxuICAgICAgICB2YXIgZ2VzdG9OYW1lID0gZS5pc0NvbnRyb2wgPyBcImNvbnRyb2xHZXN0b1wiIDogXCJ0YXJnZXRHZXN0b1wiO1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gZS50YXJnZXRzO1xyXG4gICAgICAgIGRyYWdTY3JvbGwub24oXCJzY3JvbGxcIiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gdGFyZ2V0cyA/IFwib25TY3JvbGxHcm91cFwiIDogXCJvblNjcm9sbFwiO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0cykge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldHMgPSB0YXJnZXRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgZXZlbnROYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pLm9uKFwibW92ZVwiLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldFggPSBfYS5vZmZzZXRYLCBvZmZzZXRZID0gX2Eub2Zmc2V0WSwgaW5wdXRFdmVudCA9IF9hLmlucHV0RXZlbnQ7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlW2dlc3RvTmFtZV0uc2Nyb2xsQnkob2Zmc2V0WCwgb2Zmc2V0WSwgaW5wdXRFdmVudC5pbnB1dEV2ZW50LCBmYWxzZSk7XHJcbiAgICAgICAgfSkub24oXCJzY3JvbGxEcmFnXCIsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IF9hLm5leHQ7XHJcbiAgICAgICAgICAgIG5leHQobW92ZWFibGVbZ2VzdG9OYW1lXS5nZXRDdXJyZW50RXZlbnQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZHJhZ1Njcm9sbC5kcmFnU3RhcnQoZSwgX19hc3NpZ24oeyBjb250YWluZXI6IHNjcm9sbENvbnRhaW5lckVsZW1lbnQgfSwgc2Nyb2xsT3B0aW9ucykpO1xyXG4gICAgfSxcclxuICAgIGNoZWNrU2Nyb2xsOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZHJhZ1Njcm9sbCA9IGUuZGF0YXMuZHJhZ1Njcm9sbDtcclxuICAgICAgICBpZiAoIWRyYWdTY3JvbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcywgX2IgPSBfYS5zY3JvbGxDb250YWluZXIsIHNjcm9sbENvbnRhaW5lciA9IF9iID09PSB2b2lkIDAgPyBtb3ZlYWJsZS5nZXRDb250YWluZXIoKSA6IF9iLCBfYyA9IF9hLnNjcm9sbFRocmVzaG9sZCwgc2Nyb2xsVGhyZXNob2xkID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgX2QgPSBfYS5zY3JvbGxUaHJvdHRsZVRpbWUsIHNjcm9sbFRocm90dGxlVGltZSA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gX2EuZ2V0U2Nyb2xsUG9zaXRpb24sIGdldFNjcm9sbFBvc2l0aW9uID0gX2UgPT09IHZvaWQgMCA/IGdldERlZmF1bHRTY3JvbGxQb3NpdGlvbiA6IF9lLCBzY3JvbGxPcHRpb25zID0gX2Euc2Nyb2xsT3B0aW9ucztcclxuICAgICAgICBkcmFnU2Nyb2xsLmRyYWcoZSwgX19hc3NpZ24oeyBjb250YWluZXI6IHNjcm9sbENvbnRhaW5lciwgdGhyZXNob2xkOiBzY3JvbGxUaHJlc2hvbGQsIHRocm90dGxlVGltZTogc2Nyb2xsVGhyb3R0bGVUaW1lLCBnZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2Nyb2xsUG9zaXRpb24oeyBzY3JvbGxDb250YWluZXI6IGV2LmNvbnRhaW5lciwgZGlyZWN0aW9uOiBldi5kaXJlY3Rpb24gfSk7XHJcbiAgICAgICAgICAgIH0gfSwgc2Nyb2xsT3B0aW9ucykpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrU2Nyb2xsKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICBlLmRhdGFzLmRyYWdTY3JvbGwuZHJhZ0VuZCgpO1xyXG4gICAgICAgIGUuZGF0YXMuZHJhZ1Njcm9sbCA9IG51bGw7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZSksIHsgaXNDb250cm9sOiB0cnVlIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWcobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdFbmQobW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMsIGlzQ29udHJvbDogdHJ1ZSB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHRhcmdldHM6IG1vdmVhYmxlLnByb3BzLnRhcmdldHMgfSkpO1xyXG4gICAgfSxcclxuICAgIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgKF9hID0gc3RhdGUuZHJhZ1Njcm9sbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYWdFbmQoKTtcclxuICAgICAgICBzdGF0ZS5kcmFnU2Nyb2xsID0gbnVsbDtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBkcmFnIGN1cnNvciBsZWF2ZXMgdGhlIHNjcm9sbENvbnRhaW5lciwgdGhlIGBzY3JvbGxgIGV2ZW50IG9jY3VyIHRvIHNjcm9sbC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlNjcm9sbGFibGVcclxuICogQGV2ZW50IHNjcm9sbFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlNjcm9sbGFibGUuT25TY3JvbGx9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY3JvbGxgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwic2Nyb2xsXCIsICh7IHNjcm9sbENvbnRhaW5lciwgZGlyZWN0aW9uIH0pID0+IHtcclxuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBkaXJlY3Rpb25bMF0gKiAxMDtcclxuICogICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wICs9IGRpcmVjdGlvblsxXSAqIDEwO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIHRoZSBkcmFnIGN1cnNvciBsZWF2ZXMgdGhlIHNjcm9sbENvbnRhaW5lciwgdGhlIGBzY3JvbGxHcm91cGAgZXZlbnQgb2NjdXIgdG8gc2Nyb2xsIGluIGdyb3VwLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuU2Nyb2xsYWJsZVxyXG4gKiBAZXZlbnQgc2Nyb2xsR3JvdXBcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5TY3JvbGxhYmxlLk9uU2Nyb2xsR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBzY3JvbGxHcm91cGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJzY3JvbGxcIiwgKHsgc2Nyb2xsQ29udGFpbmVyLCBkaXJlY3Rpb24gfSkgPT4ge1xyXG4gKiAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IGRpcmVjdGlvblswXSAqIDEwO1xyXG4gKiAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKz0gZGlyZWN0aW9uWzFdICogMTA7XHJcbiAqIH0pO1xyXG4gKi9cblxudmFyIERlZmF1bHQgPSB7XHJcbiAgICBuYW1lOiBcIlwiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcInRhcmdldFwiLFxyXG4gICAgICAgIFwiZHJhZ1RhcmdldFNlbGZcIixcclxuICAgICAgICBcImRyYWdUYXJnZXRcIixcclxuICAgICAgICBcImRyYWdDb250YWluZXJcIixcclxuICAgICAgICBcImNvbnRhaW5lclwiLFxyXG4gICAgICAgIFwid2FycFNlbGZcIixcclxuICAgICAgICBcInJvb3RDb250YWluZXJcIixcclxuICAgICAgICBcInVzZVJlc2l6ZU9ic2VydmVyXCIsXHJcbiAgICAgICAgXCJ1c2VNdXRhdGlvbk9ic2VydmVyXCIsXHJcbiAgICAgICAgXCJ6b29tXCIsXHJcbiAgICAgICAgXCJkcmFnRm9jdXNlZElucHV0XCIsXHJcbiAgICAgICAgXCJ0cmFuc2Zvcm1PcmlnaW5cIixcclxuICAgICAgICBcImFibGVzXCIsXHJcbiAgICAgICAgXCJjbGFzc05hbWVcIixcclxuICAgICAgICBcInBpbmNoVGhyZXNob2xkXCIsXHJcbiAgICAgICAgXCJwaW5jaE91dHNpZGVcIixcclxuICAgICAgICBcInRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5XCIsXHJcbiAgICAgICAgXCJjaGVja0lucHV0XCIsXHJcbiAgICAgICAgXCJjc3BOb25jZVwiLFxyXG4gICAgICAgIFwidHJhbnNsYXRlWlwiLFxyXG4gICAgICAgIFwiaGlkZURlZmF1bHRMaW5lc1wiLFxyXG4gICAgICAgIFwicHJvcHNcIixcclxuICAgICAgICBcImZsdXNoU3luY1wiLFxyXG4gICAgICAgIFwic3RvcFByb3BhZ2F0aW9uXCIsXHJcbiAgICAgICAgXCJwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZ1wiLFxyXG4gICAgICAgIFwicHJldmVudENsaWNrRGVmYXVsdFwiLFxyXG4gICAgICAgIFwidmlld0NvbnRhaW5lclwiLFxyXG4gICAgICAgIFwicGVyc2lzdERhdGFcIixcclxuICAgICAgICBcInVzZUFjY3VyYXRlUG9zaXRpb25cIixcclxuICAgICAgICBcImZpcnN0UmVuZGVyU3RhdGVcIixcclxuICAgICAgICBcImxpbmVQYWRkaW5nXCIsXHJcbiAgICAgICAgXCJjb250cm9sUGFkZGluZ1wiLFxyXG4gICAgICAgIFwicHJldmVudERlZmF1bHRcIixcclxuICAgICAgICBcInByZXZlbnRSaWdodENsaWNrXCIsXHJcbiAgICAgICAgXCJwcmV2ZW50V2hlZWxDbGlja1wiLFxyXG4gICAgICAgIFwicmVxdWVzdFN0eWxlc1wiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwiY2hhbmdlVGFyZ2V0c1wiLFxyXG4gICAgXSxcclxufTtcblxudmFyIFBhZGRpbmcgPSBtYWtlQWJsZShcInBhZGRpbmdcIiwge1xyXG4gICAgcHJvcHM6IFtcInBhZGRpbmdcIl0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgICAgICBpZiAocHJvcHMuZHJhZ0FyZWEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBnZXRQYWRkaW5nQm94KHByb3BzLnBhZGRpbmcgfHwge30pLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0LCBib3R0b20gPSBfYS5ib3R0b207XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgcmVuZGVyUG9zZXMgPSBfYi5yZW5kZXJQb3NlcywgcG9zMSA9IF9iLnBvczEsIHBvczIgPSBfYi5wb3MyLCBwb3MzID0gX2IucG9zMywgcG9zNCA9IF9iLnBvczQ7XHJcbiAgICAgICAgdmFyIHBvc2VzID0gW3BvczEsIHBvczIsIHBvczMsIHBvczRdO1xyXG4gICAgICAgIHZhciBwYWRkaW5nRGlyZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGlmIChsZWZ0ID4gMCkge1xyXG4gICAgICAgICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFswLCAyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b3AgPiAwKSB7XHJcbiAgICAgICAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzAsIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICBwYWRkaW5nRGlyZWN0aW9ucy5wdXNoKFsxLCAzXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3R0b20gPiAwKSB7XHJcbiAgICAgICAgICAgIHBhZGRpbmdEaXJlY3Rpb25zLnB1c2goWzIsIDNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhZGRpbmdEaXJlY3Rpb25zLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgZGlyMSA9IF9iWzBdLCBkaXIyID0gX2JbMV07XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nUG9zMSA9IHBvc2VzW2RpcjFdO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1BvczIgPSBwb3Nlc1tkaXIyXTtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdQb3MzID0gcmVuZGVyUG9zZXNbZGlyMV07XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nUG9zNCA9IHJlbmRlclBvc2VzW2RpcjJdO1xyXG4gICAgICAgICAgICB2YXIgaCA9IGNyZWF0ZVdhcnBNYXRyaXgoWzAsIDBdLCBbMTAwLCAwXSwgWzAsIDEwMF0sIFsxMDAsIDEwMF0sIHBhZGRpbmdQb3MxLCBwYWRkaW5nUG9zMiwgcGFkZGluZ1BvczMsIHBhZGRpbmdQb3M0KTtcclxuICAgICAgICAgICAgaWYgKCFoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwicGFkZGluZ1wiLmNvbmNhdChpKSwgY2xhc3NOYW1lOiBwcmVmaXgoXCJwYWRkaW5nXCIpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogbWFrZU1hdHJpeENTUyhoLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxufSk7XHJcbi8qKlxyXG4gKiBBZGQgcGFkZGluZyBhcm91bmQgdGhlIHRhcmdldCB0byBpbmNyZWFzZSB0aGUgZHJhZyBhcmVhLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZSNwYWRkaW5nXHJcbiAqIEBkZWZhdWx0IG51bGxcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxyXG4gKiAgcGFkZGluZzogeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLnBhZGRpbmcgPSB7IGxlZnQ6IDEwLCB0b3A6IDEwLCByaWdodDogMTAsIGJvdHRvbTogMTAgfSxcclxuICogbW92ZWFibGUudXBkYXRlUmVjdCgpO1xyXG4gKi9cblxudmFyIFJBRElVU19ESVJFQ1RJT05TID0gW1wibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIl07XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVJhdGlvKHZhbHVlcywgc2l6ZSkge1xyXG4gICAgdmFyIHN1bVNpemUgPSB2YWx1ZXNbMF0gKyB2YWx1ZXNbMV07XHJcbiAgICB2YXIgc3VtUmF0aW8gPSBzdW1TaXplID4gc2l6ZSA/IHNpemUgLyBzdW1TaXplIDogMTtcclxuICAgIHZhbHVlc1swXSAqPSBzdW1SYXRpbztcclxuICAgIHZhbHVlc1sxXSA9IHNpemUgLSB2YWx1ZXNbMV0gKiBzdW1SYXRpbztcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn1cclxudmFyIEhPUklaT05UQUxfUkFESVVTX09SREVSID0gWzEsIDIsIDUsIDZdO1xyXG52YXIgVkVSVElDQUxfUkFESVVTX09SREVSID0gWzAsIDMsIDQsIDddO1xyXG52YXIgSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OUyA9IFsxLCAtMSwgLTEsIDFdO1xyXG52YXIgVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlMgPSBbMSwgMSwgLTEsIC0xXTtcclxuZnVuY3Rpb24gZ2V0UmFkaXVzU3R5bGVzKG5leHRQb3NlcywgaXNSZWxhdGl2ZSwgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XHJcbiAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSAwOyB9XHJcbiAgICBpZiAodG9wID09PSB2b2lkIDApIHsgdG9wID0gMDsgfVxyXG4gICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSB3aWR0aDsgfVxyXG4gICAgaWYgKGJvdHRvbSA9PT0gdm9pZCAwKSB7IGJvdHRvbSA9IGhlaWdodDsgfVxyXG4gICAgdmFyIGNsaXBTdHlsZXMgPSBbXTtcclxuICAgIHZhciBpc1ZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICB2YXIgcmFkaXVzUG9zZXMgPSBuZXh0UG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuICFwb3MudmlydHVhbDsgfSk7XHJcbiAgICB2YXIgcmF3cyA9IHJhZGl1c1Bvc2VzLm1hcChmdW5jdGlvbiAocG9zSW5mbykge1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsID0gcG9zSW5mby5ob3Jpem9udGFsLCB2ZXJ0aWNhbCA9IHBvc0luZm8udmVydGljYWwsIHBvcyA9IHBvc0luZm8ucG9zO1xyXG4gICAgICAgIGlmICh2ZXJ0aWNhbCAmJiAhaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICAgICAgY2xpcFN0eWxlcy5wdXNoKFwiL1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgdmFyIHJhd1BvcyA9IE1hdGgubWF4KDAsIHZlcnRpY2FsID09PSAxID8gcG9zWzFdIC0gdG9wIDogYm90dG9tIC0gcG9zWzFdKTtcclxuICAgICAgICAgICAgY2xpcFN0eWxlcy5wdXNoKGNvbnZlcnRDU1NTaXplKHJhd1BvcywgaGVpZ2h0LCBpc1JlbGF0aXZlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdQb3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmF3UG9zID0gTWF0aC5tYXgoMCwgaG9yaXpvbnRhbCA9PT0gMSA/IHBvc1swXSAtIGxlZnQgOiByaWdodCAtIHBvc1swXSk7XHJcbiAgICAgICAgICAgIGNsaXBTdHlsZXMucHVzaChjb252ZXJ0Q1NTU2l6ZShyYXdQb3MsIHdpZHRoLCBpc1JlbGF0aXZlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdQb3M7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJhZGl1c1Bvc2VzOiByYWRpdXNQb3NlcyxcclxuICAgICAgICBzdHlsZXM6IGNsaXBTdHlsZXMsXHJcbiAgICAgICAgcmF3czogcmF3cyxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmFkaXVzUmFuZ2UoY29udHJvbFBvc2VzKSB7XHJcbiAgICAvLyBbc3RhcnQsIGxlbmd0aF1cclxuICAgIHZhciBob3Jpem9udGFsUmFuZ2UgPSBbMCwgMF07XHJcbiAgICB2YXIgdmVydGljYWxSYW5nZSA9IFswLCAwXTtcclxuICAgIHZhciBsZW5ndGggPSBjb250cm9sUG9zZXMubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBjbGlwUG9zZSA9IGNvbnRyb2xQb3Nlc1tpXTtcclxuICAgICAgICBpZiAoIWNsaXBQb3NlLnN1Yikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsaXBQb3NlLmhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgaWYgKGhvcml6b250YWxSYW5nZVsxXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbFJhbmdlWzBdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3Jpem9udGFsUmFuZ2VbMV0gPSBpIC0gaG9yaXpvbnRhbFJhbmdlWzBdICsgMTtcclxuICAgICAgICAgICAgdmVydGljYWxSYW5nZVswXSA9IGkgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xpcFBvc2UudmVydGljYWwpIHtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsUmFuZ2VbMV0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsUmFuZ2VbMF0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZlcnRpY2FsUmFuZ2VbMV0gPSBpIC0gdmVydGljYWxSYW5nZVswXSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBob3Jpem9udGFsUmFuZ2U6IGhvcml6b250YWxSYW5nZSxcclxuICAgICAgICB2ZXJ0aWNhbFJhbmdlOiB2ZXJ0aWNhbFJhbmdlLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRSYWRpdXNWYWx1ZXModmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AsIG1pbkNvdW50cywgZnVsbCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgaWYgKG1pbkNvdW50cyA9PT0gdm9pZCAwKSB7IG1pbkNvdW50cyA9IFswLCAwXTsgfVxyXG4gICAgaWYgKGZ1bGwgPT09IHZvaWQgMCkgeyBmdWxsID0gZmFsc2U7IH1cclxuICAgIHZhciBzcGxpdEluZGV4ID0gdmFsdWVzLmluZGV4T2YoXCIvXCIpO1xyXG4gICAgdmFyIHNwbGl0TGVuZ3RoID0gKHNwbGl0SW5kZXggPiAtMSA/IHZhbHVlcy5zbGljZSgwLCBzcGxpdEluZGV4KSA6IHZhbHVlcykubGVuZ3RoO1xyXG4gICAgdmFyIGhvcml6b250YWxWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UoMCwgc3BsaXRMZW5ndGgpO1xyXG4gICAgdmFyIHZlcnRpY2FsVmFsdWVzID0gdmFsdWVzLnNsaWNlKHNwbGl0TGVuZ3RoICsgMSk7XHJcbiAgICB2YXIgaG9yaXpvbnRhbFZhbHVlc0xlbmd0aCA9IGhvcml6b250YWxWYWx1ZXMubGVuZ3RoO1xyXG4gICAgdmFyIHZlcnRpY2FsVmFsdWVzTGVuZ3RoID0gdmVydGljYWxWYWx1ZXMubGVuZ3RoO1xyXG4gICAgdmFyIGhhc1ZlcnRpY2FsVmFsdWVzID0gdmVydGljYWxWYWx1ZXNMZW5ndGggPiAwO1xyXG4gICAgdmFyIF9lID0gX19yZWFkKGhvcml6b250YWxWYWx1ZXMsIDQpLCBfZiA9IF9lWzBdLCBud1ZhbHVlID0gX2YgPT09IHZvaWQgMCA/IFwiMHB4XCIgOiBfZiwgX2cgPSBfZVsxXSwgbmVWYWx1ZSA9IF9nID09PSB2b2lkIDAgPyBud1ZhbHVlIDogX2csIF9oID0gX2VbMl0sIHNlVmFsdWUgPSBfaCA9PT0gdm9pZCAwID8gbndWYWx1ZSA6IF9oLCBfaiA9IF9lWzNdLCBzd1ZhbHVlID0gX2ogPT09IHZvaWQgMCA/IG5lVmFsdWUgOiBfajtcclxuICAgIHZhciBfayA9IF9fcmVhZCh2ZXJ0aWNhbFZhbHVlcywgNCksIF9sID0gX2tbMF0sIHduVmFsdWUgPSBfbCA9PT0gdm9pZCAwID8gbndWYWx1ZSA6IF9sLCBfbSA9IF9rWzFdLCBlblZhbHVlID0gX20gPT09IHZvaWQgMCA/IGhhc1ZlcnRpY2FsVmFsdWVzID8gd25WYWx1ZSA6IG5lVmFsdWUgOiBfbSwgX28gPSBfa1syXSwgZXNWYWx1ZSA9IF9vID09PSB2b2lkIDAgPyBoYXNWZXJ0aWNhbFZhbHVlcyA/IHduVmFsdWUgOiBzZVZhbHVlIDogX28sIF9wID0gX2tbM10sIHdzVmFsdWUgPSBfcCA9PT0gdm9pZCAwID8gaGFzVmVydGljYWxWYWx1ZXMgPyBlblZhbHVlIDogc3dWYWx1ZSA6IF9wO1xyXG4gICAgdmFyIGhvcml6b250YWxSYXdQb3NlcyA9IFtud1ZhbHVlLCBuZVZhbHVlLCBzZVZhbHVlLCBzd1ZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgd2lkdGgpOyB9KTtcclxuICAgIHZhciB2ZXJ0aWNhbFJhd1Bvc2VzID0gW3duVmFsdWUsIGVuVmFsdWUsIGVzVmFsdWUsIHdzVmFsdWVdLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCBoZWlnaHQpOyB9KTtcclxuICAgIHZhciBob3Jpem9udGFsUG9zZXMgPSBob3Jpem9udGFsUmF3UG9zZXMuc2xpY2UoKTtcclxuICAgIHZhciB2ZXJ0aWNhbFBvc2VzID0gdmVydGljYWxSYXdQb3Nlcy5zbGljZSgpO1xyXG4gICAgX2EgPSBfX3JlYWQoY2FsY3VsYXRlUmF0aW8oW2hvcml6b250YWxQb3Nlc1swXSwgaG9yaXpvbnRhbFBvc2VzWzFdXSwgd2lkdGgpLCAyKSwgaG9yaXpvbnRhbFBvc2VzWzBdID0gX2FbMF0sIGhvcml6b250YWxQb3Nlc1sxXSA9IF9hWzFdO1xyXG4gICAgX2IgPSBfX3JlYWQoY2FsY3VsYXRlUmF0aW8oW2hvcml6b250YWxQb3Nlc1szXSwgaG9yaXpvbnRhbFBvc2VzWzJdXSwgd2lkdGgpLCAyKSwgaG9yaXpvbnRhbFBvc2VzWzNdID0gX2JbMF0sIGhvcml6b250YWxQb3Nlc1syXSA9IF9iWzFdO1xyXG4gICAgX2MgPSBfX3JlYWQoY2FsY3VsYXRlUmF0aW8oW3ZlcnRpY2FsUG9zZXNbMF0sIHZlcnRpY2FsUG9zZXNbM11dLCBoZWlnaHQpLCAyKSwgdmVydGljYWxQb3Nlc1swXSA9IF9jWzBdLCB2ZXJ0aWNhbFBvc2VzWzNdID0gX2NbMV07XHJcbiAgICBfZCA9IF9fcmVhZChjYWxjdWxhdGVSYXRpbyhbdmVydGljYWxQb3Nlc1sxXSwgdmVydGljYWxQb3Nlc1syXV0sIGhlaWdodCksIDIpLCB2ZXJ0aWNhbFBvc2VzWzFdID0gX2RbMF0sIHZlcnRpY2FsUG9zZXNbMl0gPSBfZFsxXTtcclxuICAgIHZhciBuZXh0SG9yaXpvbnRhbFBvc2VzID0gZnVsbFxyXG4gICAgICAgID8gaG9yaXpvbnRhbFBvc2VzXHJcbiAgICAgICAgOiBob3Jpem9udGFsUG9zZXMuc2xpY2UoMCwgTWF0aC5tYXgobWluQ291bnRzWzBdLCBob3Jpem9udGFsVmFsdWVzTGVuZ3RoKSk7XHJcbiAgICB2YXIgbmV4dFZlcnRpY2FsUG9zZXMgPSBmdWxsXHJcbiAgICAgICAgPyB2ZXJ0aWNhbFBvc2VzXHJcbiAgICAgICAgOiB2ZXJ0aWNhbFBvc2VzLnNsaWNlKDAsIE1hdGgubWF4KG1pbkNvdW50c1sxXSwgdmVydGljYWxWYWx1ZXNMZW5ndGgpKTtcclxuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuZXh0SG9yaXpvbnRhbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IFJBRElVU19ESVJFQ1RJT05TW2ldO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZpcnR1YWw6IGkgPj0gaG9yaXpvbnRhbFZhbHVlc0xlbmd0aCxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbDogSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcclxuICAgICAgICAgICAgdmVydGljYWw6IDAsXHJcbiAgICAgICAgICAgIHBvczogW2xlZnQgKyBwb3MsIHRvcCArIChWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gLTEgPyBoZWlnaHQgOiAwKV0sXHJcbiAgICAgICAgICAgIHN1YjogdHJ1ZSxcclxuICAgICAgICAgICAgcmF3OiBob3Jpem9udGFsUmF3UG9zZXNbaV0sXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICB9KSksIGZhbHNlKSwgX19yZWFkKG5leHRWZXJ0aWNhbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IFJBRElVU19ESVJFQ1RJT05TW2ldO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZpcnR1YWw6IGkgPj0gdmVydGljYWxWYWx1ZXNMZW5ndGgsXHJcbiAgICAgICAgICAgIGhvcml6b250YWw6IDAsXHJcbiAgICAgICAgICAgIHZlcnRpY2FsOiBWRVJUSUNBTF9SQURJVVNfRElSRUNUSU9OU1tpXSxcclxuICAgICAgICAgICAgcG9zOiBbbGVmdCArIChIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAtMSA/IHdpZHRoIDogMCksIHRvcCArIHBvc10sXHJcbiAgICAgICAgICAgIHN1YjogdHJ1ZSxcclxuICAgICAgICAgICAgcmF3OiB2ZXJ0aWNhbFJhd1Bvc2VzW2ldLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcclxuICAgICAgICB9O1xyXG4gICAgfSkpLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlUmFkaXVzUG9zKGNvbnRyb2xQb3NlcywgcG9zZXMsIGluZGV4LCBzdGFydEluZGV4LCBsZW5ndGgpIHtcclxuICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgeyBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7IH1cclxuICAgIHZhciBfYSA9IGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcy5zbGljZShzdGFydEluZGV4KSksIGhvcml6b250YWxSYW5nZSA9IF9hLmhvcml6b250YWxSYW5nZSwgdmVydGljYWxSYW5nZSA9IF9hLnZlcnRpY2FsUmFuZ2U7XHJcbiAgICB2YXIgcmFkaXVzbEluZGV4ID0gaW5kZXggLSBzdGFydEluZGV4O1xyXG4gICAgdmFyIGRlbGV0ZUNvdW50ID0gMDtcclxuICAgIGlmIChyYWRpdXNsSW5kZXggPT09IDApIHtcclxuICAgICAgICBkZWxldGVDb3VudCA9IGxlbmd0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJhZGl1c2xJbmRleCA+IDAgJiYgcmFkaXVzbEluZGV4IDwgaG9yaXpvbnRhbFJhbmdlWzFdKSB7XHJcbiAgICAgICAgZGVsZXRlQ291bnQgPSBob3Jpem9udGFsUmFuZ2VbMV0gLSByYWRpdXNsSW5kZXg7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYWRpdXNsSW5kZXggPj0gdmVydGljYWxSYW5nZVswXSkge1xyXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gdmVydGljYWxSYW5nZVswXSArIHZlcnRpY2FsUmFuZ2VbMV0gLSByYWRpdXNsSW5kZXg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb250cm9sUG9zZXMuc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCk7XHJcbiAgICBwb3Nlcy5zcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KTtcclxufVxyXG5mdW5jdGlvbiBhZGRSYWRpdXNQb3MoY29udHJvbFBvc2VzLCBwb3Nlcywgc3RhcnRJbmRleCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHJpZ2h0LCBib3R0b20sIGxlZnQsIHRvcCkge1xyXG4gICAgaWYgKGxlZnQgPT09IHZvaWQgMCkgeyBsZWZ0ID0gMDsgfVxyXG4gICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cclxuICAgIHZhciBfYSA9IGdldFJhZGl1c1JhbmdlKGNvbnRyb2xQb3Nlcy5zbGljZShzdGFydEluZGV4KSksIGhvcml6b250YWxSYW5nZSA9IF9hLmhvcml6b250YWxSYW5nZSwgdmVydGljYWxSYW5nZSA9IF9hLnZlcnRpY2FsUmFuZ2U7XHJcbiAgICBpZiAoaG9yaXpvbnRhbEluZGV4ID4gLTEpIHtcclxuICAgICAgICB2YXIgcmFkaXVzWCA9IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaG9yaXpvbnRhbEluZGV4XSA9PT0gMVxyXG4gICAgICAgICAgICA/IGRpc3RYIC0gbGVmdFxyXG4gICAgICAgICAgICA6IHJpZ2h0IC0gZGlzdFg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGhvcml6b250YWxSYW5nZVsxXTsgaSA8PSBob3Jpem9udGFsSW5kZXg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgeSA9IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxID8gdG9wIDogYm90dG9tO1xyXG4gICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsSW5kZXggPT09IGkpIHtcclxuICAgICAgICAgICAgICAgIHggPSBkaXN0WDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gbGVmdCArIHJhZGl1c1g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHggPSByaWdodCAtIChwb3Nlc1tzdGFydEluZGV4XVswXSAtIGxlZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRyb2xQb3Nlcy5zcGxpY2Uoc3RhcnRJbmRleCArIGksIDAsIHtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IEhPUklaT05UQUxfUkFESVVTX0RJUkVDVElPTlNbaV0sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogMCxcclxuICAgICAgICAgICAgICAgIHBvczogW3gsIHldLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcG9zZXMuc3BsaWNlKHN0YXJ0SW5kZXggKyBpLCAwLCBbeCwgeV0pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2ZXJ0aWNhbEluZGV4ID4gLTEpIHtcclxuICAgICAgICB2YXIgcmFkaXVzWSA9IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW3ZlcnRpY2FsSW5kZXhdID09PSAxXHJcbiAgICAgICAgICAgID8gZGlzdFkgLSB0b3BcclxuICAgICAgICAgICAgOiBib3R0b20gLSBkaXN0WTtcclxuICAgICAgICBpZiAoaG9yaXpvbnRhbFJhbmdlWzFdID09PSAwICYmIHZlcnRpY2FsUmFuZ2VbMV0gPT09IDApIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IFtcclxuICAgICAgICAgICAgICAgIGxlZnQgKyByYWRpdXNZLFxyXG4gICAgICAgICAgICAgICAgdG9wLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBjb250cm9sUG9zZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBIT1JJWk9OVEFMX1JBRElVU19ESVJFQ1RJT05TWzBdLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IDAsXHJcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHBvc2VzLnB1c2gocG9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0VmVydGljYWxJbmRleCA9IHZlcnRpY2FsUmFuZ2VbMF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHZlcnRpY2FsUmFuZ2VbMV07IGkgPD0gdmVydGljYWxJbmRleDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gSE9SSVpPTlRBTF9SQURJVVNfRElSRUNUSU9OU1tpXSA9PT0gMSA/IGxlZnQgOiByaWdodDtcclxuICAgICAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgICAgICBpZiAodmVydGljYWxJbmRleCA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IGRpc3RZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHkgPSB0b3AgKyByYWRpdXNZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gcG9zZXNbc3RhcnRJbmRleCArIHN0YXJ0VmVydGljYWxJbmRleF1bMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoVkVSVElDQUxfUkFESVVTX0RJUkVDVElPTlNbaV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gYm90dG9tIC0gKHBvc2VzW3N0YXJ0SW5kZXggKyBzdGFydFZlcnRpY2FsSW5kZXhdWzFdIC0gdG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250cm9sUG9zZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiAwLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IFZFUlRJQ0FMX1JBRElVU19ESVJFQ1RJT05TW2ldLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBbeCwgeV0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwb3Nlcy5wdXNoKFt4LCB5XSk7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzcGxpdFJhZGl1c1Bvc2VzKGNvbnRyb2xQb3NlcywgcmF3cykge1xyXG4gICAgaWYgKHJhd3MgPT09IHZvaWQgMCkgeyByYXdzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MucmF3OyB9KTsgfVxyXG4gICAgdmFyIGhvcml6b250YWxzID0gY29udHJvbFBvc2VzXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7IHJldHVybiBwb3MuaG9yaXpvbnRhbCA/IHJhd3NbaV0gOiBudWxsOyB9KS5maWx0ZXIoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zICE9IG51bGw7IH0pO1xyXG4gICAgdmFyIHZlcnRpY2FscyA9IGNvbnRyb2xQb3Nlc1xyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBvcywgaSkgeyByZXR1cm4gcG9zLnZlcnRpY2FsID8gcmF3c1tpXSA6IG51bGw7IH0pLmZpbHRlcihmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MgIT0gbnVsbDsgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhvcml6b250YWxzOiBob3Jpem9udGFscyxcclxuICAgICAgICB2ZXJ0aWNhbHM6IHZlcnRpY2FscyxcclxuICAgIH07XHJcbn1cblxudmFyIENMSVBfRElSRUNUSU9OUyA9IFtcclxuICAgIFswLCAtMSwgXCJuXCJdLFxyXG4gICAgWzEsIDAsIFwiZVwiXSxcclxuXTtcclxudmFyIENMSVBfUkVDVF9ESVJFQ1RJT05TID0gW1xyXG4gICAgWy0xLCAtMSwgXCJud1wiXSxcclxuICAgIFswLCAtMSwgXCJuXCJdLFxyXG4gICAgWzEsIC0xLCBcIm5lXCJdLFxyXG4gICAgWzEsIDAsIFwiZVwiXSxcclxuICAgIFsxLCAxLCBcInNlXCJdLFxyXG4gICAgWzAsIDEsIFwic1wiXSxcclxuICAgIFstMSwgMSwgXCJzd1wiXSxcclxuICAgIFstMSwgMCwgXCJ3XCJdLFxyXG5dO1xyXG4vLyAxIDIgNSA2IDAgMyA0IDdcclxuLy8gMCAxIDIgMyA0IDUgNiA3XHJcbmZ1bmN0aW9uIGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBwb3Nlcykge1xyXG4gICAgdmFyIGNsaXBSZWxhdGl2ZSA9IG1vdmVhYmxlLnByb3BzLmNsaXBSZWxhdGl2ZTtcclxuICAgIHZhciBfYSA9IG1vdmVhYmxlLnN0YXRlLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICB2YXIgX2IgPSBjbGlwUGF0aCwgY2xpcFR5cGUgPSBfYi50eXBlLCBjbGlwUG9zZXMgPSBfYi5wb3NlcztcclxuICAgIHZhciBpc1JlY3QgPSBjbGlwVHlwZSA9PT0gXCJyZWN0XCI7XHJcbiAgICB2YXIgaXNDaXJjbGUgPSBjbGlwVHlwZSA9PT0gXCJjaXJjbGVcIjtcclxuICAgIGlmIChjbGlwVHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcclxuICAgICAgICByZXR1cm4gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIFwiXCIuY29uY2F0KGNvbnZlcnRDU1NTaXplKHBvc1swXSwgd2lkdGgsIGNsaXBSZWxhdGl2ZSksIFwiIFwiKS5jb25jYXQoY29udmVydENTU1NpemUocG9zWzFdLCBoZWlnaHQsIGNsaXBSZWxhdGl2ZSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVjdCB8fCBjbGlwVHlwZSA9PT0gXCJpbnNldFwiKSB7XHJcbiAgICAgICAgdmFyIHRvcF8xID0gcG9zZXNbMV1bMV07XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gcG9zZXNbM11bMF07XHJcbiAgICAgICAgdmFyIGxlZnQgPSBwb3Nlc1s3XVswXTtcclxuICAgICAgICB2YXIgYm90dG9tID0gcG9zZXNbNV1bMV07XHJcbiAgICAgICAgaWYgKGlzUmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgdG9wXzEsXHJcbiAgICAgICAgICAgICAgICByaWdodCxcclxuICAgICAgICAgICAgICAgIGJvdHRvbSxcclxuICAgICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgIF0ubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIFwiXCIuY29uY2F0KHBvcywgXCJweFwiKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjbGlwU3R5bGVzID0gW3RvcF8xLCB3aWR0aCAtIHJpZ2h0LCBoZWlnaHQgLSBib3R0b20sIGxlZnRdXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBvcywgaSkgeyByZXR1cm4gY29udmVydENTU1NpemUocG9zLCBpICUgMiA/IHdpZHRoIDogaGVpZ2h0LCBjbGlwUmVsYXRpdmUpOyB9KTtcclxuICAgICAgICBpZiAocG9zZXMubGVuZ3RoID4gOCkge1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfX3JlYWQobWludXMocG9zZXNbNF0sIHBvc2VzWzBdKSwgMiksIHN1YldpZHRoID0gX2NbMF0sIHN1YkhlaWdodCA9IF9jWzFdO1xyXG4gICAgICAgICAgICBjbGlwU3R5bGVzLnB1c2guYXBwbHkoY2xpcFN0eWxlcywgX19zcHJlYWRBcnJheShbXCJyb3VuZFwiXSwgX19yZWFkKGdldFJhZGl1c1N0eWxlcyhjbGlwUG9zZXMuc2xpY2UoOCkubWFwKGZ1bmN0aW9uIChpbmZvLCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IHBvczogcG9zZXNbaV0gfSk7XHJcbiAgICAgICAgICAgIH0pLCBjbGlwUmVsYXRpdmUsIHN1YldpZHRoLCBzdWJIZWlnaHQsIGxlZnQsIHRvcF8xLCByaWdodCwgYm90dG9tKS5zdHlsZXMpLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xpcFN0eWxlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQ2lyY2xlIHx8IGNsaXBUeXBlID09PSBcImVsbGlwc2VcIikge1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSBwb3Nlc1swXTtcclxuICAgICAgICB2YXIgcnkgPSBjb252ZXJ0Q1NTU2l6ZShhYnMocG9zZXNbMV1bMV0gLSBjZW50ZXJbMV0pLCBpc0NpcmNsZSA/IE1hdGguc3FydCgod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyKSA6IGhlaWdodCwgY2xpcFJlbGF0aXZlKTtcclxuICAgICAgICB2YXIgY2xpcFN0eWxlcyA9IGlzQ2lyY2xlID8gW3J5XVxyXG4gICAgICAgICAgICA6IFtjb252ZXJ0Q1NTU2l6ZShhYnMocG9zZXNbMl1bMF0gLSBjZW50ZXJbMF0pLCB3aWR0aCwgY2xpcFJlbGF0aXZlKSwgcnldO1xyXG4gICAgICAgIGNsaXBTdHlsZXMucHVzaChcImF0XCIsIGNvbnZlcnRDU1NTaXplKGNlbnRlclswXSwgd2lkdGgsIGNsaXBSZWxhdGl2ZSksIGNvbnZlcnRDU1NTaXplKGNlbnRlclsxXSwgaGVpZ2h0LCBjbGlwUmVsYXRpdmUpKTtcclxuICAgICAgICByZXR1cm4gY2xpcFN0eWxlcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRSZWN0UG9zZXModG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KSB7XHJcbiAgICB2YXIgeHMgPSBbbGVmdCwgKGxlZnQgKyByaWdodCkgLyAyLCByaWdodF07XHJcbiAgICB2YXIgeXMgPSBbdG9wLCAodG9wICsgYm90dG9tKSAvIDIsIGJvdHRvbV07XHJcbiAgICByZXR1cm4gQ0xJUF9SRUNUX0RJUkVDVElPTlMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMyksIGRpcnggPSBfYlswXSwgZGlyeSA9IF9iWzFdLCBkaXIgPSBfYlsyXTtcclxuICAgICAgICB2YXIgeCA9IHhzW2RpcnggKyAxXTtcclxuICAgICAgICB2YXIgeSA9IHlzW2RpcnkgKyAxXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbDogYWJzKGRpcnkpLFxyXG4gICAgICAgICAgICBob3Jpem9udGFsOiBhYnMoZGlyeCksXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyLFxyXG4gICAgICAgICAgICBwb3M6IFt4LCB5XSxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udHJvbFNpemUoY29udHJvbFBvc2VzKSB7XHJcbiAgICB2YXIgeFJhbmdlID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xyXG4gICAgdmFyIHlSYW5nZSA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcclxuICAgIGNvbnRyb2xQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBwb3MgPSBfYS5wb3M7XHJcbiAgICAgICAgeFJhbmdlWzBdID0gTWF0aC5taW4oeFJhbmdlWzBdLCBwb3NbMF0pO1xyXG4gICAgICAgIHhSYW5nZVsxXSA9IE1hdGgubWF4KHhSYW5nZVsxXSwgcG9zWzBdKTtcclxuICAgICAgICB5UmFuZ2VbMF0gPSBNYXRoLm1pbih5UmFuZ2VbMF0sIHBvc1sxXSk7XHJcbiAgICAgICAgeVJhbmdlWzFdID0gTWF0aC5tYXgoeVJhbmdlWzFdLCBwb3NbMV0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGFicyh4UmFuZ2VbMV0gLSB4UmFuZ2VbMF0pLFxyXG4gICAgICAgIGFicyh5UmFuZ2VbMV0gLSB5UmFuZ2VbMF0pLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwLCBjdXN0b21DbGlwKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcclxuICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGNsaXBUZXh0ID0gY3VzdG9tQ2xpcDtcclxuICAgIGlmICghY2xpcFRleHQpIHtcclxuICAgICAgICB2YXIgZ2V0U3R5bGUgPSBnZXRDYWNoZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IGdldFN0eWxlKFwiY2xpcFBhdGhcIik7XHJcbiAgICAgICAgY2xpcFRleHQgPSBjbGlwUGF0aCAhPT0gXCJub25lXCIgPyBjbGlwUGF0aCA6IGdldFN0eWxlKFwiY2xpcFwiKTtcclxuICAgIH1cclxuICAgIGlmICghY2xpcFRleHQgfHwgY2xpcFRleHQgPT09IFwibm9uZVwiIHx8IGNsaXBUZXh0ID09PSBcImF1dG9cIikge1xyXG4gICAgICAgIGNsaXBUZXh0ID0gZGVmYXVsdENsaXA7XHJcbiAgICAgICAgaWYgKCFjbGlwVGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIF9rID0gc3BsaXRCcmFja2V0KGNsaXBUZXh0KSwgX2wgPSBfay5wcmVmaXgsIGNsaXBQcmVmaXggPSBfbCA9PT0gdm9pZCAwID8gY2xpcFRleHQgOiBfbCwgX20gPSBfay52YWx1ZSwgdmFsdWUgPSBfbSA9PT0gdm9pZCAwID8gXCJcIiA6IF9tO1xyXG4gICAgdmFyIGlzQ2lyY2xlID0gY2xpcFByZWZpeCA9PT0gXCJjaXJjbGVcIjtcclxuICAgIHZhciBzcGxpdHRlciA9IFwiIFwiO1xyXG4gICAgaWYgKGNsaXBQcmVmaXggPT09IFwicG9seWdvblwiKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHNwbGl0Q29tbWEodmFsdWUgfHwgXCIwJSAwJSwgMTAwJSAwJSwgMTAwJSAxMDAlLCAwJSAxMDAlXCIpO1xyXG4gICAgICAgIHNwbGl0dGVyID0gXCIsXCI7XHJcbiAgICAgICAgdmFyIHBvc2VzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChwb3Muc3BsaXQoXCIgXCIpLCAyKSwgeFBvcyA9IF9hWzBdLCB5UG9zID0gX2FbMV07XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogMSxcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IDEsXHJcbiAgICAgICAgICAgICAgICBwb3M6IFtcclxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0VW5pdFNpemUoeFBvcywgd2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRVbml0U2l6ZSh5UG9zLCBoZWlnaHQpLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbWluTWF4cyA9IGdldE1pbk1heHMocG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvcy5wb3M7IH0pKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBjbGlwUHJlZml4LFxyXG4gICAgICAgICAgICBjbGlwVGV4dDogY2xpcFRleHQsXHJcbiAgICAgICAgICAgIHBvc2VzOiBwb3NlcyxcclxuICAgICAgICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyLFxyXG4gICAgICAgICAgICBsZWZ0OiBtaW5NYXhzLm1pblgsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBtaW5NYXhzLm1heFgsXHJcbiAgICAgICAgICAgIHRvcDogbWluTWF4cy5taW5ZLFxyXG4gICAgICAgICAgICBib3R0b206IG1pbk1heHMubWF4WSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNDaXJjbGUgfHwgY2xpcFByZWZpeCA9PT0gXCJlbGxpcHNlXCIpIHtcclxuICAgICAgICB2YXIgeFBvcyA9IFwiXCI7XHJcbiAgICAgICAgdmFyIHlQb3MgPSBcIlwiO1xyXG4gICAgICAgIHZhciByYWRpdXNYXzEgPSAwO1xyXG4gICAgICAgIHZhciByYWRpdXNZXzEgPSAwO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBzcGxpdFNwYWNlKHZhbHVlKTtcclxuICAgICAgICBpZiAoaXNDaXJjbGUpIHtcclxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IFwiXCI7XHJcbiAgICAgICAgICAgIF9hID0gX19yZWFkKHZhbHVlcywgNCksIF9iID0gX2FbMF0sIHJhZGl1cyA9IF9iID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2IsIF9jID0gX2FbMl0sIHhQb3MgPSBfYyA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9jLCBfZCA9IF9hWzNdLCB5UG9zID0gX2QgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZDtcclxuICAgICAgICAgICAgcmFkaXVzWF8xID0gY29udmVydFVuaXRTaXplKHJhZGl1cywgTWF0aC5zcXJ0KCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDIpKTtcclxuICAgICAgICAgICAgcmFkaXVzWV8xID0gcmFkaXVzWF8xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHhSYWRpdXMgPSBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgeVJhZGl1cyA9IFwiXCI7XHJcbiAgICAgICAgICAgIF9lID0gX19yZWFkKHZhbHVlcywgNSksIF9mID0gX2VbMF0sIHhSYWRpdXMgPSBfZiA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9mLCBfZyA9IF9lWzFdLCB5UmFkaXVzID0gX2cgPT09IHZvaWQgMCA/IFwiNTAlXCIgOiBfZywgX2ggPSBfZVszXSwgeFBvcyA9IF9oID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2gsIF9qID0gX2VbNF0sIHlQb3MgPSBfaiA9PT0gdm9pZCAwID8gXCI1MCVcIiA6IF9qO1xyXG4gICAgICAgICAgICByYWRpdXNYXzEgPSBjb252ZXJ0VW5pdFNpemUoeFJhZGl1cywgd2lkdGgpO1xyXG4gICAgICAgICAgICByYWRpdXNZXzEgPSBjb252ZXJ0VW5pdFNpemUoeVJhZGl1cywgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNlbnRlclBvc18xID0gW1xyXG4gICAgICAgICAgICBjb252ZXJ0VW5pdFNpemUoeFBvcywgd2lkdGgpLFxyXG4gICAgICAgICAgICBjb252ZXJ0VW5pdFNpemUoeVBvcywgaGVpZ2h0KSxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBwb3NlcyA9IF9fc3ByZWFkQXJyYXkoW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogMSxcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWw6IDEsXHJcbiAgICAgICAgICAgICAgICBwb3M6IGNlbnRlclBvc18xLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBcIm5lc3dcIixcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sIF9fcmVhZChDTElQX0RJUkVDVElPTlMuc2xpY2UoMCwgaXNDaXJjbGUgPyAxIDogMikubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsOiBhYnMoZGlyWzFdKSxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbDogZGlyWzBdLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IGRpclsyXSxcclxuICAgICAgICAgICAgc3ViOiB0cnVlLFxyXG4gICAgICAgICAgICBwb3M6IFtcclxuICAgICAgICAgICAgICAgIGNlbnRlclBvc18xWzBdICsgZGlyWzBdICogcmFkaXVzWF8xLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyUG9zXzFbMV0gKyBkaXJbMV0gKiByYWRpdXNZXzEsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfSk7IH0pKSwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IGNsaXBQcmVmaXgsXHJcbiAgICAgICAgICAgIGNsaXBUZXh0OiBjbGlwVGV4dCxcclxuICAgICAgICAgICAgcmFkaXVzWDogcmFkaXVzWF8xLFxyXG4gICAgICAgICAgICByYWRpdXNZOiByYWRpdXNZXzEsXHJcbiAgICAgICAgICAgIGxlZnQ6IGNlbnRlclBvc18xWzBdIC0gcmFkaXVzWF8xLFxyXG4gICAgICAgICAgICB0b3A6IGNlbnRlclBvc18xWzFdIC0gcmFkaXVzWV8xLFxyXG4gICAgICAgICAgICByaWdodDogY2VudGVyUG9zXzFbMF0gKyByYWRpdXNYXzEsXHJcbiAgICAgICAgICAgIGJvdHRvbTogY2VudGVyUG9zXzFbMV0gKyByYWRpdXNZXzEsXHJcbiAgICAgICAgICAgIHBvc2VzOiBwb3NlcyxcclxuICAgICAgICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjbGlwUHJlZml4ID09PSBcImluc2V0XCIpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gc3BsaXRTcGFjZSh2YWx1ZSB8fCBcIjAgMCAwIDBcIik7XHJcbiAgICAgICAgdmFyIHJvdW5kSW5kZXggPSB2YWx1ZXMuaW5kZXhPZihcInJvdW5kXCIpO1xyXG4gICAgICAgIHZhciByZWN0TGVuZ3RoID0gKHJvdW5kSW5kZXggPiAtMSA/IHZhbHVlcy5zbGljZSgwLCByb3VuZEluZGV4KSA6IHZhbHVlcykubGVuZ3RoO1xyXG4gICAgICAgIHZhciByYWRpdXNWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UocmVjdExlbmd0aCArIDEpO1xyXG4gICAgICAgIHZhciBfbyA9IF9fcmVhZCh2YWx1ZXMuc2xpY2UoMCwgcmVjdExlbmd0aCksIDQpLCB0b3BWYWx1ZSA9IF9vWzBdLCBfcCA9IF9vWzFdLCByaWdodFZhbHVlID0gX3AgPT09IHZvaWQgMCA/IHRvcFZhbHVlIDogX3AsIF9xID0gX29bMl0sIGJvdHRvbVZhbHVlID0gX3EgPT09IHZvaWQgMCA/IHRvcFZhbHVlIDogX3EsIF9yID0gX29bM10sIGxlZnRWYWx1ZSA9IF9yID09PSB2b2lkIDAgPyByaWdodFZhbHVlIDogX3I7XHJcbiAgICAgICAgdmFyIF9zID0gX19yZWFkKFt0b3BWYWx1ZSwgYm90dG9tVmFsdWVdLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBjb252ZXJ0VW5pdFNpemUocG9zLCBoZWlnaHQpOyB9KSwgMiksIHRvcF8yID0gX3NbMF0sIGJvdHRvbSA9IF9zWzFdO1xyXG4gICAgICAgIHZhciBfdCA9IF9fcmVhZChbbGVmdFZhbHVlLCByaWdodFZhbHVlXS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gY29udmVydFVuaXRTaXplKHBvcywgd2lkdGgpOyB9KSwgMiksIGxlZnQgPSBfdFswXSwgcmlnaHQgPSBfdFsxXTtcclxuICAgICAgICB2YXIgbmV4dFJpZ2h0ID0gd2lkdGggLSByaWdodDtcclxuICAgICAgICB2YXIgbmV4dEJvdHRvbSA9IGhlaWdodCAtIGJvdHRvbTtcclxuICAgICAgICB2YXIgcmFkaXVzUG9zZXMgPSBnZXRSYWRpdXNWYWx1ZXMocmFkaXVzVmFsdWVzLCBuZXh0UmlnaHQgLSBsZWZ0LCBuZXh0Qm90dG9tIC0gdG9wXzIsIGxlZnQsIHRvcF8yKTtcclxuICAgICAgICB2YXIgcG9zZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChnZXRSZWN0UG9zZXModG9wXzIsIG5leHRSaWdodCwgbmV4dEJvdHRvbSwgbGVmdCkpLCBmYWxzZSksIF9fcmVhZChyYWRpdXNQb3NlcyksIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBcImluc2V0XCIsXHJcbiAgICAgICAgICAgIGNsaXBUZXh0OiBjbGlwVGV4dCxcclxuICAgICAgICAgICAgcG9zZXM6IHBvc2VzLFxyXG4gICAgICAgICAgICB0b3A6IHRvcF8yLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogbmV4dFJpZ2h0LFxyXG4gICAgICAgICAgICBib3R0b206IG5leHRCb3R0b20sXHJcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzVmFsdWVzLFxyXG4gICAgICAgICAgICBzcGxpdHRlcjogc3BsaXR0ZXIsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNsaXBQcmVmaXggPT09IFwicmVjdFwiKSB7XHJcbiAgICAgICAgLy8gdG9wIHJpZ2h0IGJvdHRvbSBsZWZ0XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHNwbGl0Q29tbWEodmFsdWUgfHwgXCIwcHgsIFwiLmNvbmNhdCh3aWR0aCwgXCJweCwgXCIpLmNvbmNhdChoZWlnaHQsIFwicHgsIDBweFwiKSk7XHJcbiAgICAgICAgc3BsaXR0ZXIgPSBcIixcIjtcclxuICAgICAgICB2YXIgX3UgPSBfX3JlYWQodmFsdWVzLm1hcChmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NWYWx1ZSA9IHNwbGl0VW5pdChwb3MpLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zVmFsdWU7XHJcbiAgICAgICAgfSksIDQpLCB0b3BfMyA9IF91WzBdLCByaWdodCA9IF91WzFdLCBib3R0b20gPSBfdVsyXSwgbGVmdCA9IF91WzNdO1xyXG4gICAgICAgIHZhciBwb3NlcyA9IGdldFJlY3RQb3Nlcyh0b3BfMywgcmlnaHQsIGJvdHRvbSwgbGVmdCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogXCJyZWN0XCIsXHJcbiAgICAgICAgICAgIGNsaXBUZXh0OiBjbGlwVGV4dCxcclxuICAgICAgICAgICAgcG9zZXM6IHBvc2VzLFxyXG4gICAgICAgICAgICB0b3A6IHRvcF8zLFxyXG4gICAgICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxyXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcclxuICAgICAgICAgICAgc3BsaXR0ZXI6IHNwbGl0dGVyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbn1cblxuZnVuY3Rpb24gbW92ZUNvbnRyb2xQb3MoY29udHJvbFBvc2VzLCBpbmRleCwgZGlzdCwgaXNSZWN0LCBrZWVwUmF0aW8pIHtcclxuICAgIHZhciBfYSA9IGNvbnRyb2xQb3Nlc1tpbmRleF0sIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbiwgc3ViID0gX2Euc3ViO1xyXG4gICAgdmFyIGRpc3RzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBbMCwgMF07IH0pO1xyXG4gICAgdmFyIGRpcmVjdGlvbnMgPSBkaXJlY3Rpb24gPyBkaXJlY3Rpb24uc3BsaXQoXCJcIikgOiBbXTtcclxuICAgIGlmIChpc1JlY3QgJiYgaW5kZXggPCA4KSB7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsRGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpciA9PT0gXCJ3XCIgfHwgZGlyID09PSBcImVcIjsgfSk7XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxEaXJlY3Rpb25zID0gZGlyZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyID09PSBcIm5cIiB8fCBkaXIgPT09IFwic1wiOyB9KTtcclxuICAgICAgICB2YXIgdmVydGljYWxEaXJlY3Rpb25fMSA9IHZlcnRpY2FsRGlyZWN0aW9uc1swXTtcclxuICAgICAgICB2YXIgaG9yaXpvbnRhbERpcmVjdGlvbl8xID0gaG9yaXpvbnRhbERpcmVjdGlvbnNbMF07XHJcbiAgICAgICAgZGlzdHNbaW5kZXhdID0gZGlzdDtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoZ2V0Q29udHJvbFNpemUoY29udHJvbFBvc2VzKSwgMiksIHdpZHRoID0gX2JbMF0sIGhlaWdodCA9IF9iWzFdO1xyXG4gICAgICAgIHZhciByYXRpbyA9IHdpZHRoICYmIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogMDtcclxuICAgICAgICBpZiAocmF0aW8gJiYga2VlcFJhdGlvKSB7XHJcbiAgICAgICAgICAgIC8vIDAgMSAyXHJcbiAgICAgICAgICAgIC8vIDcgICAzXHJcbiAgICAgICAgICAgIC8vIDYgNSA0XHJcbiAgICAgICAgICAgIHZhciBmaXhlZEluZGV4ID0gKGluZGV4ICsgNCkgJSA4O1xyXG4gICAgICAgICAgICB2YXIgZml4ZWRQb3NpdGlvbiA9IGNvbnRyb2xQb3Nlc1tmaXhlZEluZGV4XS5wb3M7XHJcbiAgICAgICAgICAgIHZhciBzaXplRGlyZWN0aW9uID0gWzAsIDBdO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJ3XCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHNpemVEaXJlY3Rpb25bMF0gPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcImVcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZURpcmVjdGlvblswXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwiblwiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRGlyZWN0aW9uWzFdID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHNpemVEaXJlY3Rpb25bMV0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXh0RGlzdCA9IGdldFNpemVEaXN0QnlEaXN0KFt3aWR0aCwgaGVpZ2h0XSwgZGlzdCwgcmF0aW8sIHNpemVEaXJlY3Rpb24sIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgbmV4dFdpZHRoID0gd2lkdGggKyBuZXh0RGlzdFswXTtcclxuICAgICAgICAgICAgdmFyIG5leHRIZWlnaHQgPSBoZWlnaHQgKyBuZXh0RGlzdFsxXTtcclxuICAgICAgICAgICAgdmFyIHRvcF8xID0gZml4ZWRQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGZpeGVkUG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZml4ZWRQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZml4ZWRQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMF0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQgLSBuZXh0V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZURpcmVjdGlvblswXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBsZWZ0ICsgbmV4dFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgLSBuZXh0V2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodCArIG5leHRXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpemVEaXJlY3Rpb25bMV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BfMSA9IGJvdHRvbSAtIG5leHRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZURpcmVjdGlvblsxXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgYm90dG9tID0gdG9wXzEgKyBuZXh0SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9wXzEgPSBib3R0b20gLSBuZXh0SGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHRvcF8xICsgbmV4dEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV4dENvbnRyb2xQb3Nlc18xID0gZ2V0UmVjdFBvc2VzKHRvcF8xLCByaWdodCwgYm90dG9tLCBsZWZ0KTtcclxuICAgICAgICAgICAgY29udHJvbFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xQb3NlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0c1tpXVswXSA9IG5leHRDb250cm9sUG9zZXNfMVtpXS5wb3NbMF0gLSBjb250cm9sUG9zZS5wb3NbMF07XHJcbiAgICAgICAgICAgICAgICBkaXN0c1tpXVsxXSA9IG5leHRDb250cm9sUG9zZXNfMVtpXS5wb3NbMV0gLSBjb250cm9sUG9zZS5wb3NbMV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udHJvbFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xQb3NlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbERpciA9IGNvbnRyb2xQb3NlLmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICghY29udHJvbERpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sRGlyLmluZGV4T2YodmVydGljYWxEaXJlY3Rpb25fMSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RzW2ldWzBdID0gZGlzdFswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sRGlyLmluZGV4T2YoaG9yaXpvbnRhbERpcmVjdGlvbl8xKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdHNbaV1bMV0gPSBkaXN0WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsRGlyZWN0aW9uXzEpIHtcclxuICAgICAgICAgICAgICAgIGRpc3RzWzFdWzBdID0gZGlzdFswXSAvIDI7XHJcbiAgICAgICAgICAgICAgICBkaXN0c1s1XVswXSA9IGRpc3RbMF0gLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsRGlyZWN0aW9uXzEpIHtcclxuICAgICAgICAgICAgICAgIGRpc3RzWzNdWzFdID0gZGlzdFsxXSAvIDI7XHJcbiAgICAgICAgICAgICAgICBkaXN0c1s3XVsxXSA9IGRpc3RbMV0gLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uICYmICFzdWIpIHtcclxuICAgICAgICBkaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xyXG4gICAgICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IGRpciA9PT0gXCJuXCIgfHwgZGlyID09PSBcInNcIjtcclxuICAgICAgICAgICAgY29udHJvbFBvc2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xQb3NlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyRGlyID0gY29udHJvbFBvc2UuZGlyZWN0aW9uLCBkaXJIb3Jpem9udGFsID0gY29udHJvbFBvc2UuaG9yaXpvbnRhbCwgZGlyVmVydGljYWwgPSBjb250cm9sUG9zZS52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgIGlmICghZGlyRGlyIHx8IGRpckRpci5pbmRleE9mKGRpcikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlzdHNbaV0gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWZXJ0aWNhbCB8fCAhZGlySG9yaXpvbnRhbCA/IDAgOiBkaXN0WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICFpc1ZlcnRpY2FsIHx8ICFkaXJWZXJ0aWNhbCA/IDAgOiBkaXN0WzFdLFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkaXN0c1tpbmRleF0gPSBkaXN0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpc3RzO1xyXG59XHJcbmZ1bmN0aW9uIGFkZENsaXBQYXRoKG1vdmVhYmxlLCBlKSB7XHJcbiAgICB2YXIgX2EgPSBfX3JlYWQoY2FsY3VsYXRlUG9pbnRlckRpc3QobW92ZWFibGUsIGUpLCAyKSwgZGlzdFggPSBfYVswXSwgZGlzdFkgPSBfYVsxXTtcclxuICAgIHZhciBfYiA9IGUuZGF0YXMsIGNsaXBQYXRoID0gX2IuY2xpcFBhdGgsIGNsaXBJbmRleCA9IF9iLmNsaXBJbmRleDtcclxuICAgIHZhciBfYyA9IGNsaXBQYXRoLCBjbGlwVHlwZSA9IF9jLnR5cGUsIGNsaXBQb3NlcyA9IF9jLnBvc2VzLCBzcGxpdHRlciA9IF9jLnNwbGl0dGVyO1xyXG4gICAgdmFyIHBvc2VzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MucG9zOyB9KTtcclxuICAgIGlmIChjbGlwVHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcclxuICAgICAgICBwb3Nlcy5zcGxpY2UoY2xpcEluZGV4LCAwLCBbZGlzdFgsIGRpc3RZXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjbGlwVHlwZSA9PT0gXCJpbnNldFwiKSB7XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxJbmRleCA9IEhPUklaT05UQUxfUkFESVVTX09SREVSLmluZGV4T2YoY2xpcEluZGV4KTtcclxuICAgICAgICB2YXIgdmVydGljYWxJbmRleCA9IFZFUlRJQ0FMX1JBRElVU19PUkRFUi5pbmRleE9mKGNsaXBJbmRleCk7XHJcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gY2xpcFBvc2VzLmxlbmd0aDtcclxuICAgICAgICBhZGRSYWRpdXNQb3MoY2xpcFBvc2VzLCBwb3NlcywgOCwgaG9yaXpvbnRhbEluZGV4LCB2ZXJ0aWNhbEluZGV4LCBkaXN0WCwgZGlzdFksIHBvc2VzWzRdWzBdLCBwb3Nlc1s0XVsxXSwgcG9zZXNbMF1bMF0sIHBvc2VzWzBdWzFdKTtcclxuICAgICAgICBpZiAobGVuZ3RoXzEgPT09IGNsaXBQb3Nlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjbGlwU3R5bGVzID0gZ2V0Q2xpcFN0eWxlcyhtb3ZlYWJsZSwgY2xpcFBhdGgsIHBvc2VzKTtcclxuICAgIHZhciBjbGlwU3R5bGUgPSBcIlwiLmNvbmNhdChjbGlwVHlwZSwgXCIoXCIpLmNvbmNhdChjbGlwU3R5bGVzLmpvaW4oc3BsaXR0ZXIpLCBcIilcIik7XHJcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgY2xpcEV2ZW50VHlwZTogXCJhZGRlZFwiLCBjbGlwVHlwZTogY2xpcFR5cGUsIHBvc2VzOiBwb3NlcywgY2xpcFN0eWxlczogY2xpcFN0eWxlcywgY2xpcFN0eWxlOiBjbGlwU3R5bGUsIGRpc3RYOiAwLCBkaXN0WTogMCB9LCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICBjbGlwUGF0aDogY2xpcFN0eWxlLFxyXG4gICAgfSwgZSkpKSk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQ2xpcFBhdGgobW92ZWFibGUsIGUpIHtcclxuICAgIHZhciBfYSA9IGUuZGF0YXMsIGNsaXBQYXRoID0gX2EuY2xpcFBhdGgsIGNsaXBJbmRleCA9IF9hLmNsaXBJbmRleDtcclxuICAgIHZhciBfYiA9IGNsaXBQYXRoLCBjbGlwVHlwZSA9IF9iLnR5cGUsIGNsaXBQb3NlcyA9IF9iLnBvc2VzLCBzcGxpdHRlciA9IF9iLnNwbGl0dGVyO1xyXG4gICAgdmFyIHBvc2VzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MucG9zOyB9KTtcclxuICAgIHZhciBsZW5ndGggPSBwb3Nlcy5sZW5ndGg7XHJcbiAgICBpZiAoY2xpcFR5cGUgPT09IFwicG9seWdvblwiKSB7XHJcbiAgICAgICAgY2xpcFBvc2VzLnNwbGljZShjbGlwSW5kZXgsIDEpO1xyXG4gICAgICAgIHBvc2VzLnNwbGljZShjbGlwSW5kZXgsIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2xpcFR5cGUgPT09IFwiaW5zZXRcIikge1xyXG4gICAgICAgIGlmIChjbGlwSW5kZXggPCA4KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlUmFkaXVzUG9zKGNsaXBQb3NlcywgcG9zZXMsIGNsaXBJbmRleCwgOCwgbGVuZ3RoKTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSBjbGlwUG9zZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY2xpcFN0eWxlcyA9IGdldENsaXBTdHlsZXMobW92ZWFibGUsIGNsaXBQYXRoLCBwb3Nlcyk7XHJcbiAgICB2YXIgY2xpcFN0eWxlID0gXCJcIi5jb25jYXQoY2xpcFR5cGUsIFwiKFwiKS5jb25jYXQoY2xpcFN0eWxlcy5qb2luKHNwbGl0dGVyKSwgXCIpXCIpO1xyXG4gICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQ2xpcFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IGNsaXBFdmVudFR5cGU6IFwicmVtb3ZlZFwiLCBjbGlwVHlwZTogY2xpcFR5cGUsIHBvc2VzOiBwb3NlcywgY2xpcFN0eWxlczogY2xpcFN0eWxlcywgY2xpcFN0eWxlOiBjbGlwU3R5bGUsIGRpc3RYOiAwLCBkaXN0WTogMCB9LCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICBjbGlwUGF0aDogY2xpcFN0eWxlLFxyXG4gICAgfSwgZSkpKSk7XHJcbn1cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuQ2xpcHBhYmxlXHJcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRvIGNsaXAgdGhlIHRhcmdldC5cclxuICovXHJcbnZhciBDbGlwcGFibGUgPSB7XHJcbiAgICBuYW1lOiBcImNsaXBwYWJsZVwiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcImNsaXBwYWJsZVwiLFxyXG4gICAgICAgIFwiZGVmYXVsdENsaXBQYXRoXCIsXHJcbiAgICAgICAgXCJjdXN0b21DbGlwUGF0aFwiLFxyXG4gICAgICAgIFwia2VlcFJhdGlvXCIsXHJcbiAgICAgICAgXCJjbGlwUmVsYXRpdmVcIixcclxuICAgICAgICBcImNsaXBBcmVhXCIsXHJcbiAgICAgICAgXCJkcmFnV2l0aENsaXBcIixcclxuICAgICAgICBcImNsaXBUYXJnZXRCb3VuZHNcIixcclxuICAgICAgICBcImNsaXBWZXJ0aWNhbEd1aWRlbGluZXNcIixcclxuICAgICAgICBcImNsaXBIb3Jpem9udGFsR3VpZGVsaW5lc1wiLFxyXG4gICAgICAgIFwiY2xpcFNuYXBUaHJlc2hvbGRcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcImNsaXBTdGFydFwiLFxyXG4gICAgICAgIFwiY2xpcFwiLFxyXG4gICAgICAgIFwiY2xpcEVuZFwiLFxyXG4gICAgXSxcclxuICAgIGNzczogW1xyXG4gICAgICAgIFwiLmNvbnRyb2wuY2xpcC1jb250cm9sIHtcXG5iYWNrZ3JvdW5kOiAjNmQ2O1xcbmN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmNvbnRyb2wuY2xpcC1jb250cm9sLmNsaXAtcmFkaXVzIHtcXG5iYWNrZ3JvdW5kOiAjZDY2O1xcbn1cXG4ubGluZS5jbGlwLWxpbmUge1xcbmJhY2tncm91bmQ6ICM2ZTY7XFxuY3Vyc29yOiBtb3ZlO1xcbnotaW5kZXg6IDE7XFxufVxcbi5jbGlwLWFyZWEge1xcbnBvc2l0aW9uOiBhYnNvbHV0ZTtcXG50b3A6IDA7XFxubGVmdDogMDtcXG59XFxuLmNsaXAtZWxsaXBzZSB7XFxucG9zaXRpb246IGFic29sdXRlO1xcbmN1cnNvcjogbW92ZTtcXG5ib3JkZXI6IDFweCBzb2xpZCAjNmQ2O1xcbmJvcmRlcjogdmFyKC0tem9vbXB4KSBzb2xpZCAjNmQ2O1xcbmJvcmRlci1yYWRpdXM6IDUwJTtcXG50cmFuc2Zvcm0tb3JpZ2luOiAwcHggMHB4O1xcbn1cIixcclxuICAgICAgICBcIjpob3N0IHtcXG4tLWJvdW5kcy1jb2xvcjogI2Q2NjtcXG59XCIsXHJcbiAgICAgICAgXCIuZ3VpZGVsaW5lIHtcXG5wb2ludGVyLWV2ZW50czogbm9uZTtcXG56LWluZGV4OiAyO1xcbn1cIixcclxuICAgICAgICBcIi5saW5lLmd1aWRlbGluZS5ib3VuZHMge1xcbmJhY2tncm91bmQ6ICNkNjY7XFxuYmFja2dyb3VuZDogdmFyKC0tYm91bmRzLWNvbG9yKTtcXG59XCIsXHJcbiAgICBdLFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIGN1c3RvbUNsaXBQYXRoID0gX2EuY3VzdG9tQ2xpcFBhdGgsIGRlZmF1bHRDbGlwUGF0aCA9IF9hLmRlZmF1bHRDbGlwUGF0aCwgY2xpcEFyZWEgPSBfYS5jbGlwQXJlYSwgem9vbSA9IF9hLnpvb20sIGdyb3VwYWJsZSA9IF9hLmdyb3VwYWJsZTtcclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCB0YXJnZXQgPSBfYi50YXJnZXQsIHdpZHRoID0gX2Iud2lkdGgsIGhlaWdodCA9IF9iLmhlaWdodCwgYWxsTWF0cml4ID0gX2IuYWxsTWF0cml4LCBpczNkID0gX2IuaXMzZCwgbGVmdCA9IF9iLmxlZnQsIHRvcCA9IF9iLnRvcCwgcG9zMSA9IF9iLnBvczEsIHBvczIgPSBfYi5wb3MyLCBwb3MzID0gX2IucG9zMywgcG9zNCA9IF9iLnBvczQsIGNsaXBQYXRoU3RhdGUgPSBfYi5jbGlwUGF0aFN0YXRlLCBzbmFwQm91bmRJbmZvcyA9IF9iLnNuYXBCb3VuZEluZm9zLCByb3RhdGlvblJhZCA9IF9iLnJvdGF0aW9uO1xyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGdyb3VwYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjbGlwUGF0aCA9IGdldENsaXBQYXRoKHRhcmdldCwgd2lkdGgsIGhlaWdodCwgZGVmYXVsdENsaXBQYXRoIHx8IFwiaW5zZXRcIiwgY2xpcFBhdGhTdGF0ZSB8fCBjdXN0b21DbGlwUGF0aCk7XHJcbiAgICAgICAgaWYgKCFjbGlwUGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgIHZhciB0eXBlID0gY2xpcFBhdGgudHlwZTtcclxuICAgICAgICB2YXIgY2xpcFBvc2VzID0gY2xpcFBhdGgucG9zZXM7XHJcbiAgICAgICAgdmFyIHBvc2VzID0gY2xpcFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkUG9zID0gY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBwb3MucG9zLCBuKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRQb3NbMF0gLSBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFBvc1sxXSAtIHRvcCxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY29udHJvbHMgPSBbXTtcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICB2YXIgaXNSZWN0ID0gdHlwZSA9PT0gXCJyZWN0XCI7XHJcbiAgICAgICAgdmFyIGlzSW5zZXQgPSB0eXBlID09PSBcImluc2V0XCI7XHJcbiAgICAgICAgdmFyIGlzUG9seWdvbiA9IHR5cGUgPT09IFwicG9seWdvblwiO1xyXG4gICAgICAgIGlmIChpc1JlY3QgfHwgaXNJbnNldCB8fCBpc1BvbHlnb24pIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVQb3Nlc18xID0gaXNJbnNldCA/IHBvc2VzLnNsaWNlKDAsIDgpIDogcG9zZXM7XHJcbiAgICAgICAgICAgIGxpbmVzID0gbGluZVBvc2VzXzEubWFwKGZ1bmN0aW9uICh0bywgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBpID09PSAwID8gbGluZVBvc2VzXzFbbGluZVBvc2VzXzEubGVuZ3RoIC0gMV0gOiBsaW5lUG9zZXNfMVtpIC0gMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkID0gZ2V0UmFkKGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gZ2V0RGlhZ29uYWxTaXplKGZyb20sIHRvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImNsaXBMaW5lXCIuY29uY2F0KGkpLCBjbGFzc05hbWU6IHByZWZpeChcImxpbmVcIiwgXCJjbGlwLWxpbmVcIiwgXCJzbmFwLWNvbnRyb2xcIiksIFwiZGF0YS1jbGlwLWluZGV4XCI6IGksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChkaXN0LCBcInB4XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChmcm9tWzBdLCBcInB4LCBcIikuY29uY2F0KGZyb21bMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJhZCwgXCJyYWQpIHNjYWxlWShcIikuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udHJvbHMgPSBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJjbGlwQ29udHJvbFwiLmNvbmNhdChpKSwgY2xhc3NOYW1lOiBwcmVmaXgoXCJjb250cm9sXCIsIFwiY2xpcC1jb250cm9sXCIsIFwic25hcC1jb250cm9sXCIpLCBcImRhdGEtY2xpcC1pbmRleFwiOiBpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHBvc1swXSwgXCJweCwgXCIpLmNvbmNhdChwb3NbMV0sIFwicHgpIHJvdGF0ZShcIikuY29uY2F0KHJvdGF0aW9uUmFkLCBcInJhZCkgc2NhbGUoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICAgICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0luc2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzLnB1c2guYXBwbHkoY29udHJvbHMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlcy5zbGljZSg4KS5tYXAoZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiY2xpcFJhZGl1c0NvbnRyb2xcIi5jb25jYXQoaSksIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbFwiLCBcImNsaXAtY29udHJvbFwiLCBcImNsaXAtcmFkaXVzXCIsIFwic25hcC1jb250cm9sXCIpLCBcImRhdGEtY2xpcC1pbmRleFwiOiA4ICsgaSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQocG9zWzBdLCBcInB4LCBcIikuY29uY2F0KHBvc1sxXSwgXCJweCkgcm90YXRlKFwiKS5jb25jYXQocm90YXRpb25SYWQsIFwicmFkKSBzY2FsZShcIikuY29uY2F0KHpvb20sIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgICAgICB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGlwTGVmdCA9IGNsaXBQYXRoLmxlZnQsIGNsaXBUb3AgPSBjbGlwUGF0aC50b3AsIHJhZGl1c1ggPSBjbGlwUGF0aC5yYWRpdXNYLCByYWRpdXNZID0gY2xpcFBhdGgucmFkaXVzWTtcclxuICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKG1pbnVzKGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgW2NsaXBMZWZ0LCBjbGlwVG9wXSwgbiksIGNhbGN1bGF0ZVBvc2l0aW9uKGFsbE1hdHJpeCwgWzAsIDBdLCBuKSksIDIpLCBkaXN0TGVmdCA9IF9jWzBdLCBkaXN0VG9wID0gX2NbMV07XHJcbiAgICAgICAgICAgIHZhciBlbGxpcHNlQ2xpcFBhdGggPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgaWYgKCFjbGlwQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpZWNlID0gTWF0aC5tYXgoMTAsIHJhZGl1c1ggLyA1LCByYWRpdXNZIC8gNSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJlYVBvc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwaWVjZTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhZCA9IE1hdGguUEkgKiAyIC8gcGllY2UgKiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzWCArIChyYWRpdXNYIC0gem9vbSkgKiBNYXRoLmNvcyhyYWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNZICsgKHJhZGl1c1kgLSB6b29tKSAqIE1hdGguc2luKHJhZCksXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCwgLTJdKTtcclxuICAgICAgICAgICAgICAgIGFyZWFQb3Nlcy5wdXNoKFstMiwgLTJdKTtcclxuICAgICAgICAgICAgICAgIGFyZWFQb3Nlcy5wdXNoKFstMiwgcmFkaXVzWSAqIDIgKyAyXSk7XHJcbiAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCAqIDIgKyAyLCByYWRpdXNZICogMiArIDJdKTtcclxuICAgICAgICAgICAgICAgIGFyZWFQb3Nlcy5wdXNoKFtyYWRpdXNYICogMiArIDIsIC0yXSk7XHJcbiAgICAgICAgICAgICAgICBhcmVhUG9zZXMucHVzaChbcmFkaXVzWCwgLTJdKTtcclxuICAgICAgICAgICAgICAgIGVsbGlwc2VDbGlwUGF0aCA9IFwicG9seWdvbihcIi5jb25jYXQoYXJlYVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBcIlwiLmNvbmNhdChwb3NbMF0sIFwicHggXCIpLmNvbmNhdChwb3NbMV0sIFwicHhcIik7IH0pLmpvaW4oXCIsIFwiKSwgXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRyb2xzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJjbGlwRWxsaXBzZVwiLCBjbGFzc05hbWU6IHByZWZpeChcImNsaXAtZWxsaXBzZVwiLCBcInNuYXAtY29udHJvbFwiKSwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQocmFkaXVzWCAqIDIsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChyYWRpdXNZICogMiwgXCJweFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aDogZWxsaXBzZUNsaXBQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KC1sZWZ0ICsgZGlzdExlZnQsIFwicHgsIFwiKS5jb25jYXQoLXRvcCArIGRpc3RUb3AsIFwicHgpIFwiKS5jb25jYXQobWFrZU1hdHJpeENTUyhhbGxNYXRyaXgpKSxcclxuICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xpcEFyZWEpIHtcclxuICAgICAgICAgICAgdmFyIF9kID0gZ2V0UmVjdChfX3NwcmVhZEFycmF5KFtwb3MxLCBwb3MyLCBwb3MzLCBwb3M0XSwgX19yZWFkKHBvc2VzKSwgZmFsc2UpKSwgYWxsV2lkdGggPSBfZC53aWR0aCwgYWxsSGVpZ2h0ID0gX2QuaGVpZ2h0LCBhbGxMZWZ0XzEgPSBfZC5sZWZ0LCBhbGxUb3BfMSA9IF9kLnRvcDtcclxuICAgICAgICAgICAgaWYgKGlzUG9seWdvbiB8fCBpc1JlY3QgfHwgaXNJbnNldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZWFQb3NlcyA9IGlzSW5zZXQgPyBwb3Nlcy5zbGljZSgwLCA4KSA6IHBvc2VzO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbHMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBcImNsaXBBcmVhXCIsIGNsYXNzTmFtZTogcHJlZml4KFwiY2xpcC1hcmVhXCIsIFwic25hcC1jb250cm9sXCIpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQoYWxsV2lkdGgsIFwicHhcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoYWxsSGVpZ2h0LCBcInB4XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChhbGxMZWZ0XzEsIFwicHgsIFwiKS5jb25jYXQoYWxsVG9wXzEsIFwicHgpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aDogXCJwb2x5Z29uKFwiLmNvbmNhdChhcmVhUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIFwiXCIuY29uY2F0KHBvc1swXSAtIGFsbExlZnRfMSwgXCJweCBcIikuY29uY2F0KHBvc1sxXSAtIGFsbFRvcF8xLCBcInB4XCIpOyB9KS5qb2luKFwiLCBcIiksIFwiKVwiKSxcclxuICAgICAgICAgICAgICAgICAgICB9IH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcEJvdW5kSW5mb3MpIHtcclxuICAgICAgICAgICAgW1widmVydGljYWxcIiwgXCJob3Jpem9udGFsXCJdLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gc25hcEJvdW5kSW5mb3NbZGlyZWN0aW9uVHlwZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uVHlwZSA9PT0gXCJob3Jpem9udGFsXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5pc1NuYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoaW5mby5zbmFwLnBvc0luZm9zLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBQb3MxID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBpc0hvcml6b250YWwgPyBbMCwgcG9zXSA6IFtwb3MsIDBdLCBuKSwgW2xlZnQsIHRvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc25hcFBvczIgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIGlzSG9yaXpvbnRhbCA/IFt3aWR0aCwgcG9zXSA6IFtwb3MsIGhlaWdodF0sIG4pLCBbbGVmdCwgdG9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBcIlwiLCBzbmFwUG9zMSwgc25hcFBvczIsIHpvb20sIFwiY2xpcFwiLmNvbmNhdChkaXJlY3Rpb25UeXBlLCBcInNuYXBcIikuY29uY2F0KGkpLCBcImd1aWRlbGluZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGluZm8uYm91bmRzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF9hLnBvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBQb3MxID0gbWludXMoY2FsY3VsYXRlUG9zaXRpb24oYWxsTWF0cml4LCBpc0hvcml6b250YWwgPyBbMCwgcG9zXSA6IFtwb3MsIDBdLCBuKSwgW2xlZnQsIHRvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc25hcFBvczIgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIGlzSG9yaXpvbnRhbCA/IFt3aWR0aCwgcG9zXSA6IFtwb3MsIGhlaWdodF0sIG4pLCBbbGVmdCwgdG9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJMaW5lKFJlYWN0LCBcIlwiLCBzbmFwUG9zMSwgc25hcFBvczIsIHpvb20sIFwiY2xpcFwiLmNvbmNhdChkaXJlY3Rpb25UeXBlLCBcImJvdW5kc1wiKS5jb25jYXQoaSksIFwiZ3VpZGVsaW5lXCIsIFwiYm91bmRzXCIsIFwiYm9sZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoY29udHJvbHMpLCBmYWxzZSksIF9fcmVhZChsaW5lcyksIGZhbHNlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGUuaW5wdXRFdmVudCAmJiAoZS5pbnB1dEV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5pbmRleE9mKFwiY2xpcFwiKSA+IC0xO1xyXG4gICAgfSxcclxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgdmFyIF9hID0gcHJvcHMuZHJhZ1dpdGhDbGlwLCBkcmFnV2l0aENsaXAgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hO1xyXG4gICAgICAgIGlmIChkcmFnV2l0aENsaXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGlzRHJhZ1RhcmdldDogdHJ1ZSB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHZhciBfYSA9IG1vdmVhYmxlLnByb3BzLCBkZWZhdWx0Q2xpcFBhdGggPSBfYS5kZWZhdWx0Q2xpcFBhdGgsIGN1c3RvbUNsaXBQYXRoID0gX2EuY3VzdG9tQ2xpcFBhdGg7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldCwgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBpbnB1dFRhcmdldCA9IGUuaW5wdXRFdmVudCA/IGUuaW5wdXRFdmVudC50YXJnZXQgOiBudWxsO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoaW5wdXRUYXJnZXQgJiYgaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikpIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICB2YXIgY2xpcFBhdGggPSBnZXRDbGlwUGF0aCh0YXJnZXQsIHdpZHRoLCBoZWlnaHQsIGRlZmF1bHRDbGlwUGF0aCB8fCBcImluc2V0XCIsIGN1c3RvbUNsaXBQYXRoKTtcclxuICAgICAgICBpZiAoIWNsaXBQYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNsaXBUZXh0ID0gY2xpcFBhdGguY2xpcFRleHQsIHR5cGUgPSBjbGlwUGF0aC50eXBlLCBwb3NlcyA9IGNsaXBQYXRoLnBvc2VzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25DbGlwU3RhcnRcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBjbGlwVHlwZTogdHlwZSxcclxuICAgICAgICAgICAgY2xpcFN0eWxlOiBjbGlwVGV4dCxcclxuICAgICAgICAgICAgcG9zZXM6IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3MucG9zOyB9KSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZGF0YXMuaXNDbGlwU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5pc0NvbnRyb2wgPSBjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWNvbnRyb2xcIikgPiAtMTtcclxuICAgICAgICBkYXRhcy5pc0xpbmUgPSBjbGFzc05hbWUuaW5kZXhPZihcImNsaXAtbGluZVwiKSA+IC0xO1xyXG4gICAgICAgIGRhdGFzLmlzQXJlYSA9IGNsYXNzTmFtZS5pbmRleE9mKFwiY2xpcC1hcmVhXCIpID4gLTEgfHwgY2xhc3NOYW1lLmluZGV4T2YoXCJjbGlwLWVsbGlwc2VcIikgPiAtMTtcclxuICAgICAgICBkYXRhcy5jbGlwSW5kZXggPSBpbnB1dFRhcmdldCA/IHBhcnNlSW50KGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY2xpcC1pbmRleFwiKSwgMTApIDogLTE7XHJcbiAgICAgICAgZGF0YXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcclxuICAgICAgICBkYXRhcy5pc0NsaXBTdGFydCA9IHRydWU7XHJcbiAgICAgICAgc3RhdGUuY2xpcFBhdGhTdGF0ZSA9IGNsaXBUZXh0O1xyXG4gICAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIG9yaWdpbmFsRGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMsIGlzRHJhZ1RhcmdldCA9IGUuaXNEcmFnVGFyZ2V0O1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNDbGlwU3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2QgPSBkYXRhcywgaXNDb250cm9sID0gX2QuaXNDb250cm9sLCBpc0xpbmUgPSBfZC5pc0xpbmUsIGlzQXJlYSA9IF9kLmlzQXJlYSwgY2xpcEluZGV4ID0gX2QuY2xpcEluZGV4LCBjbGlwUGF0aCA9IF9kLmNsaXBQYXRoO1xyXG4gICAgICAgIGlmICghY2xpcFBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcHMgPSBnZXRQcm9wcyhtb3ZlYWJsZS5wcm9wcywgXCJjbGlwcGFibGVcIik7XHJcbiAgICAgICAgdmFyIGtlZXBSYXRpbyA9IHByb3BzLmtlZXBSYXRpbztcclxuICAgICAgICB2YXIgZGlzdFggPSAwO1xyXG4gICAgICAgIHZhciBkaXN0WSA9IDA7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsRHJhZ2dhYmxlID0gb3JpZ2luYWxEYXRhcy5kcmFnZ2FibGU7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsRGlzdCA9IGdldERyYWdEaXN0KGUpO1xyXG4gICAgICAgIGlmIChpc0RyYWdUYXJnZXQgJiYgb3JpZ2luYWxEcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgX2EgPSBfX3JlYWQob3JpZ2luYWxEcmFnZ2FibGUucHJldkJlZm9yZURpc3QsIDIpLCBkaXN0WCA9IF9hWzBdLCBkaXN0WSA9IF9hWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2IgPSBfX3JlYWQob3JpZ2luYWxEaXN0LCAyKSwgZGlzdFggPSBfYlswXSwgZGlzdFkgPSBfYlsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZpcnN0RGlzdCA9IFtkaXN0WCwgZGlzdFldO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHN0YXRlLndpZHRoLCBoZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGlzRHJhZ1dpdGhUYXJnZXQgPSAhaXNBcmVhICYmICFpc0NvbnRyb2wgJiYgIWlzTGluZTtcclxuICAgICAgICB2YXIgY2xpcFR5cGUgPSBjbGlwUGF0aC50eXBlLCBjbGlwUG9zZXMgPSBjbGlwUGF0aC5wb3Nlcywgc3BsaXR0ZXIgPSBjbGlwUGF0aC5zcGxpdHRlcjtcclxuICAgICAgICB2YXIgcG9zZXMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvcy5wb3M7IH0pO1xyXG4gICAgICAgIGlmIChpc0RyYWdXaXRoVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGRpc3RYID0gLWRpc3RYO1xyXG4gICAgICAgICAgICBkaXN0WSA9IC1kaXN0WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzQWxsID0gIWlzQ29udHJvbCB8fCBjbGlwUG9zZXNbY2xpcEluZGV4XS5kaXJlY3Rpb24gPT09IFwibmVzd1wiO1xyXG4gICAgICAgIHZhciBpc1JlY3QgPSBjbGlwVHlwZSA9PT0gXCJpbnNldFwiIHx8IGNsaXBUeXBlID09PSBcInJlY3RcIjtcclxuICAgICAgICB2YXIgZGlzdHMgPSBjbGlwUG9zZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFswLCAwXTsgfSk7XHJcbiAgICAgICAgaWYgKGlzQ29udHJvbCAmJiAhaXNBbGwpIHtcclxuICAgICAgICAgICAgdmFyIF9lID0gY2xpcFBvc2VzW2NsaXBJbmRleF0sIGhvcml6b250YWwgPSBfZS5ob3Jpem9udGFsLCB2ZXJ0aWNhbCA9IF9lLnZlcnRpY2FsO1xyXG4gICAgICAgICAgICB2YXIgZGlzdCA9IFtcclxuICAgICAgICAgICAgICAgIGRpc3RYICogYWJzKGhvcml6b250YWwpLFxyXG4gICAgICAgICAgICAgICAgZGlzdFkgKiBhYnModmVydGljYWwpLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBkaXN0cyA9IG1vdmVDb250cm9sUG9zKGNsaXBQb3NlcywgY2xpcEluZGV4LCBkaXN0LCBpc1JlY3QsIGtlZXBSYXRpbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3RzID0gcG9zZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtkaXN0WCwgZGlzdFldOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5leHRQb3NlcyA9IHBvc2VzLm1hcChmdW5jdGlvbiAocG9zLCBpKSB7IHJldHVybiBwbHVzKHBvcywgZGlzdHNbaV0pOyB9KTtcclxuICAgICAgICB2YXIgZ3VpZGVQb3NlcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuZXh0UG9zZXMpLCBmYWxzZSk7XHJcbiAgICAgICAgc3RhdGUuc25hcEJvdW5kSW5mb3MgPSBudWxsO1xyXG4gICAgICAgIHZhciBpc0NpcmNsZSA9IGNsaXBQYXRoLnR5cGUgPT09IFwiY2lyY2xlXCI7XHJcbiAgICAgICAgdmFyIGlzRWxsaXBzZSA9IGNsaXBQYXRoLnR5cGUgPT09IFwiZWxsaXBzZVwiO1xyXG4gICAgICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcclxuICAgICAgICAgICAgdmFyIGd1aWRlUmVjdCA9IGdldFJlY3QobmV4dFBvc2VzKTtcclxuICAgICAgICAgICAgdmFyIHJ5ID0gYWJzKGd1aWRlUmVjdC5ib3R0b20gLSBndWlkZVJlY3QudG9wKTtcclxuICAgICAgICAgICAgdmFyIHJ4ID0gYWJzKGlzRWxsaXBzZSA/IGd1aWRlUmVjdC5yaWdodCAtIGd1aWRlUmVjdC5sZWZ0IDogcnkpO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gbmV4dFBvc2VzWzBdWzFdICsgcnk7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gbmV4dFBvc2VzWzBdWzBdIC0gcng7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IG5leHRQb3Nlc1swXVswXSArIHJ4O1xyXG4gICAgICAgICAgICAvLyByaWdodFxyXG4gICAgICAgICAgICBpZiAoaXNDaXJjbGUpIHtcclxuICAgICAgICAgICAgICAgIGd1aWRlUG9zZXMucHVzaChbcmlnaHQsIGd1aWRlUmVjdC5ib3R0b21dKTtcclxuICAgICAgICAgICAgICAgIGRpc3RzLnB1c2goWzEsIDBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBib3R0b21cclxuICAgICAgICAgICAgZ3VpZGVQb3Nlcy5wdXNoKFtndWlkZVJlY3QubGVmdCwgYm90dG9tXSk7XHJcbiAgICAgICAgICAgIGRpc3RzLnB1c2goWzAsIDFdKTtcclxuICAgICAgICAgICAgLy8gbGVmdFxyXG4gICAgICAgICAgICBndWlkZVBvc2VzLnB1c2goW2xlZnQsIGd1aWRlUmVjdC5ib3R0b21dKTtcclxuICAgICAgICAgICAgZGlzdHMucHVzaChbMSwgMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ3VpZGVsaW5lcyA9IGdldERlZmF1bHRHdWlkZWxpbmVzKChwcm9wcy5jbGlwSG9yaXpvbnRhbEd1aWRlbGluZXMgfHwgW10pLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gY29udmVydFVuaXRTaXplKFwiXCIuY29uY2F0KHYpLCBoZWlnaHQpOyB9KSwgKHByb3BzLmNsaXBWZXJ0aWNhbEd1aWRlbGluZXMgfHwgW10pLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gY29udmVydFVuaXRTaXplKFwiXCIuY29uY2F0KHYpLCB3aWR0aCk7IH0pLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB2YXIgZ3VpZGVYUG9zZXMgPSBbXTtcclxuICAgICAgICB2YXIgZ3VpZGVZUG9zZXMgPSBbXTtcclxuICAgICAgICBpZiAoaXNDaXJjbGUgfHwgaXNFbGxpcHNlKSB7XHJcbiAgICAgICAgICAgIGd1aWRlWFBvc2VzID0gW2d1aWRlUG9zZXNbNF1bMF0sIGd1aWRlUG9zZXNbMl1bMF1dO1xyXG4gICAgICAgICAgICBndWlkZVlQb3NlcyA9IFtndWlkZVBvc2VzWzFdWzFdLCBndWlkZVBvc2VzWzNdWzFdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0UG9zZXMgPSBbZ3VpZGVQb3Nlc1swXSwgZ3VpZGVQb3Nlc1syXSwgZ3VpZGVQb3Nlc1s0XSwgZ3VpZGVQb3Nlc1s2XV07XHJcbiAgICAgICAgICAgIHZhciByZWN0RGlzdHNfMSA9IFtkaXN0c1swXSwgZGlzdHNbMl0sIGRpc3RzWzRdLCBkaXN0c1s2XV07XHJcbiAgICAgICAgICAgIGd1aWRlWFBvc2VzID0gcmVjdFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gcmVjdERpc3RzXzFbaV1bMF07IH0pLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMF07IH0pO1xyXG4gICAgICAgICAgICBndWlkZVlQb3NlcyA9IHJlY3RQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIHJlY3REaXN0c18xW2ldWzFdOyB9KS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzFdOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGd1aWRlWFBvc2VzID0gZ3VpZGVQb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGRpc3RzW2ldWzBdOyB9KS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcG9zWzBdOyB9KTtcclxuICAgICAgICAgICAgZ3VpZGVZUG9zZXMgPSBndWlkZVBvc2VzLmZpbHRlcihmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gZGlzdHNbaV1bMV07IH0pLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMV07IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYm91bmREZWx0YSA9IFswLCAwXTtcclxuICAgICAgICB2YXIgX2YgPSBjaGVja1NuYXBCb3VuZHMoZ3VpZGVsaW5lcywgcHJvcHMuY2xpcFRhcmdldEJvdW5kcyAmJiB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHdpZHRoLCBib3R0b206IGhlaWdodCB9LCBndWlkZVhQb3NlcywgZ3VpZGVZUG9zZXMsIDUsIDUpLCBob3Jpem9udGFsU25hcEluZm8gPSBfZi5ob3Jpem9udGFsLCB2ZXJ0aWNhbFNuYXBJbmZvID0gX2YudmVydGljYWw7XHJcbiAgICAgICAgdmFyIHNuYXBPZmZzZXRZID0gaG9yaXpvbnRhbFNuYXBJbmZvLm9mZnNldDtcclxuICAgICAgICB2YXIgc25hcE9mZnNldFggPSB2ZXJ0aWNhbFNuYXBJbmZvLm9mZnNldDtcclxuICAgICAgICBpZiAoaG9yaXpvbnRhbFNuYXBJbmZvLmlzQm91bmQpIHtcclxuICAgICAgICAgICAgYm91bmREZWx0YVsxXSArPSBzbmFwT2Zmc2V0WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnRpY2FsU25hcEluZm8uaXNCb3VuZCkge1xyXG4gICAgICAgICAgICBib3VuZERlbHRhWzBdICs9IHNuYXBPZmZzZXRYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGlzRWxsaXBzZSB8fCBpc0NpcmNsZSkgJiYgZGlzdHNbMF1bMF0gPT09IDAgJiYgZGlzdHNbMF1bMV0gPT09IDApIHtcclxuICAgICAgICAgICAgdmFyIGd1aWRlUmVjdCA9IGdldFJlY3QobmV4dFBvc2VzKTtcclxuICAgICAgICAgICAgdmFyIGN5ID0gZ3VpZGVSZWN0LmJvdHRvbSAtIGd1aWRlUmVjdC50b3A7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IGlzRWxsaXBzZSA/IGd1aWRlUmVjdC5yaWdodCAtIGd1aWRlUmVjdC5sZWZ0IDogY3k7XHJcbiAgICAgICAgICAgIHZhciBkaXN0U25hcFggPSB2ZXJ0aWNhbFNuYXBJbmZvLmlzQm91bmRcclxuICAgICAgICAgICAgICAgID8gYWJzKHNuYXBPZmZzZXRYKVxyXG4gICAgICAgICAgICAgICAgOiAodmVydGljYWxTbmFwSW5mby5zbmFwSW5kZXggPT09IDAgPyAtc25hcE9mZnNldFggOiBzbmFwT2Zmc2V0WCk7XHJcbiAgICAgICAgICAgIHZhciBkaXN0U25hcFkgPSBob3Jpem9udGFsU25hcEluZm8uaXNCb3VuZFxyXG4gICAgICAgICAgICAgICAgPyBhYnMoc25hcE9mZnNldFkpXHJcbiAgICAgICAgICAgICAgICA6IChob3Jpem9udGFsU25hcEluZm8uc25hcEluZGV4ID09PSAwID8gLXNuYXBPZmZzZXRZIDogc25hcE9mZnNldFkpO1xyXG4gICAgICAgICAgICBjeCAtPSBkaXN0U25hcFg7XHJcbiAgICAgICAgICAgIGN5IC09IGRpc3RTbmFwWTtcclxuICAgICAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgICAgICBjeSA9IGNoZWNrU25hcEJvdW5kUHJpb3JpdHkodmVydGljYWxTbmFwSW5mbywgaG9yaXpvbnRhbFNuYXBJbmZvKSA+IDAgPyBjeSA6IGN4O1xyXG4gICAgICAgICAgICAgICAgY3ggPSBjeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gZ3VpZGVQb3Nlc1swXTtcclxuICAgICAgICAgICAgZ3VpZGVQb3Nlc1sxXVsxXSA9IGNlbnRlclsxXSAtIGN5O1xyXG4gICAgICAgICAgICBndWlkZVBvc2VzWzJdWzBdID0gY2VudGVyWzBdICsgY3g7XHJcbiAgICAgICAgICAgIGd1aWRlUG9zZXNbM11bMV0gPSBjZW50ZXJbMV0gKyBjeTtcclxuICAgICAgICAgICAgZ3VpZGVQb3Nlc1s0XVswXSA9IGNlbnRlclswXSAtIGN4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlY3QgJiYga2VlcFJhdGlvICYmIGlzQ29udHJvbCkge1xyXG4gICAgICAgICAgICB2YXIgX2cgPSBfX3JlYWQoZ2V0Q29udHJvbFNpemUoY2xpcFBvc2VzKSwgMiksIHdpZHRoXzEgPSBfZ1swXSwgaGVpZ2h0XzEgPSBfZ1sxXTtcclxuICAgICAgICAgICAgdmFyIHJhdGlvID0gd2lkdGhfMSAmJiBoZWlnaHRfMSA/IHdpZHRoXzEgLyBoZWlnaHRfMSA6IDA7XHJcbiAgICAgICAgICAgIHZhciBjbGlwUG9zZSA9IGNsaXBQb3Nlc1tjbGlwSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gY2xpcFBvc2UuZGlyZWN0aW9uIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciB0b3BfMiA9IGd1aWRlUG9zZXNbMV1bMV07XHJcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBndWlkZVBvc2VzWzVdWzFdO1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGd1aWRlUG9zZXNbN11bMF07XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IGd1aWRlUG9zZXNbM11bMF07XHJcbiAgICAgICAgICAgIGlmIChhYnMoc25hcE9mZnNldFkpIDw9IGFicyhzbmFwT2Zmc2V0WCkpIHtcclxuICAgICAgICAgICAgICAgIHNuYXBPZmZzZXRZID0gc2lnbihzbmFwT2Zmc2V0WSkgKiBhYnMoc25hcE9mZnNldFgpIC8gcmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbmFwT2Zmc2V0WCA9IHNpZ24oc25hcE9mZnNldFgpICogYWJzKHNuYXBPZmZzZXRZKSAqIHJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcIndcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCAtPSBzbmFwT2Zmc2V0WDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24uaW5kZXhPZihcImVcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgLT0gc25hcE9mZnNldFg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHNuYXBPZmZzZXRYIC8gMjtcclxuICAgICAgICAgICAgICAgIHJpZ2h0IC09IHNuYXBPZmZzZXRYIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uLmluZGV4T2YoXCJuXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRvcF8yIC09IHNuYXBPZmZzZXRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbi5pbmRleE9mKFwic1wiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBib3R0b20gLT0gc25hcE9mZnNldFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b3BfMiArPSBzbmFwT2Zmc2V0WSAvIDI7XHJcbiAgICAgICAgICAgICAgICBib3R0b20gLT0gc25hcE9mZnNldFkgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZXh0Q29udHJvbFBvc2VzXzIgPSBnZXRSZWN0UG9zZXModG9wXzIsIHJpZ2h0LCBib3R0b20sIGxlZnQpO1xyXG4gICAgICAgICAgICBndWlkZVBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHBvcywgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQobmV4dENvbnRyb2xQb3Nlc18yW2ldLnBvcywgMiksIHBvc1swXSA9IF9hWzBdLCBwb3NbMV0gPSBfYVsxXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBndWlkZVBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHBvcywgaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBkaXN0c1tqXTtcclxuICAgICAgICAgICAgICAgIGlmIChkaXN0WzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zWzBdIC09IHNuYXBPZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NbMV0gLT0gc25hcE9mZnNldFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dENsaXBTdHlsZXMgPSBnZXRDbGlwU3R5bGVzKG1vdmVhYmxlLCBjbGlwUGF0aCwgbmV4dFBvc2VzKTtcclxuICAgICAgICB2YXIgY2xpcFN0eWxlID0gXCJcIi5jb25jYXQoY2xpcFR5cGUsIFwiKFwiKS5jb25jYXQobmV4dENsaXBTdHlsZXMuam9pbihzcGxpdHRlciksIFwiKVwiKTtcclxuICAgICAgICBzdGF0ZS5jbGlwUGF0aFN0YXRlID0gY2xpcFN0eWxlO1xyXG4gICAgICAgIGlmIChpc0NpcmNsZSB8fCBpc0VsbGlwc2UpIHtcclxuICAgICAgICAgICAgZ3VpZGVYUG9zZXMgPSBbZ3VpZGVQb3Nlc1s0XVswXSwgZ3VpZGVQb3Nlc1syXVswXV07XHJcbiAgICAgICAgICAgIGd1aWRlWVBvc2VzID0gW2d1aWRlUG9zZXNbMV1bMV0sIGd1aWRlUG9zZXNbM11bMV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlY3QpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3RQb3NlcyA9IFtndWlkZVBvc2VzWzBdLCBndWlkZVBvc2VzWzJdLCBndWlkZVBvc2VzWzRdLCBndWlkZVBvc2VzWzZdXTtcclxuICAgICAgICAgICAgZ3VpZGVYUG9zZXMgPSByZWN0UG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1swXTsgfSk7XHJcbiAgICAgICAgICAgIGd1aWRlWVBvc2VzID0gcmVjdFBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMV07IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ3VpZGVYUG9zZXMgPSBndWlkZVBvc2VzLm1hcChmdW5jdGlvbiAocG9zKSB7IHJldHVybiBwb3NbMF07IH0pO1xyXG4gICAgICAgICAgICBndWlkZVlQb3NlcyA9IGd1aWRlUG9zZXMubWFwKGZ1bmN0aW9uIChwb3MpIHsgcmV0dXJuIHBvc1sxXTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLnNuYXBCb3VuZEluZm9zID0gY2hlY2tTbmFwQm91bmRzKGd1aWRlbGluZXMsIHByb3BzLmNsaXBUYXJnZXRCb3VuZHMgJiYgeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB3aWR0aCwgYm90dG9tOiBoZWlnaHQgfSwgZ3VpZGVYUG9zZXMsIGd1aWRlWVBvc2VzLCAxLCAxKTtcclxuICAgICAgICBpZiAob3JpZ2luYWxEcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgdmFyIGlzM2QgPSBzdGF0ZS5pczNkLCBhbGxNYXRyaXggPSBzdGF0ZS5hbGxNYXRyaXg7XHJcbiAgICAgICAgICAgIHZhciBuID0gaXMzZCA/IDQgOiAzO1xyXG4gICAgICAgICAgICB2YXIgZHJhZ0Rpc3QgPSBib3VuZERlbHRhO1xyXG4gICAgICAgICAgICBpZiAoaXNEcmFnVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnRGlzdCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdERpc3RbMF0gKyBib3VuZERlbHRhWzBdIC0gb3JpZ2luYWxEaXN0WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RGlzdFsxXSArIGJvdW5kRGVsdGFbMV0gLSBvcmlnaW5hbERpc3RbMV0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRHJhZ2dhYmxlLmRlbHRhT2Zmc2V0ID0gbXVsdGlwbHkoYWxsTWF0cml4LCBbZHJhZ0Rpc3RbMF0sIGRyYWdEaXN0WzFdLCAwLCAwXSwgbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oeyBjbGlwRXZlbnRUeXBlOiBcImNoYW5nZWRcIiwgY2xpcFR5cGU6IGNsaXBUeXBlLCBwb3NlczogbmV4dFBvc2VzLCBjbGlwU3R5bGU6IGNsaXBTdHlsZSwgY2xpcFN0eWxlczogbmV4dENsaXBTdHlsZXMsIGRpc3RYOiBkaXN0WCwgZGlzdFk6IGRpc3RZIH0sIGZpbGxDU1NPYmplY3QoKF9jID0ge30sXHJcbiAgICAgICAgICAgIF9jW2NsaXBUeXBlID09PSBcInJlY3RcIiA/IFwiY2xpcFwiIDogXCJjbGlwUGF0aFwiXSA9IGNsaXBTdHlsZSxcclxuICAgICAgICAgICAgX2MpLCBlKSkpKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdGhpcy51bnNldChtb3ZlYWJsZSk7XHJcbiAgICAgICAgdmFyIGlzRHJhZyA9IGUuaXNEcmFnLCBkYXRhcyA9IGUuZGF0YXMsIGlzRG91YmxlID0gZS5pc0RvdWJsZTtcclxuICAgICAgICB2YXIgaXNMaW5lID0gZGF0YXMuaXNMaW5lLCBpc0NsaXBTdGFydCA9IGRhdGFzLmlzQ2xpcFN0YXJ0LCBpc0NvbnRyb2wgPSBkYXRhcy5pc0NvbnRyb2w7XHJcbiAgICAgICAgaWYgKCFpc0NsaXBTdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaXBFbmRcIiwgZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pKTtcclxuICAgICAgICBpZiAoaXNEb3VibGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xpcFBhdGgobW92ZWFibGUsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTGluZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkXHJcbiAgICAgICAgICAgICAgICBhZGRDbGlwUGF0aChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRG91YmxlIHx8IGlzRHJhZztcclxuICAgIH0sXHJcbiAgICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuY2xpcFBhdGhTdGF0ZSA9IFwiXCI7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuc25hcEJvdW5kSW5mb3MgPSBudWxsO1xyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gY2xpcCB0aGUgdGFyZ2V0LiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwcGFibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcclxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxyXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcclxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcclxuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcclxuICogICAgIH0gZWxzZSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcclxuICogICAgIH1cclxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqICBJZiBjbGlwcGF0aCBpcyBub3Qgc2V0LCB0aGUgZGVmYXVsdCB2YWx1ZSBjYW4gYmUgc2V0LiAoZGVmYXVsdENsaXBQYXRoIDwgc3R5bGUgPCBjdXN0b21DbGlwUGF0aCA8IGRyYWdnaW5nIGNsaXBQYXRoKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjZGVmYXVsdENsaXBQYXRoXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiAlIENhbiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGFic29sdXRlIHB4IChgcmVjdGAgbm90IHBvc3NpYmxlKSAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwUmVsYXRpdmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiAqICAgICBkZWZhdWx0Q2xpcFBhdGg6IFwiaW5zZXRcIixcclxuICogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxyXG4gKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuICogICAgIGNsaXBBcmVhOiBmYWxzZSxcclxuICogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiY2xpcFN0YXJ0XCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pLm9uKFwiY2xpcFwiLCBlID0+IHtcclxuICogICAgIGlmIChlLmNsaXBUeXBlID09PSBcInJlY3RcIikge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcclxuICogICAgIH0gZWxzZSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcFBhdGggPSBlLmNsaXBTdHlsZTtcclxuICogICAgIH1cclxuICogfSkub24oXCJjbGlwRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFlvdSBjYW4gZm9yY2UgdGhlIGN1c3RvbSBjbGlwUGF0aC4gKGRlZmF1bHRDbGlwUGF0aCA8IHN0eWxlIDwgY3VzdG9tQ2xpcFBhdGggPCBkcmFnZ2luZyBjbGlwUGF0aClcclxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2N1c3RvbUNsaXBQYXRoXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIGRyYWdnaW5nIHRoZSB0YXJnZXQsIHRoZSBjbGlwIGFsc28gbW92ZXMuIChkZWZhdWx0OiB0cnVlKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjZHJhZ1dpdGhDbGlwXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBZb3UgY2FuIGRyYWcgdGhlIGNsaXAgYnkgc2V0dGluZyBjbGlwQXJlYS5cclxuICogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBBcmVhXHJcbiAqIEBkZWZhdWx0IGZhbHNlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4qIFdoZXRoZXIgdGhlIGNsaXAgaXMgYm91bmQgdG8gdGhlIHRhcmdldC5cclxuKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcFRhcmdldEJvdW5kc1xyXG4qIEBkZWZhdWx0IGZhbHNlXHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiogICAgIGN1c3RvbUNsaXBQYXRoOiBcIlwiLFxyXG4qICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4qICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiogICAgIGRyYWdXaXRoQ2xpcDogdHJ1ZSxcclxuKiAgICAgY2xpcFRhcmdldEJvdW5kczogdHJ1ZSxcclxuKiB9KTtcclxuKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4qICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXAgPSBlLmNsaXBTdHlsZTtcclxuKiAgICAgfSBlbHNlIHtcclxuKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiogICAgIH1cclxuKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuICogQWRkIGNsaXAgZ3VpZGVsaW5lcyBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5DbGlwcGFibGUjY2xpcFZlcnRpY2FsR3VpZGVsaW5lc1xyXG4gKiBAZGVmYXVsdCAwXHJcbiAqIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiogICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXHJcbiogICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcclxuKiAgICAgY2xpcFNuYXBUaHJlc2hvbGQ6IDUsXHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4qIEFkZCBjbGlwIGd1aWRlbGluZXMgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uLlxyXG4qIEBuYW1lIE1vdmVhYmxlLkNsaXBwYWJsZSNjbGlwSG9yaXpvbnRhbEd1aWRlbGluZXNcclxuKiBAZGVmYXVsdCBbXVxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiogICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXHJcbiogICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcclxuKiAgICAgY2xpcFNuYXBUaHJlc2hvbGQ6IDUsXHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4qIGlzdGFuY2UgdmFsdWUgdGhhdCBjYW4gc25hcCB0byBjbGlwIGd1aWRlbGluZXMuXHJcbiogQG5hbWUgTW92ZWFibGUuQ2xpcHBhYmxlI2NsaXBTbmFwVGhyZXNob2xkXHJcbiogQGRlZmF1bHQgNVxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBjbGlwcGFibGU6IHRydWUsXHJcbiogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4qICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuKiAgICAgY2xpcFJlbGF0aXZlOiBmYWxzZSxcclxuKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4qICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiogICAgIGNsaXBWZXJ0aWNhbEd1aWRlbGluZXM6IFswLCAxMDAsIDIwMF0sXHJcbiogICAgIGNsaXBIb3Jpem9udGFsR3VpZGVsaW5lczogWzAsIDEwMCwgMjAwXSxcclxuKiAgICAgY2xpcFNuYXBUaHJlc2hvbGQ6IDUsXHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4gKiBXaGVuIGRyYWcgc3RhcnQgdGhlIGNsaXAgYXJlYSBvciBjb250cm9scywgdGhlIGBjbGlwU3RhcnRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLkNsaXBwYWJsZVxyXG4gKiBAZXZlbnQgY2xpcFN0YXJ0XHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpcFN0YXJ0YCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIGNsaXBwYWJsZTogdHJ1ZSxcclxuICogICAgIGRlZmF1bHRDbGlwUGF0aDogXCJpbnNldFwiLFxyXG4gKiAgICAgY3VzdG9tQ2xpcFBhdGg6IFwiXCIsXHJcbiAqICAgICBjbGlwUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgY2xpcEFyZWE6IGZhbHNlLFxyXG4gKiAgICAgZHJhZ1dpdGhDbGlwOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJjbGlwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSkub24oXCJjbGlwXCIsIGUgPT4ge1xyXG4gKiAgICAgaWYgKGUuY2xpcFR5cGUgPT09IFwicmVjdFwiKSB7XHJcbiAqICAgICAgICAgZS50YXJnZXQuc3R5bGUuY2xpcCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfSBlbHNlIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwUGF0aCA9IGUuY2xpcFN0eWxlO1xyXG4gKiAgICAgfVxyXG4gKiB9KS5vbihcImNsaXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuQ2xpcHBhYmxlXHJcbiAqIEBldmVudCBjbGlwXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIGRyYWcgZW5kIHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgY2xpcEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuQ2xpcHBhYmxlXHJcbiAqIEBldmVudCBjbGlwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuQ2xpcHBhYmxlLk9uQ2xpcEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaXBFbmRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgY2xpcHBhYmxlOiB0cnVlLFxyXG4gKiAgICAgZGVmYXVsdENsaXBQYXRoOiBcImluc2V0XCIsXHJcbiAqICAgICBjdXN0b21DbGlwUGF0aDogXCJcIixcclxuICogICAgIGNsaXBSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBjbGlwQXJlYTogZmFsc2UsXHJcbiAqICAgICBkcmFnV2l0aENsaXA6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcImNsaXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcImNsaXBcIiwgZSA9PiB7XHJcbiAqICAgICBpZiAoZS5jbGlwVHlwZSA9PT0gXCJyZWN0XCIpIHtcclxuICogICAgICAgICBlLnRhcmdldC5zdHlsZS5jbGlwID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgIGUudGFyZ2V0LnN0eWxlLmNsaXBQYXRoID0gZS5jbGlwU3R5bGU7XHJcbiAqICAgICB9XHJcbiAqIH0pLm9uKFwiY2xpcEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXG5cbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE9yaWdpbkRyYWdnYWJsZVxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGRlc2NyaXB0aW9uIFdoZXRoZXIgdG8gZHJhZyBvcmlnaW4gKGRlZmF1bHQ6IGZhbHNlKVxyXG4gKi9cclxudmFyIE9yaWdpbkRyYWdnYWJsZSA9IHtcclxuICAgIG5hbWU6IFwib3JpZ2luRHJhZ2dhYmxlXCIsXHJcbiAgICBwcm9wczogW1xyXG4gICAgICAgIFwib3JpZ2luRHJhZ2dhYmxlXCIsXHJcbiAgICAgICAgXCJvcmlnaW5SZWxhdGl2ZVwiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwiZHJhZ09yaWdpblN0YXJ0XCIsXHJcbiAgICAgICAgXCJkcmFnT3JpZ2luXCIsXHJcbiAgICAgICAgXCJkcmFnT3JpZ2luRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgY3NzOiBbXHJcbiAgICAgICAgXCI6aG9zdFtkYXRhLWFibGUtb3JpZ2luZHJhZ2dhYmxlXSAuY29udHJvbC5vcmlnaW4ge1xcbnBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbn1cIixcclxuICAgIF0sXHJcbiAgICBkcmFnQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKF8sIGUpIHtcclxuICAgICAgICBpZiAoZS5pc1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGUucmVxdWVzdEFibGUgPT09IFwib3JpZ2luRHJhZ2dhYmxlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNDbGFzcyhlLmlucHV0RXZlbnQudGFyZ2V0LCBwcmVmaXgoXCJvcmlnaW5cIikpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgc2V0RHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IERyYWdnYWJsZS5kcmFnU3RhcnQobW92ZWFibGUsIG5ldyBDdXN0b21HZXN0bygpLmRyYWdTdGFydChbMCwgMF0sIGUpKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ09yaWdpblN0YXJ0XCIsIHBhcmFtcyk7XHJcbiAgICAgICAgZGF0YXMuc3RhcnRPcmlnaW4gPSBtb3ZlYWJsZS5zdGF0ZS50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgZGF0YXMuc3RhcnRUYXJnZXRPcmlnaW4gPSBtb3ZlYWJsZS5zdGF0ZS50YXJnZXRPcmlnaW47XHJcbiAgICAgICAgZGF0YXMucHJldk9yaWdpbiA9IFswLCAwXTtcclxuICAgICAgICBkYXRhcy5pc0RyYWdPcmlnaW4gPSB0cnVlO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGRhdGFzLmlzRHJhZ09yaWdpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2w6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXMsIGlzUGluY2ggPSBlLmlzUGluY2gsIGlzUmVxdWVzdCA9IGUuaXNSZXF1ZXN0O1xyXG4gICAgICAgIGlmICghZGF0YXMuaXNEcmFnT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGdldERyYWdEaXN0KGUpLCAyKSwgZGlzdFggPSBfYVswXSwgZGlzdFkgPSBfYVsxXTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBtb3ZlYWJsZS5zdGF0ZTtcclxuICAgICAgICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0LCBvZmZzZXRNYXRyaXggPSBzdGF0ZS5vZmZzZXRNYXRyaXgsIHRhcmdldE1hdHJpeCA9IHN0YXRlLnRhcmdldE1hdHJpeCwgaXMzZCA9IHN0YXRlLmlzM2Q7XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMub3JpZ2luUmVsYXRpdmUsIG9yaWdpblJlbGF0aXZlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcclxuICAgICAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgICAgICB2YXIgZGlzdCA9IFtkaXN0WCwgZGlzdFldO1xyXG4gICAgICAgIGlmIChpc1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgdmFyIGRpc3RPcmlnaW4gPSBlLmRpc3RPcmlnaW47XHJcbiAgICAgICAgICAgIGlmIChkaXN0T3JpZ2luWzBdIHx8IGRpc3RPcmlnaW5bMV0pIHtcclxuICAgICAgICAgICAgICAgIGRpc3QgPSBkaXN0T3JpZ2luO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW4gPSBwbHVzKGRhdGFzLnN0YXJ0T3JpZ2luLCBkaXN0KTtcclxuICAgICAgICB2YXIgdGFyZ2V0T3JpZ2luID0gcGx1cyhkYXRhcy5zdGFydFRhcmdldE9yaWdpbiwgZGlzdCk7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gbWludXMoZGlzdCwgZGF0YXMucHJldk9yaWdpbik7XHJcbiAgICAgICAgdmFyIG5leHRNYXRyaXggPSBnZXROZXh0TWF0cml4KG9mZnNldE1hdHJpeCwgdGFyZ2V0TWF0cml4LCBvcmlnaW4sIG4pO1xyXG4gICAgICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIHZhciBuZXh0UmVjdCA9IGdldFJlY3QoY2FsY3VsYXRlUG9zZXMobmV4dE1hdHJpeCwgd2lkdGgsIGhlaWdodCwgbikpO1xyXG4gICAgICAgIHZhciBkcmFnRGVsdGEgPSBbXHJcbiAgICAgICAgICAgIHJlY3QubGVmdCAtIG5leHRSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgIHJlY3QudG9wIC0gbmV4dFJlY3QudG9wLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgZGF0YXMucHJldk9yaWdpbiA9IGRpc3Q7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybU9yaWdpbiA9IFtcclxuICAgICAgICAgICAgY29udmVydENTU1NpemUodGFyZ2V0T3JpZ2luWzBdLCB3aWR0aCwgb3JpZ2luUmVsYXRpdmUpLFxyXG4gICAgICAgICAgICBjb252ZXJ0Q1NTU2l6ZSh0YXJnZXRPcmlnaW5bMV0sIGhlaWdodCwgb3JpZ2luUmVsYXRpdmUpLFxyXG4gICAgICAgIF0uam9pbihcIiBcIik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBzZXRDdXN0b21EcmFnKGUsIG1vdmVhYmxlLnN0YXRlLCBkcmFnRGVsdGEsICEhaXNQaW5jaCwgZmFsc2UpKTtcclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwgX19hc3NpZ24oX19hc3NpZ24oeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBvcmlnaW46IG9yaWdpbiwgZGlzdDogZGlzdCwgZGVsdGE6IGRlbHRhLCB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbiwgZHJhZzogcmVzdWx0IH0sIGZpbGxDU1NPYmplY3Qoe1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpbixcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiByZXN1bHQudHJhbnNmb3JtLFxyXG4gICAgICAgIH0sIGUpKSwgeyBhZnRlclRyYW5zZm9ybTogcmVzdWx0LnRyYW5zZm9ybSB9KSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uRHJhZ09yaWdpblwiLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IGUuZGF0YXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc0RyYWdPcmlnaW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25EcmFnT3JpZ2luRW5kXCIsIGZpbGxFbmRQYXJhbXMobW92ZWFibGUsIGUsIHt9KSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbENvbmRpdGlvbjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0NvbnRyb2xDb25kaXRpb24obW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZHJhZ0NvbnRyb2xTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlYWJsZS50cmFuc2Zvcm1PcmlnaW4gPSBwYXJhbXMudHJhbnNmb3JtT3JpZ2luO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgKiBAbWV0aG9kIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZSNyZXF1ZXN0XHJcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBlIC0gdGhlIE9yaWdpbkRyYWdnYWJsZSdzIHJlcXVlc3QgcGFyYW1ldGVyXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS54XSAtIHggcG9zaXRpb25cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLnldIC0geSBwb3NpdGlvblxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gW2UuZGVsdGFYXSAtIHggbnVtYmVyIHRvIG1vdmVcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IFtlLmRlbHRhWV0gLSB5IG51bWJlciB0byBtb3ZlXHJcbiAgICAqIEBwYXJhbSB7YXJyYXl9IFtlLmRlbHRhT3JpZ2luXSAtIGxlZnQsIHRvcCBudW1iZXIgdG8gbW92ZSB0cmFuc2Zvcm0tb3JpZ2luXHJcbiAgICAqIEBwYXJhbSB7YXJyYXl9IFtlLm9yaWdpbl0gLSB0cmFuc2Zvcm0tb3JpZ2luIHBvc2l0aW9uXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZS5pc0luc3RhbnRdIC0gV2hldGhlciB0byBleGVjdXRlIHRoZSByZXF1ZXN0IGluc3RhbnRseVxyXG4gICAgKiBAcmV0dXJuIHtNb3ZlYWJsZS5SZXF1ZXN0ZXJ9IE1vdmVhYmxlIFJlcXVlc3RlclxyXG4gICAgKiBAZXhhbXBsZVxyXG5cbiAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcclxuICAgICogLy8gVXNlIFJlbGF0aXZlIFZhbHVlXHJcbiAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0sIHRydWUpO1xyXG4gICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcclxuICAgICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0sIHRydWUpO1xyXG4gICAgKiAvLyBVc2UgVHJhbnNmb3JtIFZhbHVlXHJcbiAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyBkZWx0YU9yaWdpbjogWzEwLCAwXSB9LCB0cnVlKTtcclxuICAgICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IG9yaWdpbjogWzEwMCwgMF0gfSwgdHJ1ZSk7XHJcbiAgICAqIC8vIHJlcXVlc3RTdGFydFxyXG4gICAgKiBjb25zdCByZXF1ZXN0ZXIgPSBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIpO1xyXG4gICAgKlxyXG4gICAgKiAvLyByZXF1ZXN0XHJcbiAgICAqIC8vIFVzZSBSZWxhdGl2ZSBWYWx1ZVxyXG4gICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAqIHJlcXVlc3Rlci5yZXF1ZXN0KHsgZGVsdGFYOiAxMCwgZGVsdGFZOiAxMCB9KTtcclxuICAgICogcmVxdWVzdGVyLnJlcXVlc3QoeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0pO1xyXG4gICAgKiAvLyBVc2UgQWJzb2x1dGUgVmFsdWVcclxuICAgICogbW92ZWFibGUucmVxdWVzdChcIm9yaWdpbkRyYWdnYWJsZVwiLCB7IHg6IDIwMCwgeTogMTAwIH0pO1xyXG4gICAgKiBtb3ZlYWJsZS5yZXF1ZXN0KFwib3JpZ2luRHJhZ2dhYmxlXCIsIHsgeDogMjIwLCB5OiAxMDAgfSk7XHJcbiAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJvcmlnaW5EcmFnZ2FibGVcIiwgeyB4OiAyNDAsIHk6IDEwMCB9KTtcclxuICAgICpcclxuICAgICogLy8gcmVxdWVzdEVuZFxyXG4gICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xyXG4gICAgKi9cclxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHZhciBkYXRhcyA9IHt9O1xyXG4gICAgICAgIHZhciByZWN0ID0gbW92ZWFibGUuZ2V0UmVjdCgpO1xyXG4gICAgICAgIHZhciBkaXN0WCA9IDA7XHJcbiAgICAgICAgdmFyIGRpc3RZID0gMDtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gcmVjdC50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgdmFyIGRpc3RPcmlnaW4gPSBbMCwgMF07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNDb250cm9sOiB0cnVlLFxyXG4gICAgICAgICAgICByZXF1ZXN0U3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFzOiBkYXRhcyB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiZGVsdGFPcmlnaW5cIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdE9yaWdpblswXSArPSBlLmRlbHRhT3JpZ2luWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RPcmlnaW5bMV0gKz0gZS5kZWx0YU9yaWdpblsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwib3JpZ2luXCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RPcmlnaW5bMF0gPSBlLm9yaWdpblswXSAtIHRyYW5zZm9ybU9yaWdpblswXTtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0T3JpZ2luWzFdID0gZS5vcmlnaW5bMV0gLSB0cmFuc2Zvcm1PcmlnaW5bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ4XCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0WCA9IGUueCAtIHJlY3QubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkZWx0YVhcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RYICs9IGUuZGVsdGFYO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ5XCIgaW4gZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0WSA9IGUueSAtIHJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcImRlbHRhWVwiIGluIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdFkgKz0gZS5kZWx0YVk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YXM6IGRhdGFzLCBkaXN0WDogZGlzdFgsIGRpc3RZOiBkaXN0WSwgZGlzdE9yaWdpbjogZGlzdE9yaWdpbiB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhczogZGF0YXMsIGlzRHJhZzogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciB0byBkcmFnIG9yaWdpbiAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZSNvcmlnaW5EcmFnZ2FibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBsZXQgdHJhbnNsYXRlID0gWzAsIDBdO1xyXG4gKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcclxuICogICAgIGUuZHJhZ1N0YXJ0ICYmIGUuZHJhZ1N0YXJ0LnNldCh0cmFuc2xhdGUpO1xyXG4gKiB9KS5vbihcImRyYWdPcmlnaW5cIiwgZSA9PiB7XHJcbiAqICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xyXG4gKiAgICAgZS50YXJnZXQuc3R5bGUuY3NzVGV4dFxyXG4gKiAgICAgICAgID0gYHRyYW5zZm9ybS1vcmlnaW46ICR7ZS50cmFuc2Zvcm1PcmlnaW59O2BcclxuICogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcclxuICogfSkub24oXCJkcmFnT3JpZ2luRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqICUgQ2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYWJzb2x1dGUgcHggKGRlZmF1bHQ6IHRydWUpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZSNvcmlnaW5SZWxhdGl2ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcclxuICogICAgIG9yaWdpblJlbGF0aXZlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9yaWdpblJlbGF0aXZlID0gdHJ1ZTtcclxuICovXHJcbi8qKlxyXG4qIFdoZW4gZHJhZyBzdGFydCB0aGUgb3JpZ2luLCB0aGUgYGRyYWdPcmlnaW5TdGFydGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGVcclxuKiBAZXZlbnQgZHJhZ09yaWdpblN0YXJ0XHJcbiogQHBhcmFtIHtNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGUuT25EcmFnT3JpZ2luU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnT3JpZ2luU3RhcnRgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcclxuKiB9KTtcclxuKiBsZXQgdHJhbnNsYXRlID0gWzAsIDBdO1xyXG4qIG1vdmVhYmxlLm9uKFwiZHJhZ09yaWdpblN0YXJ0XCIsIGUgPT4ge1xyXG4qICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcclxuKiB9KS5vbihcImRyYWdPcmlnaW5cIiwgZSA9PiB7XHJcbiogICAgIHRyYW5zbGF0ZSA9IGUuZHJhZy5iZWZvcmVUcmFuc2xhdGU7XHJcbiogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcclxuKiAgICAgICAgID0gYHRyYW5zZm9ybS1vcmlnaW46ICR7ZS50cmFuc2Zvcm1PcmlnaW59O2BcclxuKiAgICAgICAgICsgYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfXB4LCAke3RyYW5zbGF0ZVsxXX1weClgO1xyXG4qIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiogfSk7XHJcbiovXHJcbi8qKlxyXG4qIFdoZW4gZHJhZyB0aGUgb3JpZ2luLCB0aGUgYGRyYWdPcmlnaW5gIGV2ZW50IGlzIGNhbGxlZC5cclxuKiBAbWVtYmVyb2YgTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlXHJcbiogQGV2ZW50IGRyYWdPcmlnaW5cclxuKiBAcGFyYW0ge01vdmVhYmxlLk9yaWdpbkRyYWdnYWJsZS5PbkRyYWdPcmlnaW59IC0gUGFyYW1ldGVycyBmb3IgdGhlIGBkcmFnT3JpZ2luYCBldmVudFxyXG4qIEBleGFtcGxlXHJcbiogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4qXHJcbiogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4qICAgICBvcmlnaW5EcmFnZ2FibGU6IHRydWUsXHJcbiogfSk7XHJcbiogbGV0IHRyYW5zbGF0ZSA9IFswLCAwXTtcclxuKiBtb3ZlYWJsZS5vbihcImRyYWdPcmlnaW5TdGFydFwiLCBlID0+IHtcclxuKiAgICAgZS5kcmFnU3RhcnQgJiYgZS5kcmFnU3RhcnQuc2V0KHRyYW5zbGF0ZSk7XHJcbiogfSkub24oXCJkcmFnT3JpZ2luXCIsIGUgPT4ge1xyXG4qICAgICB0cmFuc2xhdGUgPSBlLmRyYWcuYmVmb3JlVHJhbnNsYXRlO1xyXG4qICAgICBlLnRhcmdldC5zdHlsZS5jc3NUZXh0XHJcbiogICAgICAgICA9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke2UudHJhbnNmb3JtT3JpZ2lufTtgXHJcbiogICAgICAgICArIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVswXX1weCwgJHt0cmFuc2xhdGVbMV19cHgpYDtcclxuKiB9KS5vbihcImRyYWdPcmlnaW5FbmRcIiwgZSA9PiB7XHJcbiogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4qIH0pO1xyXG4qL1xyXG4vKipcclxuKiBXaGVuIGRyYWcgZW5kIHRoZSBvcmlnaW4sIHRoZSBgZHJhZ09yaWdpbkVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4qIEBtZW1iZXJvZiBNb3ZlYWJsZS5PcmlnaW5EcmFnZ2FibGVcclxuKiBAZXZlbnQgZHJhZ09yaWdpbkVuZFxyXG4qIEBwYXJhbSB7TW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLk9uRHJhZ09yaWdpbkVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGRyYWdPcmlnaW5FbmRgIGV2ZW50XHJcbiogQGV4YW1wbGVcclxuKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbipcclxuKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiogICAgIG9yaWdpbkRyYWdnYWJsZTogdHJ1ZSxcclxuKiB9KTtcclxuKiBsZXQgdHJhbnNsYXRlID0gWzAsIDBdO1xyXG4qIG1vdmVhYmxlLm9uKFwiZHJhZ09yaWdpblN0YXJ0XCIsIGUgPT4ge1xyXG4qICAgICBlLmRyYWdTdGFydCAmJiBlLmRyYWdTdGFydC5zZXQodHJhbnNsYXRlKTtcclxuKiB9KS5vbihcImRyYWdPcmlnaW5cIiwgZSA9PiB7XHJcbiogICAgIHRyYW5zbGF0ZSA9IGUuZHJhZy5iZWZvcmVUcmFuc2xhdGU7XHJcbiogICAgIGUudGFyZ2V0LnN0eWxlLmNzc1RleHRcclxuKiAgICAgICAgID0gYHRyYW5zZm9ybS1vcmlnaW46ICR7ZS50cmFuc2Zvcm1PcmlnaW59O2BcclxuKiAgICAgICAgICsgYHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dHJhbnNsYXRlWzBdfXB4LCAke3RyYW5zbGF0ZVsxXX1weClgO1xyXG4qIH0pLm9uKFwiZHJhZ09yaWdpbkVuZFwiLCBlID0+IHtcclxuKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiogfSk7XHJcbiovXG5cbmZ1bmN0aW9uIGFkZEJvcmRlclJhZGl1c0J5TGluZShjb250cm9sUG9zZXMsIGxpbmVJbmRleCwgZGlzdFgsIGRpc3RZKSB7XHJcbiAgICAvLyBsaW5lSW5kZXhcclxuICAgIC8vIDAgdG9wXHJcbiAgICAvLyAxIHJpZ2h0XHJcbiAgICAvLyAyIGJvdHRvbVxyXG4gICAgLy8gMyBsZWZ0XHJcbiAgICB2YXIgaG9yaXpvbnRhbHNMZW5ndGggPSBjb250cm9sUG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB2aXJ0dWFsID0gX2EudmlydHVhbCwgaG9yaXpvbnRhbCA9IF9hLmhvcml6b250YWw7XHJcbiAgICAgICAgcmV0dXJuIGhvcml6b250YWwgJiYgIXZpcnR1YWw7XHJcbiAgICB9KS5sZW5ndGg7XHJcbiAgICB2YXIgdmVydGljYWxzTGVuZ3RoID0gY29udHJvbFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgdmlydHVhbCA9IF9hLnZpcnR1YWwsIHZlcnRpY2FsID0gX2EudmVydGljYWw7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRpY2FsICYmICF2aXJ0dWFsO1xyXG4gICAgfSkubGVuZ3RoO1xyXG4gICAgdmFyIGNvbnRyb2xJbmRleCA9IC0xO1xyXG4gICAgLy90b3BcclxuICAgIGlmIChsaW5lSW5kZXggPT09IDApIHtcclxuICAgICAgICBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29udHJvbEluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgY29udHJvbEluZGV4ID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBib3R0b21cclxuICAgIGlmIChsaW5lSW5kZXggPT09IDIpIHtcclxuICAgICAgICBpZiAoaG9yaXpvbnRhbHNMZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICBjb250cm9sSW5kZXggPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob3Jpem9udGFsc0xlbmd0aCA8PSAzKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xJbmRleCA9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbGVmdFxyXG4gICAgaWYgKGxpbmVJbmRleCA9PT0gMykge1xyXG4gICAgICAgIGlmICh2ZXJ0aWNhbHNMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29udHJvbEluZGV4ID0gNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmVydGljYWxzTGVuZ3RoIDwgNCkge1xyXG4gICAgICAgICAgICBjb250cm9sSW5kZXggPSA3O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJpZ2h0XHJcbiAgICBpZiAobGluZUluZGV4ID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xJbmRleCA9IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZlcnRpY2Fsc0xlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xJbmRleCA9IDY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNvbnRyb2xJbmRleCA9PT0gLTEgfHwgIWNvbnRyb2xQb3Nlc1tjb250cm9sSW5kZXhdLnZpcnR1YWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY29udHJvbFBvc2VJbmZvID0gY29udHJvbFBvc2VzW2NvbnRyb2xJbmRleF07XHJcbiAgICBhZGRCb3JkZXJSYWRpdXMoY29udHJvbFBvc2VzLCBjb250cm9sSW5kZXgpO1xyXG4gICAgaWYgKGNvbnRyb2xJbmRleCA8IDQpIHtcclxuICAgICAgICBjb250cm9sUG9zZUluZm8ucG9zWzBdID0gZGlzdFg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250cm9sUG9zZUluZm8ucG9zWzFdID0gZGlzdFk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkQm9yZGVyUmFkaXVzKGNvbnRyb2xQb3NlcywgaW5kZXgpIHtcclxuICAgIGlmIChpbmRleCA8IDQpIHtcclxuICAgICAgICBjb250cm9sUG9zZXMuc2xpY2UoMCwgaW5kZXggKyAxKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgIGluZm8udmlydHVhbCA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGNvbnRyb2xQb3Nlc1swXS52aXJ0dWFsKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xQb3Nlc1swXS52aXJ0dWFsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2xQb3Nlcy5zbGljZSg0LCBpbmRleCArIDEpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgaW5mby52aXJ0dWFsID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlQm9yZGVyUmFkaXVzKGNvbnRyb2xQb3NlcywgaW5kZXgpIHtcclxuICAgIGlmIChpbmRleCA8IDQpIHtcclxuICAgICAgICBjb250cm9sUG9zZXMuc2xpY2UoaW5kZXgsIDQpLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgaW5mby52aXJ0dWFsID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnRyb2xQb3Nlcy5zbGljZShpbmRleCkuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICBpbmZvLnZpcnR1YWwgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEJvcmRlclJhZGl1cyhib3JkZXJSYWRpdXMsIHdpZHRoLCBoZWlnaHQsIG1pbkNvdW50cywgZnVsbCkge1xyXG4gICAgaWYgKG1pbkNvdW50cyA9PT0gdm9pZCAwKSB7IG1pbkNvdW50cyA9IFswLCAwXTsgfVxyXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgaWYgKCFib3JkZXJSYWRpdXMgfHwgYm9yZGVyUmFkaXVzID09PSBcIjBweFwiKSB7XHJcbiAgICAgICAgdmFsdWVzID0gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWx1ZXMgPSBzcGxpdFNwYWNlKGJvcmRlclJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0UmFkaXVzVmFsdWVzKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgMCwgMCwgbWluQ291bnRzLCBmdWxsKTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyUm91bmRFdmVudChtb3ZlYWJsZSwgZSwgZGlzdCwgZGVsdGEsIG5leHRQb3Nlcykge1xyXG4gICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICB2YXIgd2lkdGggPSBzdGF0ZS53aWR0aCwgaGVpZ2h0ID0gc3RhdGUuaGVpZ2h0O1xyXG4gICAgdmFyIF9hID0gZ2V0UmFkaXVzU3R5bGVzKG5leHRQb3NlcywgbW92ZWFibGUucHJvcHMucm91bmRSZWxhdGl2ZSwgd2lkdGgsIGhlaWdodCksIHJhd3MgPSBfYS5yYXdzLCBzdHlsZXMgPSBfYS5zdHlsZXMsIHJhZGl1c1Bvc2VzID0gX2EucmFkaXVzUG9zZXM7XHJcbiAgICB2YXIgX2IgPSBzcGxpdFJhZGl1c1Bvc2VzKHJhZGl1c1Bvc2VzLCByYXdzKSwgaG9yaXpvbnRhbHMgPSBfYi5ob3Jpem9udGFscywgdmVydGljYWxzID0gX2IudmVydGljYWxzO1xyXG4gICAgdmFyIGJvcmRlclJhZGl1cyA9IHN0eWxlcy5qb2luKFwiIFwiKTtcclxuICAgIHN0YXRlLmJvcmRlclJhZGl1c1N0YXRlID0gYm9yZGVyUmFkaXVzO1xyXG4gICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgaG9yaXpvbnRhbHM6IGhvcml6b250YWxzLCB2ZXJ0aWNhbHM6IHZlcnRpY2FscywgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGRlbHRhOiBkZWx0YSwgZGlzdDogZGlzdCB9LCBmaWxsQ1NTT2JqZWN0KHtcclxuICAgICAgICBib3JkZXJSYWRpdXM6IGJvcmRlclJhZGl1cyxcclxuICAgIH0sIGUpKSk7XHJcbiAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3VuZFwiLCBwYXJhbXMpO1xyXG4gICAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5mdW5jdGlvbiBnZXRTdHlsZUJvcmRlclJhZGl1cyhtb3ZlYWJsZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciBzdHlsZSA9IG1vdmVhYmxlLmdldFN0YXRlKCkuc3R5bGU7XHJcbiAgICB2YXIgYm9yZGVyUmFkaXVzID0gc3R5bGUuYm9yZGVyUmFkaXVzIHx8IFwiXCI7XHJcbiAgICBpZiAoIWJvcmRlclJhZGl1cyAmJiBtb3ZlYWJsZS5wcm9wcy5ncm91cGFibGUpIHtcclxuICAgICAgICB2YXIgZmlyc3RNb3ZlYWJsZSA9IG1vdmVhYmxlLm1vdmVhYmxlc1swXTtcclxuICAgICAgICB2YXIgZmlyc3RUYXJnZXQgPSBtb3ZlYWJsZS5nZXRUYXJnZXRzKClbMF07XHJcbiAgICAgICAgaWYgKGZpcnN0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICgoZmlyc3RNb3ZlYWJsZSA9PT0gbnVsbCB8fCBmaXJzdE1vdmVhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdE1vdmVhYmxlLnByb3BzLnRhcmdldCkgPT09IGZpcnN0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXMgPSAoX2IgPSAoX2EgPSBtb3ZlYWJsZS5tb3ZlYWJsZXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZS5zdHlsZS5ib3JkZXJSYWRpdXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSBib3JkZXJSYWRpdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXMgPSBnZXRDb21wdXRlZFN0eWxlKGZpcnN0VGFyZ2V0KS5ib3JkZXJSYWRpdXM7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSBib3JkZXJSYWRpdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYm9yZGVyUmFkaXVzO1xyXG59XHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIE1vdmVhYmxlLlJvdW5kYWJsZVxyXG4gKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBzaG93IGFuZCBkcmFnIG9yIGRvdWJsZSBjbGljayBib3JkZXItcmFkaXVzXHJcbiAqL1xyXG52YXIgUm91bmRhYmxlID0ge1xyXG4gICAgbmFtZTogXCJyb3VuZGFibGVcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJyb3VuZGFibGVcIixcclxuICAgICAgICBcInJvdW5kUmVsYXRpdmVcIixcclxuICAgICAgICBcIm1pblJvdW5kQ29udHJvbHNcIixcclxuICAgICAgICBcIm1heFJvdW5kQ29udHJvbHNcIixcclxuICAgICAgICBcInJvdW5kQ2xpY2thYmxlXCIsXHJcbiAgICAgICAgXCJyb3VuZFBhZGRpbmdcIixcclxuICAgICAgICBcImlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcInJvdW5kU3RhcnRcIixcclxuICAgICAgICBcInJvdW5kXCIsXHJcbiAgICAgICAgXCJyb3VuZEVuZFwiLFxyXG4gICAgICAgIFwicm91bmRHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJyb3VuZEdyb3VwXCIsXHJcbiAgICAgICAgXCJyb3VuZEdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgY3NzOiBbXHJcbiAgICAgICAgXCIuY29udHJvbC5ib3JkZXItcmFkaXVzIHtcXG5iYWNrZ3JvdW5kOiAjZDY2O1xcbmN1cnNvcjogcG9pbnRlcjtcXG56LWluZGV4OiAzO1xcbn1cIixcclxuICAgICAgICBcIi5jb250cm9sLmJvcmRlci1yYWRpdXMudmVydGljYWwge1xcbmJhY2tncm91bmQ6ICNkNmQ7XFxuei1pbmRleDogMjtcXG59XCIsXHJcbiAgICAgICAgXCIuY29udHJvbC5ib3JkZXItcmFkaXVzLnZpcnR1YWwge1xcbm9wYWNpdHk6IDAuNTtcXG56LWluZGV4OiAxO1xcbn1cIixcclxuICAgICAgICBcIjpob3N0LnJvdW5kLWxpbmUtY2xpY2thYmxlIC5saW5lLmRpcmVjdGlvbiB7XFxuY3Vyc29yOiBwb2ludGVyO1xcbn1cIixcclxuICAgIF0sXHJcbiAgICBjbGFzc05hbWU6IGZ1bmN0aW9uIChtb3ZlYWJsZSkge1xyXG4gICAgICAgIHZhciByb3VuZENsaWNrYWJsZSA9IG1vdmVhYmxlLnByb3BzLnJvdW5kQ2xpY2thYmxlO1xyXG4gICAgICAgIHJldHVybiByb3VuZENsaWNrYWJsZSA9PT0gdHJ1ZSB8fCByb3VuZENsaWNrYWJsZSA9PT0gXCJsaW5lXCIgPyBwcmVmaXgoXCJyb3VuZC1saW5lLWNsaWNrYWJsZVwiKSA6IFwiXCI7XHJcbiAgICB9LFxyXG4gICAgcmVxdWVzdFN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcImJvcmRlclJhZGl1c1wiXTtcclxuICAgIH0sXHJcbiAgICByZXF1ZXN0Q2hpbGRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXCJib3JkZXJSYWRpdXNcIl07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUuZ2V0U3RhdGUoKSwgdGFyZ2V0ID0gX2EudGFyZ2V0LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQsIGFsbE1hdHJpeCA9IF9hLmFsbE1hdHJpeCwgaXMzZCA9IF9hLmlzM2QsIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIGJvcmRlclJhZGl1c1N0YXRlID0gX2EuYm9yZGVyUmFkaXVzU3RhdGU7XHJcbiAgICAgICAgdmFyIF9iID0gbW92ZWFibGUucHJvcHMsIF9jID0gX2IubWluUm91bmRDb250cm9scywgbWluUm91bmRDb250cm9scyA9IF9jID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfYywgX2QgPSBfYi5tYXhSb3VuZENvbnRyb2xzLCBtYXhSb3VuZENvbnRyb2xzID0gX2QgPT09IHZvaWQgMCA/IFs0LCA0XSA6IF9kLCB6b29tID0gX2Iuem9vbSwgX2UgPSBfYi5yb3VuZFBhZGRpbmcsIHJvdW5kUGFkZGluZyA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIGlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHMgPSBfYi5pc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzLCBncm91cGFibGUgPSBfYi5ncm91cGFibGU7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBib3JkZXJSYWRpdXMgPSBib3JkZXJSYWRpdXNTdGF0ZSB8fCBnZXRTdHlsZUJvcmRlclJhZGl1cyhtb3ZlYWJsZSk7XHJcbiAgICAgICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICAgICAgdmFyIHJhZGl1c1ZhbHVlcyA9IGdldEJvcmRlclJhZGl1cyhib3JkZXJSYWRpdXMsIHdpZHRoLCBoZWlnaHQsIG1pblJvdW5kQ29udHJvbHMsIHRydWUpO1xyXG4gICAgICAgIGlmICghcmFkaXVzVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmVydGljYWxDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGJhc2VQb3MgPSBncm91cGFibGUgPyBbMCwgMF0gOiBbbGVmdCwgdG9wXTtcclxuICAgICAgICByZXR1cm4gcmFkaXVzVmFsdWVzLm1hcChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IHYuaG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2FsID0gdi52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHYuZGlyZWN0aW9uIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFBvcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh2LnBvcyksIGZhbHNlKTtcclxuICAgICAgICAgICAgaG9yaXpvbnRhbENvdW50ICs9IE1hdGguYWJzKGhvcml6b250YWwpO1xyXG4gICAgICAgICAgICB2ZXJ0aWNhbENvdW50ICs9IE1hdGguYWJzKHZlcnRpY2FsKTtcclxuICAgICAgICAgICAgaWYgKGhvcml6b250YWwgJiYgZGlyZWN0aW9uLmluZGV4T2YoXCJuXCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9zWzFdIC09IHJvdW5kUGFkZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVydGljYWwgJiYgZGlyZWN0aW9uLmluZGV4T2YoXCJ3XCIpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUG9zWzBdIC09IHJvdW5kUGFkZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCAmJiBkaXJlY3Rpb24uaW5kZXhPZihcInNcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQb3NbMV0gKz0gcm91bmRQYWRkaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCAmJiBkaXJlY3Rpb24uaW5kZXhPZihcImVcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQb3NbMF0gKz0gcm91bmRQYWRkaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwb3MgPSBtaW51cyhjYWxjdWxhdGVQb3NpdGlvbihhbGxNYXRyaXgsIG9yaWdpbmFsUG9zLCBuKSwgYmFzZVBvcyk7XHJcbiAgICAgICAgICAgIHZhciBpc0Rpc3BsYXlWZXJ0aWNhbFNoYWRvdyA9IGlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHNcclxuICAgICAgICAgICAgICAgICYmIGlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHMgIT09IFwiaG9yaXpvbnRhbFwiO1xyXG4gICAgICAgICAgICB2YXIgaXNEaXNwbGF5ID0gdi52ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgPyB2ZXJ0aWNhbENvdW50IDw9IG1heFJvdW5kQ29udHJvbHNbMV0gJiYgKGlzRGlzcGxheVZlcnRpY2FsU2hhZG93IHx8ICF2LnZpcnR1YWwpXHJcbiAgICAgICAgICAgICAgICA6IGhvcml6b250YWxDb3VudCA8PSBtYXhSb3VuZENvbnRyb2xzWzBdICYmIChpc0Rpc3BsYXlTaGFkb3dSb3VuZENvbnRyb2xzIHx8ICF2LnZpcnR1YWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogXCJib3JkZXJSYWRpdXNDb250cm9sXCIuY29uY2F0KGkpLCBjbGFzc05hbWU6IHByZWZpeChcImNvbnRyb2xcIiwgXCJib3JkZXItcmFkaXVzXCIsIHYudmVydGljYWwgPyBcInZlcnRpY2FsXCIgOiBcIlwiLCB2LnZpcnR1YWwgPyBcInZpcnR1YWxcIiA6IFwiXCIpLCBcImRhdGEtcmFkaXVzLWluZGV4XCI6IGksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogaXNEaXNwbGF5ID8gXCJibG9ja1wiIDogXCJub25lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQocG9zWzBdLCBcInB4LCBcIikuY29uY2F0KHBvc1sxXSwgXCJweCkgc2NhbGUoXCIpLmNvbmNhdCh6b29tLCBcIilcIiksXHJcbiAgICAgICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICBpZiAoIWUuaW5wdXRFdmVudCB8fCBlLmlzUmVxdWVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoZS5pbnB1dEV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoXCJib3JkZXItcmFkaXVzXCIpID4gLTFcclxuICAgICAgICAgICAgfHwgKGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtbGluZVwiKSA+IC0xICYmIGNsYXNzTmFtZS5pbmRleE9mKFwibW92ZWFibGUtZGlyZWN0aW9uXCIpID4gLTEpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYWdDb250cm9sQ29uZGl0aW9uKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudCwgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHZhciBpbnB1dFRhcmdldCA9IGlucHV0RXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAoaW5wdXRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XHJcbiAgICAgICAgdmFyIGlzQ29udHJvbCA9IGNsYXNzTmFtZS5pbmRleE9mKFwiYm9yZGVyLXJhZGl1c1wiKSA+IC0xO1xyXG4gICAgICAgIHZhciBpc0xpbmUgPSBjbGFzc05hbWUuaW5kZXhPZihcIm1vdmVhYmxlLWxpbmVcIikgPiAtMSAmJiBjbGFzc05hbWUuaW5kZXhPZihcIm1vdmVhYmxlLWRpcmVjdGlvblwiKSA+IC0xO1xyXG4gICAgICAgIHZhciBjb250cm9sSW5kZXggPSBpc0NvbnRyb2wgPyBwYXJzZUludChpbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJhZGl1cy1pbmRleFwiKSwgMTApIDogLTE7XHJcbiAgICAgICAgdmFyIGxpbmVJbmRleCA9IC0xO1xyXG4gICAgICAgIGlmIChpc0xpbmUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4QXR0ciA9IGlucHV0VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtbGluZS1rZXlcIikgfHwgXCJcIjtcclxuICAgICAgICAgICAgaWYgKGluZGV4QXR0cikge1xyXG4gICAgICAgICAgICAgICAgbGluZUluZGV4ID0gcGFyc2VJbnQoaW5kZXhBdHRyLnJlcGxhY2UoL3JlbmRlci1saW5lLS9nLCBcIlwiKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGxpbmVJbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQ29udHJvbCAmJiAhaXNMaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHt9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRTdGFydFwiLCBwYXJhbXMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YXMubGluZUluZGV4ID0gbGluZUluZGV4O1xyXG4gICAgICAgIGRhdGFzLmNvbnRyb2xJbmRleCA9IGNvbnRyb2xJbmRleDtcclxuICAgICAgICBkYXRhcy5pc0NvbnRyb2wgPSBpc0NvbnRyb2w7XHJcbiAgICAgICAgZGF0YXMuaXNMaW5lID0gaXNMaW5lO1xyXG4gICAgICAgIHNldERyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIHJvdW5kUmVsYXRpdmUgPSBfYS5yb3VuZFJlbGF0aXZlLCBfYiA9IF9hLm1pblJvdW5kQ29udHJvbHMsIG1pblJvdW5kQ29udHJvbHMgPSBfYiA9PT0gdm9pZCAwID8gWzAsIDBdIDogX2I7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbW92ZWFibGUuc3RhdGU7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gc3RhdGUud2lkdGgsIGhlaWdodCA9IHN0YXRlLmhlaWdodDtcclxuICAgICAgICBkYXRhcy5pc1JvdW5kID0gdHJ1ZTtcclxuICAgICAgICBkYXRhcy5wcmV2RGlzdCA9IFswLCAwXTtcclxuICAgICAgICB2YXIgYm9yZGVyUmFkaXVzID0gZ2V0U3R5bGVCb3JkZXJSYWRpdXMobW92ZWFibGUpO1xyXG4gICAgICAgIHZhciBjb250cm9sUG9zZXMgPSBnZXRCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzIHx8IFwiXCIsIHdpZHRoLCBoZWlnaHQsIG1pblJvdW5kQ29udHJvbHMsIHRydWUpIHx8IFtdO1xyXG4gICAgICAgIGRhdGFzLmNvbnRyb2xQb3NlcyA9IGNvbnRyb2xQb3NlcztcclxuICAgICAgICBzdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IGdldFJhZGl1c1N0eWxlcyhjb250cm9sUG9zZXMsIHJvdW5kUmVsYXRpdmUsIHdpZHRoLCBoZWlnaHQpLnN0eWxlcy5qb2luKFwiIFwiKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgICAgIHZhciBjb250cm9sUG9zZXMgPSBkYXRhcy5jb250cm9sUG9zZXM7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1JvdW5kIHx8ICFkYXRhcy5pc0NvbnRyb2wgfHwgIWNvbnRyb2xQb3Nlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXggPSBkYXRhcy5jb250cm9sSW5kZXg7XHJcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGdldERyYWdEaXN0KGUpLCAyKSwgZGlzdFggPSBfYVswXSwgZGlzdFkgPSBfYVsxXTtcclxuICAgICAgICB2YXIgZGlzdCA9IFtkaXN0WCwgZGlzdFldO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IG1pbnVzKGRpc3QsIGRhdGFzLnByZXZEaXN0KTtcclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5wcm9wcy5tYXhSb3VuZENvbnRyb2xzLCBtYXhSb3VuZENvbnRyb2xzID0gX2IgPT09IHZvaWQgMCA/IFs0LCA0XSA6IF9iO1xyXG4gICAgICAgIHZhciBfYyA9IG1vdmVhYmxlLnN0YXRlLCB3aWR0aCA9IF9jLndpZHRoLCBoZWlnaHQgPSBfYy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkQ29udHJvbFBvc2UgPSBjb250cm9sUG9zZXNbaW5kZXhdO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZFZlcnRpY2FsID0gc2VsZWN0ZWRDb250cm9sUG9zZS52ZXJ0aWNhbDtcclxuICAgICAgICB2YXIgc2VsZWN0ZWRIb3Jpem9udGFsID0gc2VsZWN0ZWRDb250cm9sUG9zZS5ob3Jpem9udGFsO1xyXG4gICAgICAgIC8vIDA6IFswLCAxLCAyLCAzXSBtYXhDb3VudCA9PT0gMVxyXG4gICAgICAgIC8vIDA6IFswLCAyXSBtYXhDb3VudCA9PT0gMlxyXG4gICAgICAgIC8vIDE6IFsxLCAzXSBtYXhDb3VudCA9PT0gMlxyXG4gICAgICAgIC8vIDA6IFswXSBtYXhDb3VudCA9PT0gM1xyXG4gICAgICAgIC8vIDE6IFsxLCAzXSBtYXhDb3VudCA9PT0gM1xyXG4gICAgICAgIHZhciBkaXN0cyA9IGNvbnRyb2xQb3Nlcy5tYXAoZnVuY3Rpb24gKHBvc2UpIHtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWwgPSBwb3NlLmhvcml6b250YWwsIHZlcnRpY2FsID0gcG9zZS52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgdmFyIHBvc2VEaXN0ID0gW1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbCAqIHNlbGVjdGVkSG9yaXpvbnRhbCAqIGRpc3RbMF0sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbCAqIHNlbGVjdGVkVmVydGljYWwgKiBkaXN0WzFdLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heFJvdW5kQ29udHJvbHNbMF0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhSb3VuZENvbnRyb2xzWzBdIDwgNCAmJiBob3Jpem9udGFsICE9PSBzZWxlY3RlZEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zZURpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWF4Um91bmRDb250cm9sc1sxXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcG9zZURpc3RbMV0gPSB2ZXJ0aWNhbCAqIHNlbGVjdGVkSG9yaXpvbnRhbCAqIGRpc3RbMF0gLyB3aWR0aCAqIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RlZFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4Um91bmRDb250cm9sc1sxXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NlRGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heFJvdW5kQ29udHJvbHNbMV0gPCA0ICYmIHZlcnRpY2FsICE9PSBzZWxlY3RlZFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc2VEaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlzdHNbaW5kZXhdID0gZGlzdDtcclxuICAgICAgICB2YXIgbmV4dFBvc2VzID0gY29udHJvbFBvc2VzLm1hcChmdW5jdGlvbiAoaW5mbywgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm8pLCB7IHBvczogcGx1cyhpbmZvLnBvcywgZGlzdHNbaV0pIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDQpIHtcclxuICAgICAgICAgICAgbmV4dFBvc2VzLnNsaWNlKDAsIGluZGV4ICsgMSkuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaW5mby52aXJ0dWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dFBvc2VzLnNsaWNlKDQsIGluZGV4ICsgMSkuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaW5mby52aXJ0dWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhcy5wcmV2RGlzdCA9IFtkaXN0WCwgZGlzdFldO1xyXG4gICAgICAgIHJldHVybiB0cmlnZ2VyUm91bmRFdmVudChtb3ZlYWJsZSwgZSwgZGlzdCwgZGVsdGEsIG5leHRQb3Nlcyk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IG1vdmVhYmxlLnN0YXRlO1xyXG4gICAgICAgIHN0YXRlLmJvcmRlclJhZGl1c1N0YXRlID0gXCJcIjtcclxuICAgICAgICB2YXIgZGF0YXMgPSBlLmRhdGFzLCBpc0RvdWJsZSA9IGUuaXNEb3VibGU7XHJcbiAgICAgICAgaWYgKCFkYXRhcy5pc1JvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzQ29udHJvbCA9IGRhdGFzLmlzQ29udHJvbCwgY29udHJvbEluZGV4ID0gZGF0YXMuY29udHJvbEluZGV4LCBpc0xpbmUgPSBkYXRhcy5pc0xpbmUsIGxpbmVJbmRleCA9IGRhdGFzLmxpbmVJbmRleDtcclxuICAgICAgICB2YXIgY29udHJvbFBvc2VzID0gZGF0YXMuY29udHJvbFBvc2VzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBjb250cm9sUG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgdmlydHVhbCA9IF9hLnZpcnR1YWw7XHJcbiAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsO1xyXG4gICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICB2YXIgX2EgPSBtb3ZlYWJsZS5wcm9wcy5yb3VuZENsaWNrYWJsZSwgcm91bmRDbGlja2FibGUgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hO1xyXG4gICAgICAgIGlmIChpc0RvdWJsZSAmJiByb3VuZENsaWNrYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNDb250cm9sICYmIChyb3VuZENsaWNrYWJsZSA9PT0gdHJ1ZSB8fCByb3VuZENsaWNrYWJsZSA9PT0gXCJjb250cm9sXCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVCb3JkZXJSYWRpdXMoY29udHJvbFBvc2VzLCBjb250cm9sSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTGluZSAmJiAocm91bmRDbGlja2FibGUgPT09IHRydWUgfHwgcm91bmRDbGlja2FibGUgPT09IFwibGluZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKGNhbGN1bGF0ZVBvaW50ZXJEaXN0KG1vdmVhYmxlLCBlKSwgMiksIGRpc3RYID0gX2JbMF0sIGRpc3RZID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICBhZGRCb3JkZXJSYWRpdXNCeUxpbmUoY29udHJvbFBvc2VzLCBsaW5lSW5kZXgsIGRpc3RYLCBkaXN0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gY29udHJvbFBvc2VzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2aXJ0dWFsID0gX2EudmlydHVhbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJSb3VuZEV2ZW50KG1vdmVhYmxlLCBlLCBbMCwgMF0sIFswLCAwXSwgY29udHJvbFBvc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyYW1zID0gZmlsbEVuZFBhcmFtcyhtb3ZlYWJsZSwgZSwge30pO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvblJvdW5kRW5kXCIsIHBhcmFtcyk7XHJcbiAgICAgICAgc3RhdGUuYm9yZGVyUmFkaXVzU3RhdGUgPSBcIlwiO1xyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kcmFnQ29udHJvbFN0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XHJcbiAgICAgICAgdmFyIHRhcmdldHMgPSBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzO1xyXG4gICAgICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwicm91bmRhYmxlXCIsIGUpO1xyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwgeyB0YXJnZXQ6IHRhcmdldHNbaV0sIG1vdmVhYmxlOiBtb3ZlYWJsZXNbaV0sIGN1cnJlbnRUYXJnZXQ6IG1vdmVhYmxlc1tpXSB9KTtcclxuICAgICAgICAgICAgfSkgfSwgcmVzdWx0KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3VuZEdyb3VwU3RhcnRcIiwgbmV4dFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kcmFnQ29udHJvbChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gbW92ZWFibGUucHJvcHMudGFyZ2V0cztcclxuICAgICAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcInJvdW5kYWJsZVwiLCBlKTtcclxuICAgICAgICB2YXIgbmV4dFBhcmFtcyA9IF9fYXNzaWduKHsgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cywgZXZlbnRzOiBldmVudHMubWFwKGZ1bmN0aW9uIChldiwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgdGFyZ2V0OiB0YXJnZXRzW2ldLCBtb3ZlYWJsZTogbW92ZWFibGVzW2ldLCBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZXNbaV0gfSksIGZpbGxDU1NPYmplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogcmVzdWx0LmJvcmRlclJhZGl1cyxcclxuICAgICAgICAgICAgICAgIH0sIGV2KSk7XHJcbiAgICAgICAgICAgIH0pIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRHcm91cFwiLCBuZXh0UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV4dFBhcmFtcztcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gbW92ZWFibGUucHJvcHMudGFyZ2V0cztcclxuICAgICAgICB2YXIgZXZlbnRzID0gZmlsbENoaWxkRXZlbnRzKG1vdmVhYmxlLCBcInJvdW5kYWJsZVwiLCBlKTtcclxuICAgICAgICBjYXRjaEV2ZW50KG1vdmVhYmxlLCBcIm9uUm91bmRcIiwgZnVuY3Rpb24gKHBhcmVudEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBldiksIHsgdGFyZ2V0OiB0YXJnZXRzW2ldLCBtb3ZlYWJsZTogbW92ZWFibGVzW2ldLCBjdXJyZW50VGFyZ2V0OiBtb3ZlYWJsZXNbaV0gfSksIGZpbGxDU1NPYmplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHBhcmVudEV2ZW50LmJvcmRlclJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICB9LCBldikpO1xyXG4gICAgICAgICAgICAgICAgfSkgfSwgcGFyZW50RXZlbnQpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3VuZEdyb3VwXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRyYWdDb250cm9sRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gX19hc3NpZ24oeyB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGV2LCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2KSwgeyB0YXJnZXQ6IHRhcmdldHNbaV0sIG1vdmVhYmxlOiBtb3ZlYWJsZXNbaV0sIGN1cnJlbnRUYXJnZXQ6IG1vdmVhYmxlc1tpXSwgbGFzdEV2ZW50OiAoX2EgPSBldi5kYXRhcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RFdmVudCB9KTtcclxuICAgICAgICAgICAgfSkgfSwgcmVzdWx0KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25Sb3VuZEdyb3VwRW5kXCIsIG5leHRQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0UGFyYW1zO1xyXG4gICAgfSxcclxuICAgIHVuc2V0OiBmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICBtb3ZlYWJsZS5zdGF0ZS5ib3JkZXJSYWRpdXNTdGF0ZSA9IFwiXCI7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogV2hldGhlciB0byBzaG93IGFuZCBkcmFnIG9yIGRvdWJsZSBjbGljayBib3JkZXItcmFkaXVzLCAoZGVmYXVsdDogZmFsc2UpXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNyb3VuZGFibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XHJcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogJSBDYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhYnNvbHV0ZSBweFxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjcm91bmRSZWxhdGl2ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcclxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3VuZFN0YXJ0XCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pLm9uKFwicm91bmRcIiwgZSA9PiB7XHJcbiAqICAgICBlLnRhcmdldC5zdHlsZS5ib3JkZXJSYWRpdXMgPSBlLmJvcmRlclJhZGl1cztcclxuICogfSkub24oXCJyb3VuZEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBNaW5pbXVtIG51bWJlciBvZiByb3VuZCBjb250cm9scy4gSXQgbW92ZXMgaW4gcHJvcG9ydGlvbiBieSBjb250cm9sLiBbaG9yaXpvbnRhbCwgdmVydGljYWxdIChkZWZhdWx0OiBbMCwgMF0pXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNtaW5Sb3VuZENvbnRyb2xzXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiAgICAgcm91bmRSZWxhdGl2ZTogZmFsc2UsXHJcbiAqICAgICBtaW5Sb3VuZENvbnRyb2xzOiBbMCwgMF0sXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5taW5Sb3VuZENvbnRyb2xzID0gWzEsIDBdO1xyXG4gKi9cclxuLyoqXHJcbiAqIE1heGltdW0gbnVtYmVyIG9mIHJvdW5kIGNvbnRyb2xzLiBJdCBtb3ZlcyBpbiBwcm9wb3J0aW9uIGJ5IGNvbnRyb2wuIFtob3Jpem9udGFsLCB2ZXJ0aWNhbF0gKGRlZmF1bHQ6IFs0LCA0XSlcclxuICogQG5hbWUgTW92ZWFibGUuUm91bmRhYmxlI21heFJvdW5kQ29udHJvbHNcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogICAgIG1heFJvdW5kQ29udHJvbHM6IFs0LCA0XSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm1heFJvdW5kQ29udHJvbHMgPSBbMSwgMF07XHJcbiAqL1xyXG4vKipcclxuICogV2hldGhlciB5b3UgY2FuIGFkZC9kZWxldGUgcm91bmQgY29udHJvbHMgYnkgZG91YmxlLWNsaWNraW5nIGEgbGluZSBvciBjb250cm9sLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjcm91bmRDbGlja2FibGVcclxuICogQGRlZmF1bHQgdHJ1ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcclxuICogICAgIHJvdW5kUmVsYXRpdmU6IGZhbHNlLFxyXG4gKiAgICAgcm91bmRDbGlja2FibGU6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5yb3VuZENsaWNrYWJsZSA9IGZhbHNlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gc2hvdyBhIHJvdW5kIGNvbnRyb2wgdGhhdCBkb2VzIG5vdCBhY3R1YWxseSBleGlzdCBhcyBhIHNoYWRvd1xyXG4gKiBAbmFtZSBNb3ZlYWJsZS5Sb3VuZGFibGUjaXNEaXNwbGF5U2hhZG93Um91bmRDb250cm9sc1xyXG4gKiBAZGVmYXVsdCBmYWxzZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcclxuICogICAgIGlzRGlzcGxheVNoYWRvd1JvdW5kQ29udHJvbHM6IGZhbHNlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUuaXNEaXNwbGF5U2hhZG93Um91bmRDb250cm9scyA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogVGhlIHBhZGRpbmcgdmFsdWUgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSByb3VuZCBjb250cm9sXHJcbiAqIEBuYW1lIE1vdmVhYmxlLlJvdW5kYWJsZSNyb3VuZFBhZGRpbmdcclxuICogQGRlZmF1bHQgZmFsc2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFBhZGRpbmc6IDAsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5yb3VuZFBhZGRpbmcgPSAxNTtcclxuICovXHJcbi8qKlxyXG4gKiBXaGVuIGRyYWcgc3RhcnQgdGhlIGNsaXAgYXJlYSBvciBjb250cm9scywgdGhlIGByb3VuZFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3VuZGFibGVcclxuICogQGV2ZW50IHJvdW5kU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUuT25Sb3VuZFN0YXJ0fSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcm91bmRTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XHJcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIG9yIGRvdWJsZSBjbGljayB0aGUgYm9yZGVyIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxyXG4gKiBAZXZlbnQgcm91bmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUuT25Sb3VuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XHJcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIGVuZCB0aGUgYm9yZGVyIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRFbmRgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxyXG4gKiBAZXZlbnQgcm91bmRFbmRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5Sb3VuZGFibGUub25Sb3VuZEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqICAgICByb3VuZFJlbGF0aXZlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KS5vbihcInJvdW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgZS50YXJnZXQuc3R5bGUuYm9yZGVyUmFkaXVzID0gZS5ib3JkZXJSYWRpdXM7XHJcbiAqIH0pLm9uKFwicm91bmRFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIHN0YXJ0IHRoZSBjbGlwIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRHcm91cFN0YXJ0YCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZS5Sb3VuZGFibGVcclxuICogQGV2ZW50IHJvdW5kR3JvdXBTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdW5kYWJsZS5PblJvdW5kR3JvdXBTdGFydH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kR3JvdXBTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXRzOiBbdGFyZ2V0MSwgdGFyZ2V0MiwgdGFyZ2V0M10sXHJcbiAqICAgICByb3VuZGFibGU6IHRydWUsXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJvdW5kR3JvdXBTdGFydFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0cyk7XHJcbiAqIH0pLm9uKFwicm91bmRHcm91cFwiLCBlID0+IHtcclxuICogICBlLmV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcclxuICogICAgICAgZXYudGFyZ2V0LnN0eWxlLmNzc1RleHQgKz0gZXYuY3NzVGV4dDtcclxuICogICB9KTtcclxuICogfSkub24oXCJyb3VuZEdyb3VwRW5kXCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZSk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIFdoZW4gZHJhZyBvciBkb3VibGUgY2xpY2sgdGhlIGJvcmRlciBhcmVhIG9yIGNvbnRyb2xzLCB0aGUgYHJvdW5kR3JvdXBgIGV2ZW50IGlzIGNhbGxlZC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlLlJvdW5kYWJsZVxyXG4gKiBAZXZlbnQgcm91bmRHcm91cFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLlJvdW5kYWJsZS5PblJvdW5kR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByb3VuZEdyb3VwYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldHM6IFt0YXJnZXQxLCB0YXJnZXQyLCB0YXJnZXQzXSxcclxuICogICAgIHJvdW5kYWJsZTogdHJ1ZSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwicm91bmRHcm91cFN0YXJ0XCIsIGUgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coZS50YXJnZXRzKTtcclxuICogfSkub24oXCJyb3VuZEdyb3VwXCIsIGUgPT4ge1xyXG4gKiAgIGUuZXZlbnRzLmZvckVhY2goZXYgPT4ge1xyXG4gKiAgICAgICBldi50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBldi5jc3NUZXh0O1xyXG4gKiAgIH0pO1xyXG4gKiB9KS5vbihcInJvdW5kR3JvdXBFbmRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiBkcmFnIGVuZCB0aGUgYm9yZGVyIGFyZWEgb3IgY29udHJvbHMsIHRoZSBgcm91bmRHcm91cEVuZGAgZXZlbnQgaXMgY2FsbGVkLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGUuUm91bmRhYmxlXHJcbiAqIEBldmVudCByb3VuZEdyb3VwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuUm91bmRhYmxlLm9uUm91bmRHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJvdW5kR3JvdXBFbmRgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0czogW3RhcmdldDEsIHRhcmdldDIsIHRhcmdldDNdLFxyXG4gKiAgICAgcm91bmRhYmxlOiB0cnVlLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyb3VuZEdyb3VwU3RhcnRcIiwgZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhlLnRhcmdldHMpO1xyXG4gKiB9KS5vbihcInJvdW5kR3JvdXBcIiwgZSA9PiB7XHJcbiAqICAgICBlLmV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcclxuICogICAgICAgICBldi50YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBldi5jc3NUZXh0O1xyXG4gKiAgICAgfSk7XHJcbiAqIH0pLm9uKFwicm91bmRHcm91cEVuZFwiLCBlID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gKiB9KTtcclxuICovXG5cbmZ1bmN0aW9uIGlzSWRlbnRpdHlNYXRyaXgobWF0cml4LCBpczNkKSB7XHJcbiAgICB2YXIgbiA9IGlzM2QgPyA0IDogMztcclxuICAgIHZhciBpZGVudGl0eU1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgdmFyIHZhbHVlID0gXCJtYXRyaXhcIi5jb25jYXQoaXMzZCA/IFwiM2RcIiA6IFwiXCIsIFwiKFwiKS5jb25jYXQoaWRlbnRpdHlNYXRyaXguam9pbihcIixcIiksIFwiKVwiKTtcclxuICAgIHJldHVybiBtYXRyaXggPT09IHZhbHVlIHx8IG1hdHJpeCA9PT0gXCJtYXRyaXgoMSwwLDAsMSwwLDApXCI7XHJcbn1cclxudmFyIEJlZm9yZVJlbmRlcmFibGUgPSB7XHJcbiAgICBpc1BpbmNoOiB0cnVlLFxyXG4gICAgbmFtZTogXCJiZWZvcmVSZW5kZXJhYmxlXCIsXHJcbiAgICBwcm9wczogW10sXHJcbiAgICBldmVudHM6IFtcclxuICAgICAgICBcImJlZm9yZVJlbmRlclN0YXJ0XCIsXHJcbiAgICAgICAgXCJiZWZvcmVSZW5kZXJcIixcclxuICAgICAgICBcImJlZm9yZVJlbmRlckVuZFwiLFxyXG4gICAgICAgIFwiYmVmb3JlUmVuZGVyR3JvdXBTdGFydFwiLFxyXG4gICAgICAgIFwiYmVmb3JlUmVuZGVyR3JvdXBcIixcclxuICAgICAgICBcImJlZm9yZVJlbmRlckdyb3VwRW5kXCIsXHJcbiAgICBdLFxyXG4gICAgZHJhZ1JlbGF0aW9uOiBcIndlYWtcIixcclxuICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF9hID0gbW92ZWFibGUuc3RhdGUsIGlzM2QgPSBfYS5pczNkLCB0YXJnZXRNYXRyaXggPSBfYS50YXJnZXRNYXRyaXgsIGlubGluZVRyYW5zZm9ybSA9IF9hLmlubGluZVRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgY3NzTWF0cml4ID0gaXMzZFxyXG4gICAgICAgICAgICA/IFwibWF0cml4M2QoXCIuY29uY2F0KHRhcmdldE1hdHJpeC5qb2luKFwiLFwiKSwgXCIpXCIpXHJcbiAgICAgICAgICAgIDogXCJtYXRyaXgoXCIuY29uY2F0KGNvbnZlcnRNYXRyaXh0b0NTUyh0YXJnZXRNYXRyaXgsIHRydWUpLCBcIilcIik7XHJcbiAgICAgICAgdmFyIHN0YXJ0VHJhbnNmb3JtID0gIWlubGluZVRyYW5zZm9ybSB8fCBpbmxpbmVUcmFuc2Zvcm0gPT09IFwibm9uZVwiID8gY3NzTWF0cml4IDogaW5saW5lVHJhbnNmb3JtO1xyXG4gICAgICAgIGUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zID0gaXNJZGVudGl0eU1hdHJpeChzdGFydFRyYW5zZm9ybSwgaXMzZCkgPyBbXSA6IHNwbGl0U3BhY2Uoc3RhcnRUcmFuc2Zvcm0pO1xyXG4gICAgfSxcclxuICAgIHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFzID0gZS5kYXRhcztcclxuICAgICAgICBkYXRhcy5uZXh0U3R5bGUgPSB7fTtcclxuICAgICAgICBkYXRhcy5uZXh0VHJhbnNmb3JtcyA9IGUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zO1xyXG4gICAgICAgIGRhdGFzLm5leHRUcmFuc2Zvcm1BcHBlbmRlZEluZGV4ZXMgPSBbXTtcclxuICAgIH0sXHJcbiAgICBmaWxsRHJhZ1N0YXJ0UGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgIGUuZGF0YXMuc3RhcnRUcmFuc2Zvcm1zID0gaXNBcnJheSh0cmFuc2Zvcm0pID8gdHJhbnNmb3JtIDogc3BsaXRTcGFjZSh0cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBmaWxsRHJhZ1BhcmFtczogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdGhpcy5yZXNldFN0eWxlKGUpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlclN0YXJ0XCIsIHRoaXMuZmlsbERyYWdTdGFydFBhcmFtcyhtb3ZlYWJsZSwgZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWc6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGlmICghZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0obW92ZWFibGUsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0U3R5bGUoZSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgaXNQaW5jaDogISFlLmlzUGluY2gsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGlmICghZS5kYXRhcy5zdGFydFRyYW5zZm9ybXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0obW92ZWFibGUsIGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0U3R5bGUoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkJlZm9yZVJlbmRlckVuZFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgICAgICBpc0RyYWc6IGUuaXNEcmFnLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRyYWdTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJiZWZvcmVSZW5kZXJhYmxlXCIsIGUpO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkRXZlbnQsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XHJcbiAgICAgICAgICAgIF90aGlzLnNldFRyYW5zZm9ybShjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcclxuICAgICAgICAgICAgX3RoaXMucmVzZXRTdHlsZShjaGlsZEV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbGxEcmFnU3RhcnRQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyR3JvdXBTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICAgICAgZXZlbnRzOiBwYXJhbXMsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRyYWcobW92ZWFibGUsIGUpO1xyXG4gICAgICAgIHZhciBldmVudHMgPSBmaWxsQ2hpbGRFdmVudHMobW92ZWFibGUsIFwiYmVmb3JlUmVuZGVyYWJsZVwiLCBlKTtcclxuICAgICAgICB2YXIgbW92ZWFibGVzID0gbW92ZWFibGUubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChjaGlsZEV2ZW50LCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZE1vdmVhYmxlID0gbW92ZWFibGVzW2ldO1xyXG4gICAgICAgICAgICBfdGhpcy5yZXNldFN0eWxlKGNoaWxkRXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZmlsbERyYWdQYXJhbXMoY2hpbGRNb3ZlYWJsZSwgY2hpbGRFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uQmVmb3JlUmVuZGVyR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc1BpbmNoOiAhIWUuaXNQaW5jaCxcclxuICAgICAgICAgICAgdGFyZ2V0czogbW92ZWFibGUucHJvcHMudGFyZ2V0cyxcclxuICAgICAgICAgICAgZXZlbnRzOiBwYXJhbXMsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnRW5kKG1vdmVhYmxlLCBlKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25CZWZvcmVSZW5kZXJHcm91cEVuZFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgICAgICBpc0RyYWc6IGUuaXNEcmFnLFxyXG4gICAgICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxufTtcblxudmFyIFJlbmRlcmFibGUgPSB7XHJcbiAgICBuYW1lOiBcInJlbmRlcmFibGVcIixcclxuICAgIHByb3BzOiBbXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwicmVuZGVyU3RhcnRcIixcclxuICAgICAgICBcInJlbmRlclwiLFxyXG4gICAgICAgIFwicmVuZGVyRW5kXCIsXHJcbiAgICAgICAgXCJyZW5kZXJHcm91cFN0YXJ0XCIsXHJcbiAgICAgICAgXCJyZW5kZXJHcm91cFwiLFxyXG4gICAgICAgIFwicmVuZGVyR3JvdXBFbmRcIixcclxuICAgIF0sXHJcbiAgICBkcmFnUmVsYXRpb246IFwid2Vha1wiLFxyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJcIiwgdGhpcy5maWxsRHJhZ1BhcmFtcyhtb3ZlYWJsZSwgZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyRW5kXCIsIHRoaXMuZmlsbERyYWdFbmRQYXJhbXMobW92ZWFibGUsIGUpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KG1vdmVhYmxlLCBcIm9uUmVuZGVyR3JvdXBTdGFydFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCB7XHJcbiAgICAgICAgICAgIGlzUGluY2g6ICEhZS5pc1BpbmNoLFxyXG4gICAgICAgICAgICB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXA6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJiZWZvcmVSZW5kZXJhYmxlXCIsIGUpO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkRXZlbnQsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ1BhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJHcm91cFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbihfX2Fzc2lnbih7IGlzUGluY2g6ICEhZS5pc1BpbmNoLCB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCB0cmFuc2Zvcm06IGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpLCB0cmFuc2Zvcm1PYmplY3Q6IHt9IH0sIGZpbGxDU1NPYmplY3QoZ2V0TmV4dFN0eWxlKGUpKSksIHsgZXZlbnRzOiBwYXJhbXMgfSkpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IGZpbGxDaGlsZEV2ZW50cyhtb3ZlYWJsZSwgXCJiZWZvcmVSZW5kZXJhYmxlXCIsIGUpO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZXMgPSBtb3ZlYWJsZS5tb3ZlYWJsZXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24gKGNoaWxkRXZlbnQsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTW92ZWFibGUgPSBtb3ZlYWJsZXNbaV07XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5maWxsRHJhZ0VuZFBhcmFtcyhjaGlsZE1vdmVhYmxlLCBjaGlsZEV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQobW92ZWFibGUsIFwib25SZW5kZXJHcm91cEVuZFwiLCBmaWxsUGFyYW1zKG1vdmVhYmxlLCBlLCBfX2Fzc2lnbih7IGlzUGluY2g6ICEhZS5pc1BpbmNoLCBpc0RyYWc6IGUuaXNEcmFnLCB0YXJnZXRzOiBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzLCBldmVudHM6IHBhcmFtcywgdHJhbnNmb3JtT2JqZWN0OiB7fSwgdHJhbnNmb3JtOiBnZXROZXh0VHJhbnNmb3JtVGV4dChlKSB9LCBmaWxsQ1NTT2JqZWN0KGdldE5leHRTdHlsZShlKSkpKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xTdGFydDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZyhtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0NvbnRyb2xBZnRlcjogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0FmdGVyKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnQ29udHJvbEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBTdGFydChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29udHJvbDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0dyb3VwKG1vdmVhYmxlLCBlKTtcclxuICAgIH0sXHJcbiAgICBkcmFnR3JvdXBDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmFnR3JvdXBFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGZpbGxEcmFnUGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtT2JqZWN0ID0ge307XHJcbiAgICAgICAgcGFyc2UoZ2V0TmV4dFRyYW5zZm9ybXMoZSkgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKG1hdHJpeEluZm8pIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT2JqZWN0W21hdHJpeEluZm8ubmFtZV0gPSBtYXRyaXhJbmZvLmZ1bmN0aW9uVmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgaXNQaW5jaDogISFlLmlzUGluY2gsIHRyYW5zZm9ybU9iamVjdDogdHJhbnNmb3JtT2JqZWN0LCB0cmFuc2Zvcm06IGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpIH0sIGZpbGxDU1NPYmplY3QoZ2V0TmV4dFN0eWxlKGUpKSkpO1xyXG4gICAgfSxcclxuICAgIGZpbGxEcmFnRW5kUGFyYW1zOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtT2JqZWN0ID0ge307XHJcbiAgICAgICAgcGFyc2UoZ2V0TmV4dFRyYW5zZm9ybXMoZSkgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKG1hdHJpeEluZm8pIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtT2JqZWN0W21hdHJpeEluZm8ubmFtZV0gPSBtYXRyaXhJbmZvLmZ1bmN0aW9uVmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIF9fYXNzaWduKHsgaXNQaW5jaDogISFlLmlzUGluY2gsIGlzRHJhZzogZS5pc0RyYWcsIHRyYW5zZm9ybU9iamVjdDogdHJhbnNmb3JtT2JqZWN0LCB0cmFuc2Zvcm06IGdldE5leHRUcmFuc2Zvcm1UZXh0KGUpIH0sIGZpbGxDU1NPYmplY3QoZ2V0TmV4dFN0eWxlKGUpKSkpO1xyXG4gICAgfSxcclxufTtcblxuZnVuY3Rpb24gdHJpZ2dlckFibGUobW92ZWFibGUsIG1vdmVhYmxlQWJsZXMsIGV2ZW50T3BlcmF0aW9ucywgZXZlbnRBZmZpeCwgZXZlbnRUeXBlLCBlLCByZXF1ZXN0SW5zdGFudCkge1xyXG4gICAgLy8gcHJlIHNldHRpbmdcclxuICAgIGUuY2xpZW50RGlzdFggPSBlLmRpc3RYO1xyXG4gICAgZS5jbGllbnREaXN0WSA9IGUuZGlzdFk7XHJcbiAgICB2YXIgaXNTdGFydCA9IGV2ZW50VHlwZSA9PT0gXCJTdGFydFwiO1xyXG4gICAgdmFyIGlzRW5kID0gZXZlbnRUeXBlID09PSBcIkVuZFwiO1xyXG4gICAgdmFyIGlzQWZ0ZXIgPSBldmVudFR5cGUgPT09IFwiQWZ0ZXJcIjtcclxuICAgIHZhciB0YXJnZXQgPSBtb3ZlYWJsZS5zdGF0ZS50YXJnZXQ7XHJcbiAgICB2YXIgaXNSZXF1ZXN0ID0gZS5pc1JlcXVlc3Q7XHJcbiAgICB2YXIgaXNDb250cm9sID0gZXZlbnRBZmZpeC5pbmRleE9mKFwiQ29udHJvbFwiKSA+IC0xO1xyXG4gICAgaWYgKCF0YXJnZXRcclxuICAgICAgICB8fCAoaXNTdGFydCAmJiBpc0NvbnRyb2wgJiYgIWlzUmVxdWVzdCAmJiBtb3ZlYWJsZS5hcmVhRWxlbWVudCA9PT0gZS5pbnB1dEV2ZW50LnRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgYWJsZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobW92ZWFibGVBYmxlcyksIGZhbHNlKTtcclxuICAgIGlmIChpc1JlcXVlc3QpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdEFibGVfMSA9IGUucmVxdWVzdEFibGU7XHJcbiAgICAgICAgaWYgKCFhYmxlcy5zb21lKGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlLm5hbWUgPT09IHJlcXVlc3RBYmxlXzE7IH0pKSB7XHJcbiAgICAgICAgICAgIGFibGVzLnB1c2guYXBwbHkoYWJsZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChtb3ZlYWJsZS5wcm9wcy5hYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHsgcmV0dXJuIGFibGUubmFtZSA9PT0gcmVxdWVzdEFibGVfMTsgfSkpLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghYWJsZXMubGVuZ3RoIHx8IGFibGVzLmV2ZXJ5KGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlLmRyYWdSZWxhdGlvbjsgfSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBcImRyYWdcIiBcIkNvbnRyb2xcIiBcIkFmdGVyXCJcclxuICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xyXG4gICAgdmFyIGlucHV0VGFyZ2V0O1xyXG4gICAgaWYgKGlzRW5kICYmIGlucHV0RXZlbnQpIHtcclxuICAgICAgICBpbnB1dFRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpIHx8IGlucHV0RXZlbnQudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgdmFyIGlzRHJhZ1N0b3AgPSBmYWxzZTtcclxuICAgIHZhciBzdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpc0RyYWdTdG9wID0gdHJ1ZTtcclxuICAgICAgICAoX2EgPSBlLnN0b3ApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGUpO1xyXG4gICAgfTtcclxuICAgIHZhciBpc0ZpcnN0U3RhcnQgPSBpc1N0YXJ0ICYmICghbW92ZWFibGUudGFyZ2V0R2VzdG8gfHwgIW1vdmVhYmxlLmNvbnRyb2xHZXN0b1xyXG4gICAgICAgIHx8ICghbW92ZWFibGUudGFyZ2V0R2VzdG8uaXNGbGFnKCkgfHwgIW1vdmVhYmxlLmNvbnRyb2xHZXN0by5pc0ZsYWcoKSkpO1xyXG4gICAgaWYgKGlzRmlyc3RTdGFydCkge1xyXG4gICAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QoZXZlbnRUeXBlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvLyB0cmlnZ2VyIGFibGVzXHJcbiAgICB2YXIgZGF0YXMgPSBlLmRhdGFzO1xyXG4gICAgdmFyIGdlc3RvVHlwZSA9IGlzQ29udHJvbCA/IFwiY29udHJvbEdlc3RvXCIgOiBcInRhcmdldEdlc3RvXCI7XHJcbiAgICB2YXIgcHJldkdlc3RvID0gbW92ZWFibGVbZ2VzdG9UeXBlXTtcclxuICAgIHZhciB0cmlnZ2VyID0gZnVuY3Rpb24gKGFibGUsIGV2ZW50TmFtZSwgY29uZGl0aW9uTmFtZSkge1xyXG4gICAgICAgIGlmICghKGV2ZW50TmFtZSBpbiBhYmxlKSB8fCBwcmV2R2VzdG8gIT09IG1vdmVhYmxlW2dlc3RvVHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWJsZU5hbWUgPSBhYmxlLm5hbWU7XHJcbiAgICAgICAgdmFyIG5leHREYXRhcyA9IGRhdGFzW2FibGVOYW1lXSB8fCAoZGF0YXNbYWJsZU5hbWVdID0ge30pO1xyXG4gICAgICAgIGlmIChpc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIG5leHREYXRhcy5pc0V2ZW50U3RhcnQgPSAhY29uZGl0aW9uTmFtZVxyXG4gICAgICAgICAgICAgICAgfHwgIWFibGVbY29uZGl0aW9uTmFtZV0gfHwgYWJsZVtjb25kaXRpb25OYW1lXShtb3ZlYWJsZSwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV4dERhdGFzLmlzRXZlbnRTdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBhYmxlW2V2ZW50TmFtZV0obW92ZWFibGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyBzdG9wOiBzdG9wLCBkYXRhczogbmV4dERhdGFzLCBvcmlnaW5hbERhdGFzOiBkYXRhcywgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0IH0pKTtcclxuICAgICAgICBtb3ZlYWJsZS5fZW1pdHRlci5vZmYoKTtcclxuICAgICAgICBpZiAoaXNTdGFydCAmJiByZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIG5leHREYXRhcy5pc0V2ZW50U3RhcnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvLyB1bnNldCBhYmxlcyBmb3IgZmlyc3QgZHJhZyBzdGFydFxyXG4gICAgaWYgKGlzRmlyc3RTdGFydCkge1xyXG4gICAgICAgIGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgYWJsZS51bnNldCAmJiBhYmxlLnVuc2V0KG1vdmVhYmxlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEJlZm9yZVJlbmRlcmFibGVcclxuICAgIHRyaWdnZXIoQmVmb3JlUmVuZGVyYWJsZSwgXCJkcmFnXCIuY29uY2F0KGV2ZW50QWZmaXgpLmNvbmNhdChldmVudFR5cGUpKTtcclxuICAgIHZhciBmb3JjZUVuZGVkQ291bnQgPSAwO1xyXG4gICAgdmFyIHVwZGF0ZWRDb3VudCA9IDA7XHJcbiAgICBldmVudE9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRPcGVyYXRpb24pIHtcclxuICAgICAgICBpZiAoaXNEcmFnU3RvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudE5hbWUgPSBcIlwiLmNvbmNhdChldmVudE9wZXJhdGlvbikuY29uY2F0KGV2ZW50QWZmaXgpLmNvbmNhdChldmVudFR5cGUpO1xyXG4gICAgICAgIHZhciBjb25kaXRpb25OYW1lID0gXCJcIi5jb25jYXQoZXZlbnRPcGVyYXRpb24pLmNvbmNhdChldmVudEFmZml4LCBcIkNvbmRpdGlvblwiKTtcclxuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcIlwiICYmICFpc1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBkaXN0WCwgZGlzdFlcclxuICAgICAgICAgICAgY29udmVydERyYWdEaXN0KG1vdmVhYmxlLnN0YXRlLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc3QgaXNHcm91cCA9IGV2ZW50QWZmaXguaW5kZXhPZihcIkdyb3VwXCIpID4gLTE7XHJcbiAgICAgICAgdmFyIGV2ZW50QWJsZXMgPSBhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHsgcmV0dXJuIGFibGVbZXZlbnROYW1lXTsgfSk7XHJcbiAgICAgICAgZXZlbnRBYmxlcyA9IGV2ZW50QWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChhYmxlLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhYmxlLm5hbWUgJiYgZXZlbnRBYmxlcy5pbmRleE9mKGFibGUpID09PSBpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gZXZlbnRBYmxlcy5maWx0ZXIoZnVuY3Rpb24gKGFibGUpIHsgcmV0dXJuIHRyaWdnZXIoYWJsZSwgZXZlbnROYW1lLCBjb25kaXRpb25OYW1lKTsgfSk7XHJcbiAgICAgICAgdmFyIGlzVXBkYXRlID0gcmVzdWx0cy5sZW5ndGg7XHJcbiAgICAgICAgLy8gZW5kIGFibGVzXHJcbiAgICAgICAgaWYgKGlzRHJhZ1N0b3ApIHtcclxuICAgICAgICAgICAgKytmb3JjZUVuZGVkQ291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1VwZGF0ZSkge1xyXG4gICAgICAgICAgICArK3VwZGF0ZWRDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0RyYWdTdG9wICYmIGlzU3RhcnQgJiYgZXZlbnRBYmxlcy5sZW5ndGggJiYgIWlzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIGZvcmNlRW5kZWRDb3VudCArPSBldmVudEFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFibGVOYW1lID0gYWJsZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHREYXRhcyA9IGRhdGFzW2FibGVOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0RGF0YXMuaXNFdmVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFibGUuZHJhZ1JlbGF0aW9uID09PSBcInN0cm9uZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBkcmFnXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwcmUgc3RvcCBkcmFnXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pLmxlbmd0aCA/IDEgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKCFpc0FmdGVyIHx8IHVwZGF0ZWRDb3VudCkge1xyXG4gICAgICAgIHRyaWdnZXIoUmVuZGVyYWJsZSwgXCJkcmFnXCIuY29uY2F0KGV2ZW50QWZmaXgpLmNvbmNhdChldmVudFR5cGUpKTtcclxuICAgIH1cclxuICAgIC8vIHN0b3AgZ2VzdG8gY29uZGl0aW9uXHJcbiAgICB2YXIgaXNGb3JjZUVuZCA9IHByZXZHZXN0byAhPT0gbW92ZWFibGVbZ2VzdG9UeXBlXSB8fCBmb3JjZUVuZGVkQ291bnQgPT09IGV2ZW50T3BlcmF0aW9ucy5sZW5ndGg7XHJcbiAgICBpZiAoaXNFbmQgfHwgaXNEcmFnU3RvcCB8fCBpc0ZvcmNlRW5kKSB7XHJcbiAgICAgICAgbW92ZWFibGUuc3RhdGUuZ2VzdG9zID0ge307XHJcbiAgICAgICAgaWYgKG1vdmVhYmxlLm1vdmVhYmxlcykge1xyXG4gICAgICAgICAgICBtb3ZlYWJsZS5tb3ZlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRNb3ZlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRNb3ZlYWJsZS5zdGF0ZS5nZXN0b3MgPSB7fTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgYWJsZS51bnNldCAmJiBhYmxlLnVuc2V0KG1vdmVhYmxlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0YXJ0ICYmICFpc0ZvcmNlRW5kICYmICFpc1JlcXVlc3QgJiYgdXBkYXRlZENvdW50ICYmIG1vdmVhYmxlLnByb3BzLnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBpZiAobW92ZWFibGUuaXNVbm1vdW50ZWQgfHwgaXNGb3JjZUVuZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICgoIWlzU3RhcnQgJiYgdXBkYXRlZENvdW50ICYmICFyZXF1ZXN0SW5zdGFudCkgfHwgaXNFbmQpIHtcclxuICAgICAgICB2YXIgZmx1c2hTeW5jID0gbW92ZWFibGUucHJvcHMuZmx1c2hTeW5jIHx8IGRlZmF1bHRTeW5jO1xyXG4gICAgICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QoaXNFbmQgPyBldmVudFR5cGUgOiBcIlwiLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzU3RhcnQgJiYgIWlzRW5kICYmICFpc0FmdGVyICYmIHVwZGF0ZWRDb3VudCAmJiAhcmVxdWVzdEluc3RhbnQpIHtcclxuICAgICAgICB0cmlnZ2VyQWJsZShtb3ZlYWJsZSwgbW92ZWFibGVBYmxlcywgZXZlbnRPcGVyYXRpb25zLCBldmVudEFmZml4LCBldmVudFR5cGUgKyBcIkFmdGVyXCIsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tNb3ZlYWJsZVRhcmdldChtb3ZlYWJsZSwgaXNDb250cm9sKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHRhcmdldCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gZS5pbnB1dEV2ZW50LnRhcmdldDsgfVxyXG4gICAgICAgIHZhciBldmVudFRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB2YXIgYXJlYUVsZW1lbnQgPSBtb3ZlYWJsZS5hcmVhRWxlbWVudDtcclxuICAgICAgICB2YXIgZHJhZ1RhcmdldEVsZW1lbnQgPSBtb3ZlYWJsZS5fZHJhZ1RhcmdldDtcclxuICAgICAgICBpZiAoIWRyYWdUYXJnZXRFbGVtZW50IHx8ICghaXNDb250cm9sICYmICgoX2EgPSBtb3ZlYWJsZS5jb250cm9sR2VzdG8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0ZsYWcoKSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VGFyZ2V0ID09PSBkcmFnVGFyZ2V0RWxlbWVudFxyXG4gICAgICAgICAgICB8fCBkcmFnVGFyZ2V0RWxlbWVudC5jb250YWlucyhldmVudFRhcmdldClcclxuICAgICAgICAgICAgfHwgZXZlbnRUYXJnZXQgPT09IGFyZWFFbGVtZW50XHJcbiAgICAgICAgICAgIHx8ICghbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZXZlbnRUYXJnZXQpICYmICFtb3ZlYWJsZS5jb250cm9sQm94LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSlcclxuICAgICAgICAgICAgfHwgaGFzQ2xhc3MoZXZlbnRUYXJnZXQsIFwibW92ZWFibGUtYXJlYVwiKVxyXG4gICAgICAgICAgICB8fCBoYXNDbGFzcyhldmVudFRhcmdldCwgXCJtb3ZlYWJsZS1wYWRkaW5nXCIpXHJcbiAgICAgICAgICAgIHx8IGhhc0NsYXNzKGV2ZW50VGFyZ2V0LCBcIm1vdmVhYmxlLWVkZ2VEcmFnZ2FibGVcIik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldEFibGVHZXN0byhtb3ZlYWJsZSwgbW92ZWFibGVUYXJnZXQsIGV2ZW50QWZmaXgpIHtcclxuICAgIHZhciBjb250cm9sQm94ID0gbW92ZWFibGUuY29udHJvbEJveDtcclxuICAgIHZhciB0YXJnZXRzID0gW107XHJcbiAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgIHZhciBkcmFnQXJlYSA9IHByb3BzLmRyYWdBcmVhO1xyXG4gICAgdmFyIHRhcmdldCA9IG1vdmVhYmxlLnN0YXRlLnRhcmdldDtcclxuICAgIHZhciBkcmFnVGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldDtcclxuICAgIHRhcmdldHMucHVzaChjb250cm9sQm94KTtcclxuICAgIGlmICghZHJhZ0FyZWEgfHwgZHJhZ1RhcmdldCkge1xyXG4gICAgICAgIHRhcmdldHMucHVzaChtb3ZlYWJsZVRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWRyYWdBcmVhICYmIGRyYWdUYXJnZXQgJiYgdGFyZ2V0ICYmIG1vdmVhYmxlVGFyZ2V0ICE9PSB0YXJnZXQgJiYgcHJvcHMuZHJhZ1RhcmdldFNlbGYpIHtcclxuICAgICAgICB0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHZhciBjaGVja1RhcmdldCA9IGNoZWNrTW92ZWFibGVUYXJnZXQobW92ZWFibGUpO1xyXG4gICAgcmV0dXJuIGdldEFibGVHZXN0byhtb3ZlYWJsZSwgdGFyZ2V0cywgXCJ0YXJnZXRBYmxlc1wiLCBldmVudEFmZml4LCB7XHJcbiAgICAgICAgZHJhZ1N0YXJ0OiBjaGVja1RhcmdldCxcclxuICAgICAgICBwaW5jaFN0YXJ0OiBjaGVja1RhcmdldCxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRyb2xBYmxlR2VzdG8obW92ZWFibGUsIGV2ZW50QWZmaXgpIHtcclxuICAgIHZhciBjb250cm9sQm94ID0gbW92ZWFibGUuY29udHJvbEJveDtcclxuICAgIHZhciB0YXJnZXRzID0gW107XHJcbiAgICB0YXJnZXRzLnB1c2goY29udHJvbEJveCk7XHJcbiAgICB2YXIgY2hlY2tUYXJnZXQgPSBjaGVja01vdmVhYmxlVGFyZ2V0KG1vdmVhYmxlLCB0cnVlKTtcclxuICAgIHZhciBjaGVja0NvbnRyb2xUYXJnZXQgPSBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7IHRhcmdldCA9IGUuaW5wdXRFdmVudC50YXJnZXQ7IH1cclxuICAgICAgICBpZiAodGFyZ2V0ID09PSBjb250cm9sQm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gY2hlY2tUYXJnZXQoZSwgdGFyZ2V0KTtcclxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZ2V0QWJsZUdlc3RvKG1vdmVhYmxlLCB0YXJnZXRzLCBcImNvbnRyb2xBYmxlc1wiLCBldmVudEFmZml4LCB7XHJcbiAgICAgICAgZHJhZ1N0YXJ0OiBjaGVja0NvbnRyb2xUYXJnZXQsXHJcbiAgICAgICAgcGluY2hTdGFydDogY2hlY2tDb250cm9sVGFyZ2V0LFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWJsZUdlc3RvKG1vdmVhYmxlLCB0YXJnZXQsIGFibGVUeXBlLCBldmVudEFmZml4LCBjb25kaXRpb25GdW5jdGlvbnMpIHtcclxuICAgIGlmIChjb25kaXRpb25GdW5jdGlvbnMgPT09IHZvaWQgMCkgeyBjb25kaXRpb25GdW5jdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIGlzVGFyZ2V0QWJsZXMgPSBhYmxlVHlwZSA9PT0gXCJ0YXJnZXRBYmxlc1wiO1xyXG4gICAgdmFyIF9hID0gbW92ZWFibGUucHJvcHMsIHBpbmNoT3V0c2lkZSA9IF9hLnBpbmNoT3V0c2lkZSwgcGluY2hUaHJlc2hvbGQgPSBfYS5waW5jaFRocmVzaG9sZCwgcHJldmVudENsaWNrRXZlbnRPbkRyYWcgPSBfYS5wcmV2ZW50Q2xpY2tFdmVudE9uRHJhZywgcHJldmVudENsaWNrRGVmYXVsdCA9IF9hLnByZXZlbnRDbGlja0RlZmF1bHQsIGNoZWNrSW5wdXQgPSBfYS5jaGVja0lucHV0LCBkcmFnRm9jdXNlZElucHV0ID0gX2EuZHJhZ0ZvY3VzZWRJbnB1dCwgX2IgPSBfYS5wcmV2ZW50RGVmYXVsdCwgcHJldmVudERlZmF1bHQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLnByZXZlbnRSaWdodENsaWNrLCBwcmV2ZW50UmlnaHRDbGljayA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2EucHJldmVudFdoZWVsQ2xpY2ssIHByZXZlbnRXaGVlbENsaWNrID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgZHJhZ0NvbnRhaWVuck9wdGlvbiA9IF9hLmRyYWdDb250YWluZXI7XHJcbiAgICB2YXIgZHJhZ0NvbnRhaW5lciA9IGdldFJlZlRhcmdldChkcmFnQ29udGFpZW5yT3B0aW9uLCB0cnVlKTtcclxuICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcclxuICAgICAgICBwcmV2ZW50UmlnaHRDbGljazogcHJldmVudFJpZ2h0Q2xpY2ssXHJcbiAgICAgICAgcHJldmVudFdoZWVsQ2xpY2s6IHByZXZlbnRXaGVlbENsaWNrLFxyXG4gICAgICAgIGNvbnRhaW5lcjogZHJhZ0NvbnRhaW5lciB8fCBnZXRXaW5kb3cobW92ZWFibGUuZ2V0Q29udHJvbEJveEVsZW1lbnQoKSksXHJcbiAgICAgICAgcGluY2hUaHJlc2hvbGQ6IHBpbmNoVGhyZXNob2xkLFxyXG4gICAgICAgIHBpbmNoT3V0c2lkZTogcGluY2hPdXRzaWRlLFxyXG4gICAgICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnOiBpc1RhcmdldEFibGVzID8gcHJldmVudENsaWNrRXZlbnRPbkRyYWcgOiBmYWxzZSxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tFdmVudE9uRHJhZ1N0YXJ0OiBpc1RhcmdldEFibGVzID8gcHJldmVudENsaWNrRGVmYXVsdCA6IGZhbHNlLFxyXG4gICAgICAgIHByZXZlbnRDbGlja0V2ZW50QnlDb25kaXRpb246IGlzVGFyZ2V0QWJsZXMgPyBudWxsIDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdmVhYmxlLmNvbnRyb2xCb3guY29udGFpbnMoZS50YXJnZXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hlY2tJbnB1dDogaXNUYXJnZXRBYmxlcyA/IGNoZWNrSW5wdXQgOiBmYWxzZSxcclxuICAgICAgICBkcmFnRm9jdXNlZElucHV0OiBkcmFnRm9jdXNlZElucHV0LFxyXG4gICAgfTtcclxuICAgIHZhciBnZXN0byA9IG5ldyBHZXN0byh0YXJnZXQsIG9wdGlvbnMpO1xyXG4gICAgdmFyIGlzQ29udHJvbCA9IGV2ZW50QWZmaXggPT09IFwiQ29udHJvbFwiO1xyXG4gICAgW1wiZHJhZ1wiLCBcInBpbmNoXCJdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50T3BlcmF0aW9uKSB7XHJcbiAgICAgICAgW1wiU3RhcnRcIiwgXCJcIiwgXCJFbmRcIl0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGdlc3RvLm9uKFwiXCIuY29uY2F0KGV2ZW50T3BlcmF0aW9uKS5jb25jYXQoZXZlbnRUeXBlKSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBlLmV2ZW50VHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1BpbmNoU2NoZWR1bGVkID0gZXZlbnRPcGVyYXRpb24gPT09IFwiZHJhZ1wiICYmIGUuaXNQaW5jaDtcclxuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25GdW5jdGlvbnNbZXZlbnROYW1lXSAmJiAhY29uZGl0aW9uRnVuY3Rpb25zW2V2ZW50TmFtZV0oZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQaW5jaFNjaGVkdWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBldmVudE9wZXJhdGlvbnMgPSBldmVudE9wZXJhdGlvbiA9PT0gXCJkcmFnXCIgPyBbZXZlbnRPcGVyYXRpb25dIDogW1wiZHJhZ1wiLCBldmVudE9wZXJhdGlvbl07XHJcbiAgICAgICAgICAgICAgICB2YXIgbW92ZWFibGVBYmxlcyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChtb3ZlYWJsZVthYmxlVHlwZV0pLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJpZ2dlckFibGUobW92ZWFibGUsIG1vdmVhYmxlQWJsZXMsIGV2ZW50T3BlcmF0aW9ucywgZXZlbnRBZmZpeCwgZXZlbnRUeXBlLCBlKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3ZlYWJsZS5wcm9wcy5zdG9wUHJvcGFnYXRpb24gfHwgKGV2ZW50VHlwZSA9PT0gXCJTdGFydFwiICYmIGlzQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuaW5wdXRFdmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGdlc3RvO1xyXG59XG5cbnZhciBFdmVudE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIodGFyZ2V0LCBtb3ZlYWJsZSwgZXZlbnROYW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLm1vdmVhYmxlID0gbW92ZWFibGU7XHJcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XHJcbiAgICAgICAgdGhpcy5hYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX29uRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gX3RoaXMuZXZlbnROYW1lO1xyXG4gICAgICAgICAgICB2YXIgbW92ZWFibGUgPSBfdGhpcy5tb3ZlYWJsZTtcclxuICAgICAgICAgICAgaWYgKG1vdmVhYmxlLnN0YXRlLmRpc2FibGVOYXRpdmVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGFibGVbZXZlbnROYW1lXShtb3ZlYWJsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0RXZlbnQ6IGUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUudG9Mb3dlckNhc2UoKSwgdGhpcy5fb25FdmVudCk7XHJcbiAgICB9XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnNldEFibGVzID0gZnVuY3Rpb24gKGFibGVzKSB7XHJcbiAgICAgICAgdGhpcy5hYmxlcyA9IGFibGVzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLnRvTG93ZXJDYXNlKCksIHRoaXMuX29uRXZlbnQpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1vdmVhYmxlID0gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG59KCkpO1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRyaXhTdGFjayh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgaXNBYnNvbHV0ZTNkKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAocm9vdENvbnRhaW5lciA9PT0gdm9pZCAwKSB7IHJvb3RDb250YWluZXIgPSBjb250YWluZXI7IH1cclxuICAgIHZhciBfYiA9IGdldE1hdHJpeFN0YWNrSW5mbyh0YXJnZXQsIGNvbnRhaW5lciksIG1hdHJpeGVzID0gX2IubWF0cml4ZXMsIGlzM2QgPSBfYi5pczNkLCBwcmV2VGFyZ2V0TWF0cml4ID0gX2IudGFyZ2V0TWF0cml4LCB0cmFuc2Zvcm1PcmlnaW4gPSBfYi50cmFuc2Zvcm1PcmlnaW4sIHRhcmdldE9yaWdpbiA9IF9iLnRhcmdldE9yaWdpbiwgb2Zmc2V0Q29udGFpbmVyID0gX2Iub2Zmc2V0Q29udGFpbmVyLCBoYXNGaXhlZCA9IF9iLmhhc0ZpeGVkLCBjb250YWluZXJab29tID0gX2Iuem9vbTsgLy8gcHJldk1hdHJpeFxyXG4gICAgdmFyIF9jID0gZ2V0Q2FjaGVkTWF0cml4Q29udGFpbmVySW5mbyhvZmZzZXRDb250YWluZXIsIHJvb3RDb250YWluZXIpLCByb290TWF0cml4ZXMgPSBfYy5tYXRyaXhlcywgaXNSb290M2QgPSBfYy5pczNkLCBvZmZzZXRSb290Q29udGFpbmVyID0gX2Mub2Zmc2V0Q29udGFpbmVyLCByb290Wm9vbSA9IF9jLnpvb207IC8vIHByZXZSb290TWF0cml4XHJcbiAgICAvLyBpZiAocm9vdENvbnRhaW5lciA9PT0gZG9jdW1lbnQuYm9keSkge1xyXG4gICAgLy8gICAgIGNvbnNvbGUubG9nKG9mZnNldENvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgcm9vdE1hdHJpeGVzKTtcclxuICAgIC8vIH1cclxuICAgIHZhciBpc05leHQzZCA9IGlzQWJzb2x1dGUzZCB8fCBpc1Jvb3QzZCB8fCBpczNkO1xyXG4gICAgdmFyIG4gPSBpc05leHQzZCA/IDQgOiAzO1xyXG4gICAgdmFyIGlzU1ZHR3JhcGhpY0VsZW1lbnQgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInN2Z1wiICYmIFwib3duZXJTVkdFbGVtZW50XCIgaW4gdGFyZ2V0O1xyXG4gICAgdmFyIHRhcmdldE1hdHJpeCA9IHByZXZUYXJnZXRNYXRyaXg7XHJcbiAgICAvLyBsZXQgYWxsTWF0cml4ID0gcHJldk1hdHJpeCA/IGNvbnZlcnREaW1lbnNpb24ocHJldk1hdHJpeCwgcHJldk4hLCBuKSA6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgLy8gbGV0IHJvb3RNYXRyaXggPSBwcmV2Um9vdE1hdHJpeCA/IGNvbnZlcnREaW1lbnNpb24ocHJldlJvb3RNYXRyaXgsIHByZXZOISwgbikgOiBjcmVhdGVJZGVudGl0eU1hdHJpeChuKTtcclxuICAgIC8vIGxldCBiZWZvcmVNYXRyaXggPSBwcmV2TWF0cml4ID8gY29udmVydERpbWVuc2lvbihwcmV2TWF0cml4LCBwcmV2TiEsIG4pIDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XHJcbiAgICB2YXIgYWxsTWF0cml4ID0gY3JlYXRlSWRlbnRpdHlNYXRyaXgobik7XHJcbiAgICB2YXIgcm9vdE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgdmFyIGJlZm9yZU1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgdmFyIG9mZnNldE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pO1xyXG4gICAgdmFyIGxlbmd0aCA9IG1hdHJpeGVzLmxlbmd0aDtcclxuICAgIHZhciBuZXh0Um9vdE1hdHJpeGVzID0gcm9vdE1hdHJpeGVzLm1hcChmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5mbyksIHsgbWF0cml4OiBpbmZvLm1hdHJpeCA/IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChpbmZvLm1hdHJpeCksIGZhbHNlKSA6IHVuZGVmaW5lZCB9KTtcclxuICAgIH0pLnJldmVyc2UoKTtcclxuICAgIG1hdHJpeGVzLnJldmVyc2UoKTtcclxuICAgIGlmICghaXMzZCAmJiBpc05leHQzZCkge1xyXG4gICAgICAgIHRhcmdldE1hdHJpeCA9IGNvbnZlcnREaW1lbnNpb24odGFyZ2V0TWF0cml4LCAzLCA0KTtcclxuICAgICAgICBjb252ZXJ0M0RNYXRyaXhlcyhtYXRyaXhlcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzUm9vdDNkICYmIGlzTmV4dDNkKSB7XHJcbiAgICAgICAgY29udmVydDNETWF0cml4ZXMobmV4dFJvb3RNYXRyaXhlcyk7XHJcbiAgICB9XHJcbiAgICAvLyByb290TWF0cml4ID0gKC4uLikgLT4gY29udGFpbmVyIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSAtPiBvZmZzZXQgLT4gYWJzb2x1dGUodGFyZ2V0TWF0cml4KVxyXG4gICAgLy8gcm9vdE1hdHJpeEJlZm9yZU9mZnNldCA9IGxhc3RPZmZzZXRNYXRyaXggLT4gKC4uLikgLT4gY29udGFpbmVyXHJcbiAgICAvLyBiZWZvcmVNYXRyaXggPSAoLi4uIC0+IGNvbnRhaW5lciAtPiBvZmZzZXQgLT4gYWJzb2x1dGUpIC0+IG9mZnNldCAtPiBhYnNvbHV0ZSh0YXJnZXRNYXRyaXgpXHJcbiAgICAvLyBvZmZzZXRNYXRyaXggPSAoLi4uIC0+IGNvbnRhaW5lciAtPiBvZmZzZXQgLT4gYWJzb2x1dGUgLT4gb2Zmc2V0KSAtPiBhYnNvbHV0ZSh0YXJnZXRNYXRyaXgpXHJcbiAgICBuZXh0Um9vdE1hdHJpeGVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICByb290TWF0cml4ID0gbXVsdGlwbHkocm9vdE1hdHJpeCwgaW5mby5tYXRyaXgsIG4pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgb3JpZ2luYWxSb290Q29udGFpbmVyID0gcm9vdENvbnRhaW5lciB8fCBnZXREb2N1bWVudEJvZHkodGFyZ2V0KTtcclxuICAgIHZhciBlbmRDb250YWluZXIgPSAoKF9hID0gbmV4dFJvb3RNYXRyaXhlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldClcclxuICAgICAgICB8fCBnZXRPZmZzZXRJbmZvKG9yaWdpbmFsUm9vdENvbnRhaW5lciwgb3JpZ2luYWxSb290Q29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnQ7XHJcbiAgICB2YXIgcm9vdE1hdHJpeEJlZm9yZU9mZnNldCA9IG5leHRSb290TWF0cml4ZXMuc2xpY2UoMSkucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIGluZm8pIHtcclxuICAgICAgICByZXR1cm4gbXVsdGlwbHkobWF0cml4LCBpbmZvLm1hdHJpeCwgbik7XHJcbiAgICB9LCBjcmVhdGVJZGVudGl0eU1hdHJpeChuKSk7XHJcbiAgICBtYXRyaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvLCBpKSB7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAtIDIgPT09IGkpIHtcclxuICAgICAgICAgICAgLy8gbGVuZ3RoIC0gM1xyXG4gICAgICAgICAgICBiZWZvcmVNYXRyaXggPSBhbGxNYXRyaXguc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCAtIDEgPT09IGkpIHtcclxuICAgICAgICAgICAgLy8gbGVuZ3RoIC0gMlxyXG4gICAgICAgICAgICBvZmZzZXRNYXRyaXggPSBhbGxNYXRyaXguc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIGZvciBTVkdFbGVtZW50XHJcbiAgICAgICAgaWYgKCFpbmZvLm1hdHJpeCkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dEluZm8gPSBtYXRyaXhlc1tpICsgMV07XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZXRTVkdPZmZzZXQoaW5mbywgbmV4dEluZm8sIGVuZENvbnRhaW5lciwgbiwgbXVsdGlwbHkocm9vdE1hdHJpeEJlZm9yZU9mZnNldCwgYWxsTWF0cml4LCBuKSk7XHJcbiAgICAgICAgICAgIGluZm8ubWF0cml4ID0gY3JlYXRlT3JpZ2luTWF0cml4KG9mZnNldCwgbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFsbE1hdHJpeCA9IG11bHRpcGx5KGFsbE1hdHJpeCwgaW5mby5tYXRyaXgsIG4pO1xyXG4gICAgfSk7XHJcbiAgICB2YXIgaXNNYXRyaXgzZCA9ICFpc1NWR0dyYXBoaWNFbGVtZW50ICYmIGlzM2Q7XHJcbiAgICBpZiAoIXRhcmdldE1hdHJpeCkge1xyXG4gICAgICAgIHRhcmdldE1hdHJpeCA9IGNyZWF0ZUlkZW50aXR5TWF0cml4KGlzTWF0cml4M2QgPyA0IDogMyk7XHJcbiAgICB9XHJcbiAgICB2YXIgdGFyZ2V0VHJhbnNmb3JtID0gbWFrZU1hdHJpeENTUyhpc1NWR0dyYXBoaWNFbGVtZW50ICYmIHRhcmdldE1hdHJpeC5sZW5ndGggPT09IDE2XHJcbiAgICAgICAgPyBjb252ZXJ0RGltZW5zaW9uKHRhcmdldE1hdHJpeCwgNCwgMykgOiB0YXJnZXRNYXRyaXgsIGlzTWF0cml4M2QpO1xyXG4gICAgdmFyIG9yaWdpbmFsUm9vdE1hdHJpeCA9IHJvb3RNYXRyaXg7XHJcbiAgICByb290TWF0cml4ID0gaWdub3JlRGltZW5zaW9uKHJvb3RNYXRyaXgsIG4sIG4pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoYXNab29tOiBjb250YWluZXJab29tICE9PSAxIHx8IHJvb3Rab29tICE9PSAxLFxyXG4gICAgICAgIGhhc0ZpeGVkOiBoYXNGaXhlZCxcclxuICAgICAgICBtYXRyaXhlczogbWF0cml4ZXMsXHJcbiAgICAgICAgcm9vdE1hdHJpeDogcm9vdE1hdHJpeCxcclxuICAgICAgICBvcmlnaW5hbFJvb3RNYXRyaXg6IG9yaWdpbmFsUm9vdE1hdHJpeCxcclxuICAgICAgICBiZWZvcmVNYXRyaXg6IGJlZm9yZU1hdHJpeCxcclxuICAgICAgICBvZmZzZXRNYXRyaXg6IG9mZnNldE1hdHJpeCxcclxuICAgICAgICBhbGxNYXRyaXg6IGFsbE1hdHJpeCxcclxuICAgICAgICB0YXJnZXRNYXRyaXg6IHRhcmdldE1hdHJpeCxcclxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm06IHRhcmdldFRyYW5zZm9ybSxcclxuICAgICAgICBpbmxpbmVUcmFuc2Zvcm06IHRhcmdldC5zdHlsZS50cmFuc2Zvcm0sXHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXHJcbiAgICAgICAgdGFyZ2V0T3JpZ2luOiB0YXJnZXRPcmlnaW4sXHJcbiAgICAgICAgaXMzZDogaXNOZXh0M2QsXHJcbiAgICAgICAgb2Zmc2V0Q29udGFpbmVyOiBvZmZzZXRDb250YWluZXIsXHJcbiAgICAgICAgb2Zmc2V0Um9vdENvbnRhaW5lcjogb2Zmc2V0Um9vdENvbnRhaW5lcixcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIsIGlzQWJzb2x1dGUzZCkge1xyXG4gICAgaWYgKHJvb3RDb250YWluZXIgPT09IHZvaWQgMCkgeyByb290Q29udGFpbmVyID0gY29udGFpbmVyOyB9XHJcbiAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgdmFyIGhlaWdodCA9IDA7XHJcbiAgICB2YXIgcm90YXRpb24gPSAwO1xyXG4gICAgdmFyIGFsbFJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIHNpemVzID0gZ2V0U2l6ZSh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIHdpZHRoID0gc2l6ZXMub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZXMub2Zmc2V0SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVNYXRyaXhTdGFjayh0YXJnZXQsIGNvbnRhaW5lciwgcm9vdENvbnRhaW5lciwgaXNBYnNvbHV0ZTNkKTtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjYWxjdWxhdGVFbGVtZW50UG9zaXRpb24ocmVzdWx0LmFsbE1hdHJpeCwgcmVzdWx0LnRyYW5zZm9ybU9yaWdpbiwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgYWxsUmVzdWx0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3VsdCksIHBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgcm90YXRpb25Qb3NpdGlvbiA9IGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbihyZXN1bHQuYWxsTWF0cml4LCBbNTAsIDUwXSwgMTAwLCAxMDApO1xyXG4gICAgICAgIHJvdGF0aW9uID0gZ2V0Um90YXRpb25SYWQoW3JvdGF0aW9uUG9zaXRpb24ucG9zMSwgcm90YXRpb25Qb3NpdGlvbi5wb3MyXSwgcm90YXRpb25Qb3NpdGlvbi5kaXJlY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgdmFyIG4gPSBpc0Fic29sdXRlM2QgPyA0IDogMztcclxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7IGhhc1pvb206IGZhbHNlLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCByb3RhdGlvbjogcm90YXRpb24gfSwgc2l6ZXMpLCB7IG9yaWdpbmFsUm9vdE1hdHJpeDogY3JlYXRlSWRlbnRpdHlNYXRyaXgobiksIHJvb3RNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLCBiZWZvcmVNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLCBvZmZzZXRNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLCBhbGxNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLCB0YXJnZXRNYXRyaXg6IGNyZWF0ZUlkZW50aXR5TWF0cml4KG4pLCB0YXJnZXRUcmFuc2Zvcm06IFwiXCIsIGlubGluZVRyYW5zZm9ybTogXCJcIiwgdHJhbnNmb3JtT3JpZ2luOiBbMCwgMF0sIHRhcmdldE9yaWdpbjogWzAsIDBdLCBpczNkOiAhIWlzQWJzb2x1dGUzZCwgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBvcmlnaW46IFswLCAwXSwgcG9zMTogWzAsIDBdLCBwb3MyOiBbMCwgMF0sIHBvczM6IFswLCAwXSwgcG9zNDogWzAsIDBdLCBkaXJlY3Rpb246IDEsIGhhc0ZpeGVkOiBmYWxzZSwgb2Zmc2V0Q29udGFpbmVyOiBudWxsLCBvZmZzZXRSb290Q29udGFpbmVyOiBudWxsLCBtYXRyaXhlczogW10gfSksIGFsbFJlc3VsdCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RWxlbWVudEluZm8odGFyZ2V0LCBjb250YWluZXIsIHJvb3RDb250YWluZXIpIHtcclxuICAgIGlmIChyb290Q29udGFpbmVyID09PSB2b2lkIDApIHsgcm9vdENvbnRhaW5lciA9IGNvbnRhaW5lcjsgfVxyXG4gICAgcmV0dXJuIGNhbGN1bGF0ZUVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyLCB0cnVlKTtcclxufVxuXG5mdW5jdGlvbiBnZXRNb3ZlYWJsZVRhcmdldEluZm8obW92ZWFibGVFbGVtZW50LCB0YXJnZXQsIGNvbnRhaW5lciwgcGFyZW50Q29udGFpbmVyLCByb290Q29udGFpbmVyLCByZXF1ZXN0U3R5bGVzKSB7XHJcbiAgICBpZiAocmVxdWVzdFN0eWxlcyA9PT0gdm9pZCAwKSB7IHJlcXVlc3RTdHlsZXMgPSBbXTsgfVxyXG4gICAgdmFyIGJlZm9yZURpcmVjdGlvbiA9IDE7XHJcbiAgICB2YXIgYmVmb3JlT3JpZ2luID0gWzAsIDBdO1xyXG4gICAgdmFyIHRhcmdldENsaWVudFJlY3QgPSByZXNldENsaWVudFJlY3QoKTtcclxuICAgIHZhciBtb3ZlYWJsZUNsaWVudFJlY3QgPSByZXNldENsaWVudFJlY3QoKTtcclxuICAgIHZhciBjb250YWluZXJDbGllbnRSZWN0ID0gcmVzZXRDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgcm9vdENvbnRhaW5lckNsaWVudFJlY3QgPSByZXNldENsaWVudFJlY3QoKTtcclxuICAgIHZhciBvZmZzZXREZWx0YSA9IFswLCAwXTtcclxuICAgIHZhciBzdHlsZSA9IHt9O1xyXG4gICAgdmFyIHJlc3VsdCA9IGNhbGN1bGF0ZUVsZW1lbnRJbmZvKHRhcmdldCwgY29udGFpbmVyLCByb290Q29udGFpbmVyLCB0cnVlKTtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgZ2V0U3R5bGVfMSA9IGdldENhY2hlZFN0eWxlKHRhcmdldCk7XHJcbiAgICAgICAgcmVxdWVzdFN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHN0eWxlW25hbWVdID0gZ2V0U3R5bGVfMShuYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbiA9IHJlc3VsdC5pczNkID8gNCA6IDM7XHJcbiAgICAgICAgdmFyIGJlZm9yZVBvc2l0aW9uID0gY2FsY3VsYXRlRWxlbWVudFBvc2l0aW9uKHJlc3VsdC5vZmZzZXRNYXRyaXgsIHBsdXMocmVzdWx0LnRyYW5zZm9ybU9yaWdpbiwgZ2V0T3JpZ2luKHJlc3VsdC50YXJnZXRNYXRyaXgsIG4pKSwgcmVzdWx0LndpZHRoLCByZXN1bHQuaGVpZ2h0KTtcclxuICAgICAgICBiZWZvcmVEaXJlY3Rpb24gPSBiZWZvcmVQb3NpdGlvbi5kaXJlY3Rpb247XHJcbiAgICAgICAgYmVmb3JlT3JpZ2luID0gcGx1cyhiZWZvcmVQb3NpdGlvbi5vcmlnaW4sIFtiZWZvcmVQb3NpdGlvbi5sZWZ0IC0gcmVzdWx0LmxlZnQsIGJlZm9yZVBvc2l0aW9uLnRvcCAtIHJlc3VsdC50b3BdKTtcclxuICAgICAgICByb290Q29udGFpbmVyQ2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QocmVzdWx0Lm9mZnNldFJvb3RDb250YWluZXIpO1xyXG4gICAgICAgIHZhciBvZmZzZXRDb250YWluZXIgPSBnZXRPZmZzZXRJbmZvKHBhcmVudENvbnRhaW5lciwgcGFyZW50Q29udGFpbmVyLCB0cnVlKS5vZmZzZXRQYXJlbnRcclxuICAgICAgICAgICAgfHwgcmVzdWx0Lm9mZnNldFJvb3RDb250YWluZXI7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5oYXNab29tKSB7XHJcbiAgICAgICAgICAgIHZhciBhYnNvbHV0ZVRhcmdldFBvc2l0aW9uID0gY2FsY3VsYXRlRWxlbWVudFBvc2l0aW9uKG11bHRpcGx5KHJlc3VsdC5vcmlnaW5hbFJvb3RNYXRyaXgsIHJlc3VsdC5hbGxNYXRyaXgpLCByZXN1bHQudHJhbnNmb3JtT3JpZ2luLCByZXN1bHQud2lkdGgsIHJlc3VsdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgYWJzb2x1dGVDb250YWluZXJQb3NpdGlvbiA9IGNhbGN1bGF0ZUVsZW1lbnRQb3NpdGlvbihyZXN1bHQub3JpZ2luYWxSb290TWF0cml4LCBnZXRUcmFuc2Zvcm1PcmlnaW5BcnJheShnZXRDYWNoZWRTdHlsZShvZmZzZXRDb250YWluZXIpKFwidHJhbnNmb3JtT3JpZ2luXCIpKS5tYXAoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gcGFyc2VGbG9hdChwb3MpOyB9KSwgb2Zmc2V0Q29udGFpbmVyLm9mZnNldFdpZHRoLCBvZmZzZXRDb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICAgICAgdGFyZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3RCeVBvc2l0aW9uKGFic29sdXRlVGFyZ2V0UG9zaXRpb24sIHJvb3RDb250YWluZXJDbGllbnRSZWN0KTtcclxuICAgICAgICAgICAgY29udGFpbmVyQ2xpZW50UmVjdCA9IGdldENsaWVudFJlY3RCeVBvc2l0aW9uKGFic29sdXRlQ29udGFpbmVyUG9zaXRpb24sIHJvb3RDb250YWluZXJDbGllbnRSZWN0LCBvZmZzZXRDb250YWluZXIsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAobW92ZWFibGVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IGFic29sdXRlVGFyZ2V0UG9zaXRpb24ubGVmdDtcclxuICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IGFic29sdXRlVGFyZ2V0UG9zaXRpb24udG9wO1xyXG4gICAgICAgICAgICAgICAgbW92ZWFibGVDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdEJ5UG9zaXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3BfMSxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHRvcF8xLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0b3BfMSxcclxuICAgICAgICAgICAgICAgIH0sIHJvb3RDb250YWluZXJDbGllbnRSZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGFyZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3QodGFyZ2V0KTtcclxuICAgICAgICAgICAgY29udGFpbmVyQ2xpZW50UmVjdCA9IGdldENhY2hlZENsaWVudFJlY3Qob2Zmc2V0Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgaWYgKG1vdmVhYmxlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgbW92ZWFibGVDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdChtb3ZlYWJsZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXJDbGllbnRSZWN0TGVmdCA9IGNvbnRhaW5lckNsaWVudFJlY3QubGVmdCwgY29udGFpbmVyQ2xpZW50UmVjdFRvcCA9IGNvbnRhaW5lckNsaWVudFJlY3QudG9wLCBjb250YWludGVyQ2xpZW50TGVmdCA9IGNvbnRhaW5lckNsaWVudFJlY3QuY2xpZW50TGVmdCwgY29udGFpbmVyQ2xpZW50VG9wID0gY29udGFpbmVyQ2xpZW50UmVjdC5jbGllbnRUb3A7XHJcbiAgICAgICAgICAgIHZhciBjbGllbnREZWx0YSA9IFtcclxuICAgICAgICAgICAgICAgIHRhcmdldENsaWVudFJlY3QubGVmdCAtIGNvbnRhaW5lckNsaWVudFJlY3RMZWZ0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2xpZW50UmVjdC50b3AgLSBjb250YWluZXJDbGllbnRSZWN0VG9wLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBvZmZzZXREZWx0YSA9IG1pbnVzKGNhbGN1bGF0ZUludmVyc2VQb3NpdGlvbihyZXN1bHQucm9vdE1hdHJpeCwgY2xpZW50RGVsdGEsIDQpLCBbY29udGFpbnRlckNsaWVudExlZnQgKyByZXN1bHQubGVmdCwgY29udGFpbmVyQ2xpZW50VG9wICsgcmVzdWx0LnRvcF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbih7IHRhcmdldENsaWVudFJlY3Q6IHRhcmdldENsaWVudFJlY3QsIGNvbnRhaW5lckNsaWVudFJlY3Q6IGNvbnRhaW5lckNsaWVudFJlY3QsIG1vdmVhYmxlQ2xpZW50UmVjdDogbW92ZWFibGVDbGllbnRSZWN0LCByb290Q29udGFpbmVyQ2xpZW50UmVjdDogcm9vdENvbnRhaW5lckNsaWVudFJlY3QsIGJlZm9yZURpcmVjdGlvbjogYmVmb3JlRGlyZWN0aW9uLCBiZWZvcmVPcmlnaW46IGJlZm9yZU9yaWdpbiwgb3JpZ2luYWxCZWZvcmVPcmlnaW46IGJlZm9yZU9yaWdpbiwgdGFyZ2V0OiB0YXJnZXQsIHN0eWxlOiBzdHlsZSwgb2Zmc2V0RGVsdGE6IG9mZnNldERlbHRhIH0sIHJlc3VsdCk7XHJcbn1cblxuZnVuY3Rpb24gZ2V0UGVyc2lzdFN0YXRlKHJlY3QpIHtcclxuICAgIHZhciBwb3MxID0gcmVjdC5wb3MxLCBwb3MyID0gcmVjdC5wb3MyLCBwb3MzID0gcmVjdC5wb3MzLCBwb3M0ID0gcmVjdC5wb3M0O1xyXG4gICAgaWYgKCFwb3MxIHx8ICFwb3MyIHx8ICFwb3MzIHx8ICFwb3M0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgbWluUG9zID0gZ2V0TWluTWF4cyhbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0pO1xyXG4gICAgdmFyIHBvc0RlbHRhID0gW21pblBvcy5taW5YLCBtaW5Qb3MubWluWV07XHJcbiAgICB2YXIgb3JpZ2luID0gbWludXMocmVjdC5vcmlnaW4sIHBvc0RlbHRhKTtcclxuICAgIHBvczEgPSBtaW51cyhwb3MxLCBwb3NEZWx0YSk7XHJcbiAgICBwb3MyID0gbWludXMocG9zMiwgcG9zRGVsdGEpO1xyXG4gICAgcG9zMyA9IG1pbnVzKHBvczMsIHBvc0RlbHRhKTtcclxuICAgIHBvczQgPSBtaW51cyhwb3M0LCBwb3NEZWx0YSk7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY3QpLCB7IGxlZnQ6IHJlY3QubGVmdCwgdG9wOiByZWN0LnRvcCwgcG9zRGVsdGE6IHBvc0RlbHRhLCBwb3MxOiBwb3MxLCBwb3MyOiBwb3MyLCBwb3MzOiBwb3MzLCBwb3M0OiBwb3M0LCBvcmlnaW46IG9yaWdpbiwgYmVmb3JlT3JpZ2luOiBvcmlnaW4sIFxyXG4gICAgICAgIC8vIG9yaWdpbmFsQmVmb3JlT3JpZ2luOiBvcmlnaW4sXHJcbiAgICAgICAgaXNQZXJzaXN0ZWQ6IHRydWUgfSk7XHJcbn1cblxudmFyIE1vdmVhYmxlTWFuYWdlciA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNb3ZlYWJsZU1hbmFnZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb3ZlYWJsZU1hbmFnZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfX2Fzc2lnbih7IGNvbnRhaW5lcjogbnVsbCwgZ2VzdG9zOiB7fSwgcmVuZGVyTGluZXM6IFtcclxuICAgICAgICAgICAgICAgIFtbMCwgMF0sIFswLCAwXV0sXHJcbiAgICAgICAgICAgICAgICBbWzAsIDBdLCBbMCwgMF1dLFxyXG4gICAgICAgICAgICAgICAgW1swLCAwXSwgWzAsIDBdXSxcclxuICAgICAgICAgICAgICAgIFtbMCwgMF0sIFswLCAwXV0sXHJcbiAgICAgICAgICAgIF0sIHJlbmRlclBvc2VzOiBbWzAsIDBdLCBbMCwgMF0sIFswLCAwXSwgWzAsIDBdXSwgZGlzYWJsZU5hdGl2ZUV2ZW50OiBmYWxzZSwgcG9zRGVsdGE6IFswLCAwXSB9LCBnZXRNb3ZlYWJsZVRhcmdldEluZm8obnVsbCkpO1xyXG4gICAgICAgIF90aGlzLnJlbmRlclN0YXRlID0ge307XHJcbiAgICAgICAgX3RoaXMuZW5hYmxlZEFibGVzID0gW107XHJcbiAgICAgICAgX3RoaXMudGFyZ2V0QWJsZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5jb250cm9sQWJsZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgX3RoaXMuc2NhbGUgPSBbMSwgMV07XHJcbiAgICAgICAgX3RoaXMuaXNNb3ZlYWJsZU1vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5pc1VubW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmV2ZW50cyA9IHtcclxuICAgICAgICAgICAgXCJtb3VzZUVudGVyXCI6IG51bGwsXHJcbiAgICAgICAgICAgIFwibW91c2VMZWF2ZVwiOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuX3ByZXZPcmlnaW5hbERyYWdUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9vcmlnaW5hbERyYWdUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9wcmV2RHJhZ1RhcmdldCA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX2RyYWdUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9wcmV2UHJvcFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX3Byb3BUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl9wcmV2RHJhZ0FyZWEgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLl9oYXNGaXJzdFRhcmdldCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLl9yZWlzemVPYnNlcnZlciA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX29ic2VydmVySWQgPSAwO1xyXG4gICAgICAgIF90aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fcm9vdENvbnRhaW5lciA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuX3ZpZXdDb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLl92aWV3Q2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLl9zdG9yZSA9IHt9O1xyXG4gICAgICAgIF90aGlzLmNoZWNrVXBkYXRlUmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IF90aGlzLnByb3BzLnBhcmVudE1vdmVhYmxlO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50TW92ZWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudE1vdmVhYmxlLmNoZWNrVXBkYXRlUmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLl9vYnNlcnZlcklkKTtcclxuICAgICAgICAgICAgX3RoaXMuX29ic2VydmVySWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVJlY3QoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5fb25QcmV2ZW50Q2xpY2sgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZUV2ZW50KHdpbmRvdywgXCJjbGlja1wiLCB0aGlzLl9vblByZXZlbnRDbGljaywgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcclxuICAgICAgICB2YXIgcGFyZW50UG9zaXRpb24gPSBwcm9wcy5wYXJlbnRQb3NpdGlvbiwgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLCBwcm9wc1RhcmdldCA9IHByb3BzLnRhcmdldCwgem9vbSA9IHByb3BzLnpvb20sIGNzcE5vbmNlID0gcHJvcHMuY3NwTm9uY2UsIHRyYW5zbGF0ZVogPSBwcm9wcy50cmFuc2xhdGVaLCBDb250cm9sQm94RWxlbWVudCA9IHByb3BzLmNzc1N0eWxlZCwgZ3JvdXBhYmxlID0gcHJvcHMuZ3JvdXBhYmxlLCBsaW5lUGFkZGluZyA9IHByb3BzLmxpbmVQYWRkaW5nLCBjb250cm9sUGFkZGluZyA9IHByb3BzLmNvbnRyb2xQYWRkaW5nO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tVcGRhdGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlclBvc2VzKCk7XHJcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHBhcmVudFBvc2l0aW9uIHx8IFswLCAwXSwgMiksIHBhcmVudExlZnQgPSBfYVswXSwgcGFyZW50VG9wID0gX2FbMV07XHJcbiAgICAgICAgdmFyIGxlZnQgPSBzdGF0ZS5sZWZ0LCB0b3AgPSBzdGF0ZS50b3AsIHN0YXRlVGFyZ2V0ID0gc3RhdGUudGFyZ2V0LCBkaXJlY3Rpb24gPSBzdGF0ZS5kaXJlY3Rpb24sIGhhc0ZpeGVkID0gc3RhdGUuaGFzRml4ZWQsIG9mZnNldERlbHRhID0gc3RhdGUub2Zmc2V0RGVsdGE7XHJcbiAgICAgICAgdmFyIGdyb3VwVGFyZ2V0cyA9IHByb3BzLnRhcmdldHM7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmcoKTtcclxuICAgICAgICB2YXIgYWJsZUF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmdldEVuYWJsZWRBYmxlcygpLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgYWJsZUF0dHJpYnV0ZXNbXCJkYXRhLWFibGUtXCIuY29uY2F0KGFibGUubmFtZS50b0xvd2VyQ2FzZSgpKV0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBhYmxlQ2xhc3NOYW1lID0gdGhpcy5fZ2V0QWJsZUNsYXNzTmFtZSgpO1xyXG4gICAgICAgIHZhciBpc0Rpc3BsYXkgPSAoZ3JvdXBUYXJnZXRzICYmIGdyb3VwVGFyZ2V0cy5sZW5ndGggJiYgKHN0YXRlVGFyZ2V0IHx8IGdyb3VwYWJsZSkpXHJcbiAgICAgICAgICAgIHx8IHByb3BzVGFyZ2V0XHJcbiAgICAgICAgICAgIHx8ICghdGhpcy5faGFzRmlyc3RUYXJnZXQgJiYgdGhpcy5zdGF0ZS5pc1BlcnNpc3RlZCk7XHJcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMuY29udHJvbEJveCB8fCB0aGlzLnByb3BzLmZpcnN0UmVuZGVyU3RhdGUgfHwgdGhpcy5wcm9wcy5wZXJzaXN0RGF0YTtcclxuICAgICAgICB2YXIgdHJhbnNsYXRlID0gW2xlZnQgLSBwYXJlbnRMZWZ0LCB0b3AgLSBwYXJlbnRUb3BdO1xyXG4gICAgICAgIGlmICghZ3JvdXBhYmxlICYmIHByb3BzLnVzZUFjY3VyYXRlUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRlWzBdICs9IG9mZnNldERlbHRhWzBdO1xyXG4gICAgICAgICAgICB0cmFuc2xhdGVbMV0gKz0gb2Zmc2V0RGVsdGFbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHlsZSA9IHtcclxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBoYXNGaXhlZCA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IGlzRGlzcGxheSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICBcInZpc2liaWxpdHlcIjogaXNWaXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiOiBcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdCh0cmFuc2xhdGVbMF0sIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWzFdLCBcInB4LCBcIikuY29uY2F0KHRyYW5zbGF0ZVosIFwiKVwiKSxcclxuICAgICAgICAgICAgXCItLXpvb21cIjogem9vbSxcclxuICAgICAgICAgICAgXCItLXpvb21weFwiOiBcIlwiLmNvbmNhdCh6b29tLCBcInB4XCIpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxpbmVQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHN0eWxlW1wiLS1tb3ZlYWJsZS1saW5lLXBhZGRpbmdcIl0gPSBsaW5lUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHN0eWxlW1wiLS1tb3ZlYWJsZS1jb250cm9sLXBhZGRpbmdcIl0gPSBjb250cm9sUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRyb2xCb3hFbGVtZW50LCBfX2Fzc2lnbih7IGNzcE5vbmNlOiBjc3BOb25jZSwgcmVmOiByZWYodGhpcywgXCJjb250cm9sQm94XCIpLCBjbGFzc05hbWU6IFwiXCIuY29uY2F0KHByZWZpeChcImNvbnRyb2wtYm94XCIsIGRpcmVjdGlvbiA9PT0gLTEgPyBcInJldmVyc2VcIiA6IFwiXCIsIGlzRHJhZ2dpbmcgPyBcImRyYWdnaW5nXCIgOiBcIlwiKSwgXCIgXCIpLmNvbmNhdChhYmxlQ2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KGNsYXNzTmFtZSkgfSwgYWJsZUF0dHJpYnV0ZXMsIHsgb25DbGljazogdGhpcy5fb25QcmV2ZW50Q2xpY2ssIHN0eWxlOiBzdHlsZSB9KSxcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBYmxlcygpLFxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMaW5lcygpKSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzTW92ZWFibGVNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzVW5tb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgcGFyZW50TW92ZWFibGUgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZSwgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrVXBkYXRlUm9vdENvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrVXBkYXRlVmlld0NvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRhcmdldHMoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVOYXRpdmVFdmVudHMoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVFdmVudHMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrSW5wdXQoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVPYnNlcnZlcih0aGlzLnByb3BzKTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lciAmJiAhcGFyZW50TW92ZWFibGUgJiYgIXRoaXMuc3RhdGUuaXNQZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVSZWN0KFwiXCIsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tVcGRhdGVSb290Q29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tVcGRhdGVWaWV3Q29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTmF0aXZlRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVGFyZ2V0cygpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hlY2tJbnB1dCgpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU9ic2VydmVyKHByZXZQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuaXNNb3ZlYWJsZU1vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9lbWl0dGVyLm9mZigpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX3JlaXN6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIChfYiA9IHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSB0aGlzLl92aWV3Q29udGFpbmVyO1xyXG4gICAgICAgIGlmICh2aWV3Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFibGVWaWV3Q2xhc3NOYW1lcyhbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuc2V0R2VzdG8odGhpcywgZmFsc2UpO1xyXG4gICAgICAgIHVuc2V0R2VzdG8odGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBldmVudHMpIHtcclxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBldmVudHNbbmFtZV8xXTtcclxuICAgICAgICAgICAgbWFuYWdlciAmJiBtYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnByb3BzLnRhcmdldDtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0ID8gW3RhcmdldF0gOiBbXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYWJsZSB1c2VkIGluIE1vdmVhYmxlTWFuYWdlci5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0QWJsZVxyXG4gICAgICogQHBhcmFtIC0gYWJsZSBuYW1lXHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0QWJsZSA9IGZ1bmN0aW9uIChhYmxlTmFtZSkge1xyXG4gICAgICAgIHZhciBhYmxlcyA9IHRoaXMucHJvcHMuYWJsZXMgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIGZpbmQoYWJsZXMsIGZ1bmN0aW9uIChhYmxlKSB7IHJldHVybiBhYmxlLm5hbWUgPT09IGFibGVOYW1lOyB9KTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBwYXJlbnRNb3ZlYWJsZSA9IF9hLnBhcmVudE1vdmVhYmxlLCB3cmFwcGVyTW92ZWFibGUgPSBfYS53cmFwcGVyTW92ZWFibGUsIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcclxuICAgICAgICByZXR1cm4gY29udGFpbmVyXHJcbiAgICAgICAgICAgIHx8ICh3cmFwcGVyTW92ZWFibGUgJiYgd3JhcHBlck1vdmVhYmxlLmdldENvbnRhaW5lcigpKVxyXG4gICAgICAgICAgICB8fCAocGFyZW50TW92ZWFibGUgJiYgcGFyZW50TW92ZWFibGUuZ2V0Q29udGFpbmVyKCkpXHJcbiAgICAgICAgICAgIHx8IHRoaXMuY29udHJvbEJveC5wYXJlbnRFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgY29udHJvbCBib3guXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldENvbnRyb2xCb3hFbGVtZW50XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0Q29udHJvbEJveEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEJveDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGJlIGRyYWdnZWQgaW4gbW92ZWFibGVcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0RHJhZ0VsZW1lbnRcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5nZXREcmFnRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ1RhcmdldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gZWxlbWVudCBpbmNsdWRlZCBpbiB0aGUgbW92ZWFibGUuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2lzTW92ZWFibGVFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gLSB0aGUgdGFyZ2V0XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XHJcbiAgICAgKiAgICAgaWYgKCFtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChlLnRhcmdldCkpIHtcclxuICAgICAqICAgICAgICAgbW92ZWFibGUudGFyZ2V0ID0gZS50YXJnZXQ7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuaXNNb3ZlYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQgJiYgKCgoX2EgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YXJnZXQsIFwiY2xhc3NcIikpIHx8IFwiXCIpLmluZGV4T2YoUFJFRklYKSA+IC0xO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogWW91IGNhbiBkcmFnIHN0YXJ0IHRoZSBNb3ZlYWJsZSB0aHJvdWdoIHRoZSBleHRlcm5hbCBgTW91c2VFdmVudGBvciBgVG91Y2hFdmVudGAuIChBbmd1bGFyOiBuZ0RyYWdTdGFydClcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjZHJhZ1N0YXJ0XHJcbiAgICAgKiBAcGFyYW0gLSBleHRlcm5hbCBgTW91c2VFdmVudGBvciBgVG91Y2hFdmVudGBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xyXG4gICAgICogICAgIGlmICghbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoZS50YXJnZXQpKSB7XHJcbiAgICAgKiAgICAgICAgICBtb3ZlYWJsZS5kcmFnU3RhcnQoZSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUsIHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBlLnRhcmdldDsgfVxyXG4gICAgICAgIHZhciB0YXJnZXRHZXN0byA9IHRoaXMudGFyZ2V0R2VzdG87XHJcbiAgICAgICAgdmFyIGNvbnRyb2xHZXN0byA9IHRoaXMuY29udHJvbEdlc3RvO1xyXG4gICAgICAgIGlmICh0YXJnZXRHZXN0byAmJiBjaGVja01vdmVhYmxlVGFyZ2V0KHRoaXMpKHsgaW5wdXRFdmVudDogZSB9LCB0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0R2VzdG8uaXNGbGFnKCkpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldEdlc3RvLnRyaWdnZXJEcmFnU3RhcnQoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udHJvbEdlc3RvICYmIHRoaXMuaXNNb3ZlYWJsZUVsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xHZXN0by5pc0ZsYWcoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbEdlc3RvLnRyaWdnZXJEcmFnU3RhcnQoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIaXQgdGVzdCBhbiBlbGVtZW50IG9yIHJlY3Qgb24gYSBtb3ZlYWJsZSB0YXJnZXQuXHJcbiAgICAgKiAoMTAwJSA9IDEwMClcclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjaGl0VGVzdFxyXG4gICAgICogQHBhcmFtIC0gZWxlbWVudCBvciByZWN0IHRvIHRlc3RcclxuICAgICAqIEByZXR1cm4gLSBHZXQgaGl0IHRlc3QgcmF0ZSAocmF0ZSA+IDAgaXMgaGl0dGVkKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XHJcbiAgICAgKiAgICAgaWYgKG1vdmVhYmxlLmhpdFRlc3QoZS50YXJnZXQpID4gMCkge1xyXG4gICAgICogICAgICAgICAgY29uc29sZS5sb2coXCJoaWl0ZWRcIik7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfSk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHRhcmdldCA9IF9hLnRhcmdldCwgcG9zMSA9IF9hLnBvczEsIHBvczIgPSBfYS5wb3MyLCBwb3MzID0gX2EucG9zMywgcG9zNCA9IF9hLnBvczQsIHRhcmdldENsaWVudFJlY3QgPSBfYS50YXJnZXRDbGllbnRSZWN0O1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjdDtcclxuICAgICAgICBpZiAoaXNOb2RlKGVsKSkge1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICByZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogY2xpZW50UmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBjbGllbnRSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjbGllbnRSZWN0LmhlaWdodCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY3QgPSBfX2Fzc2lnbih7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSwgZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVjdExlZnQgPSByZWN0LmxlZnQsIHJlY3RUb3AgPSByZWN0LnRvcCwgcmVjdFdpZHRoID0gcmVjdC53aWR0aCwgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBmaXRQb2ludHMoW3BvczEsIHBvczIsIHBvczQsIHBvczNdLCB0YXJnZXRDbGllbnRSZWN0KTtcclxuICAgICAgICB2YXIgc2l6ZSA9IGdldE92ZXJsYXBTaXplKHBvaW50cywgW1xyXG4gICAgICAgICAgICBbcmVjdExlZnQsIHJlY3RUb3BdLFxyXG4gICAgICAgICAgICBbcmVjdExlZnQgKyByZWN0V2lkdGgsIHJlY3RUb3BdLFxyXG4gICAgICAgICAgICBbcmVjdExlZnQgKyByZWN0V2lkdGgsIHJlY3RUb3AgKyByZWN0SGVpZ2h0XSxcclxuICAgICAgICAgICAgW3JlY3RMZWZ0LCByZWN0VG9wICsgcmVjdEhlaWdodF0sXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdmFyIHRvdGFsU2l6ZSA9IGdldEFyZWFTaXplKHBvaW50cyk7XHJcbiAgICAgICAgaWYgKCFzaXplIHx8ICF0b3RhbFNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbigxMDAsIHNpemUgLyB0b3RhbFNpemUgKiAxMDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSBNb3ZlYWJsZVxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSNpc0luc2lkZVxyXG4gICAgICogQHBhcmFtIC0geCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gLSB5IGNvb3JkaW5hdGVcclxuICAgICAqIEByZXR1cm4gLSBUcnVlIGlmIHRoZSBjb29yZGluYXRlIGlzIGluIG1vdmVhYmxlIG9yIGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBlID0+IHtcclxuICAgICAqICAgICBpZiAobW92ZWFibGUuaXNJbnNpZGUoZS5jbGllbnRYLCBlLmNsaWVudFkpKSB7XHJcbiAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhcImluc2lkZVwiKTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5pc0luc2lkZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgdGFyZ2V0ID0gX2EudGFyZ2V0LCBwb3MxID0gX2EucG9zMSwgcG9zMiA9IF9hLnBvczIsIHBvczMgPSBfYS5wb3MzLCBwb3M0ID0gX2EucG9zNCwgdGFyZ2V0Q2xpZW50UmVjdCA9IF9hLnRhcmdldENsaWVudFJlY3Q7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNJbnNpZGUoW2NsaWVudFgsIGNsaWVudFldLCBmaXRQb2ludHMoW3BvczEsIHBvczIsIHBvczQsIHBvczNdLCB0YXJnZXRDbGllbnRSZWN0KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgd2lkdGgsIGhlaWdodCwgbGVmdCwgYW5kIHRvcCBvZiBhbGwgZWxlbWVudHMgY2hhbmdlLCB1cGRhdGUgdGhlIHNoYXBlIG9mIHRoZSBtb3ZlYWJsZS5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjdXBkYXRlUmVjdFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlID0+IHtcclxuICAgICAqICAgICBtb3ZlYWJsZS51cGRhdGVSZWN0KCk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqL1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVSZWN0ID0gZnVuY3Rpb24gKHR5cGUsIGlzVGFyZ2V0LCBpc1NldFN0YXRlKSB7XHJcbiAgICAgICAgaWYgKGlzU2V0U3RhdGUgPT09IHZvaWQgMCkgeyBpc1NldFN0YXRlID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIGlzU2luZ2xlID0gIXByb3BzLnBhcmVudFBvc2l0aW9uICYmICFwcm9wcy53cmFwcGVyTW92ZWFibGU7XHJcbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XHJcbiAgICAgICAgICAgIHNldFN0b3JlQ2FjaGUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJlbnRNb3ZlYWJsZSA9IHByb3BzLnBhcmVudE1vdmVhYmxlO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IChzdGF0ZS50YXJnZXQgfHwgcHJvcHMudGFyZ2V0KTtcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcclxuICAgICAgICB2YXIgcm9vdENvbnRhaW5lciA9IHBhcmVudE1vdmVhYmxlXHJcbiAgICAgICAgICAgID8gcGFyZW50TW92ZWFibGUuX3Jvb3RDb250YWluZXJcclxuICAgICAgICAgICAgOiB0aGlzLl9yb290Q29udGFpbmVyO1xyXG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBnZXRNb3ZlYWJsZVRhcmdldEluZm8odGhpcy5jb250cm9sQm94LCB0YXJnZXQsIGNvbnRhaW5lciwgY29udGFpbmVyLCByb290Q29udGFpbmVyIHx8IGNvbnRhaW5lciwgdGhpcy5fZ2V0UmVxdWVzdFN0eWxlcygpKTtcclxuICAgICAgICBpZiAoIXRhcmdldCAmJiB0aGlzLl9oYXNGaXJzdFRhcmdldCAmJiBwcm9wcy5wZXJzaXN0RGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgcGVyc2lzdFN0YXRlID0gZ2V0UGVyc2lzdFN0YXRlKHByb3BzLnBlcnNpc3REYXRhKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIHBlcnNpc3RTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlW25hbWVfMl0gPSBwZXJzaXN0U3RhdGVbbmFtZV8yXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcclxuICAgICAgICAgICAgc2V0U3RvcmVDYWNoZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5leHRTdGF0ZSwgcGFyZW50TW92ZWFibGUgPyBmYWxzZSA6IGlzU2V0U3RhdGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIG1vdmVhYmxlIHN0YXRlIGlzIGJlaW5nIGRyYWdnZWQuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2lzRHJhZ2dpbmdcclxuICAgICAqIEBwYXJhbSAtIElmIHlvdSB3YW50IHRvIGNoZWNrIGlmIGFibGUgaXMgZHJhZ2dpbmcsIHNwZWNpZnkgYWJsZU5hbWUuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGZhbHNlXHJcbiAgICAgKiBjb25zb2xlLmxvZyhtb3ZlYWJsZS5pc0RyYWdnaW5nKCkpO1xyXG4gICAgICpcclxuICAgICAqIG1vdmVhYmxlLm9uKFwiZHJhZ1wiLCAoKSA9PiB7XHJcbiAgICAgKiAgIC8vIHRydWVcclxuICAgICAqICAgY29uc29sZS5sb2cobW92ZWFibGUuaXNEcmFnZ2luZygpKTtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoYWJsZU5hbWUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciB0YXJnZXRHZXN0byA9IHRoaXMudGFyZ2V0R2VzdG87XHJcbiAgICAgICAgdmFyIGNvbnRyb2xHZXN0byA9IHRoaXMuY29udHJvbEdlc3RvO1xyXG4gICAgICAgIGlmICh0YXJnZXRHZXN0byA9PT0gbnVsbCB8fCB0YXJnZXRHZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0R2VzdG8uaXNGbGFnKCkpIHtcclxuICAgICAgICAgICAgaWYgKCFhYmxlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0YXJnZXRHZXN0by5nZXRFdmVudERhdGEoKTtcclxuICAgICAgICAgICAgcmV0dXJuICEhKChfYSA9IGRhdGFbYWJsZU5hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFdmVudFN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xHZXN0byA9PT0gbnVsbCB8fCBjb250cm9sR2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRyb2xHZXN0by5pc0ZsYWcoKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFibGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGNvbnRyb2xHZXN0by5nZXRFdmVudERhdGEoKTtcclxuICAgICAgICAgICAgcmV0dXJuICEhKChfYiA9IGRhdGFbYWJsZU5hbWVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNFdmVudFN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIHdpZHRoLCBoZWlnaHQsIGxlZnQsIGFuZCB0b3Agb2YgdGhlIG9ubHkgdGFyZ2V0IGNoYW5nZSwgdXBkYXRlIHRoZSBzaGFwZSBvZiB0aGUgbW92ZWFibGUuXHJcbiAgICAgKiBVc2UgYC51cGRhdGVSZWN0KClgIG1ldGhvZFxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSN1cGRhdGVUYXJnZXRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIG1vdmVhYmxlLnVwZGF0ZVRhcmdldCgpO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVRhcmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSZWN0KHR5cGUsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogWW91IGNhbiBnZXQgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiwgcG9zaXRpb24gYW5kIG9mZnNldCBzaXplIGluZm9ybWF0aW9uIG9mIHRoZSB0YXJnZXQgYmFzZWQgb24gdGhlIGNvbnRhaW5lci5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0UmVjdFxyXG4gICAgICogQHJldHVybiAtIFRoZSBSZWN0IEluZm9cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgcmVjdEluZm8gPSBtb3ZlYWJsZS5nZXRSZWN0KCk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIHZhciBwb3NlcyA9IGdldEFic29sdXRlUG9zZXNCeVN0YXRlKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChwb3NlcywgNCksIHBvczEgPSBfYVswXSwgcG9zMiA9IF9hWzFdLCBwb3MzID0gX2FbMl0sIHBvczQgPSBfYVszXTtcclxuICAgICAgICB2YXIgcmVjdCA9IGdldFJlY3QocG9zZXMpO1xyXG4gICAgICAgIHZhciBvZmZzZXRXaWR0aCA9IHN0YXRlLndpZHRoLCBvZmZzZXRIZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCwgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsIGxlZnQgPSByZWN0LmxlZnQsIHRvcCA9IHJlY3QudG9wO1xyXG4gICAgICAgIHZhciBzdGF0ZVBvcyA9IFtzdGF0ZS5sZWZ0LCBzdGF0ZS50b3BdO1xyXG4gICAgICAgIHZhciBvcmlnaW4gPSBwbHVzKHN0YXRlUG9zLCBzdGF0ZS5vcmlnaW4pO1xyXG4gICAgICAgIHZhciBiZWZvcmVPcmlnaW4gPSBwbHVzKHN0YXRlUG9zLCBzdGF0ZS5iZWZvcmVPcmlnaW4pO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBzdGF0ZS50cmFuc2Zvcm1PcmlnaW47XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgICAgIHBvczE6IHBvczEsXHJcbiAgICAgICAgICAgIHBvczI6IHBvczIsXHJcbiAgICAgICAgICAgIHBvczM6IHBvczMsXHJcbiAgICAgICAgICAgIHBvczQ6IHBvczQsXHJcbiAgICAgICAgICAgIG9mZnNldFdpZHRoOiBvZmZzZXRXaWR0aCxcclxuICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0OiBvZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgICAgIGJlZm9yZU9yaWdpbjogYmVmb3JlT3JpZ2luLFxyXG4gICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcclxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW4sXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIG1hbmFnZXIgdGhhdCBtYW5hZ2VzIHRoZSBtb3ZlYWJsZSdzIHN0YXRlIGFuZCBwcm9wcy5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjZ2V0TWFuYWdlclxyXG4gICAgICogQHJldHVybiAtIFRoZSBSZWN0IEluZm9cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbWFuYWdlciA9IG1vdmVhYmxlLmdldE1hbmFnZXIoKTsgLy8gcmVhbCBtb3ZlYWJsZSBjbGFzcyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBZb3UgY2FuIHN0b3AgdGhlIGRyYWdnaW5nIGN1cnJlbnRseSBpbiBwcm9ncmVzcyB0aHJvdWdoIGEgbWV0aG9kIGZyb20gb3V0c2lkZS5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjc3RvcERyYWdcclxuICAgICAqIEByZXR1cm4gLSBUaGUgUmVjdCBJbmZvXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIG1vdmVhYmxlLnN0b3BEcmFnKCk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBcInRhcmdldFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBnZXN0byA9IHRoaXMudGFyZ2V0R2VzdG87XHJcbiAgICAgICAgICAgIGlmICgoZ2VzdG8gPT09IG51bGwgfHwgZ2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlc3RvLmlzSWRsZSgpKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHVuc2V0QWJsZXModGhpcywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdlc3RvID09PSBudWxsIHx8IGdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXN0by5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBcImNvbnRyb2xcIikge1xyXG4gICAgICAgICAgICB2YXIgZ2VzdG8gPSB0aGlzLmNvbnRyb2xHZXN0bztcclxuICAgICAgICAgICAgaWYgKChnZXN0byA9PT0gbnVsbCB8fCBnZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VzdG8uaXNJZGxlKCkpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdW5zZXRBYmxlcyh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXN0byA9PT0gbnVsbCB8fCBnZXN0byA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VzdG8uc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHBvczEgPSBfYS5wb3MxLCBwb3MyID0gX2EucG9zMiwgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xyXG4gICAgICAgIHJldHVybiBnZXRBYnNvbHV0ZVJvdGF0aW9uKHBvczEsIHBvczIsIGRpcmVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0IGFibGUgdGhyb3VnaCBhIG1ldGhvZCByYXRoZXIgdGhhbiBhbiBldmVudC5cclxuICAgICAqIEF0IHRoZSBtb21lbnQgb2YgZXhlY3V0aW9uLCByZXF1ZXN0U3RhcnQgaXMgZXhlY3V0ZWQsXHJcbiAgICAgKiBhbmQgdGhlbiByZXF1ZXN0IGFuZCByZXF1ZXN0RW5kIGNhbiBiZSBleGVjdXRlZCB0aHJvdWdoIFJlcXVlc3Rlci5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjcmVxdWVzdFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXlicnVzaC5jb20vbW92ZWFibGUvcmVsZWFzZS9sYXRlc3QvZG9jL01vdmVhYmxlLkRyYWdnYWJsZS5odG1sI3JlcXVlc3R8RHJhZ2dhYmxlIFJlcXVlc3Rlcn1cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5SZXNpemFibGUuaHRtbCNyZXF1ZXN0fFJlc2l6YWJsZSBSZXF1ZXN0ZXJ9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuU2NhbGFibGUuaHRtbCNyZXF1ZXN0fFNjYWxhYmxlIFJlcXVlc3Rlcn1cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGF5YnJ1c2guY29tL21vdmVhYmxlL3JlbGVhc2UvbGF0ZXN0L2RvYy9Nb3ZlYWJsZS5Sb3RhdGFibGUuaHRtbCNyZXF1ZXN0fFJvdGF0YWJsZSBSZXF1ZXN0ZXJ9XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RheWJydXNoLmNvbS9tb3ZlYWJsZS9yZWxlYXNlL2xhdGVzdC9kb2MvTW92ZWFibGUuT3JpZ2luRHJhZ2dhYmxlLmh0bWwjcmVxdWVzdHxPcmlnaW5EcmFnZ2FibGUgUmVxdWVzdGVyfVxyXG4gICAgICogQHBhcmFtIC0gYWJsZU5hbWVcclxuICAgICAqIEBwYXJhbSAtIHJlcXVlc3QgdG8gYmUgYWJsZSBwYXJhbXMuXHJcbiAgICAgKiBAcGFyYW0gLSBJZiBpc0luc3RhbnQgaXMgdHJ1ZSwgcmVxdWVzdCBhbmQgcmVxdWVzdEVuZCBhcmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXHJcbiAgICAgKiBAcmV0dXJuIC0gQWJsZSBSZXF1ZXN0ZXIuIElmIHRoZXJlIGlzIG5vIHJlcXVlc3QgaW4gYWJsZSwgbm90aGluZyB3aWxsIHdvcmsuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICpcclxuICAgICAqIC8vIEluc3RhbnRseSBSZXF1ZXN0IChyZXF1ZXN0U3RhcnQgLSByZXF1ZXN0IC0gcmVxdWVzdEVuZClcclxuICAgICAqIG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIiwgeyBkZWx0YVg6IDEwLCBkZWx0YVk6IDEwIH0sIHRydWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFN0YXJ0IG1vdmVcclxuICAgICAqIGNvbnN0IHJlcXVlc3RlciA9IG1vdmVhYmxlLnJlcXVlc3QoXCJkcmFnZ2FibGVcIik7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdCh7IGRlbHRhWDogMTAsIGRlbHRhWTogMTAgfSk7XHJcbiAgICAgKiByZXF1ZXN0ZXIucmVxdWVzdEVuZCgpO1xyXG4gICAgICovXHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoYWJsZU5hbWUsIHBhcmFtLCBpc0luc3RhbnQpIHtcclxuICAgICAgICBpZiAocGFyYW0gPT09IHZvaWQgMCkgeyBwYXJhbSA9IHt9OyB9XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHNlbGYucHJvcHM7XHJcbiAgICAgICAgdmFyIG1hbmFnZXIgPSBwcm9wcy5wYXJlbnRNb3ZlYWJsZSB8fCBwcm9wcy53cmFwcGVyTW92ZWFibGUgfHwgc2VsZjtcclxuICAgICAgICB2YXIgYWxsQWJsZXMgPSBtYW5hZ2VyLnByb3BzLmFibGVzO1xyXG4gICAgICAgIHZhciBncm91cGFibGUgPSBwcm9wcy5ncm91cGFibGU7XHJcbiAgICAgICAgdmFyIHJlcXVzZXRBYmxlID0gZmluZChhbGxBYmxlcywgZnVuY3Rpb24gKGFibGUpIHsgcmV0dXJuIGFibGUubmFtZSA9PT0gYWJsZU5hbWU7IH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhcmVxdXNldEFibGUgfHwgIXJlcXVzZXRBYmxlLnJlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWJsZVJlcXVlc3RlciA9IHJlcXVzZXRBYmxlLnJlcXVlc3Qoc2VsZik7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RJbnN0YW50ID0gaXNJbnN0YW50IHx8IHBhcmFtLmlzSW5zdGFudDtcclxuICAgICAgICB2YXIgYWJsZVR5cGUgPSBhYmxlUmVxdWVzdGVyLmlzQ29udHJvbCA/IFwiY29udHJvbEFibGVzXCIgOiBcInRhcmdldEFibGVzXCI7XHJcbiAgICAgICAgdmFyIGV2ZW50QWZmaXggPSBcIlwiLmNvbmNhdCgoZ3JvdXBhYmxlID8gXCJHcm91cFwiIDogXCJcIikpLmNvbmNhdChhYmxlUmVxdWVzdGVyLmlzQ29udHJvbCA/IFwiQ29udHJvbFwiIDogXCJcIik7XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlQWJsZXMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobWFuYWdlclthYmxlVHlwZV0pLCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RlciA9IHtcclxuICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24gKGFibGVQYXJhbSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckFibGUoc2VsZiwgbW92ZWFibGVBYmxlcywgW1wiZHJhZ1wiXSwgZXZlbnRBZmZpeCwgXCJcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFibGVSZXF1ZXN0ZXIucmVxdWVzdChhYmxlUGFyYW0pKSwgeyByZXF1ZXN0QWJsZTogYWJsZU5hbWUsIGlzUmVxdWVzdDogdHJ1ZSB9KSwgcmVxdWVzdEluc3RhbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckFibGUoc2VsZiwgbW92ZWFibGVBYmxlcywgW1wiZHJhZ1wiXSwgZXZlbnRBZmZpeCwgXCJFbmRcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFibGVSZXF1ZXN0ZXIucmVxdWVzdEVuZCgpKSwgeyByZXF1ZXN0QWJsZTogYWJsZU5hbWUsIGlzUmVxdWVzdDogdHJ1ZSB9KSwgcmVxdWVzdEluc3RhbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyaWdnZXJBYmxlKHNlbGYsIG1vdmVhYmxlQWJsZXMsIFtcImRyYWdcIl0sIGV2ZW50QWZmaXgsIFwiU3RhcnRcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFibGVSZXF1ZXN0ZXIucmVxdWVzdFN0YXJ0KHBhcmFtKSksIHsgcmVxdWVzdEFibGU6IGFibGVOYW1lLCBpc1JlcXVlc3Q6IHRydWUgfSksIHJlcXVlc3RJbnN0YW50KTtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdEluc3RhbnQgPyByZXF1ZXN0ZXIucmVxdWVzdChwYXJhbSkucmVxdWVzdEVuZCgpIDogcmVxdWVzdGVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogbW92ZWFibGUgaXMgdGhlIHRvcCBsZXZlbCB0aGF0IG1hbmFnZXMgdGFyZ2V0c1xyXG4gICAgICogYFNpbmdsZWA6IE1vdmVhYmxlTWFuYWdlciBpbnN0YW5jZVxyXG4gICAgICogYEdyb3VwYDogTW92ZWFibGVHcm91cCBpbnN0YW5jZVxyXG4gICAgICogYEluZGl2aWR1YWxHcm91cGA6IE1vdmVhYmxlSW5kaXZpZGF1bEdyb3VwIGluc3RhbmNlXHJcbiAgICAgKiBSZXR1cm5zIGxlYWYgdGFyZ2V0IE1vdmVhYmxlTWFuYWdlcnMuXHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0TW92ZWFibGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpc107XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIE1vdmVhYmxlIG9iamVjdCBhbmQgdGhlIGV2ZW50cy5cclxuICAgICAqIEBtZXRob2QgTW92ZWFibGUjZGVzdHJveVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICAgICAqXHJcbiAgICAgKiBtb3ZlYWJsZS5kZXN0cm95KCk7XHJcbiAgICAgKi9cclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVSZW5kZXJQb3NlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHByb3BzLnBhZGRpbmc7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsQmVmb3JlT3JpZ2luID0gc3RhdGUub3JpZ2luYWxCZWZvcmVPcmlnaW4sIHRyYW5zZm9ybU9yaWdpbiA9IHN0YXRlLnRyYW5zZm9ybU9yaWdpbiwgYWxsTWF0cml4ID0gc3RhdGUuYWxsTWF0cml4LCBpczNkID0gc3RhdGUuaXMzZCwgcG9zMSA9IHN0YXRlLnBvczEsIHBvczIgPSBzdGF0ZS5wb3MyLCBwb3MzID0gc3RhdGUucG9zMywgcG9zNCA9IHN0YXRlLnBvczQsIHN0YXRlTGVmdCA9IHN0YXRlLmxlZnQsIHN0YXRlVG9wID0gc3RhdGUudG9wLCBpc1BlcnNpc3RlZCA9IHN0YXRlLmlzUGVyc2lzdGVkO1xyXG4gICAgICAgIHZhciB6b29tID0gcHJvcHMuem9vbSB8fCAxO1xyXG4gICAgICAgIGlmICghcGFkZGluZyAmJiB6b29tIDw9IDEpIHtcclxuICAgICAgICAgICAgc3RhdGUucmVuZGVyUG9zZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBwb3MxLFxyXG4gICAgICAgICAgICAgICAgcG9zMixcclxuICAgICAgICAgICAgICAgIHBvczMsXHJcbiAgICAgICAgICAgICAgICBwb3M0LFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBzdGF0ZS5yZW5kZXJMaW5lcyA9IFtcclxuICAgICAgICAgICAgICAgIFtwb3MxLCBwb3MyXSxcclxuICAgICAgICAgICAgICAgIFtwb3MyLCBwb3M0XSxcclxuICAgICAgICAgICAgICAgIFtwb3M0LCBwb3MzXSxcclxuICAgICAgICAgICAgICAgIFtwb3MzLCBwb3MxXSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBnZXRQYWRkaW5nQm94KHBhZGRpbmcgfHwge30pLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCBib3R0b20gPSBfYS5ib3R0b20sIHJpZ2h0ID0gX2EucmlnaHQ7XHJcbiAgICAgICAgdmFyIG4gPSBpczNkID8gNCA6IDM7XHJcbiAgICAgICAgLy8gY29uc3QgY2xpcFBhdGhJbmZvID0gZ2V0Q2xpcFBhdGgoXHJcbiAgICAgICAgLy8gICAgIHByb3BzLnRhcmdldCxcclxuICAgICAgICAvLyAgICAgb2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgLy8gICAgIG9mZnNldEhlaWdodCxcclxuICAgICAgICAvLyApO1xyXG4gICAgICAgIC8vIGlmIChjbGlwUGF0aEluZm8pIHtcclxuICAgICAgICAvLyAgICAgbGVmdCAtPSBNYXRoLm1heCgwLCBjbGlwUGF0aEluZm8ubGVmdCk7XHJcbiAgICAgICAgLy8gICAgIHRvcCAtPSBNYXRoLm1heCgwLCBjbGlwUGF0aEluZm8udG9wKTtcclxuICAgICAgICAvLyAgICAgYm90dG9tIC09IE1hdGgubWF4KDAsIG9mZnNldEhlaWdodCAtIGNsaXBQYXRoSW5mby5ib3R0b20pO1xyXG4gICAgICAgIC8vICAgICByaWdodCAtPSBNYXRoLm1heCgwLCBvZmZzZXRXaWR0aCAtIGNsaXBQYXRoSW5mby5yaWdodCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHZhciBhYnNvbHV0ZU9yaWdpbiA9IFtdO1xyXG4gICAgICAgIGlmIChpc1BlcnNpc3RlZCkge1xyXG4gICAgICAgICAgICBhYnNvbHV0ZU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250cm9sQm94ICYmIHByb3BzLmdyb3VwYWJsZSkge1xyXG4gICAgICAgICAgICBhYnNvbHV0ZU9yaWdpbiA9IG9yaWdpbmFsQmVmb3JlT3JpZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWJzb2x1dGVPcmlnaW4gPSBwbHVzKG9yaWdpbmFsQmVmb3JlT3JpZ2luLCBbc3RhdGVMZWZ0LCBzdGF0ZVRvcF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dE1hdHJpeCA9IG11bHRpcGxpZXMobiwgY3JlYXRlT3JpZ2luTWF0cml4KGFic29sdXRlT3JpZ2luLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gLXY7IH0pLCBuKSwgYWxsTWF0cml4LCBjcmVhdGVPcmlnaW5NYXRyaXgodHJhbnNmb3JtT3JpZ2luLCBuKSk7XHJcbiAgICAgICAgdmFyIHJlbmRlclBvczEgPSBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczEsIFstbGVmdCwgLXRvcF0sIG4pO1xyXG4gICAgICAgIHZhciByZW5kZXJQb3MyID0gY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MyLCBbcmlnaHQsIC10b3BdLCBuKTtcclxuICAgICAgICB2YXIgcmVuZGVyUG9zMyA9IGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zMywgWy1sZWZ0LCBib3R0b21dLCBuKTtcclxuICAgICAgICB2YXIgcmVuZGVyUG9zNCA9IGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zNCwgW3JpZ2h0LCBib3R0b21dLCBuKTtcclxuICAgICAgICBzdGF0ZS5yZW5kZXJQb3NlcyA9IFtcclxuICAgICAgICAgICAgcmVuZGVyUG9zMSxcclxuICAgICAgICAgICAgcmVuZGVyUG9zMixcclxuICAgICAgICAgICAgcmVuZGVyUG9zMyxcclxuICAgICAgICAgICAgcmVuZGVyUG9zNCxcclxuICAgICAgICBdO1xyXG4gICAgICAgIHN0YXRlLnJlbmRlckxpbmVzID0gW1xyXG4gICAgICAgICAgICBbcmVuZGVyUG9zMSwgcmVuZGVyUG9zMl0sXHJcbiAgICAgICAgICAgIFtyZW5kZXJQb3MyLCByZW5kZXJQb3M0XSxcclxuICAgICAgICAgICAgW3JlbmRlclBvczQsIHJlbmRlclBvczNdLFxyXG4gICAgICAgICAgICBbcmVuZGVyUG9zMywgcmVuZGVyUG9zMV0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAoem9vbSkge1xyXG4gICAgICAgICAgICB2YXIgem9vbU9mZnNldCA9IHpvb20gLyAyO1xyXG4gICAgICAgICAgICBzdGF0ZS5yZW5kZXJMaW5lcyA9IFtcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczEsIFstbGVmdCAtIHpvb21PZmZzZXQsIC10b3BdLCBuKSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczIsIFtyaWdodCArIHpvb21PZmZzZXQsIC10b3BdLCBuKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3MyLCBbcmlnaHQsIC10b3AgLSB6b29tT2Zmc2V0XSwgbiksXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3M0LCBbcmlnaHQsIGJvdHRvbSArIHpvb21PZmZzZXRdLCBuKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlUGFkZGluZyhuZXh0TWF0cml4LCBwb3M0LCBbcmlnaHQgKyB6b29tT2Zmc2V0LCBib3R0b21dLCBuKSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczMsIFstbGVmdCAtIHpvb21PZmZzZXQsIGJvdHRvbV0sIG4pLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVQYWRkaW5nKG5leHRNYXRyaXgsIHBvczMsIFstbGVmdCwgYm90dG9tICsgem9vbU9mZnNldF0sIG4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBhZGRpbmcobmV4dE1hdHJpeCwgcG9zMSwgWy1sZWZ0LCAtdG9wIC0gem9vbU9mZnNldF0sIG4pLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5jaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9pc1Byb3BUYXJnZXRDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdGFyZ2V0ID0gX2EudGFyZ2V0LCBjb250YWluZXIgPSBfYS5jb250YWluZXIsIHBhcmVudE1vdmVhYmxlID0gX2EucGFyZW50TW92ZWFibGU7XHJcbiAgICAgICAgdmFyIF9iID0gdGhpcy5zdGF0ZSwgc3RhdGVUYXJnZXQgPSBfYi50YXJnZXQsIHN0YXRlQ29udGFpbmVyID0gX2IuY29udGFpbmVyO1xyXG4gICAgICAgIGlmICghc3RhdGVUYXJnZXQgJiYgIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQWJsZXMoKTtcclxuICAgICAgICB2YXIgaXNUYXJnZXRDaGFuZ2VkID0gIWVxdWFscyhzdGF0ZVRhcmdldCwgdGFyZ2V0KTtcclxuICAgICAgICB2YXIgaXNDaGFuZ2VkID0gaXNUYXJnZXRDaGFuZ2VkIHx8ICFlcXVhbHMoc3RhdGVDb250YWluZXIsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKCFpc0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW92ZWFibGVDb250YWluZXIgPSBjb250YWluZXIgfHwgdGhpcy5jb250cm9sQm94O1xyXG4gICAgICAgIGlmIChtb3ZlYWJsZUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLnVuc2V0QWJsZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7IHRhcmdldDogdGFyZ2V0LCBjb250YWluZXI6IGNvbnRhaW5lciB9KTtcclxuICAgICAgICBpZiAoIXBhcmVudE1vdmVhYmxlICYmIG1vdmVhYmxlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVjdChcIkVuZFwiLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1Byb3BUYXJnZXRDaGFuZ2VkID0gaXNUYXJnZXRDaGFuZ2VkO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUud2FpdFRvQ2hhbmdlVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoKSB7IH0pO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGUpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXIudHJpZ2dlcihuYW1lLCBlKTtcclxuICAgICAgICBpZiAocHJvcHMucGFyZW50TW92ZWFibGUgJiYgZS5pc1JlcXVlc3QgJiYgIWUuaXNSZXF1ZXN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLnBhcmVudE1vdmVhYmxlLnRyaWdnZXJFdmVudChuYW1lLCBlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gcHJvcHNbbmFtZV07XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXNlQ1NTID0gZnVuY3Rpb24gKHRhZywgY3NzKSB7XHJcbiAgICAgICAgdmFyIGN1c3RvbVN0eWxlTWFwID0gdGhpcy5wcm9wcy5jdXN0b21TdHlsZWRNYXA7XHJcbiAgICAgICAgdmFyIGtleSA9IHRhZyArIGNzcztcclxuICAgICAgICBpZiAoIWN1c3RvbVN0eWxlTWFwW2tleV0pIHtcclxuICAgICAgICAgICAgY3VzdG9tU3R5bGVNYXBba2V5XSA9IHN0eWxlZCh0YWcsIGNzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXN0b21TdHlsZU1hcFtrZXldO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKHByb3BzLnRhcmdldCB8fCAoKF9hID0gcHJvcHMudGFyZ2V0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzRmlyc3RUYXJnZXQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFzQ29udHJvbEJveCA9IHRoaXMuY29udHJvbEJveDtcclxuICAgICAgICB2YXIgcGVyc2lzdERhdGEgPSBwcm9wcy5wZXJzaXN0RGF0YTtcclxuICAgICAgICB2YXIgZmlyc3RSZW5kZXJTdGF0ZSA9IHByb3BzLmZpcnN0UmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGZpcnN0UmVuZGVyU3RhdGUgJiYgIWhhc0NvbnRyb2xCb3gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0UmVuZGVyU3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faGFzRmlyc3RUYXJnZXQgJiYgcGVyc2lzdERhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHBlcnNpc3RTdGF0ZSA9IGdldFBlcnNpc3RTdGF0ZShwZXJzaXN0RGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChwZXJzaXN0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUocGVyc2lzdFN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlLmlzUGVyc2lzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLnVuc2V0QWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnRhcmdldEFibGVzLmZvckVhY2goZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGFibGUudW5zZXQpIHtcclxuICAgICAgICAgICAgICAgIGFibGUudW5zZXQoX3RoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVBYmxlcyA9IGZ1bmN0aW9uIChhYmxlcywgZXZlbnRBZmZpeCkge1xyXG4gICAgICAgIGlmIChhYmxlcyA9PT0gdm9pZCAwKSB7IGFibGVzID0gdGhpcy5wcm9wcy5hYmxlczsgfVxyXG4gICAgICAgIGlmIChldmVudEFmZml4ID09PSB2b2lkIDApIHsgZXZlbnRBZmZpeCA9IFwiXCI7IH1cclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSA9IHByb3BzLnRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5O1xyXG4gICAgICAgIHZhciBlbmFibGVkQWJsZXMgPSB0aGlzLmdldEVuYWJsZWRBYmxlcyhhYmxlcyk7XHJcbiAgICAgICAgdmFyIGRyYWdTdGFydCA9IFwiZHJhZ1wiLmNvbmNhdChldmVudEFmZml4LCBcIlN0YXJ0XCIpO1xyXG4gICAgICAgIHZhciBwaW5jaFN0YXJ0ID0gXCJwaW5jaFwiLmNvbmNhdChldmVudEFmZml4LCBcIlN0YXJ0XCIpO1xyXG4gICAgICAgIHZhciBkcmFnQ29udHJvbFN0YXJ0ID0gXCJkcmFnXCIuY29uY2F0KGV2ZW50QWZmaXgsIFwiQ29udHJvbFN0YXJ0XCIpO1xyXG4gICAgICAgIHZhciB0YXJnZXRBYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2RyYWdTdGFydCwgcGluY2hTdGFydF0sIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5KTtcclxuICAgICAgICB2YXIgY29udHJvbEFibGVzID0gZmlsdGVyQWJsZXMoZW5hYmxlZEFibGVzLCBbZHJhZ0NvbnRyb2xTdGFydF0sIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5KTtcclxuICAgICAgICB0aGlzLmVuYWJsZWRBYmxlcyA9IGVuYWJsZWRBYmxlcztcclxuICAgICAgICB0aGlzLnRhcmdldEFibGVzID0gdGFyZ2V0QWJsZXM7XHJcbiAgICAgICAgdGhpcy5jb250cm9sQWJsZXMgPSBjb250cm9sQWJsZXM7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIChuZXh0U3RhdGUsIGlzU2V0U3RhdGUpIHtcclxuICAgICAgICBpZiAoaXNTZXRTdGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMyBpbiBuZXh0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlW25hbWVfM10gPSBuZXh0U3RhdGVbbmFtZV8zXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLmdldEVuYWJsZWRBYmxlcyA9IGZ1bmN0aW9uIChhYmxlcykge1xyXG4gICAgICAgIGlmIChhYmxlcyA9PT0gdm9pZCAwKSB7IGFibGVzID0gdGhpcy5wcm9wcy5hYmxlczsgfVxyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIGFibGVzLmZpbHRlcihmdW5jdGlvbiAoYWJsZSkgeyByZXR1cm4gYWJsZSAmJiAoKGFibGUuYWx3YXlzICYmIHByb3BzW2FibGUubmFtZV0gIT09IGZhbHNlKVxyXG4gICAgICAgICAgICB8fCBwcm9wc1thYmxlLm5hbWVdKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXJBYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5ID0gcHJvcHMudHJpZ2dlckFibGVzU2ltdWx0YW5lb3VzbHk7XHJcbiAgICAgICAgdmFyIFJlbmRlcmVyID0ge1xyXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHt9O1xyXG4gICAgICAgIHJldHVybiBncm91cEJ5TWFwKGZsYXQoZmlsdGVyQWJsZXModGhpcy5nZXRFbmFibGVkQWJsZXMoKSwgW1wicmVuZGVyXCJdLCB0cmlnZ2VyQWJsZXNTaW11bHRhbmVvdXNseSkubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gX2EucmVuZGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKF90aGlzLCBSZW5kZXJlcikgfHwgW107XHJcbiAgICAgICAgfSkpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsOyB9KSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXk7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChncm91cCkgeyByZXR1cm4gZ3JvdXBbMF07IH0pO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQ2hlY2tJbnB1dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRhcmdldEdlc3RvICYmICh0aGlzLnRhcmdldEdlc3RvLm9wdGlvbnMuY2hlY2tJbnB1dCA9IHRoaXMucHJvcHMuY2hlY2tJbnB1dCk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0UmVxdWVzdFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3R5bGVOYW1lcyA9IHRoaXMuZ2V0RW5hYmxlZEFibGVzKCkucmVkdWNlKGZ1bmN0aW9uIChuYW1lcywgYWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICB2YXIgYWJsZVN0eWxlTmFtZXMgPSAoKF9iID0gKF9hID0gYWJsZS5yZXF1ZXN0U3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFibGUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuYW1lcyksIGZhbHNlKSwgX19yZWFkKGFibGVTdHlsZU5hbWVzKSwgZmFsc2UpO1xyXG4gICAgICAgIH0sIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCgodGhpcy5wcm9wcy5yZXF1ZXN0U3R5bGVzIHx8IFtdKSksIGZhbHNlKSk7XHJcbiAgICAgICAgcmV0dXJuIHN0eWxlTmFtZXM7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVzaXplT2JzZXJ2ZXIocHJldlByb3BzKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVNdXRhdGlvbk9ic2VydmVyKHByZXZQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoYXNUYXJnZXRBYmxlID0gdGhpcy50YXJnZXRBYmxlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGhhc0NvbnRyb2xBYmxlID0gdGhpcy5jb250cm9sQWJsZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9kcmFnVGFyZ2V0O1xyXG4gICAgICAgIHZhciBpc1Vuc2V0ID0gKCFoYXNUYXJnZXRBYmxlICYmIHRoaXMudGFyZ2V0R2VzdG8pXHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2lzVGFyZ2V0Q2hhbmdlZCh0cnVlKTtcclxuICAgICAgICBpZiAoaXNVbnNldCkge1xyXG4gICAgICAgICAgICB1bnNldEdlc3RvKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7IGdlc3Rvczoge30gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaGFzQ29udHJvbEFibGUpIHtcclxuICAgICAgICAgICAgdW5zZXRHZXN0byh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCAmJiBoYXNUYXJnZXRBYmxlICYmICF0aGlzLnRhcmdldEdlc3RvKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0R2VzdG8gPSBnZXRUYXJnZXRBYmxlR2VzdG8odGhpcywgdGFyZ2V0LCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xHZXN0byAmJiBoYXNDb250cm9sQWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xHZXN0byA9IGdldENvbnRyb2xBYmxlR2VzdG8odGhpcywgXCJDb250cm9sXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl91cGRhdGVUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdGhpcy5fcHJldlByb3BUYXJnZXQgPSB0aGlzLl9wcm9wVGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX3ByZXZEcmFnVGFyZ2V0ID0gdGhpcy5fZHJhZ1RhcmdldDtcclxuICAgICAgICB0aGlzLl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0ID0gdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX3ByZXZEcmFnQXJlYSA9IHByb3BzLmRyYWdBcmVhO1xyXG4gICAgICAgIHRoaXMuX3Byb3BUYXJnZXQgPSBwcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldCB8fCBwcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fZHJhZ1RhcmdldCA9IGdldFJlZlRhcmdldCh0aGlzLl9vcmlnaW5hbERyYWdUYXJnZXQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX3JlbmRlckxpbmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIF9hID0gcHJvcHMsIHpvb20gPSBfYS56b29tLCBoaWRlRGVmYXVsdExpbmVzID0gX2EuaGlkZURlZmF1bHRMaW5lcywgaGlkZUNoaWxkTW92ZWFibGVEZWZhdWx0TGluZXMgPSBfYS5oaWRlQ2hpbGRNb3ZlYWJsZURlZmF1bHRMaW5lcywgcGFyZW50TW92ZWFibGUgPSBfYS5wYXJlbnRNb3ZlYWJsZTtcclxuICAgICAgICBpZiAoaGlkZURlZmF1bHRMaW5lcyB8fCAocGFyZW50TW92ZWFibGUgJiYgaGlkZUNoaWxkTW92ZWFibGVEZWZhdWx0TGluZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBSZW5kZXJlciA9IHtcclxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBzdGF0ZS5yZW5kZXJMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlckxpbmUoUmVuZGVyZXIsIFwiXCIsIGxpbmVbMF0sIGxpbmVbMV0sIHpvb20sIFwicmVuZGVyLWxpbmUtXCIuY29uY2F0KGkpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl9pc1RhcmdldENoYW5nZWQgPSBmdW5jdGlvbiAodXNlRHJhZ0FyZWEpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBuZXh0VGFyZ2V0ID0gcHJvcHMuZHJhZ1RhcmdldCB8fCBwcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgdmFyIHByZXZUYXJnZXQgPSB0aGlzLl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0O1xyXG4gICAgICAgIHZhciBwcmV2RHJhZ0FyZWEgPSB0aGlzLl9wcmV2RHJhZ0FyZWE7XHJcbiAgICAgICAgdmFyIGRyYWdBcmVhID0gcHJvcHMuZHJhZ0FyZWE7XHJcbiAgICAgICAgLy8gY2hlY2sgdGFyZ2V0IHdpdGhvdXQgZHJhZ0FyZWFcclxuICAgICAgICB2YXIgaXNEcmFnVGFyZ2V0Q2hhbmdlZCA9ICFkcmFnQXJlYSAmJiBwcmV2VGFyZ2V0ICE9PSBuZXh0VGFyZ2V0O1xyXG4gICAgICAgIHZhciBpc0RyYWdBcmVhQ2hhbmdlZCA9ICh1c2VEcmFnQXJlYSB8fCBkcmFnQXJlYSkgJiYgcHJldkRyYWdBcmVhICE9PSBkcmFnQXJlYTtcclxuICAgICAgICByZXR1cm4gaXNEcmFnVGFyZ2V0Q2hhbmdlZCB8fCBpc0RyYWdBcmVhQ2hhbmdlZCB8fCB0aGlzLl9wcmV2UHJvcFRhcmdldCAhPSB0aGlzLl9wcm9wVGFyZ2V0O1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX3VwZGF0ZU5hdGl2ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHByb3BzLmRyYWdBcmVhID8gdGhpcy5hcmVhRWxlbWVudCA6IHRoaXMuc3RhdGUudGFyZ2V0O1xyXG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICB2YXIgZXZlbnRLZXlzID0gZ2V0S2V5cyhldmVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1RhcmdldENoYW5nZWQoKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFuYWdlciA9IGV2ZW50c1tldmVudE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlciAmJiBtYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbmFibGVkQWJsZXMgPSB0aGlzLmVuYWJsZWRBYmxlcztcclxuICAgICAgICBldmVudEtleXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBhYmxlcyA9IGZpbHRlckFibGVzKGVuYWJsZWRBYmxlcywgW2V2ZW50TmFtZV0pO1xyXG4gICAgICAgICAgICB2YXIgaGFzQWJsZXMgPSBhYmxlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICB2YXIgbWFuYWdlciA9IGV2ZW50c1tldmVudE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0FibGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKHRhcmdldCwgX3RoaXMsIGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IG1hbmFnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFuYWdlci5zZXRBYmxlcyhhYmxlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fY2hlY2tVcGRhdGVSb290Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb290Q29udGFpbmVyID0gdGhpcy5wcm9wcy5yb290Q29udGFpbmVyO1xyXG4gICAgICAgIGlmICghdGhpcy5fcm9vdENvbnRhaW5lciAmJiByb290Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb250YWluZXIgPSBnZXRSZWZUYXJnZXQocm9vdENvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX2NoZWNrVXBkYXRlVmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lck9wdGlvbiA9IHRoaXMucHJvcHMudmlld0NvbnRhaW5lcjtcclxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdDb250YWluZXIgJiYgdmlld0NvbnRhaW5lck9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyID0gZ2V0UmVmVGFyZ2V0KHZpZXdDb250YWluZXJPcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHRoaXMuX3ZpZXdDb250YWluZXI7XHJcbiAgICAgICAgaWYgKHZpZXdDb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQWJsZVZpZXdDbGFzc05hbWVzKF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRoaXMuX2dldEFibGVWaWV3Q2xhc3NOYW1lcygpKSwgZmFsc2UpLCBbXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcoKSA/IFZJRVdfRFJBR0dJTkcgOiBcIlwiLFxyXG4gICAgICAgICAgICBdLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl9jaGFuZ2VBYmxlVmlld0NsYXNzTmFtZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lcykge1xyXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVyID0gdGhpcy5fdmlld0NvbnRhaW5lcjtcclxuICAgICAgICB2YXIgbmV4dENsYXNzTmFtZXMgPSBncm91cEJ5KGNsYXNzTmFtZXMuZmlsdGVyKEJvb2xlYW4pLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsOyB9KS5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMSksIGNsYXNzTmFtZSA9IF9iWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwcmV2Q2xhc3NOYW1lcyA9IHRoaXMuX3ZpZXdDbGFzc05hbWVzO1xyXG4gICAgICAgIHZhciBfYSA9IGRpZmYkMShwcmV2Q2xhc3NOYW1lcywgbmV4dENsYXNzTmFtZXMpLCByZW1vdmVkID0gX2EucmVtb3ZlZCwgYWRkZWQgPSBfYS5hZGRlZDtcclxuICAgICAgICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHZpZXdDb250YWluZXIsIHByZXZDbGFzc05hbWVzW2luZGV4XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgYWRkQ2xhc3Modmlld0NvbnRhaW5lciwgbmV4dENsYXNzTmFtZXNbaW5kZXhdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl92aWV3Q2xhc3NOYW1lcyA9IG5leHRDbGFzc05hbWVzO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX2dldEFibGVWaWV3Q2xhc3NOYW1lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXRFbmFibGVkQWJsZXMoKS5tYXAoZnVuY3Rpb24gKGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gKCgoX2EgPSBhYmxlLnZpZXdDbGFzc05hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFibGUsIF90aGlzKSkgfHwgXCJcIik7XHJcbiAgICAgICAgfSkuam9pbihcIiBcIikgKyBcIiBcIi5jb25jYXQodGhpcy5fZ2V0QWJsZUNsYXNzTmFtZShcIi12aWV3XCIpKSkuc3BsaXQoL1xccysvZyk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLnByb3RvdHlwZS5fZ2V0QWJsZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChjbGFzc1ByZWZpeCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNsYXNzUHJlZml4ID09PSB2b2lkIDApIHsgY2xhc3NQcmVmaXggPSBcIlwiOyB9XHJcbiAgICAgICAgdmFyIGFibGVzID0gdGhpcy5nZXRFbmFibGVkQWJsZXMoKTtcclxuICAgICAgICB2YXIgdGFyZ2V0R2VzdG8gPSB0aGlzLnRhcmdldEdlc3RvO1xyXG4gICAgICAgIHZhciBjb250cm9sR2VzdG8gPSB0aGlzLmNvbnRyb2xHZXN0bztcclxuICAgICAgICB2YXIgdGFyZ2V0R2VzdG9EYXRhID0gKHRhcmdldEdlc3RvID09PSBudWxsIHx8IHRhcmdldEdlc3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRHZXN0by5pc0ZsYWcoKSlcclxuICAgICAgICAgICAgPyB0YXJnZXRHZXN0by5nZXRFdmVudERhdGEoKSA6IHt9O1xyXG4gICAgICAgIHZhciBjb250cm9sR2VzdG9EYXRhID0gKGNvbnRyb2xHZXN0byA9PT0gbnVsbCB8fCBjb250cm9sR2VzdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRyb2xHZXN0by5pc0ZsYWcoKSlcclxuICAgICAgICAgICAgPyBjb250cm9sR2VzdG8uZ2V0RXZlbnREYXRhKCkgOiB7fTtcclxuICAgICAgICByZXR1cm4gYWJsZXMubWFwKGZ1bmN0aW9uIChhYmxlKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFibGUubmFtZTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICgoX2EgPSBhYmxlLmNsYXNzTmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWJsZSwgX3RoaXMpKSB8fCBcIlwiO1xyXG4gICAgICAgICAgICBpZiAoKChfYiA9IHRhcmdldEdlc3RvRGF0YVtuYW1lXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlzRXZlbnRTdGFydClcclxuICAgICAgICAgICAgICAgIHx8ICgoX2MgPSBjb250cm9sR2VzdG9EYXRhW25hbWVdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaXNFdmVudFN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IFwiIFwiLmNvbmNhdChwcmVmaXgoXCJcIi5jb25jYXQobmFtZSkuY29uY2F0KGNsYXNzUHJlZml4LCBcIi1kcmFnZ2luZ1wiKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWUudHJpbSgpO1xyXG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZU1hbmFnZXIucHJvdG90eXBlLl91cGRhdGVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHZhciB3aW4gPSBnZXRXaW5kb3codGhpcy5nZXRDb250cm9sQm94RWxlbWVudCgpKTtcclxuICAgICAgICBpZiAoIXdpbi5SZXNpemVPYnNlcnZlciB8fCAhdGFyZ2V0IHx8ICFwcm9wcy51c2VSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9yZWlzemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlByb3BzLnRhcmdldCA9PT0gdGFyZ2V0ICYmIHRoaXMuX3JlaXN6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IHdpbi5SZXNpemVPYnNlcnZlcih0aGlzLmNoZWNrVXBkYXRlUmVjdCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcclxuICAgICAgICAgICAgYm94OiBcImJvcmRlci1ib3hcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZWlzemVPYnNlcnZlciA9IG9ic2VydmVyO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlTWFuYWdlci5wcm90b3R5cGUuX3VwZGF0ZU11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHZhciB3aW4gPSBnZXRXaW5kb3codGhpcy5nZXRDb250cm9sQm94RWxlbWVudCgpKTtcclxuICAgICAgICBpZiAoIXdpbi5NdXRhdGlvbk9ic2VydmVyIHx8ICF0YXJnZXQgfHwgIXByb3BzLnVzZU11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5fbXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlByb3BzLnRhcmdldCA9PT0gdGFyZ2V0ICYmIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgd2luLk11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKHJlY29yZHMpIHtcclxuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByZWNvcmRzXzEgPSBfX3ZhbHVlcyhyZWNvcmRzKSwgcmVjb3Jkc18xXzEgPSByZWNvcmRzXzEubmV4dCgpOyAhcmVjb3Jkc18xXzEuZG9uZTsgcmVjb3Jkc18xXzEgPSByZWNvcmRzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gcmVjb3Jkc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmIG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwic3R5bGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGVja1VwZGF0ZVJlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzXzFfMSAmJiAhcmVjb3Jkc18xXzEuZG9uZSAmJiAoX2EgPSByZWNvcmRzXzEucmV0dXJuKSkgX2EuY2FsbChyZWNvcmRzXzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVNYW5hZ2VyLmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBkcmFnVGFyZ2V0U2VsZjogZmFsc2UsXHJcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICAgIGRyYWdUYXJnZXQ6IG51bGwsXHJcbiAgICAgICAgY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgIHJvb3RDb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgb3JpZ2luOiB0cnVlLFxyXG4gICAgICAgIHBhcmVudE1vdmVhYmxlOiBudWxsLFxyXG4gICAgICAgIHdyYXBwZXJNb3ZlYWJsZTogbnVsbCxcclxuICAgICAgICBpc1dyYXBwZXJNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBwYXJlbnRQb3NpdGlvbjogbnVsbCxcclxuICAgICAgICB3YXJwU2VsZjogZmFsc2UsXHJcbiAgICAgICAgc3ZnT3JpZ2luOiBcIlwiLFxyXG4gICAgICAgIGRyYWdDb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgdXNlUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICAgIHVzZU11dGF0aW9uT2JzZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxyXG4gICAgICAgIHByZXZlbnRSaWdodENsaWNrOiB0cnVlLFxyXG4gICAgICAgIHByZXZlbnRXaGVlbENsaWNrOiB0cnVlLFxyXG4gICAgICAgIGxpbmVQYWRkaW5nOiAwLFxyXG4gICAgICAgIGNvbnRyb2xQYWRkaW5nOiAwLFxyXG4gICAgICAgIGFibGVzOiBbXSxcclxuICAgICAgICBwaW5jaFRocmVzaG9sZDogMjAsXHJcbiAgICAgICAgZHJhZ0FyZWE6IGZhbHNlLFxyXG4gICAgICAgIHBhc3NEcmFnQXJlYTogZmFsc2UsXHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIlwiLFxyXG4gICAgICAgIGNsYXNzTmFtZTogXCJcIixcclxuICAgICAgICB6b29tOiAxLFxyXG4gICAgICAgIHRyaWdnZXJBYmxlc1NpbXVsdGFuZW91c2x5OiBmYWxzZSxcclxuICAgICAgICBwYWRkaW5nOiB7fSxcclxuICAgICAgICBwaW5jaE91dHNpZGU6IHRydWUsXHJcbiAgICAgICAgY2hlY2tJbnB1dDogZmFsc2UsXHJcbiAgICAgICAgZHJhZ0ZvY3VzZWRJbnB1dDogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXBhYmxlOiBmYWxzZSxcclxuICAgICAgICBoaWRlRGVmYXVsdExpbmVzOiBmYWxzZSxcclxuICAgICAgICBjc3BOb25jZTogXCJcIixcclxuICAgICAgICB0cmFuc2xhdGVaOiAwLFxyXG4gICAgICAgIGNzc1N0eWxlZDogbnVsbCxcclxuICAgICAgICBjdXN0b21TdHlsZWRNYXA6IHt9LFxyXG4gICAgICAgIHByb3BzOiB7fSxcclxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxyXG4gICAgICAgIHByZXZlbnRDbGlja0RlZmF1bHQ6IGZhbHNlLFxyXG4gICAgICAgIHByZXZlbnRDbGlja0V2ZW50T25EcmFnOiB0cnVlLFxyXG4gICAgICAgIGZsdXNoU3luYzogZGVmYXVsdFN5bmMsXHJcbiAgICAgICAgZmlyc3RSZW5kZXJTdGF0ZTogbnVsbCxcclxuICAgICAgICBwZXJzaXN0RGF0YTogbnVsbCxcclxuICAgICAgICB2aWV3Q29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgIHJlcXVlc3RTdHlsZXM6IFtdLFxyXG4gICAgICAgIHVzZUFjY3VyYXRlUG9zaXRpb246IGZhbHNlLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBNb3ZlYWJsZU1hbmFnZXI7XHJcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCkpO1xyXG4vKipcclxuICogVGhlIHRhcmdldCB0byBpbmRpY2F0ZSBNb3ZlYWJsZSBDb250cm9sIEJveC5cclxuICogQG5hbWUgTW92ZWFibGUjdGFyZ2V0XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSk7XHJcbiAqIG1vdmVhYmxlLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpO1xyXG4gKi9cclxuLyoqXHJcbiAqIFpvb21zIGluIHRoZSBlbGVtZW50cyBvZiBhIG1vdmVhYmxlLlxyXG4gKiBAbmFtZSBNb3ZlYWJsZSN6b29tXHJcbiAqIEBkZWZhdWx0IDFcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICogbW92ZWFibGUuem9vbSA9IDI7XHJcbiAqL1xyXG4vKipcclxuICogV2hldGhlciB0aGUgdGFyZ2V0IHNpemUgaXMgZGV0ZWN0ZWQgYW5kIHVwZGF0ZWQgd2hlbmV2ZXIgaXQgY2hhbmdlcy5cclxuICogQG5hbWUgTW92ZWFibGUjdXNlUmVzaXplT2JzZXJ2ZXJcclxuICogQGRlZmF1bHQgZmFsc2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICogbW92ZWFibGUudXNlUmVzaXplT2JzZXJ2ZXIgPSB0cnVlO1xyXG4gKi9cclxuLyoqXHJcbiAqIFJlc2l6ZSwgU2NhbGUgRXZlbnRzIGF0IGVkZ2VzXHJcbiAqIEBuYW1lIE1vdmVhYmxlI2VkZ2VcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5KTtcclxuICogbW92ZWFibGUuZWRnZSA9IHRydWU7XHJcbiAqL1xyXG4vKipcclxuICogWW91IGNhbiBzcGVjaWZ5IHRoZSBjbGFzc05hbWUgb2YgdGhlIG1vdmVhYmxlIGNvbnRyb2xib3guXHJcbiAqIEBuYW1lIE1vdmVhYmxlI2NsYXNzTmFtZVxyXG4gKiBAZGVmYXVsdCBcIlwiXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgIGNsYXNzTmFtZTogXCJcIixcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmNsYXNzTmFtZSA9IFwibW92ZWFibGUxXCI7XHJcbiAqL1xyXG4vKipcclxuICogVGhlIHRhcmdldChzKSB0byBkcmFnIE1vdmVhYmxlIHRhcmdldChzKVxyXG4gKiBAbmFtZSBNb3ZlYWJsZSNkcmFnVGFyZ2V0XHJcbiAqIEBkZWZhdWx0IHRhcmdldFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHkpO1xyXG4gKiBtb3ZlYWJsZS50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKTtcclxuICogbW92ZWFibGUuZHJhZ1RhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZHJhZ1RhcmdldFwiKTtcclxuICovXHJcbi8qKlxyXG4gKiBgcmVuZGVyU3RhcnRgIGV2ZW50IG9jY3VycyBhdCB0aGUgZmlyc3Qgc3RhcnQgb2YgYWxsIGV2ZW50cy5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBldmVudCByZW5kZXJTdGFydFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJTdGFydGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZW5kZXJTdGFydFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlclN0YXJ0XCIsIHRhcmdldCk7XHJcbiAqIH0pO1xyXG4gKi9cclxuLyoqXHJcbiAqIGByZW5kZXJgIGV2ZW50IG9jY3VycyBiZWZvcmUgdGhlIHRhcmdldCBpcyBkcmF3biBvbiB0aGUgc2NyZWVuLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGV2ZW50IHJlbmRlclxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlclwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlclwiLCB0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBgcmVuZGVyRW5kYCBldmVudCBvY2N1cnMgYXQgdGhlIGVuZCBvZiBhbGwgZXZlbnRzLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGV2ZW50IHJlbmRlckVuZFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyRW5kfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgcmVuZGVyRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi50YXJnZXRcIiksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlckVuZFwiLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckVuZFwiLCB0YXJnZXQpO1xyXG4gKiB9KTtcclxuICovXHJcbi8qKlxyXG4gKiBgcmVuZGVyR3JvdXBTdGFydGAgZXZlbnQgb2NjdXJzIGF0IHRoZSBmaXJzdCBzdGFydCBvZiBhbGwgZXZlbnRzIGluIGdyb3VwLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGV2ZW50IHJlbmRlckdyb3VwU3RhcnRcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PblJlbmRlckdyb3VwU3RhcnR9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cFN0YXJ0YCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlckdyb3VwU3RhcnRcIiwgKHsgdGFyZ2V0cyB9KSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uUmVuZGVyR3JvdXBTdGFydFwiLCB0YXJnZXRzKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogYHJlbmRlckdyb3VwYCBldmVudCBvY2N1cnMgYmVmb3JlIHRoZSB0YXJnZXQgaXMgZHJhd24gb24gdGhlIHNjcmVlbiBpbiBncm91cC5cclxuICogQG1lbWJlcm9mIE1vdmVhYmxlXHJcbiAqIEBldmVudCByZW5kZXJHcm91cFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uUmVuZGVyR3JvdXB9IC0gUGFyYW1ldGVycyBmb3IgdGhlIGByZW5kZXJHcm91cGAgZXZlbnRcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICAgICB0YXJnZXQ6IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIikpLFxyXG4gKiB9KTtcclxuICogbW92ZWFibGUub24oXCJyZW5kZXJHcm91cFwiLCAoeyB0YXJnZXRzIH0pID0+IHtcclxuICogICAgIGNvbnNvbGUubG9nKFwib25SZW5kZXJHcm91cFwiLCB0YXJnZXRzKTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogYHJlbmRlckdyb3VwRW5kYCBldmVudCBvY2N1cnMgYXQgdGhlIGVuZCBvZiBhbGwgZXZlbnRzIGluIGdyb3VwLlxyXG4gKiBAbWVtYmVyb2YgTW92ZWFibGVcclxuICogQGV2ZW50IHJlbmRlckdyb3VwRW5kXHJcbiAqIEBwYXJhbSB7TW92ZWFibGUuT25SZW5kZXJHcm91cEVuZH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYHJlbmRlckdyb3VwRW5kYCBldmVudFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAqXHJcbiAqIGNvbnN0IG1vdmVhYmxlID0gbmV3IE1vdmVhYmxlKGRvY3VtZW50LmJvZHksIHtcclxuICogICAgIHRhcmdldDogW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhcmdldFwiKSksXHJcbiAqIH0pO1xyXG4gKiBtb3ZlYWJsZS5vbihcInJlbmRlckdyb3VwRW5kXCIsICh7IHRhcmdldHMgfSkgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJvblJlbmRlckdyb3VwRW5kXCIsIHRhcmdldHMpO1xyXG4gKiB9KTtcclxuICovXG5cbnZhciBHcm91cGFibGUgPSB7XHJcbiAgICBuYW1lOiBcImdyb3VwYWJsZVwiLFxyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcImRlZmF1bHRHcm91cFJvdGF0ZVwiLFxyXG4gICAgICAgIFwidXNlRGVmYXVsdEdyb3VwUm90YXRlXCIsXHJcbiAgICAgICAgXCJkZWZhdWx0R3JvdXBPcmlnaW5cIixcclxuICAgICAgICBcImdyb3VwYWJsZVwiLFxyXG4gICAgICAgIFwiZ3JvdXBhYmxlUHJvcHNcIixcclxuICAgICAgICBcInRhcmdldEdyb3Vwc1wiLFxyXG4gICAgICAgIFwiaGlkZUNoaWxkTW92ZWFibGVEZWZhdWx0TGluZXNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtdLFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAobW92ZWFibGUsIFJlYWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IG1vdmVhYmxlLnByb3BzO1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gcHJvcHMudGFyZ2V0cyB8fCBbXTtcclxuICAgICAgICB2YXIgX2IgPSBtb3ZlYWJsZS5nZXRTdGF0ZSgpLCBsZWZ0ID0gX2IubGVmdCwgdG9wID0gX2IudG9wLCBpc1BlcnNpc3RlZCA9IF9iLmlzUGVyc2lzdGVkO1xyXG4gICAgICAgIHZhciB6b29tID0gcHJvcHMuem9vbSB8fCAxO1xyXG4gICAgICAgIHZhciByZW5kZXJHcm91cFJlY3RzID0gbW92ZWFibGUucmVuZGVyR3JvdXBSZWN0cztcclxuICAgICAgICB2YXIgcGVyc2lzdERhdENoaWxkcmVuID0gKChfYSA9IHByb3BzLnBlcnNpc3REYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2hpbGRyZW4pIHx8IFtdO1xyXG4gICAgICAgIGlmIChpc1BlcnNpc3RlZCkge1xyXG4gICAgICAgICAgICB0YXJnZXRzID0gcGVyc2lzdERhdENoaWxkcmVuLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBlcnNpc3REYXRDaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50UG9zaXRpb24gPSB3YXRjaFZhbHVlKG1vdmVhYmxlLCBcInBhcmVudFBvc2l0aW9uXCIsIFtsZWZ0LCB0b3BdLCBmdW5jdGlvbiAoc3R5bGVzKSB7IHJldHVybiBzdHlsZXMuam9pbihcIixcIik7IH0pO1xyXG4gICAgICAgIHZhciByZXF1ZXN0U3R5bGVzID0gd2F0Y2hWYWx1ZShtb3ZlYWJsZSwgXCJyZXF1ZXN0U3R5bGVzXCIsIG1vdmVhYmxlLmdldFJlcXVlc3RDaGlsZFN0eWxlcygpLCBmdW5jdGlvbiAoc3R5bGVzKSB7IHJldHVybiBzdHlsZXMuam9pbihcIixcIik7IH0pO1xyXG4gICAgICAgIG1vdmVhYmxlLm1vdmVhYmxlcyA9IG1vdmVhYmxlLm1vdmVhYmxlcy5zbGljZSgwLCB0YXJnZXRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRhcmdldHMubWFwKGZ1bmN0aW9uICh0YXJnZXQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW92ZWFibGVNYW5hZ2VyLCB7IGtleTogXCJtb3ZlYWJsZVwiICsgaSwgcmVmOiByZWZzKG1vdmVhYmxlLCBcIm1vdmVhYmxlc1wiLCBpKSwgdGFyZ2V0OiB0YXJnZXQsIG9yaWdpbjogZmFsc2UsIHJlcXVlc3RTdHlsZXM6IHJlcXVlc3RTdHlsZXMsIGNzc1N0eWxlZDogcHJvcHMuY3NzU3R5bGVkLCBjdXN0b21TdHlsZWRNYXA6IHByb3BzLmN1c3RvbVN0eWxlZE1hcCwgdXNlUmVzaXplT2JzZXJ2ZXI6IHByb3BzLnVzZVJlc2l6ZU9ic2VydmVyLCB1c2VNdXRhdGlvbk9ic2VydmVyOiBwcm9wcy51c2VNdXRhdGlvbk9ic2VydmVyLCBoaWRlQ2hpbGRNb3ZlYWJsZURlZmF1bHRMaW5lczogcHJvcHMuaGlkZUNoaWxkTW92ZWFibGVEZWZhdWx0TGluZXMsIHBhcmVudE1vdmVhYmxlOiBtb3ZlYWJsZSwgcGFyZW50UG9zaXRpb246IFtsZWZ0LCB0b3BdLCBwZXJzaXN0RGF0YTogcGVyc2lzdERhdENoaWxkcmVuW2ldLCB6b29tOiB6b29tIH0pO1xyXG4gICAgICAgIH0pKSwgZmFsc2UpLCBfX3JlYWQoZmxhdChyZW5kZXJHcm91cFJlY3RzLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcclxuICAgICAgICAgICAgdmFyIHBvczEgPSBfYS5wb3MxLCBwb3MyID0gX2EucG9zMiwgcG9zMyA9IF9hLnBvczMsIHBvczQgPSBfYS5wb3M0O1xyXG4gICAgICAgICAgICB2YXIgcG9zZXMgPSBbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF07XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBbMCwgMV0sXHJcbiAgICAgICAgICAgICAgICBbMSwgM10sXHJcbiAgICAgICAgICAgICAgICBbMywgMl0sXHJcbiAgICAgICAgICAgICAgICBbMiwgMF0sXHJcbiAgICAgICAgICAgIF0ubWFwKGZ1bmN0aW9uIChfYSwgaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgZnJvbSA9IF9iWzBdLCB0byA9IF9iWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckxpbmUoUmVhY3QsIFwiXCIsIG1pbnVzKHBvc2VzW2Zyb21dLCBwYXJlbnRQb3NpdGlvbiksIG1pbnVzKHBvc2VzW3RvXSwgcGFyZW50UG9zaXRpb24pLCB6b29tLCBcImdyb3VwLXJlY3QtXCIuY29uY2F0KGksIFwiLVwiKS5jb25jYXQoaikpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSkpLCBmYWxzZSk7XHJcbiAgICB9LFxyXG59O1xuXG52YXIgQ2xpY2thYmxlID0gbWFrZUFibGUoXCJjbGlja2FibGVcIiwge1xyXG4gICAgcHJvcHM6IFtcclxuICAgICAgICBcImNsaWNrYWJsZVwiLFxyXG4gICAgXSxcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAgIFwiY2xpY2tcIixcclxuICAgICAgICBcImNsaWNrR3JvdXBcIixcclxuICAgIF0sXHJcbiAgICBhbHdheXM6IHRydWUsXHJcbiAgICBkcmFnUmVsYXRpb246IFwid2Vha1wiLFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIGUuZGF0YXMuaW5wdXRUYXJnZXQgPSBlLmlucHV0RXZlbnQgJiYgZS5pbnB1dEV2ZW50LnRhcmdldDtcclxuICAgIH0sXHJcbiAgICBkcmFnRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gbW92ZWFibGUucHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHZhciBpbnB1dEV2ZW50ID0gZS5pbnB1dEV2ZW50O1xyXG4gICAgICAgIHZhciBpbnB1dFRhcmdldCA9IGUuaW5wdXRUYXJnZXQ7XHJcbiAgICAgICAgdmFyIGlzTW92ZWFibGVFbGVtZW50ID0gbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpO1xyXG4gICAgICAgIHZhciBjb250YWluc0VsZW1lbnQgPSAhaXNNb3ZlYWJsZUVsZW1lbnQgJiYgbW92ZWFibGUuY29udHJvbEJveC5jb250YWlucyhpbnB1dFRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFpbnB1dEV2ZW50IHx8ICFpbnB1dFRhcmdldCB8fCBlLmlzRHJhZ1xyXG4gICAgICAgICAgICB8fCBtb3ZlYWJsZS5pc01vdmVhYmxlRWxlbWVudChpbnB1dFRhcmdldClcclxuICAgICAgICAgICAgfHwgY29udGFpbnNFbGVtZW50XHJcbiAgICAgICAgLy8gRXh0ZXJuYWwgZXZlbnQgZHVwbGljYXRlIHRhcmdldCBvciBkcmFnQXJlYUVsZW1lbnRcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udGFpbnNUYXJnZXQgPSB0YXJnZXQuY29udGFpbnMoaW5wdXRUYXJnZXQpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaWNrXCIsIGZpbGxQYXJhbXMobW92ZWFibGUsIGUsIHtcclxuICAgICAgICAgICAgaXNEb3VibGU6IGUuaXNEb3VibGUsXHJcbiAgICAgICAgICAgIGlucHV0VGFyZ2V0OiBpbnB1dFRhcmdldCxcclxuICAgICAgICAgICAgaXNUYXJnZXQ6IHRhcmdldCA9PT0gaW5wdXRUYXJnZXQsXHJcbiAgICAgICAgICAgIG1vdmVhYmxlVGFyZ2V0OiBtb3ZlYWJsZS5wcm9wcy50YXJnZXQsXHJcbiAgICAgICAgICAgIGNvbnRhaW5zVGFyZ2V0OiBjb250YWluc1RhcmdldCxcclxuICAgICAgICB9KSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgaW5wdXRFdmVudCA9IGUuaW5wdXRFdmVudDtcclxuICAgICAgICB2YXIgaW5wdXRUYXJnZXQgPSBlLmlucHV0VGFyZ2V0O1xyXG4gICAgICAgIGlmICghaW5wdXRFdmVudCB8fCAhaW5wdXRUYXJnZXQgfHwgZS5pc0RyYWdcclxuICAgICAgICAgICAgfHwgbW92ZWFibGUuaXNNb3ZlYWJsZUVsZW1lbnQoaW5wdXRUYXJnZXQpXHJcbiAgICAgICAgICAgIC8vIEV4dGVybmFsIGV2ZW50IGR1cGxpY2F0ZSB0YXJnZXQgb3IgZHJhZ0FyZWFFbGVtZW50XHJcbiAgICAgICAgICAgIHx8IGUuZGF0YXMuaW5wdXRUYXJnZXQgPT09IGlucHV0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldHMgPSBtb3ZlYWJsZS5wcm9wcy50YXJnZXRzO1xyXG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IHRhcmdldHMuaW5kZXhPZihpbnB1dFRhcmdldCk7XHJcbiAgICAgICAgdmFyIGlzVGFyZ2V0ID0gdGFyZ2V0SW5kZXggPiAtMTtcclxuICAgICAgICB2YXIgY29udGFpbnNUYXJnZXQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRhcmdldEluZGV4ID0gZmluZEluZGV4KHRhcmdldHMsIGZ1bmN0aW9uIChwYXJlbnRUYXJnZXQpIHsgcmV0dXJuIHBhcmVudFRhcmdldC5jb250YWlucyhpbnB1dFRhcmdldCk7IH0pO1xyXG4gICAgICAgICAgICBjb250YWluc1RhcmdldCA9IHRhcmdldEluZGV4ID4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJFdmVudChtb3ZlYWJsZSwgXCJvbkNsaWNrR3JvdXBcIiwgZmlsbFBhcmFtcyhtb3ZlYWJsZSwgZSwge1xyXG4gICAgICAgICAgICBpc0RvdWJsZTogZS5pc0RvdWJsZSxcclxuICAgICAgICAgICAgdGFyZ2V0czogdGFyZ2V0cyxcclxuICAgICAgICAgICAgaW5wdXRUYXJnZXQ6IGlucHV0VGFyZ2V0LFxyXG4gICAgICAgICAgICB0YXJnZXRJbmRleDogdGFyZ2V0SW5kZXgsXHJcbiAgICAgICAgICAgIGlzVGFyZ2V0OiBpc1RhcmdldCxcclxuICAgICAgICAgICAgY29udGFpbnNUYXJnZXQ6IGNvbnRhaW5zVGFyZ2V0LFxyXG4gICAgICAgICAgICBtb3ZlYWJsZVRhcmdldDogdGFyZ2V0c1t0YXJnZXRJbmRleF0sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb250cm9sRW5kOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB0aGlzLmRyYWdFbmQobW92ZWFibGUsIGUpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cENvbnRyb2xFbmQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ0VuZChtb3ZlYWJsZSwgZSk7XHJcbiAgICB9LFxyXG59KTtcclxuLyoqXHJcbiAqIFdoZW4geW91IGNsaWNrIG9uIHRoZSBlbGVtZW50LCB0aGUgYGNsaWNrYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICogQHBhcmFtIHtNb3ZlYWJsZS5PbkNsaWNrfSAtIFBhcmFtZXRlcnMgZm9yIHRoZSBgY2xpY2tgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRhcmdldFwiKSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiY2xpY2tcIiwgKHsgaGFzVGFyZ2V0LCBjb250YWluc1RhcmdldCwgdGFyZ2V0SW5kZXggfSkgPT4ge1xyXG4gKiAgICAgLy8gSWYgeW91IGNsaWNrIG9uIGFuIGVsZW1lbnQgb3RoZXIgdGhhbiB0aGUgdGFyZ2V0IGFuZCBub3QgaW5jbHVkZWQgaW4gdGhlIHRhcmdldCwgaW5kZXggaXMgLTEuXHJcbiAqICAgICBjb25zb2xlLmxvZyhcIm9uQ2xpY2tHcm91cFwiLCB0YXJnZXQsIGhhc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4KTtcclxuICogfSk7XHJcbiAqL1xyXG4vKipcclxuICogV2hlbiB5b3UgY2xpY2sgb24gdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBncm91cCwgdGhlIGBjbGlja0dyb3VwYCBldmVudCBpcyBjYWxsZWQuXHJcbiAqIEBtZW1iZXJvZiBNb3ZlYWJsZVxyXG4gKiBAZXZlbnQgY2xpY2tHcm91cFxyXG4gKiBAcGFyYW0ge01vdmVhYmxlLk9uQ2xpY2tHcm91cH0gLSBQYXJhbWV0ZXJzIGZvciB0aGUgYGNsaWNrR3JvdXBgIGV2ZW50XHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCBNb3ZlYWJsZSBmcm9tIFwibW92ZWFibGVcIjtcclxuICpcclxuICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gKiAgICAgdGFyZ2V0OiBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudGFyZ2V0XCIpKSxcclxuICogfSk7XHJcbiAqIG1vdmVhYmxlLm9uKFwiY2xpY2tHcm91cFwiLCAoeyBpbnB1dFRhcmdldCwgaXNUYXJnZXQsIGNvbnRhaW5zVGFyZ2V0LCB0YXJnZXRJbmRleCB9KSA9PiB7XHJcbiAqICAgICAvLyBJZiB5b3UgY2xpY2sgb24gYW4gZWxlbWVudCBvdGhlciB0aGFuIHRoZSB0YXJnZXQgYW5kIG5vdCBpbmNsdWRlZCBpbiB0aGUgdGFyZ2V0LCBpbmRleCBpcyAtMS5cclxuICogICAgIGNvbnNvbGUubG9nKFwib25DbGlja0dyb3VwXCIsIGlucHV0VGFyZ2V0LCBpc1RhcmdldCwgY29udGFpbnNUYXJnZXQsIHRhcmdldEluZGV4KTtcclxuICogfSk7XHJcbiAqL1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVFdmVudChlKSB7XHJcbiAgICB2YXIgZGF0YXMgPSBlLm9yaWdpbmFsRGF0YXMuZHJhZ2dhYmxlO1xyXG4gICAgaWYgKCFkYXRhcykge1xyXG4gICAgICAgIGUub3JpZ2luYWxEYXRhcy5kcmFnZ2FibGUgPSB7fTtcclxuICAgICAgICBkYXRhcyA9IGUub3JpZ2luYWxEYXRhcy5kcmFnZ2FibGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IGRhdGFzOiBkYXRhcyB9KTtcclxufVxyXG52YXIgZWRnZURyYWdnYWJsZSA9IG1ha2VBYmxlKFwiZWRnZURyYWdnYWJsZVwiLCB7XHJcbiAgICBjc3M6IFtcclxuICAgICAgICBcIi5lZGdlLmVkZ2VEcmFnZ2FibGUubGluZSB7XFxuY3Vyc29yOiBtb3ZlO1xcbn1cIixcclxuICAgIF0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgUmVhY3QpIHtcclxuICAgICAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgICAgICB2YXIgZWRnZSA9IHByb3BzLmVkZ2VEcmFnZ2FibGU7XHJcbiAgICAgICAgaWYgKCFlZGdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlckVkZ2VMaW5lcyhSZWFjdCwgXCJlZGdlRHJhZ2dhYmxlXCIsIGVkZ2UsIG1vdmVhYmxlLmdldFN0YXRlKCkucmVuZGVyUG9zZXMsIHByb3BzLnpvb20pO1xyXG4gICAgfSxcclxuICAgIGRyYWdDb25kaXRpb246IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgcHJvcHMgPSBtb3ZlYWJsZS5wcm9wcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gKF9hID0gZS5pbnB1dEV2ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFyZ2V0O1xyXG4gICAgICAgIGlmICghcHJvcHMuZWRnZURyYWdnYWJsZSB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICFwcm9wcy5kcmFnZ2FibGVcclxuICAgICAgICAgICAgJiYgaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJkaXJlY3Rpb25cIikpXHJcbiAgICAgICAgICAgICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZWRnZVwiKSlcclxuICAgICAgICAgICAgJiYgaGFzQ2xhc3ModGFyZ2V0LCBwcmVmaXgoXCJlZGdlRHJhZ2dhYmxlXCIpKTtcclxuICAgIH0sXHJcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChtb3ZlYWJsZSwgZSkge1xyXG4gICAgICAgIHJldHVybiBEcmFnZ2FibGUuZHJhZ1N0YXJ0KG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZzogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnRW5kKG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwQ29uZGl0aW9uOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIHByb3BzID0gbW92ZWFibGUucHJvcHM7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IChfYSA9IGUuaW5wdXRFdmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldDtcclxuICAgICAgICBpZiAoIXByb3BzLmVkZ2VEcmFnZ2FibGUgfHwgIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhcHJvcHMuZHJhZ2dhYmxlICYmIGhhc0NsYXNzKHRhcmdldCwgcHJlZml4KFwiZGlyZWN0aW9uXCIpKSAmJiBoYXNDbGFzcyh0YXJnZXQsIHByZWZpeChcImxpbmVcIikpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cFN0YXJ0OiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cFN0YXJ0KG1vdmVhYmxlLCBnZXREcmFnZ2FibGVFdmVudChlKSk7XHJcbiAgICB9LFxyXG4gICAgZHJhZ0dyb3VwOiBmdW5jdGlvbiAobW92ZWFibGUsIGUpIHtcclxuICAgICAgICByZXR1cm4gRHJhZ2dhYmxlLmRyYWdHcm91cChtb3ZlYWJsZSwgZ2V0RHJhZ2dhYmxlRXZlbnQoZSkpO1xyXG4gICAgfSxcclxuICAgIGRyYWdHcm91cEVuZDogZnVuY3Rpb24gKG1vdmVhYmxlLCBlKSB7XHJcbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZS5kcmFnR3JvdXBFbmQobW92ZWFibGUsIGdldERyYWdnYWJsZUV2ZW50KGUpKTtcclxuICAgIH0sXHJcbiAgICB1bnNldDogZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIERyYWdnYWJsZS51bnNldChtb3ZlYWJsZSk7XHJcbiAgICB9LFxyXG59KTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdG8gbW92ZSBieSBkcmFnZ2luZyB0aGUgZWRnZSBsaW5lIChkZWZhdWx0OiBmYWxzZSlcclxuICogQG5hbWUgTW92ZWFibGUuRHJhZ2dhYmxlI2VkZ2VEcmFnZ2FibGVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IE1vdmVhYmxlIGZyb20gXCJtb3ZlYWJsZVwiO1xyXG4gKlxyXG4gKiBjb25zdCBtb3ZlYWJsZSA9IG5ldyBNb3ZlYWJsZShkb2N1bWVudC5ib2R5LCB7XHJcbiAqICBkcmFnZ2FibGU6IHRydWUsXHJcbiAqICBlZGdlRHJhZ2dhYmxlOiBmYWxzZSxcclxuICogfSk7XHJcbiAqXHJcbiAqIG1vdmVhYmxlLmVkZ2VEcmFnZ2FibGUgPSB0cnVlO1xyXG4gKi9cblxudmFyIEluZGl2aWR1YWxHcm91cGFibGUgPSB7XHJcbiAgICBuYW1lOiBcImluZGl2aWR1YWxHcm91cGFibGVcIixcclxuICAgIHByb3BzOiBbXHJcbiAgICAgICAgXCJpbmRpdmlkdWFsR3JvdXBhYmxlXCIsXHJcbiAgICAgICAgXCJpbmRpdmlkdWFsR3JvdXBhYmxlUHJvcHNcIixcclxuICAgIF0sXHJcbiAgICBldmVudHM6IFtdLFxyXG59O1xuXG52YXIgTU9WRUFCTEVfQUJMRVMgPSAgW1xyXG4gICAgQmVmb3JlUmVuZGVyYWJsZSxcclxuICAgIERlZmF1bHQsIFNuYXBwYWJsZSwgUGluY2hhYmxlLFxyXG4gICAgRHJhZ2dhYmxlLCBlZGdlRHJhZ2dhYmxlLFxyXG4gICAgUmVzaXphYmxlLCBTY2FsYWJsZSwgV2FycGFibGUsIFJvdGF0YWJsZSxcclxuICAgIFNjcm9sbGFibGUsIFBhZGRpbmcsIE9yaWdpbixcclxuICAgIE9yaWdpbkRyYWdnYWJsZSxcclxuICAgIENsaXBwYWJsZSwgUm91bmRhYmxlLCBHcm91cGFibGUsIEluZGl2aWR1YWxHcm91cGFibGUsXHJcbiAgICBDbGlja2FibGUsXHJcbiAgICBEcmFnQXJlYSxcclxuICAgIFJlbmRlcmFibGUsXHJcbl07XHJcbnZhciBNT1ZFQUJMRV9FVkVOVFMgPSAvKiNfX1BVUkVfXyovIE1PVkVBQkxFX0FCTEVTLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudCwgYWJsZSkge1xyXG4gICAgKGFibGUuZXZlbnRzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcHVzaFNldChjdXJyZW50LCBuYW1lKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGN1cnJlbnQ7XHJcbn0sIFtdKTtcclxudmFyIE1PVkVBQkxFX1BST1BTID0gLyojX19QVVJFX18qLyBNT1ZFQUJMRV9BQkxFUy5yZWR1Y2UoZnVuY3Rpb24gKGN1cnJlbnQsIGFibGUpIHtcclxuICAgIChhYmxlLnByb3BzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcHVzaFNldChjdXJyZW50LCBuYW1lKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGN1cnJlbnQ7XHJcbn0sIFtdKTtcblxuZnVuY3Rpb24gc29sdmVDb25zdGFudHNEaXN0YW5jZShfYSwgcG9zKSB7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBhID0gX2JbMF0sIGIgPSBfYlsxXSwgYyA9IF9iWzJdO1xyXG4gICAgcmV0dXJuIChhICogcG9zWzBdICsgYiAqIHBvc1sxXSArIGMpIC8gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xyXG59XHJcbmZ1bmN0aW9uIHNvbHZlQyhfYSwgcG9zKSB7XHJcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBhID0gX2JbMF0sIGIgPSBfYlsxXTtcclxuICAgIC8vIGF4ICsgYnkgKyBjID0gMFxyXG4gICAgLy8gLWF4IC1ieTtcclxuICAgIHJldHVybiAtYSAqIHBvc1swXSAtIGIgKiBwb3NbMV07XHJcbn1cblxuZnVuY3Rpb24gZ2V0TWF4UG9zKHBvc2VzLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCA0KSwgcG9zMSA9IF9iWzBdLCBwb3MyID0gX2JbMV0sIHBvczMgPSBfYlsyXSwgcG9zNCA9IF9iWzNdO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChwb3MxW2luZGV4XSwgcG9zMltpbmRleF0sIHBvczNbaW5kZXhdLCBwb3M0W2luZGV4XSk7XHJcbiAgICB9KSksIGZhbHNlKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWluUG9zKHBvc2VzLCBpbmRleCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwb3Nlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCA0KSwgcG9zMSA9IF9iWzBdLCBwb3MyID0gX2JbMV0sIHBvczMgPSBfYlsyXSwgcG9zNCA9IF9iWzNdO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihwb3MxW2luZGV4XSwgcG9zMltpbmRleF0sIHBvczNbaW5kZXhdLCBwb3M0W2luZGV4XSk7XHJcbiAgICB9KSksIGZhbHNlKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0R3JvdXBSZWN0KHBhcmVudFBvc2VzLCByb3RhdGlvbikge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICB2YXIgcG9zMSA9IFswLCAwXTtcclxuICAgIHZhciBwb3MyID0gWzAsIDBdO1xyXG4gICAgdmFyIHBvczMgPSBbMCwgMF07XHJcbiAgICB2YXIgcG9zNCA9IFswLCAwXTtcclxuICAgIHZhciB3aWR0aCA9IDA7XHJcbiAgICB2YXIgaGVpZ2h0ID0gMDtcclxuICAgIGlmICghcGFyZW50UG9zZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcG9zMTogcG9zMSxcclxuICAgICAgICAgICAgcG9zMjogcG9zMixcclxuICAgICAgICAgICAgcG9zMzogcG9zMyxcclxuICAgICAgICAgICAgcG9zNDogcG9zNCxcclxuICAgICAgICAgICAgbWluWDogMCxcclxuICAgICAgICAgICAgbWluWTogMCxcclxuICAgICAgICAgICAgbWF4WDogMCxcclxuICAgICAgICAgICAgbWF4WTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgZml4ZWRSb3RhdGlvbiA9IHRocm90dGxlKHJvdGF0aW9uLCBUSU5ZX05VTSk7XHJcbiAgICBpZiAoZml4ZWRSb3RhdGlvbiAlIDkwKSB7XHJcbiAgICAgICAgdmFyIHJhZCA9IGZpeGVkUm90YXRpb24gLyAxODAgKiBNYXRoLlBJO1xyXG4gICAgICAgIHZhciBhMV8xID0gTWF0aC50YW4ocmFkKTtcclxuICAgICAgICB2YXIgYTJfMSA9IC0xIC8gYTFfMTtcclxuICAgICAgICAvLyBheCA9IHkgIC8vIC1heCArIHkgPSAwIC8vIDAgPT4gMVxyXG4gICAgICAgIC8vIC1heCA9IHkgLy8gYXggKyB5ID0gMCAgLy8gMCA9PiAzXHJcbiAgICAgICAgdmFyIGExTWluTWF4XzEgPSBbTUFYX05VTSwgTUlOX05VTV07XHJcbiAgICAgICAgdmFyIGExTWluTWF4UG9zXzEgPSBbWzAsIDBdLCBbMCwgMF1dO1xyXG4gICAgICAgIHZhciBhMk1pbk1heF8xID0gW01BWF9OVU0sIE1JTl9OVU1dO1xyXG4gICAgICAgIHZhciBhMk1pbk1heFBvc18xID0gW1swLCAwXSwgWzAsIDBdXTtcclxuICAgICAgICBwYXJlbnRQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3Nlcykge1xyXG4gICAgICAgICAgICBwb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGIxID0gcG9zWzFdIC0gYTEgKiBwb3NbMF07XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBiMiA9IHBvc1sxXSAtIGEyICogcG9zWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGExRGlzdCA9IHNvbHZlQ29uc3RhbnRzRGlzdGFuY2UoWy1hMV8xLCAxLCAwXSwgcG9zKTtcclxuICAgICAgICAgICAgICAgIHZhciBhMkRpc3QgPSBzb2x2ZUNvbnN0YW50c0Rpc3RhbmNlKFstYTJfMSwgMSwgMF0sIHBvcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYTFNaW5NYXhfMVswXSA+IGExRGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGExTWluTWF4UG9zXzFbMF0gPSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYTFNaW5NYXhfMVswXSA9IGExRGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhMU1pbk1heF8xWzFdIDwgYTFEaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYTFNaW5NYXhQb3NfMVsxXSA9IHBvcztcclxuICAgICAgICAgICAgICAgICAgICBhMU1pbk1heF8xWzFdID0gYTFEaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGEyTWluTWF4XzFbMF0gPiBhMkRpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBhMk1pbk1heFBvc18xWzBdID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGEyTWluTWF4XzFbMF0gPSBhMkRpc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYTJNaW5NYXhfMVsxXSA8IGEyRGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEyTWluTWF4UG9zXzFbMV0gPSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYTJNaW5NYXhfMVsxXSA9IGEyRGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIF9kID0gX19yZWFkKGExTWluTWF4UG9zXzEsIDIpLCBhMU1pblBvcyA9IF9kWzBdLCBhMU1heFBvcyA9IF9kWzFdO1xyXG4gICAgICAgIHZhciBfZSA9IF9fcmVhZChhMk1pbk1heFBvc18xLCAyKSwgYTJNaW5Qb3MgPSBfZVswXSwgYTJNYXhQb3MgPSBfZVsxXTtcclxuICAgICAgICB2YXIgbWluSG9yaXpvbnRhbExpbmUgPSBbLWExXzEsIDEsIHNvbHZlQyhbLWExXzEsIDFdLCBhMU1pblBvcyldO1xyXG4gICAgICAgIHZhciBtYXhIb3Jpem9udGFsTGluZSA9IFstYTFfMSwgMSwgc29sdmVDKFstYTFfMSwgMV0sIGExTWF4UG9zKV07XHJcbiAgICAgICAgdmFyIG1pblZlcnRpY2FsTGluZSA9IFstYTJfMSwgMSwgc29sdmVDKFstYTJfMSwgMV0sIGEyTWluUG9zKV07XHJcbiAgICAgICAgdmFyIG1heFZlcnRpY2FsTGluZSA9IFstYTJfMSwgMSwgc29sdmVDKFstYTJfMSwgMV0sIGEyTWF4UG9zKV07XHJcbiAgICAgICAgX2EgPSBfX3JlYWQoW1xyXG4gICAgICAgICAgICBbbWluSG9yaXpvbnRhbExpbmUsIG1pblZlcnRpY2FsTGluZV0sXHJcbiAgICAgICAgICAgIFttaW5Ib3Jpem9udGFsTGluZSwgbWF4VmVydGljYWxMaW5lXSxcclxuICAgICAgICAgICAgW21heEhvcml6b250YWxMaW5lLCBtaW5WZXJ0aWNhbExpbmVdLFxyXG4gICAgICAgICAgICBbbWF4SG9yaXpvbnRhbExpbmUsIG1heFZlcnRpY2FsTGluZV0sXHJcbiAgICAgICAgXS5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGxpbmUxID0gX2JbMF0sIGxpbmUyID0gX2JbMV07XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb25Qb2ludHNCeUNvbnN0YW50cyhsaW5lMSwgbGluZTIpWzBdO1xyXG4gICAgICAgIH0pLCA0KSwgcG9zMSA9IF9hWzBdLCBwb3MyID0gX2FbMV0sIHBvczMgPSBfYVsyXSwgcG9zNCA9IF9hWzNdO1xyXG4gICAgICAgIHdpZHRoID0gYTJNaW5NYXhfMVsxXSAtIGEyTWluTWF4XzFbMF07XHJcbiAgICAgICAgaGVpZ2h0ID0gYTFNaW5NYXhfMVsxXSAtIGExTWluTWF4XzFbMF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbWluWF8xID0gZ2V0TWluUG9zKHBhcmVudFBvc2VzLCAwKTtcclxuICAgICAgICB2YXIgbWluWV8xID0gZ2V0TWluUG9zKHBhcmVudFBvc2VzLCAxKTtcclxuICAgICAgICB2YXIgbWF4WF8xID0gZ2V0TWF4UG9zKHBhcmVudFBvc2VzLCAwKTtcclxuICAgICAgICB2YXIgbWF4WV8xID0gZ2V0TWF4UG9zKHBhcmVudFBvc2VzLCAxKTtcclxuICAgICAgICBwb3MxID0gW21pblhfMSwgbWluWV8xXTtcclxuICAgICAgICBwb3MyID0gW21heFhfMSwgbWluWV8xXTtcclxuICAgICAgICBwb3MzID0gW21pblhfMSwgbWF4WV8xXTtcclxuICAgICAgICBwb3M0ID0gW21heFhfMSwgbWF4WV8xXTtcclxuICAgICAgICB3aWR0aCA9IG1heFhfMSAtIG1pblhfMTtcclxuICAgICAgICBoZWlnaHQgPSBtYXhZXzEgLSBtaW5ZXzE7XHJcbiAgICAgICAgaWYgKGZpeGVkUm90YXRpb24gJSAxODApIHtcclxuICAgICAgICAgICAgLy8gMFxyXG4gICAgICAgICAgICAvLyAxIDJcclxuICAgICAgICAgICAgLy8gMyA0XHJcbiAgICAgICAgICAgIC8vIDkwXHJcbiAgICAgICAgICAgIC8vIDMgMVxyXG4gICAgICAgICAgICAvLyA0IDJcclxuICAgICAgICAgICAgLy8gMTgwXHJcbiAgICAgICAgICAgIC8vIDQgM1xyXG4gICAgICAgICAgICAvLyAyIDFcclxuICAgICAgICAgICAgLy8gMjcwXHJcbiAgICAgICAgICAgIC8vIDIgNFxyXG4gICAgICAgICAgICAvLyAxIDNcclxuICAgICAgICAgICAgLy8gMSwgMiwgMyw0ID0gMyAxIDQgMlxyXG4gICAgICAgICAgICB2YXIgY2hhbmdlZFggPSBbcG9zMywgcG9zMSwgcG9zNCwgcG9zMl07XHJcbiAgICAgICAgICAgIF9iID0gX19yZWFkKGNoYW5nZWRYLCA0KSwgcG9zMSA9IF9iWzBdLCBwb3MyID0gX2JbMV0sIHBvczMgPSBfYlsyXSwgcG9zNCA9IF9iWzNdO1xyXG4gICAgICAgICAgICB3aWR0aCA9IG1heFlfMSAtIG1pbllfMTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gbWF4WF8xIC0gbWluWF8xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChmaXhlZFJvdGF0aW9uICUgMzYwID4gMTgwKSB7XHJcbiAgICAgICAgLy8gMSAyICAgNCAzXHJcbiAgICAgICAgLy8gMyA0ICAgMiAxXHJcbiAgICAgICAgdmFyIGNoYW5nZWRYID0gW3BvczQsIHBvczMsIHBvczIsIHBvczFdO1xyXG4gICAgICAgIF9jID0gX19yZWFkKGNoYW5nZWRYLCA0KSwgcG9zMSA9IF9jWzBdLCBwb3MyID0gX2NbMV0sIHBvczMgPSBfY1syXSwgcG9zNCA9IF9jWzNdO1xyXG4gICAgfVxyXG4gICAgdmFyIF9mID0gZ2V0TWluTWF4cyhbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0pLCBtaW5YID0gX2YubWluWCwgbWluWSA9IF9mLm1pblksIG1heFggPSBfZi5tYXhYLCBtYXhZID0gX2YubWF4WTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcG9zMTogcG9zMSxcclxuICAgICAgICBwb3MyOiBwb3MyLFxyXG4gICAgICAgIHBvczM6IHBvczMsXHJcbiAgICAgICAgcG9zNDogcG9zNCxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgbWluWDogbWluWCxcclxuICAgICAgICBtaW5ZOiBtaW5ZLFxyXG4gICAgICAgIG1heFg6IG1heFgsXHJcbiAgICAgICAgbWF4WTogbWF4WSxcclxuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZpbmRNb3ZlYWJsZUdyb3Vwcyhtb3ZlYWJsZXMsIGNoaWxkVGFyZ2V0R3JvdXBzKSB7XHJcbiAgICB2YXIgZ3JvdXBzID0gY2hpbGRUYXJnZXRHcm91cHMubWFwKGZ1bmN0aW9uICh0YXJnZXRHcm91cCkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldEdyb3VwKSkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRNb3ZlYWJsZUdyb3VwcyA9IGZpbmRNb3ZlYWJsZUdyb3Vwcyhtb3ZlYWJsZXMsIHRhcmdldEdyb3VwKTtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gY2hpbGRNb3ZlYWJsZUdyb3Vwcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGhfMSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE1vdmVhYmxlR3JvdXBzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aF8xID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRNb3ZlYWJsZUdyb3Vwc1swXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY2hlY2tlZCA9IGZpbmQobW92ZWFibGVzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gX2EubWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLnByb3BzLnRhcmdldCA9PT0gdGFyZ2V0R3JvdXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZC5maW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQubWFuYWdlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICBpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KGdyb3Vwc1swXSkpIHtcclxuICAgICAgICByZXR1cm4gZ3JvdXBzWzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdyb3VwcztcclxufVxyXG4vKipcclxuICogQG5hbWVzcGFjZSBNb3ZlYWJsZS5Hcm91cFxyXG4gKiBAZGVzY3JpcHRpb24gWW91IGNhbiBtYWtlIHRhcmdldHMgbW92ZWFibGUuXHJcbiAqL1xyXG52YXIgTW92ZWFibGVHcm91cCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNb3ZlYWJsZUdyb3VwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW92ZWFibGVHcm91cCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kaWZmZXIgPSBuZXcgQ2hpbGRyZW5EaWZmZXIoKTtcclxuICAgICAgICBfdGhpcy5tb3ZlYWJsZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmFuc2Zvcm1PcmlnaW4gPSBcIjUwJSA1MCVcIjtcclxuICAgICAgICBfdGhpcy5yZW5kZXJHcm91cFJlY3RzID0gW107XHJcbiAgICAgICAgX3RoaXMuX3RhcmdldEdyb3VwcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLl9oYXNGaXJzdFRhcmdldHMgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQWJsZXMoKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5nZXRUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRhcmdldHM7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUudXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoaXNTZXRTdGF0ZSA9PT0gdm9pZCAwKSB7IGlzU2V0U3RhdGUgPSB0cnVlOyB9XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICBpZiAoIXRoaXMuY29udHJvbEJveCB8fCBzdGF0ZS5pc1BlcnNpc3RlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFN0b3JlQ2FjaGUodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb3ZlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobW92ZWFibGUpIHtcclxuICAgICAgICAgICAgbW92ZWFibGUudXBkYXRlUmVjdCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlcyA9IHRoaXMubW92ZWFibGVzO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQgfHwgcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHZhciBjaGVja2VkcyA9IG1vdmVhYmxlcy5tYXAoZnVuY3Rpb24gKG1vdmVhYmxlKSB7IHJldHVybiAoeyBmaW5kZWQ6IGZhbHNlLCBtYW5hZ2VyOiBtb3ZlYWJsZSB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHRhcmdldEdyb3VwcyA9IHRoaXMucHJvcHMudGFyZ2V0R3JvdXBzIHx8IFtdO1xyXG4gICAgICAgIHZhciBtb3ZlYWJsZUdyb3VwcyA9IGZpbmRNb3ZlYWJsZUdyb3VwcyhjaGVja2VkcywgdGFyZ2V0R3JvdXBzKTtcclxuICAgICAgICB2YXIgdXNlRGVmYXVsdEdyb3VwUm90YXRlID0gcHJvcHMudXNlRGVmYXVsdEdyb3VwUm90YXRlO1xyXG4gICAgICAgIG1vdmVhYmxlR3JvdXBzLnB1c2guYXBwbHkobW92ZWFibGVHcm91cHMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjaGVja2Vkcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBmaW5kZWQgPSBfYS5maW5kZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiAhZmluZGVkO1xyXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBfYS5tYW5hZ2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICB9KSksIGZhbHNlKSk7XHJcbiAgICAgICAgdmFyIHJlbmRlckdyb3VwUmVjdHMgPSBbXTtcclxuICAgICAgICB2YXIgaXNSZXNldCA9ICFpc1RhcmdldCB8fCAodHlwZSAhPT0gXCJcIiAmJiBwcm9wcy51cGRhdGVHcm91cCk7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRHcm91cFJvdGF0ZSA9IHByb3BzLmRlZmF1bHRHcm91cFJvdGF0ZSB8fCAwO1xyXG4gICAgICAgIGlmICghdGhpcy5faGFzRmlyc3RUYXJnZXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBwZXJzaXN0ZWRSb2F0YXRpb24gPSAoX2EgPSBwcm9wcy5wZXJzaXN0RGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICBpZiAocGVyc2lzdGVkUm9hdGF0aW9uICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRHcm91cFJvdGF0ZSA9IHBlcnNpc3RlZFJvYXRhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBnZXRNb3ZlYWJsZUdyb3VwUmVjdChncm91cCwgcGFyZW50Um90YXRpb24sIGlzUm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zZXNSb3RhdGlvbnMgPSBncm91cC5tYXAoZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShtb3ZlYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdldE1vdmVhYmxlR3JvdXBSZWN0KG1vdmVhYmxlLCBwYXJlbnRSb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2VzID0gW3JlY3QucG9zMSwgcmVjdC5wb3MyLCByZWN0LnBvczMsIHJlY3QucG9zNF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyR3JvdXBSZWN0cy5wdXNoKHJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBvc2VzOiBwb3Nlcywgcm90YXRpb246IHJlY3Qucm90YXRpb24gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2VzOiBnZXRBYnNvbHV0ZVBvc2VzQnlTdGF0ZShtb3ZlYWJsZS5zdGF0ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBtb3ZlYWJsZS5nZXRSb3RhdGlvbigpLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgcm90YXRpb25zID0gcG9zZXNSb3RhdGlvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gX2Eucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm90YXRpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBSb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFJvdGF0aW9uID0gcm90YXRpb25zWzBdO1xyXG4gICAgICAgICAgICB2YXIgaXNTYW1lUm90YXRpb24gPSByb3RhdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG5leHRSb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGZpcnN0Um90YXRpb24gLSBuZXh0Um90YXRpb24pIDwgMC4xO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwUm90YXRpb24gPSAhdXNlRGVmYXVsdEdyb3VwUm90YXRlICYmIGlzU2FtZVJvdGF0aW9uID8gZmlyc3RSb3RhdGlvbiA6IGRlZmF1bHRHcm91cFJvdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwUm90YXRpb24gPSAhdXNlRGVmYXVsdEdyb3VwUm90YXRlICYmICFpc1Jvb3QgJiYgaXNTYW1lUm90YXRpb24gPyBmaXJzdFJvdGF0aW9uIDogcGFyZW50Um90YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdyb3VwUG9zZXMgPSBwb3Nlc1JvdGF0aW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zZXMgPSBfYS5wb3NlcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NlcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBncm91cFJlY3QgPSBnZXRHcm91cFJlY3QoZ3JvdXBQb3NlcywgZ3JvdXBSb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBncm91cFJlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb290R3JvdXBSZWN0ID0gZ2V0TW92ZWFibGVHcm91cFJlY3QobW92ZWFibGVHcm91cHMsIHRoaXMucm90YXRpb24sIHRydWUpO1xyXG4gICAgICAgIGlmIChpc1Jlc2V0KSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHJvdGF0YWlvblxyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm9vdEdyb3VwUmVjdC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1PcmlnaW4gPSBwcm9wcy5kZWZhdWx0R3JvdXBPcmlnaW4gfHwgXCI1MCUgNTAlXCI7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RhcmdldEdyb3VwcyA9IHRhcmdldEdyb3VwcztcclxuICAgICAgICB0aGlzLnJlbmRlckdyb3VwUmVjdHMgPSByZW5kZXJHcm91cFJlY3RzO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLnRyYW5zZm9ybU9yaWdpbjtcclxuICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcm9vdEdyb3VwUmVjdC53aWR0aCwgaGVpZ2h0ID0gcm9vdEdyb3VwUmVjdC5oZWlnaHQsIG1pblggPSByb290R3JvdXBSZWN0Lm1pblgsIG1pblkgPSByb290R3JvdXBSZWN0Lm1pblk7XHJcbiAgICAgICAgdmFyIHBvc2VzSW5mbyA9IHJvdGF0ZVBvc2VzSW5mbyhbXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgW3dpZHRoLCAwXSxcclxuICAgICAgICAgICAgWzAsIGhlaWdodF0sXHJcbiAgICAgICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcclxuICAgICAgICBdLCBjb252ZXJ0VHJhbnNmb3JtT3JpZ2luQXJyYXkodHJhbnNmb3JtT3JpZ2luLCB3aWR0aCwgaGVpZ2h0KSwgdGhpcy5yb3RhdGlvbiAvIDE4MCAqIE1hdGguUEkpO1xyXG4gICAgICAgIHZhciBfYiA9IGdldE1pbk1heHMocG9zZXNJbmZvLnJlc3VsdCksIGRlbHRhWCA9IF9iLm1pblgsIGRlbHRhWSA9IF9iLm1pblk7XHJcbiAgICAgICAgdmFyIHJvdGF0ZVNjYWxlID0gXCIgcm90YXRlKFwiLmNvbmNhdChyb3RhdGlvbiwgXCJkZWcpXCIpXHJcbiAgICAgICAgICAgICsgXCIgc2NhbGUoXCIuY29uY2F0KHNpZ24oc2NhbGVbMF0pLCBcIiwgXCIpLmNvbmNhdChzaWduKHNjYWxlWzFdKSwgXCIpXCIpO1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoLWRlbHRhWCwgXCJweCwgXCIpLmNvbmNhdCgtZGVsdGFZLCBcInB4KVwiKS5jb25jYXQocm90YXRlU2NhbGUpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbEJveC5zdHlsZS50cmFuc2Zvcm1cclxuICAgICAgICAgICAgPSBcInRyYW5zbGF0ZTNkKFwiLmNvbmNhdChtaW5YLCBcInB4LCBcIikuY29uY2F0KG1pblksIFwicHgsIFwiKS5jb25jYXQodGhpcy5wcm9wcy50cmFuc2xhdGVaIHx8IDAsIFwiKVwiKTtcclxuICAgICAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCArPSBcImxlZnQ6MHB4O3RvcDowcHg7XCJcclxuICAgICAgICAgICAgKyBcInRyYW5zZm9ybS1vcmlnaW46XCIuY29uY2F0KHRyYW5zZm9ybU9yaWdpbiwgXCI7XCIpXHJcbiAgICAgICAgICAgICsgXCJ3aWR0aDpcIi5jb25jYXQod2lkdGgsIFwicHg7aGVpZ2h0OlwiKS5jb25jYXQoaGVpZ2h0LCBcInB4O1wiKVxyXG4gICAgICAgICAgICArIFwidHJhbnNmb3JtOiBcIi5jb25jYXQodHJhbnNmb3JtKTtcclxuICAgICAgICBzdGF0ZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHN0YXRlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcclxuICAgICAgICB2YXIgaW5mbyA9IGdldE1vdmVhYmxlVGFyZ2V0SW5mbyh0aGlzLmNvbnRyb2xCb3gsIHRhcmdldCwgdGhpcy5jb250cm9sQm94LCB0aGlzLmdldENvbnRhaW5lcigpLCB0aGlzLl9yb290Q29udGFpbmVyIHx8IGNvbnRhaW5lciwgW10pO1xyXG4gICAgICAgIHZhciBwb3MgPSBbaW5mby5sZWZ0LCBpbmZvLnRvcF07XHJcbiAgICAgICAgdmFyIF9jID0gX19yZWFkKGdldEFic29sdXRlUG9zZXNCeVN0YXRlKGluZm8pLCA0KSwgcG9zMSA9IF9jWzBdLCBwb3MyID0gX2NbMV0sIHBvczMgPSBfY1syXSwgcG9zNCA9IF9jWzNdOyAvLyBpbmZvLmxlZnQgKyBpbmZvLnBvcygxIH4gNClcclxuICAgICAgICB2YXIgbWluUG9zID0gZ2V0TWluTWF4cyhbcG9zMSwgcG9zMiwgcG9zMywgcG9zNF0pO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IFttaW5Qb3MubWluWCwgbWluUG9zLm1pblldO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBzaWduKHNjYWxlWzBdICogc2NhbGVbMV0pO1xyXG4gICAgICAgIGluZm8ucG9zMSA9IG1pbnVzKHBvczEsIGRlbHRhKTtcclxuICAgICAgICBpbmZvLnBvczIgPSBtaW51cyhwb3MyLCBkZWx0YSk7XHJcbiAgICAgICAgaW5mby5wb3MzID0gbWludXMocG9zMywgZGVsdGEpO1xyXG4gICAgICAgIGluZm8ucG9zNCA9IG1pbnVzKHBvczQsIGRlbHRhKTtcclxuICAgICAgICAvLyBpbmZvLmxlZnQgPSBpbmZvLmxlZnQgKyBkZWx0YVswXTtcclxuICAgICAgICAvLyBpbmZvLnRvcCA9IGluZm8udG9wICsgZGVsdGFbMV07XHJcbiAgICAgICAgaW5mby5sZWZ0ID0gbWluWCAtIGluZm8ubGVmdCArIGRlbHRhWzBdO1xyXG4gICAgICAgIGluZm8udG9wID0gbWluWSAtIGluZm8udG9wICsgZGVsdGFbMV07XHJcbiAgICAgICAgaW5mby5vcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby5vcmlnaW4pLCBkZWx0YSk7XHJcbiAgICAgICAgaW5mby5iZWZvcmVPcmlnaW4gPSBtaW51cyhwbHVzKHBvcywgaW5mby5iZWZvcmVPcmlnaW4pLCBkZWx0YSk7XHJcbiAgICAgICAgaW5mby5vcmlnaW5hbEJlZm9yZU9yaWdpbiA9IHBsdXMocG9zLCBpbmZvLm9yaWdpbmFsQmVmb3JlT3JpZ2luKTtcclxuICAgICAgICBpbmZvLnRyYW5zZm9ybU9yaWdpbiA9IG1pbnVzKHBsdXMocG9zLCBpbmZvLnRyYW5zZm9ybU9yaWdpbiksIGRlbHRhKTtcclxuICAgICAgICB0YXJnZXQuc3R5bGUudHJhbnNmb3JtXHJcbiAgICAgICAgICAgID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KC1kZWx0YVggLSBkZWx0YVswXSwgXCJweCwgXCIpLmNvbmNhdCgtZGVsdGFZIC0gZGVsdGFbMV0sIFwicHgpXCIpXHJcbiAgICAgICAgICAgICAgICArIHJvdGF0ZVNjYWxlO1xyXG4gICAgICAgIHNldFN0b3JlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbmZvKSwgeyBwb3NEZWx0YTogZGVsdGEsIGRpcmVjdGlvbjogZGlyZWN0aW9uLCBiZWZvcmVEaXJlY3Rpb246IGRpcmVjdGlvbiB9KSwgaXNTZXRTdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVHcm91cC5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIF9zdXBlci5wcm90b3R5cGUuZ2V0UmVjdC5jYWxsKHRoaXMpKSwgeyBjaGlsZHJlbjogdGhpcy5tb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQuZ2V0UmVjdCgpOyB9KSB9KTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZSwgaXNNYW5hZ2VyKSB7XHJcbiAgICAgICAgaWYgKGlzTWFuYWdlciB8fCBuYW1lLmluZGV4T2YoXCJHcm91cFwiKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRyaWdnZXJFdmVudC5jYWxsKHRoaXMsIG5hbWUsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci50cmlnZ2VyKG5hbWUsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5nZXRSZXF1ZXN0Q2hpbGRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlTmFtZXMgPSB0aGlzLmdldEVuYWJsZWRBYmxlcygpLnJlZHVjZShmdW5jdGlvbiAobmFtZXMsIGFibGUpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgdmFyIGFibGVTdHlsZU5hbWVzID0gKChfYiA9IChfYSA9IGFibGUucmVxdWVzdENoaWxkU3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGFibGUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuYW1lcyksIGZhbHNlKSwgX19yZWFkKGFibGVTdHlsZU5hbWVzKSwgZmFsc2UpO1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICByZXR1cm4gc3R5bGVOYW1lcztcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5nZXRNb3ZlYWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0aGlzLm1vdmVhYmxlcyksIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS51cGRhdGVBYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZUFibGVzLmNhbGwodGhpcywgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodGhpcy5wcm9wcy5hYmxlcyksIGZhbHNlKSwgW0dyb3VwYWJsZV0sIGZhbHNlKSwgXCJHcm91cFwiKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl91cGRhdGVUYXJnZXRzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxEcmFnVGFyZ2V0ID0gdGhpcy5wcm9wcy5kcmFnVGFyZ2V0IHx8IHRoaXMuYXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fZHJhZ1RhcmdldCA9IGdldFJlZlRhcmdldCh0aGlzLl9vcmlnaW5hbERyYWdUYXJnZXQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlR3JvdXAucHJvdG90eXBlLl91cGRhdGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBwcmV2VGFyZ2V0ID0gdGhpcy5fcHJldkRyYWdUYXJnZXQ7XHJcbiAgICAgICAgdmFyIG5leHRUYXJnZXQgPSBwcm9wcy5kcmFnVGFyZ2V0IHx8IHRoaXMuYXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIHRhcmdldHMgPSBwcm9wcy50YXJnZXRzO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuZGlmZmVyLnVwZGF0ZSh0YXJnZXRzKSwgYWRkZWQgPSBfYS5hZGRlZCwgY2hhbmdlZCA9IF9hLmNoYW5nZWQsIHJlbW92ZWQgPSBfYS5yZW1vdmVkO1xyXG4gICAgICAgIHZhciBpc1RhcmdldENoYW5nZWQgPSBhZGRlZC5sZW5ndGggfHwgcmVtb3ZlZC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGlzVGFyZ2V0Q2hhbmdlZCB8fCB0aGlzLl9wcmV2T3JpZ2luYWxEcmFnVGFyZ2V0ICE9PSB0aGlzLl9vcmlnaW5hbERyYWdUYXJnZXQpIHtcclxuICAgICAgICAgICAgdW5zZXRHZXN0byh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHVuc2V0R2VzdG8odGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoeyBnZXN0b3M6IHt9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlRhcmdldCAhPT0gbmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0YXRlLnRhcmdldCkge1xyXG4gICAgICAgICAgICBzdGF0ZS50YXJnZXQgPSB0aGlzLmFyZWFFbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xCb3guc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFyZ2V0R2VzdG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0R2VzdG8gPSBnZXRUYXJnZXRBYmxlR2VzdG8odGhpcywgdGhpcy5fZHJhZ1RhcmdldCwgXCJHcm91cFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbEdlc3RvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xHZXN0byA9IGdldENvbnRyb2xBYmxlR2VzdG8odGhpcywgXCJHcm91cENvbnRyb2xcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzQ29udGFpbmVyQ2hhbmdlZCA9ICFlcXVhbHMoc3RhdGUuY29udGFpbmVyLCBwcm9wcy5jb250YWluZXIpO1xyXG4gICAgICAgIGlmIChpc0NvbnRhaW5lckNoYW5nZWQpIHtcclxuICAgICAgICAgICAgc3RhdGUuY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNDb250YWluZXJDaGFuZ2VkXHJcbiAgICAgICAgICAgIHx8IGlzVGFyZ2V0Q2hhbmdlZFxyXG4gICAgICAgICAgICB8fCB0aGlzLnRyYW5zZm9ybU9yaWdpbiAhPT0gKHByb3BzLmRlZmF1bHRHcm91cE9yaWdpbiB8fCBcIjUwJSA1MCVcIilcclxuICAgICAgICAgICAgfHwgY2hhbmdlZC5sZW5ndGhcclxuICAgICAgICAgICAgfHwgdGFyZ2V0cy5sZW5ndGggJiYgIWlzRGVlcEFycmF5RXF1YWxzKHRoaXMuX3RhcmdldEdyb3VwcywgcHJvcHMudGFyZ2V0R3JvdXBzIHx8IFtdKSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5faGFzRmlyc3RUYXJnZXRzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQcm9wVGFyZ2V0Q2hhbmdlZCA9ICEhaXNUYXJnZXRDaGFuZ2VkO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlR3JvdXAucHJvdG90eXBlLl91cGRhdGVPYnNlcnZlciA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1vdmVhYmxlR3JvdXAuZGVmYXVsdFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIE1vdmVhYmxlTWFuYWdlci5kZWZhdWx0UHJvcHMpLCB7IHRyYW5zZm9ybU9yaWdpbjogW1wiNTAlXCIsIFwiNTAlXCJdLCBncm91cGFibGU6IHRydWUsIGRyYWdBcmVhOiB0cnVlLCBrZWVwUmF0aW86IHRydWUsIHRhcmdldHM6IFtdLCBkZWZhdWx0R3JvdXBSb3RhdGU6IDAsIGRlZmF1bHRHcm91cE9yaWdpbjogXCI1MCUgNTAlXCIgfSk7XHJcbiAgICByZXR1cm4gTW92ZWFibGVHcm91cDtcclxufShNb3ZlYWJsZU1hbmFnZXIpKTtcblxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgTW92ZWFibGUuSW5kaXZpZHVhbEdyb3VwXHJcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgdGFyZ2V0cyBpbmRpdmlkdWFsbHksIG5vdCBhcyBhIGdyb3VwLkNyZWF0ZSB0YXJnZXRzIGluZGl2aWR1YWxseSwgbm90IGFzIGEgZ3JvdXAuXHJcbiAqL1xyXG52YXIgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5tb3ZlYWJsZXMgPSBbXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIGNzcE5vbmNlID0gcHJvcHMuY3NwTm9uY2UsIENvbnRyb2xCb3hFbGVtZW50ID0gcHJvcHMuY3NzU3R5bGVkLCBwZXJzaXN0RGF0YSA9IHByb3BzLnBlcnNpc3REYXRhO1xyXG4gICAgICAgIHZhciB0YXJnZXRzID0gcHJvcHMudGFyZ2V0cyB8fCBbXTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGFyZ2V0cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGNhblBlcnNpc3QgPSB0aGlzLmlzVW5tb3VudGVkIHx8ICFsZW5ndGg7XHJcbiAgICAgICAgdmFyIHBlcnNpc3REYXRDaGlsZHJlbiA9IChfYSA9IHBlcnNpc3REYXRhID09PSBudWxsIHx8IHBlcnNpc3REYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJzaXN0RGF0YS5jaGlsZHJlbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgaWYgKGNhblBlcnNpc3QgJiYgIWxlbmd0aCAmJiBwZXJzaXN0RGF0Q2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRhcmdldHMgPSBwZXJzaXN0RGF0Q2hpbGRyZW4ubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghY2FuUGVyc2lzdCkge1xyXG4gICAgICAgICAgICBwZXJzaXN0RGF0Q2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udHJvbEJveEVsZW1lbnQsIHsgY3NwTm9uY2U6IGNzcE5vbmNlLCByZWY6IHJlZih0aGlzLCBcImNvbnRyb2xCb3hcIiksIGNsYXNzTmFtZTogcHJlZml4KFwiY29udHJvbC1ib3hcIikgfSwgdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCwgaSkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICB2YXIgaW5kaXZpZHVhbFByb3BzID0gKF9iID0gKF9hID0gcHJvcHMuaW5kaXZpZHVhbEdyb3VwYWJsZVByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9wcywgdGFyZ2V0LCBpKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1vdmVhYmxlTWFuYWdlciwgX19hc3NpZ24oeyBrZXk6IFwibW92ZWFibGVcIiArIGksIHJlZjogcmVmcyhfdGhpcywgXCJtb3ZlYWJsZXNcIiwgaSkgfSwgcHJvcHMsIGluZGl2aWR1YWxQcm9wcywgeyB0YXJnZXQ6IHRhcmdldCwgd3JhcHBlck1vdmVhYmxlOiBfdGhpcywgaXNXcmFwcGVyTW91bnRlZDogX3RoaXMuaXNNb3ZlYWJsZU1vdW50ZWQsIHBlcnNpc3REYXRhOiBwZXJzaXN0RGF0Q2hpbGRyZW5baV0gfSkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmdldFRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudGFyZ2V0cztcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUudXBkYXRlUmVjdCA9IGZ1bmN0aW9uICh0eXBlLCBpc1RhcmdldCwgaXNTZXRTdGF0ZSkge1xyXG4gICAgICAgIGlmIChpc1NldFN0YXRlID09PSB2b2lkIDApIHsgaXNTZXRTdGF0ZSA9IHRydWU7IH1cclxuICAgICAgICBzZXRTdG9yZUNhY2hlKHRydWUpO1xyXG4gICAgICAgIHRoaXMubW92ZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKG1vdmVhYmxlKSB7XHJcbiAgICAgICAgICAgIG1vdmVhYmxlLnVwZGF0ZVJlY3QodHlwZSwgaXNUYXJnZXQsIGlzU2V0U3RhdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldFN0b3JlQ2FjaGUoKTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIF9zdXBlci5wcm90b3R5cGUuZ2V0UmVjdC5jYWxsKHRoaXMpKSwgeyBjaGlsZHJlbjogdGhpcy5tb3ZlYWJsZXMubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQuZ2V0UmVjdCgpOyB9KSB9KTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChhYmxlTmFtZSwgcGFyYW0sIGlzSW5zdGFudCkge1xyXG4gICAgICAgIGlmIChwYXJhbSA9PT0gdm9pZCAwKSB7IHBhcmFtID0ge307IH1cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMubW92ZWFibGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5yZXF1ZXN0KGFibGVOYW1lLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW0pLCB7IGlzSW5zdGFudDogZmFsc2UgfSksIGZhbHNlKTsgfSk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RJbnN0YW50ID0gaXNJbnN0YW50IHx8IHBhcmFtLmlzSW5zdGFudDtcclxuICAgICAgICB2YXIgcmVxdWVzdGVyID0ge1xyXG4gICAgICAgICAgICByZXF1ZXN0OiBmdW5jdGlvbiAoYWJsZVBhcmFtKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIucmVxdWVzdChhYmxlUGFyYW0pOyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXF1ZXN0RW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIucmVxdWVzdEVuZCgpOyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RJbnN0YW50ID8gcmVxdWVzdGVyLnJlcXVlc3QocGFyYW0pLnJlcXVlc3RFbmQoKSA6IHJlcXVlc3RlcjtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUsIHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBlLnRhcmdldDsgfVxyXG4gICAgICAgIHZhciBpbnB1dFRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB2YXIgY2hpbGRNb3ZlYWJsZSA9IGZpbmQodGhpcy5tb3ZlYWJsZXMsIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gY2hpbGQuZ2V0VGFyZ2V0cygpWzBdO1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbEJveEVsZW1lbnQgPSBjaGlsZC5nZXRDb250cm9sQm94RWxlbWVudCgpO1xyXG4gICAgICAgICAgICB2YXIgZHJhZ0VsZW1lbnQgPSBjaGlsZC5nZXREcmFnRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCB8fCAhZHJhZ0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZHJhZ0VsZW1lbnQgPT09IGlucHV0VGFyZ2V0IHx8IGRyYWdFbGVtZW50LmNvbnRhaW5zKGlucHV0VGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgfHwgKGRyYWdFbGVtZW50ICE9PSB0YXJnZXQgJiYgdGFyZ2V0ID09PSBpbnB1dFRhcmdldCB8fCB0YXJnZXQuY29udGFpbnMoaW5wdXRUYXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgfHwgY29udHJvbEJveEVsZW1lbnQgPT09IGlucHV0VGFyZ2V0IHx8IGNvbnRyb2xCb3hFbGVtZW50LmNvbnRhaW5zKGlucHV0VGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY2hpbGRNb3ZlYWJsZSkge1xyXG4gICAgICAgICAgICBjaGlsZE1vdmVhYmxlLmRyYWdTdGFydChlLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuaGl0VGVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuaXNJbnNpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuZ2V0RHJhZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgTW92ZWFibGVJbmRpdmlkdWFsR3JvdXAucHJvdG90eXBlLmdldE1vdmVhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRoaXMubW92ZWFibGVzKSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS51cGRhdGVSZW5kZXJQb3NlcyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS5jaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUudXBkYXRlQWJsZXMgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICBNb3ZlYWJsZUluZGl2aWR1YWxHcm91cC5wcm90b3R5cGUuX3VwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1vdmVhYmxlSW5kaXZpZHVhbEdyb3VwLnByb3RvdHlwZS5fdXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICByZXR1cm4gTW92ZWFibGVJbmRpdmlkdWFsR3JvdXA7XHJcbn0oTW92ZWFibGVNYW5hZ2VyKSk7XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUYXJnZXRzKHJlZlRhcmdldHMsIHNlbGVjdG9yTWFwKSB7XHJcbiAgICB2YXIgZWxlbWVudFRhcmdldHMgPSBbXTtcclxuICAgIHJlZlRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JNYXBbdGFyZ2V0XSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudFRhcmdldHMucHVzaC5hcHBseShlbGVtZW50VGFyZ2V0cywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHNlbGVjdG9yTWFwW3RhcmdldF0pLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBlbGVtZW50VGFyZ2V0cy5wdXNoLmFwcGx5KGVsZW1lbnRUYXJnZXRzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0RWxlbWVudFRhcmdldHModGFyZ2V0LCBzZWxlY3Rvck1hcCkpLCBmYWxzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbWVudFRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGVsZW1lbnRUYXJnZXRzO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldEdyb3VwcyhyZWZUYXJnZXRzLCBzZWxlY3Rvck1hcCkge1xyXG4gICAgdmFyIHRhcmdldEdyb3VwcyA9IFtdO1xyXG4gICAgcmVmVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvck1hcFt0YXJnZXRdKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRHcm91cHMucHVzaC5hcHBseSh0YXJnZXRHcm91cHMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChzZWxlY3Rvck1hcFt0YXJnZXRdKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0R3JvdXBzLnB1c2goZ2V0VGFyZ2V0R3JvdXBzKHRhcmdldCwgc2VsZWN0b3JNYXApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldEdyb3Vwcy5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0R3JvdXBzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVSZWZUYXJnZXRzKHByZXZSZWZUYXJnZXRzLCBuZXh0UmVmVGFyZ2V0cykge1xyXG4gICAgcmV0dXJuIChwcmV2UmVmVGFyZ2V0cy5sZW5ndGggIT09IG5leHRSZWZUYXJnZXRzLmxlbmd0aCkgfHwgcHJldlJlZlRhcmdldHMuc29tZShmdW5jdGlvbiAodGFyZ2V0LCBpKSB7XHJcbiAgICAgICAgdmFyIG5leHRUYXJnZXQgPSBuZXh0UmVmVGFyZ2V0c1tpXTtcclxuICAgICAgICBpZiAoIXRhcmdldCAmJiAhbmV4dFRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCAhPSBuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNBcnJheShuZXh0VGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVSZWZUYXJnZXRzKHRhcmdldCwgbmV4dFRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbnZhciBJbml0aWFsTW92ZWFibGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW5pdGlhbE1vdmVhYmxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW5pdGlhbE1vdmVhYmxlKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnJlZlRhcmdldHMgPSBbXTtcclxuICAgICAgICBfdGhpcy5zZWxlY3Rvck1hcCA9IHt9O1xyXG4gICAgICAgIF90aGlzLl9kaWZmZXIgPSBuZXcgQ2hpbGRyZW5EaWZmZXIoKTtcclxuICAgICAgICBfdGhpcy5fZWxlbWVudFRhcmdldHMgPSBbXTtcclxuICAgICAgICBfdGhpcy5fdG1wUmVmVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIF90aGlzLl90bXBTZWxlY3Rvck1hcCA9IHt9O1xyXG4gICAgICAgIF90aGlzLl9vbkNoYW5nZVRhcmdldHMgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEluaXRpYWxNb3ZlYWJsZS5tYWtlU3R5bGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjc3NNYXAgPSB7fTtcclxuICAgICAgICB2YXIgYWJsZXMgPSB0aGlzLmdldFRvdGFsQWJsZXMoKTtcclxuICAgICAgICBhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgY3NzID0gX2EuY3NzO1xyXG4gICAgICAgICAgICBpZiAoIWNzcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNzcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjc3NNYXBbdGV4dF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgc3R5bGUgPSBnZXRLZXlzKGNzc01hcCkuam9pbihcIlxcblwiKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRTdHlsZWQgPSBzdHlsZWQoXCJkaXZcIiwgcHJlZml4Q1NTKFBSRUZJWCwgTU9WRUFCTEVfQ1NTICsgc3R5bGUpKTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUuZ2V0VG90YWxBYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShbRGVmYXVsdCwgR3JvdXBhYmxlLCBJbmRpdmlkdWFsR3JvdXBhYmxlLCBEcmFnQXJlYV0sIF9fcmVhZCh0aGlzLmRlZmF1bHRBYmxlcyksIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIG1vdmVhYmxlQ29udHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgaWYgKCFtb3ZlYWJsZUNvbnRydWN0b3IuZGVmYXVsdFN0eWxlZCkge1xyXG4gICAgICAgICAgICBtb3ZlYWJsZUNvbnRydWN0b3IubWFrZVN0eWxlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCB1c2VyQWJsZXMgPSBfYi5hYmxlcywgdXNlclByb3BzID0gX2IucHJvcHMsIHByb3BzID0gX19yZXN0KF9iLCBbXCJhYmxlc1wiLCBcInByb3BzXCJdKTtcclxuICAgICAgICB2YXIgX2MgPSBfX3JlYWQodGhpcy5fdXBkYXRlUmVmcyh0cnVlKSwgMiksIHJlZlRhcmdldHMgPSBfY1swXSwgbmV4dFNlbGVjdG9yTWFwID0gX2NbMV07XHJcbiAgICAgICAgdmFyIGVsZW1lbnRUYXJnZXRzID0gZ2V0RWxlbWVudFRhcmdldHMocmVmVGFyZ2V0cywgbmV4dFNlbGVjdG9yTWFwKTtcclxuICAgICAgICB2YXIgaXNHcm91cCA9IGVsZW1lbnRUYXJnZXRzLmxlbmd0aCA+IDE7XHJcbiAgICAgICAgdmFyIHRvdGFsQWJsZXMgPSBtb3ZlYWJsZUNvbnRydWN0b3IuZ2V0VG90YWxBYmxlcygpO1xyXG4gICAgICAgIHZhciBhYmxlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRvdGFsQWJsZXMpLCBmYWxzZSksIF9fcmVhZCgodXNlckFibGVzIHx8IFtdKSksIGZhbHNlKTtcclxuICAgICAgICB2YXIgbmV4dFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzKSwgKHVzZXJQcm9wcyB8fCB7fSkpLCB7IGFibGVzOiBhYmxlcywgY3NzU3R5bGVkOiBtb3ZlYWJsZUNvbnRydWN0b3IuZGVmYXVsdFN0eWxlZCwgY3VzdG9tU3R5bGVkTWFwOiBtb3ZlYWJsZUNvbnRydWN0b3IuY3VzdG9tU3R5bGVkTWFwIH0pO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRUYXJnZXRzID0gZWxlbWVudFRhcmdldHM7XHJcbiAgICAgICAgdmFyIGZpcnN0UmVuZGVyU3RhdGUgPSBudWxsO1xyXG4gICAgICAgIHZhciBwcmV2TW92ZWFibGUgPSB0aGlzLm1vdmVhYmxlO1xyXG4gICAgICAgIHZhciBwZXJzaXN0RGF0YSA9IHByb3BzLnBlcnNpc3REYXRhO1xyXG4gICAgICAgIGlmIChwZXJzaXN0RGF0YSA9PT0gbnVsbCB8fCBwZXJzaXN0RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyc2lzdERhdGEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV2ZW4gb25lIGNoaWxkIGlzIHRyZWF0ZWQgYXMgYSBncm91cCBpZiBpbmRpdmlkdWFsR3JvdXBhYmxlIGlzIGVuYWJsZWQuICM4NjdcclxuICAgICAgICBpZiAocHJvcHMuaW5kaXZpZHVhbEdyb3VwYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNb3ZlYWJsZUluZGl2aWR1YWxHcm91cCwgX19hc3NpZ24oeyBrZXk6IFwiaW5kaXZpZHVhbC1ncm91cFwiLCByZWY6IHJlZih0aGlzLCBcIm1vdmVhYmxlXCIpIH0sIG5leHRQcm9wcywgeyB0YXJnZXQ6IG51bGwsIHRhcmdldHM6IGVsZW1lbnRUYXJnZXRzIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzR3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldEdyb3VwcyA9IGdldFRhcmdldEdyb3VwcyhyZWZUYXJnZXRzLCBuZXh0U2VsZWN0b3JNYXApO1xyXG4gICAgICAgICAgICAvLyBtYW5hZ2VyXHJcbiAgICAgICAgICAgIGlmIChwcmV2TW92ZWFibGUgJiYgIXByZXZNb3ZlYWJsZS5wcm9wcy5ncm91cGFibGUgJiYgIXByZXZNb3ZlYWJsZS5wcm9wcy5pbmRpdmlkdWFsR3JvdXBhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcHJldk1vdmVhYmxlLnByb3BzLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgZWxlbWVudFRhcmdldHMuaW5kZXhPZih0YXJnZXQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlbmRlclN0YXRlID0gX19hc3NpZ24oe30sIHByZXZNb3ZlYWJsZS5zdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW92ZWFibGVHcm91cCwgX19hc3NpZ24oeyBrZXk6IFwiZ3JvdXBcIiwgcmVmOiByZWYodGhpcywgXCJtb3ZlYWJsZVwiKSB9LCBuZXh0UHJvcHMsIChfYSA9IHByb3BzLmdyb3VwYWJsZVByb3BzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSwgeyB0YXJnZXQ6IG51bGwsIHRhcmdldHM6IGVsZW1lbnRUYXJnZXRzLCB0YXJnZXRHcm91cHM6IHRhcmdldEdyb3VwcywgZmlyc3RSZW5kZXJTdGF0ZTogZmlyc3RSZW5kZXJTdGF0ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0XzEgPSBlbGVtZW50VGFyZ2V0c1swXTtcclxuICAgICAgICAgICAgLy8gbWFuYWdlclxyXG4gICAgICAgICAgICBpZiAocHJldk1vdmVhYmxlICYmIChwcmV2TW92ZWFibGUucHJvcHMuZ3JvdXBhYmxlIHx8IHByZXZNb3ZlYWJsZS5wcm9wcy5pbmRpdmlkdWFsR3JvdXBhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vdmVhYmxlcyA9IHByZXZNb3ZlYWJsZS5tb3ZlYWJsZXMgfHwgW107XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRhcmdldE1vdmVhYmxlID0gZmluZChtb3ZlYWJsZXMsIGZ1bmN0aW9uIChtdikgeyByZXR1cm4gbXYucHJvcHMudGFyZ2V0ID09PSB0YXJnZXRfMTsgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlRhcmdldE1vdmVhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZW5kZXJTdGF0ZSA9IF9fYXNzaWduKHt9LCBwcmV2VGFyZ2V0TW92ZWFibGUuc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1vdmVhYmxlTWFuYWdlciwgX19hc3NpZ24oeyBrZXk6IFwic2luZ2xlXCIsIHJlZjogcmVmKHRoaXMsIFwibW92ZWFibGVcIikgfSwgbmV4dFByb3BzLCB7IHRhcmdldDogdGFyZ2V0XzEsIGZpcnN0UmVuZGVyU3RhdGU6IGZpcnN0UmVuZGVyU3RhdGUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQ2hhbmdlVGFyZ2V0cygpO1xyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQ2hhbmdlVGFyZ2V0cygpO1xyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVmVGFyZ2V0cyA9IFtdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRhcmdldHMgc2V0IGluIG1vdmVhYmxlIHRocm91Z2ggdGFyZ2V0IG9yIHRhcmdldHMgb2YgcHJvcHMuXHJcbiAgICAgKiBAbWV0aG9kIE1vdmVhYmxlI2dldFRhcmdldHNcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gICAgICogICAgdGFyZ2V0OiBbdGFyZ2V0UmVmLCBcIi50YXJnZXRcIiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YXJnZXRcIildLFxyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc29sZS5sb2cobW92ZWFibGUuZ2V0VGFyZ2V0cygpKTtcclxuICAgICAqL1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS5nZXRUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubW92ZWFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUYXJnZXRzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGVsZW1lbnQgbGlzdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzZWxlY3RvciBhbW9uZyB0aGUgdGFyZ2V0cyBpcyBjaGFuZ2VkLCBpdCBpcyB1cGRhdGVkLlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSN1cGRhdGVTZWxlY3RvcnNcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBpbXBvcnQgTW92ZWFibGUgZnJvbSBcIm1vdmVhYmxlXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbW92ZWFibGUgPSBuZXcgTW92ZWFibGUoZG9jdW1lbnQuYm9keSwge1xyXG4gICAgICogICAgdGFyZ2V0OiBcIi50YXJnZXRcIixcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIG1vdmVhYmxlLnVwZGF0ZVNlbGVjdG9ycygpO1xyXG4gICAgICovXHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLnVwZGF0ZVNlbGVjdG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yTWFwID0ge307XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVmcygpO1xyXG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVzZXIgY2hhbmdlcyB0YXJnZXQgYW5kIHdhaXRzIGZvciB0YXJnZXQgdG8gY2hhbmdlLlxyXG4gICAgICogQG1ldGhvZCBNb3ZlYWJsZSN3YWl0VG9DaGFuZ2VUYXJnZXRcclxuICAgICAqIEBzdG9yeSBjb21iaW5hdGlvbi13aXRoLW90aGVyLWNvbXBvbmVudHMtLWNvbXBvbmVudHMtc2VsZWN0b1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudGFyZ2V0XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZSA9PiB7XHJcbiAgICAgKiAgIG1vdmVhYmxlLndhaXRUb0NoYW5nZVRhcmdldCgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICogICAgICBtb3ZlYWJsZS5kcmFnU3RhcnQoZSwgZS5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAqICAgfSk7XHJcbiAgICAgKiAgIG1vdmVhYmxlLnRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcclxuICAgICAqIH0pO1xyXG4gICAgICovXHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLndhaXRUb0NoYW5nZVRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBsZXQgcmVzb2x2ZVByb21pc2U6IChlOiBPbkNoYW5nZVRhcmdldCkgPT4gdm9pZDtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIHRoaXMuX29uQ2hhbmdlVGFyZ2V0cyA9ICgpID0+IHtcclxuICAgICAgICAvLyAgICAgdGhpcy5fb25DaGFuZ2VUYXJnZXRzID0gbnVsbDtcclxuICAgICAgICAvLyAgICAgcmVzb2x2ZVByb21pc2Uoe1xyXG4gICAgICAgIC8vICAgICAgICAgbW92ZWFibGU6IHRoaXMuZ2V0TWFuYWdlcigpLFxyXG4gICAgICAgIC8vICAgICAgICAgdGFyZ2V0czogdGhpcy5fZWxlbWVudFRhcmdldHMsXHJcbiAgICAgICAgLy8gICAgIH0pO1xyXG4gICAgICAgIC8vIH07XHJcbiAgICAgICAgLy8gcmV0dXJuIG5ldyBQcm9taXNlPE9uQ2hhbmdlVGFyZ2V0PihyZXNvbHZlID0+IHtcclxuICAgICAgICAvLyAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xyXG4gICAgICAgIC8vIH0pO1xyXG4gICAgICAgIHZhciByZXNvbHZlUHJvbWlzZTtcclxuICAgICAgICB0aGlzLl9vbkNoYW5nZVRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLl9vbkNoYW5nZVRhcmdldHMgPSBudWxsO1xyXG4gICAgICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLndhaXRUb0NoYW5nZVRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdFRvQ2hhbmdlVGFyZ2V0KCk7XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS5nZXRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVhYmxlO1xyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuZ2V0TW92ZWFibGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVhYmxlLmdldE1vdmVhYmxlcygpO1xyXG4gICAgfTtcclxuICAgIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUuZ2V0RHJhZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZWFibGUuZ2V0RHJhZ0VsZW1lbnQoKTtcclxuICAgIH07XHJcbiAgICBJbml0aWFsTW92ZWFibGUucHJvdG90eXBlLl91cGRhdGVSZWZzID0gZnVuY3Rpb24gKGlzUmVuZGVyKSB7XHJcbiAgICAgICAgdmFyIHByZXZSZWZUYXJnZXRzID0gdGhpcy5yZWZUYXJnZXRzO1xyXG4gICAgICAgIHZhciBuZXh0UmVmVGFyZ2V0cyA9IGdldFJlZlRhcmdldHMoKHRoaXMucHJvcHMudGFyZ2V0IHx8IHRoaXMucHJvcHMudGFyZ2V0cykpO1xyXG4gICAgICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XHJcbiAgICAgICAgdmFyIGlzVXBkYXRlID0gY29tcGFyZVJlZlRhcmdldHMocHJldlJlZlRhcmdldHMsIG5leHRSZWZUYXJnZXRzKTtcclxuICAgICAgICB2YXIgc2VsZWN0b3JNYXAgPSB0aGlzLnNlbGVjdG9yTWFwO1xyXG4gICAgICAgIHZhciBuZXh0U2VsZWN0b3JNYXAgPSB7fTtcclxuICAgICAgICB0aGlzLnJlZlRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiB1cGRhdGVTZWxlY3Rvck1hcCh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclRhcmdldCA9IHNlbGVjdG9yTWFwW3RhcmdldF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JUYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U2VsZWN0b3JNYXBbdGFyZ2V0XSA9IHNlbGVjdG9yTWFwW3RhcmdldF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlbGVjdG9yTWFwW3RhcmdldF0gPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuZm9yRWFjaCh1cGRhdGVTZWxlY3Rvck1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90bXBSZWZUYXJnZXRzID0gbmV4dFJlZlRhcmdldHM7XHJcbiAgICAgICAgdGhpcy5fdG1wU2VsZWN0b3JNYXAgPSBuZXh0U2VsZWN0b3JNYXA7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV4dFJlZlRhcmdldHMsXHJcbiAgICAgICAgICAgIG5leHRTZWxlY3Rvck1hcCxcclxuICAgICAgICAgICAgIWlzUmVuZGVyICYmIGlzVXBkYXRlLFxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLnByb3RvdHlwZS5fY2hlY2tDaGFuZ2VUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHRoaXMucmVmVGFyZ2V0cyA9IHRoaXMuX3RtcFJlZlRhcmdldHM7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hcCA9IHRoaXMuX3RtcFNlbGVjdG9yTWFwO1xyXG4gICAgICAgIHZhciBfZCA9IHRoaXMuX2RpZmZlci51cGRhdGUodGhpcy5fZWxlbWVudFRhcmdldHMpLCBhZGRlZCA9IF9kLmFkZGVkLCByZW1vdmVkID0gX2QucmVtb3ZlZDtcclxuICAgICAgICB2YXIgaXNUYXJnZXRDaGFuZ2VkID0gYWRkZWQubGVuZ3RoIHx8IHJlbW92ZWQubGVuZ3RoO1xyXG4gICAgICAgIGlmIChpc1RhcmdldENoYW5nZWQpIHtcclxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5wcm9wcykub25DaGFuZ2VUYXJnZXRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xyXG4gICAgICAgICAgICAgICAgbW92ZWFibGU6IHRoaXMubW92ZWFibGUsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRzOiB0aGlzLl9lbGVtZW50VGFyZ2V0cyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIChfYyA9IHRoaXMuX29uQ2hhbmdlVGFyZ2V0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfZSA9IF9fcmVhZCh0aGlzLl91cGRhdGVSZWZzKCksIDMpLCByZWZUYXJnZXRzID0gX2VbMF0sIHNlbGVjdG9yTWFwID0gX2VbMV0sIGlzVXBkYXRlID0gX2VbMl07XHJcbiAgICAgICAgdGhpcy5yZWZUYXJnZXRzID0gcmVmVGFyZ2V0cztcclxuICAgICAgICB0aGlzLnNlbGVjdG9yTWFwID0gc2VsZWN0b3JNYXA7XHJcbiAgICAgICAgaWYgKGlzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLmRlZmF1bHRBYmxlcyA9IFtdO1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLmN1c3RvbVN0eWxlZE1hcCA9IHt9O1xyXG4gICAgSW5pdGlhbE1vdmVhYmxlLmRlZmF1bHRTdHlsZWQgPSBudWxsO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgd2l0aE1ldGhvZHMoTU9WRUFCTEVfTUVUSE9EUylcclxuICAgIF0sIEluaXRpYWxNb3ZlYWJsZS5wcm90b3R5cGUsIFwibW92ZWFibGVcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBJbml0aWFsTW92ZWFibGU7XHJcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgTW92ZWFibGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTW92ZWFibGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb3ZlYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBNb3ZlYWJsZS5kZWZhdWx0QWJsZXMgPSBNT1ZFQUJMRV9BQkxFUztcclxuICAgIHJldHVybiBNb3ZlYWJsZTtcclxufShJbml0aWFsTW92ZWFibGUpKTtcblxuZnVuY3Rpb24gbWFrZU1vdmVhYmxlKGFibGVzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gX2EgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhNb3ZlYWJsZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTW92ZWFibGUoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1vdmVhYmxlO1xyXG4gICAgICAgIH0oSW5pdGlhbE1vdmVhYmxlKSksXHJcbiAgICAgICAgX2EuZGVmYXVsdEFibGVzID0gYWJsZXMsXHJcbiAgICAgICAgX2E7XHJcbn1cblxuZXhwb3J0IHsgQ2xpcHBhYmxlLCBESVJFQ1RJT05TLCBEcmFnZ2FibGUsIGVkZ2VEcmFnZ2FibGUgYXMgRWRnZURyYWdnYWJsZSwgSW5pdGlhbE1vdmVhYmxlLCBNT1ZFQUJMRV9BQkxFUywgTU9WRUFCTEVfRVZFTlRTLCBNT1ZFQUJMRV9NRVRIT0RTLCBNT1ZFQUJMRV9QUk9QUywgUGluY2hhYmxlLCBSZXNpemFibGUsIFJvdGF0YWJsZSwgUm91bmRhYmxlLCBTY2FsYWJsZSwgU25hcHBhYmxlLCBXYXJwYWJsZSwgY2FsY3VsYXRlRWxlbWVudFBvc2l0aW9uLCBNb3ZlYWJsZSBhcyBkZWZhdWx0LCBnZXRFbGVtZW50SW5mbywgbWFrZUFibGUsIG1ha2VNb3ZlYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW92ZWFibGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-moveable/dist/moveable.esm.js\n");

/***/ })

};
;